import random‖import string‖1
self.__passcode = passcode or self.__passcode_creator()‖self.__key_list = self.__make_key_list()‖1
self.__key_list = self.__make_key_list()‖self.__shift_key = self.__make_shift_key()‖1
for i in range(1, len(iterlist), 2):‖iterlist[i] *= -1‖1
iterlist[i] *= -1‖return iterlist‖1
choices = string.ascii_letters + string.digits‖password = [random.choice(choices) for _ in range(random.randint(10, 20))]‖1
password = [random.choice(choices) for _ in range(random.randint(10, 20))]‖return password‖1
key_list_options = (‖"string.ascii_letters + string.digits + string.punctuation + "" \t\n"""‖1
"string.ascii_letters + string.digits + string.punctuation + "" \t\n"""‖)‖1
breakpoints = sorted(set(self.__passcode))‖temp_list: list[str] = []‖1
for i in key_list_options:‖temp_list.extend(i)‖1
if i in breakpoints or i == key_list_options[-1]:‖keys_l.extend(temp_list[::-1])‖1
keys_l.extend(temp_list[::-1])‖temp_list.clear()‖1
num = sum(self.__neg_pos([ord(x) for x in self.__passcode]))‖return num if num > 0 else len(self.__passcode)‖1
for i in encoded_message:‖position = self.__key_list.index(i)‖1
position = self.__key_list.index(i)‖decoded_message += self.__key_list[‖1
decoded_message += self.__key_list[‖(position - self.__shift_key) % -len(self.__key_list)‖1
(position - self.__shift_key) % -len(self.__key_list)‖]‖1
for i in plaintext:‖position = self.__key_list.index(i)‖1
position = self.__key_list.index(i)‖encoded_message += self.__key_list[‖1
encoded_message += self.__key_list[‖(position + self.__shift_key) % len(self.__key_list)‖1
(position + self.__shift_key) % len(self.__key_list)‖]‖1
cip1 = ShuffledShiftCipher()‖return cip1.decrypt(cip1.encrypt(msg))‖1
"if __name__ == ""__main__"":"‖import doctest‖463
import os‖import random‖4
import random‖import sys‖5
from . import cryptomath_module as cryptomath‖from . import rabin_miller‖1
def primitive_root(p_val: int) -> int:‖"print(""Generating primitive root of p"")"‖1
"print(""Generating primitive root of p"")"‖while True:‖1
while True:‖g = random.randrange(3, p_val)‖1
g = random.randrange(3, p_val)‖if pow(g, 2, p_val) == 1:‖1
if pow(g, 2, p_val) == 1:‖continue‖1
continue‖if pow(g, p_val, p_val) == 1:‖1
if pow(g, p_val, p_val) == 1:‖continue‖1
continue‖return g‖1
def generate_key(key_size: int) -> tuple[tuple[int, int, int, int], tuple[int, int]]:‖"print(""Generating prime p..."")"‖1
"print(""Generating prime p..."")"‖p = rabin_miller.generate_large_prime(key_size)‖1
p = rabin_miller.generate_large_prime(key_size)‖e_1 = primitive_root(p)‖1
e_1 = primitive_root(p)‖d = random.randrange(3, p)‖1
d = random.randrange(3, p)‖e_2 = cryptomath.find_mod_inverse(pow(e_1, d, p), p)‖1
public_key = (key_size, e_1, e_2, p)‖private_key = (key_size, d)‖1
def make_key_files(name: str, key_size: int) -> None:‖"if os.path.exists(f""{name}_pubkey.txt"") or os.path.exists(f""{name}_privkey.txt""):"‖2
"if os.path.exists(f""{name}_pubkey.txt"") or os.path.exists(f""{name}_privkey.txt""):"‖"print(""\nWARNING:"")"‖2
"print(""\nWARNING:"")"‖print(‖2
print(‖"f'""{name}_pubkey.txt"" or ""{name}_privkey.txt"" already exists. \n'"‖2
"f'""{name}_pubkey.txt"" or ""{name}_privkey.txt"" already exists. \n'"‖"""Use a different name or delete these files and re-run this program."""‖2
"""Use a different name or delete these files and re-run this program."""‖)‖2
)‖sys.exit()‖2
public_key, private_key = generate_key(key_size)‖"print(f""\nWriting public key to file {name}_pubkey.txt..."")"‖2
"print(f""\nWriting public key to file {name}_pubkey.txt..."")"‖"with open(f""{name}_pubkey.txt"", ""w"") as fo:"‖1
"with open(f""{name}_pubkey.txt"", ""w"") as fo:"‖"fo.write(f""{public_key[0]},{public_key[1]},{public_key[2]},{public_key[3]}"")"‖1
"print(f""Writing private key to file {name}_privkey.txt..."")"‖"with open(f""{name}_privkey.txt"", ""w"") as fo:"‖1
"with open(f""{name}_privkey.txt"", ""w"") as fo:"‖"fo.write(f""{private_key[0]},{private_key[1]}"")"‖1
def main() -> None:‖"print(""Making key files..."")"‖2
"print(""Making key files..."")"‖"make_key_files(""elgamal"", 2048)"‖1
"make_key_files(""elgamal"", 2048)"‖"print(""Key files generation successful"")"‖1
"if __name__ == ""__main__"":"‖main()‖53
values = {‖"0: ""0"","‖1
"0: ""0"","‖"1: ""1"","‖1
"1: ""1"","‖"2: ""2"","‖1
"2: ""2"","‖"3: ""3"","‖1
"3: ""3"","‖"4: ""4"","‖1
"4: ""4"","‖"5: ""5"","‖1
"5: ""5"","‖"6: ""6"","‖1
"6: ""6"","‖"7: ""7"","‖1
"7: ""7"","‖"8: ""8"","‖1
"8: ""8"","‖"9: ""9"","‖1
"9: ""9"","‖"10: ""a"","‖1
"10: ""a"","‖"11: ""b"","‖1
"11: ""b"","‖"12: ""c"","‖1
"12: ""c"","‖"13: ""d"","‖1
"13: ""d"","‖"14: ""e"","‖1
"14: ""e"","‖"15: ""f"","‖1
"15: ""f"","‖}‖1
assert isinstance(decimal, (int, float))‖assert decimal == int(decimal)‖1
assert decimal == int(decimal)‖decimal = int(decimal)‖1
decimal = int(decimal)‖"hexadecimal = """""‖1
"hexadecimal = """""‖negative = False‖1
negative = False‖if decimal < 0:‖1
if decimal < 0:‖negative = True‖1
negative = True‖decimal *= -1‖1
decimal *= -1‖while decimal > 0:‖1
while decimal > 0:‖decimal, remainder = divmod(decimal, 16)‖1
decimal, remainder = divmod(decimal, 16)‖hexadecimal = values[remainder] + hexadecimal‖1
hexadecimal = values[remainder] + hexadecimal‖"hexadecimal = ""0x"" + hexadecimal"‖1
"hexadecimal = ""0x"" + hexadecimal"‖if negative:‖1
if negative:‖"hexadecimal = ""-"" + hexadecimal"‖1
"hexadecimal = ""-"" + hexadecimal"‖return hexadecimal‖1
"binary_data = """".join(bin(ord(d))[2:].zfill(8) for d in data.decode(""utf-8""))"‖"binary_data = binary_data.ljust(5 * ((len(binary_data) // 5) + 1), ""0"")"‖1
"binary_data = binary_data.ljust(5 * ((len(binary_data) // 5) + 1), ""0"")"‖"b32_chunks = map("""".join, zip(*[iter(binary_data)] * 5))"‖1
"b32_chunks = map("""".join, zip(*[iter(binary_data)] * 5))"‖"b32_result = """".join(B32_CHARSET[int(chunk, 2)] for chunk in b32_chunks)"‖1
"b32_result = """".join(B32_CHARSET[int(chunk, 2)] for chunk in b32_chunks)"‖"return bytes(b32_result.ljust(8 * ((len(b32_result) // 8) + 1), ""=""), ""utf-8"")"‖1
"binary_chunks = """".join("‖bin(B32_CHARSET.index(_d))[2:].zfill(5)‖1
bin(B32_CHARSET.index(_d))[2:].zfill(5)‖"for _d in data.decode(""utf-8"").strip(""="")"‖1
"for _d in data.decode(""utf-8"").strip(""="")"‖)‖1
)‖"binary_data = list(map("""".join, zip(*[iter(binary_chunks)] * 8)))"‖1
"binary_data = list(map("""".join, zip(*[iter(binary_chunks)] * 8)))"‖"return bytes("""".join([chr(int(_d, 2)) for _d in binary_data]), ""utf-8"")"‖1
if bit_count < 0:‖"raise ValueError(""The given input must be positive"")"‖1
for i in range(len(sequence)):‖sequence[i] = int(sequence[i], 2)‖1
if bit_count == 0:‖"return [""0""]"‖1
if bit_count == 1:‖"return [""0"", ""1""]"‖1
for i in range(seq_len // 2):‖"generated_no = ""0"" + smaller_sequence[i]"‖1
"generated_no = ""0"" + smaller_sequence[i]"‖sequence.append(generated_no)‖1
for i in reversed(range(seq_len // 2)):‖"generated_no = ""1"" + smaller_sequence[i]"‖1
"generated_no = ""1"" + smaller_sequence[i]"‖sequence.append(generated_no)‖1
if number < 0:‖"raise ValueError(""number must not be negative"")"‖1
"raise ValueError(""number must not be negative"")"‖return number & (number - 1) == 0‖1
"plaintext = plaintext.replace("" "", """").upper()"‖"key = key.replace("" "", """").upper()"‖1
"key = key.replace("" "", """").upper()"‖key_length = len(key)‖2
key_length = len(key)‖ciphertext = []‖1
ciphertext = []‖"ord_a = ord(""A"")"‖1
for i, char in enumerate(plaintext):‖p = ord(char) - ord_a‖1
p = ord(char) - ord_a‖k = ord(key[i % key_length]) - ord_a‖1
k = ord(key[i % key_length]) - ord_a‖c = (p + k) % 26‖1
c = (p + k) % 26‖ciphertext.append(chr(c + ord_a))‖1
"ciphertext = ciphertext.replace("" "", """").upper()"‖"key = key.replace("" "", """").upper()"‖1
key_length = len(key)‖plaintext = []‖1
plaintext = []‖"ord_a = ord(""A"")"‖1
for i, char in enumerate(ciphertext):‖c = ord(char) - ord_a‖1
c = ord(char) - ord_a‖k = ord(key[i % key_length]) - ord_a‖1
k = ord(key[i % key_length]) - ord_a‖p = (c - k) % 26‖1
p = (c - k) % 26‖plaintext.append(chr(p + ord_a))‖1
def test_running_key_encrypt() -> None:‖pass‖1
doctest.testmod()‖test_running_key_encrypt()‖1
"plaintext = input(""Enter the plaintext: "").upper()"‖"print(f""\n{plaintext = }"")"‖1
"key = ""How does the duck know that? said Victor"""‖encrypted_text = running_key_encrypt(key, plaintext)‖1
encrypted_text = running_key_encrypt(key, plaintext)‖"print(f""{encrypted_text = }"")"‖1
decrypted_text = running_key_decrypt(key, encrypted_text)‖"print(f""{decrypted_text = }"")"‖1
from binascii import hexlify‖from hashlib import sha256‖1
from hashlib import sha256‖from os import urandom‖1
5: {‖"""prime"": int("‖1
"""prime"": int("‖"""FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"""‖5
"""FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"""‖"""29024E088A67CC74020BBEA63B139B22514A08798E3404DD"""‖5
"""29024E088A67CC74020BBEA63B139B22514A08798E3404DD"""‖"""EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"""‖5
"""EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"""‖"""E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"""‖5
"""E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"""‖"""EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"""‖5
"""EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"""‖"""C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"""‖5
"""C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"""‖"""83655D23DCA3AD961C62F356208552BB9ED529077096966D"""‖5
"""83655D23DCA3AD961C62F356208552BB9ED529077096966D"""‖"""670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF"","‖1
"""670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF"","‖base=16,‖1
base=16,‖),‖6
),‖"""generator"": 2,"‖6
"""generator"": 2,"‖},‖6
14: {‖"""prime"": int("‖1
"""83655D23DCA3AD961C62F356208552BB9ED529077096966D"""‖"""670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"""‖4
"""670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"""‖"""E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"""‖4
"""E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"""‖"""DE2BCBF6955817183995497CEA956AE515D2261898FA0510"""‖4
"""DE2BCBF6955817183995497CEA956AE515D2261898FA0510"""‖"""15728E5A8AACAA68FFFFFFFFFFFFFFFF"","‖1
"""15728E5A8AACAA68FFFFFFFFFFFFFFFF"","‖base=16,‖1
15: {‖"""prime"": int("‖1
"""DE2BCBF6955817183995497CEA956AE515D2261898FA0510"""‖"""15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"""‖3
"""15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"""‖"""ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"""‖3
"""ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"""‖"""ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"""‖3
"""ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"""‖"""F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"""‖3
"""F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"""‖"""BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"""‖3
"""BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"""‖"""43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF"","‖1
"""43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF"","‖base=16,‖1
16: {‖"""prime"": int("‖1
"""BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"""‖"""43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"""‖2
"""43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"""‖"""88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"""‖2
"""88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"""‖"""2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"""‖2
"""2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"""‖"""287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"""‖2
"""287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"""‖"""1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"""‖2
"""1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"""‖"""93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199"""‖1
"""93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199"""‖"""FFFFFFFFFFFFFFFF"","‖1
"""FFFFFFFFFFFFFFFF"","‖base=16,‖1
17: {‖"""prime"": int("‖1
"""prime"": int("‖"""FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08"""‖1
"""FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08"""‖"""8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B"""‖1
"""8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B"""‖"""302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9"""‖1
"""302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9"""‖"""A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6"""‖1
"""A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6"""‖"""49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8"""‖1
"""49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8"""‖"""FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D"""‖1
"""FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D"""‖"""670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C"""‖1
"""670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C"""‖"""180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718"""‖1
"""180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718"""‖"""3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D"""‖1
"""3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D"""‖"""04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D"""‖1
"""04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D"""‖"""B3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226"""‖1
"""B3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226"""‖"""1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C"""‖1
"""1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C"""‖"""BBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC"""‖1
"""BBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC"""‖"""E0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26"""‖1
"""E0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26"""‖"""99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB"""‖1
"""99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB"""‖"""04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2"""‖1
"""04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2"""‖"""233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127"""‖1
"""233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127"""‖"""D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"""‖1
"""D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"""‖"""36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406"""‖1
"""36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406"""‖"""AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918"""‖1
"""AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918"""‖"""DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B33205151"""‖1
"""DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B33205151"""‖"""2BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03"""‖1
"""2BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03"""‖"""F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97F"""‖1
"""F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97F"""‖"""BEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"""‖1
"""BEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"""‖"""CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58B"""‖1
"""CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58B"""‖"""B7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632"""‖1
"""B7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632"""‖"""387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E"""‖1
"""387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E"""‖"""6DCC4024FFFFFFFFFFFFFFFF"","‖1
"""6DCC4024FFFFFFFFFFFFFFFF"","‖base=16,‖1
18: {‖"""prime"": int("‖1
"""1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"""‖"""93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"""‖1
"""93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"""‖"""36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD"""‖1
"""36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD"""‖"""F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831"""‖1
"""F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831"""‖"""179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B"""‖1
"""179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B"""‖"""DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF"""‖1
"""DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF"""‖"""5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6"""‖1
"""5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6"""‖"""D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3"""‖1
"""D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3"""‖"""23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"""‖1
"""23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"""‖"""CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328"""‖1
"""CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328"""‖"""06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C"""‖1
"""06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C"""‖"""DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE"""‖1
"""DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE"""‖"""12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E4"""‖1
"""12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E4"""‖"""38777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300"""‖1
"""38777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300"""‖"""741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F568"""‖1
"""741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F568"""‖"""3423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9"""‖1
"""3423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9"""‖"""22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B"""‖1
"""22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B"""‖"""4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A"""‖1
"""4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A"""‖"""062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A36"""‖1
"""062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A36"""‖"""4597E899A0255DC164F31CC50846851DF9AB48195DED7EA1"""‖1
"""4597E899A0255DC164F31CC50846851DF9AB48195DED7EA1"""‖"""B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F92"""‖1
"""B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F92"""‖"""4009438B481C6CD7889A002ED5EE382BC9190DA6FC026E47"""‖1
"""4009438B481C6CD7889A002ED5EE382BC9190DA6FC026E47"""‖"""9558E4475677E9AA9E3050E2765694DFC81F56E880B96E71"""‖1
"""9558E4475677E9AA9E3050E2765694DFC81F56E880B96E71"""‖"""60C980DD98EDD3DFFFFFFFFFFFFFFFFF"","‖1
"""60C980DD98EDD3DFFFFFFFFFFFFFFFFF"","‖base=16,‖1
},‖}‖1
def __init__(self, group: int = 14) -> None:‖if group not in primes:‖1
if group not in primes:‖"raise ValueError(""Unsupported Group"")"‖1
"raise ValueError(""Unsupported Group"")"‖"self.prime = primes[group][""prime""]"‖1
"self.prime = primes[group][""prime""]"‖"self.generator = primes[group][""generator""]"‖1
def get_private_key(self) -> str:‖return hex(self.__private_key)[2:]‖1
def generate_public_key(self) -> str:‖public_key = pow(self.generator, self.__private_key, self.prime)‖1
public_key = pow(self.generator, self.__private_key, self.prime)‖return hex(public_key)[2:]‖1
return (‖2 <= key <= self.prime - 2‖1
2 <= key <= self.prime - 2‖and pow(key, (self.prime - 1) // 2, self.prime) == 1‖1
and pow(key, (self.prime - 1) // 2, self.prime) == 1‖)‖1
def generate_shared_key(self, other_key_str: str) -> str:‖other_key = int(other_key_str, base=16)‖1
other_key = int(other_key_str, base=16)‖if not self.is_valid_public_key(other_key):‖1
if not self.is_valid_public_key(other_key):‖"raise ValueError(""Invalid public key"")"‖1
"raise ValueError(""Invalid public key"")"‖shared_key = pow(other_key, self.__private_key, self.prime)‖1
shared_key = pow(other_key, self.__private_key, self.prime)‖return sha256(str(shared_key).encode()).hexdigest()‖1
@staticmethod‖def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:‖1
return (‖2 <= remote_public_key_str <= prime - 2‖1
2 <= remote_public_key_str <= prime - 2‖and pow(remote_public_key_str, (prime - 1) // 2, prime) == 1‖1
and pow(remote_public_key_str, (prime - 1) // 2, prime) == 1‖)‖1
@staticmethod‖def generate_shared_key_static(‖1
def generate_shared_key_static(‖local_private_key_str: str, remote_public_key_str: str, group: int = 14‖1
local_private_key_str: str, remote_public_key_str: str, group: int = 14‖) -> str:‖1
) -> str:‖local_private_key = int(local_private_key_str, base=16)‖1
local_private_key = int(local_private_key_str, base=16)‖remote_public_key = int(remote_public_key_str, base=16)‖1
remote_public_key = int(remote_public_key_str, base=16)‖"prime = primes[group][""prime""]"‖1
"prime = primes[group][""prime""]"‖if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):‖1
if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):‖"raise ValueError(""Invalid public key"")"‖1
"raise ValueError(""Invalid public key"")"‖shared_key = pow(remote_public_key, local_private_key, prime)‖1
shared_key = pow(remote_public_key, local_private_key, prime)‖return sha256(str(shared_key).encode()).hexdigest()‖1
return (‖all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))‖1
all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))‖and all(‖1
and all(‖board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))‖1
board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))‖)‖1
)‖and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))‖1
and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))‖and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))‖1
and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))‖)‖1
solution.append(board)‖printboard(board)‖1
printboard(board)‖print()‖1
print()‖return True‖1
return True‖for i in range(len(board)):‖1
if is_safe(board, row, i):‖board[row][i] = 1‖1
board[row][i] = 1‖solve(board, row + 1)‖1
solve(board, row + 1)‖board[row][i] = 0‖1
board[row][i] = 0‖return False‖1
for i in range(len(board)):‖for j in range(len(board)):‖1
for j in range(len(board)):‖if board[i][j] == 1:‖1
if board[i][j] == 1:‖"print(""Q"", end="" "")"‖1
"print(""Q"", end="" "")"‖else:‖1
else:‖"print(""."", end="" "")"‖1
"print(""."", end="" "")"‖print()‖1
n = 8‖board = [[0 for i in range(n)] for j in range(n)]‖1
board = [[0 for i in range(n)] for j in range(n)]‖solve(board, 0)‖1
solve(board, 0)‖"print(""The total number of solutions are:"", len(solution))"‖1
if not isinstance(number, int):‖msg = (‖1
msg = (‖"""operation can not be conducted on a object of type """‖1
"""operation can not be conducted on a object of type """‖"f""{type(number).__name__}"""‖1
"f""{type(number).__name__}"""‖)‖1
)‖raise TypeError(msg)‖6
raise TypeError(msg)‖"bit_string = """""‖1
"bit_string = """""‖for _ in range(32):‖1
for _ in range(32):‖bit_string += str(number % 2)‖1
bit_string += str(number % 2)‖number = number >> 1‖1
number = number >> 1‖return bit_string‖1
if number < 0:‖"raise ValueError(""the value of input must be positive"")"‖1
"raise ValueError(""the value of input must be positive"")"‖elif isinstance(number, float):‖1
elif isinstance(number, float):‖"raise TypeError(""Input value must be a 'int' type"")"‖1
"raise TypeError(""Input value must be a 'int' type"")"‖elif isinstance(number, str):‖1
elif isinstance(number, str):‖"raise TypeError(""'<' not supported between instances of 'str' and 'int'"")"‖1
"raise TypeError(""'<' not supported between instances of 'str' and 'int'"")"‖result = 0‖1
result = result | end_bit‖return get_reverse_bit_string(result)‖1
if isinstance(num, float):‖"raise TypeError(""'float' object cannot be interpreted as an integer"")"‖1
"raise TypeError(""'float' object cannot be interpreted as an integer"")"‖if isinstance(num, str):‖1
if isinstance(num, str):‖"raise TypeError(""'str' object cannot be interpreted as an integer"")"‖1
if num == 0:‖"return ""0b0"""‖1
if num < 0:‖negative = True‖1
negative = True‖num = -num‖1
binary: list[int] = []‖while num > 0:‖1
while num > 0:‖binary.insert(0, num % 2)‖1
binary.insert(0, num % 2)‖num >>= 1‖1
if negative:‖"return ""-0b"" + """".join(str(e) for e in binary)"‖1
decimal = int(decimal)‖if decimal in (0, 1):‖1
if decimal in (0, 1):‖return str(decimal)‖1
return str(decimal)‖div, mod = divmod(decimal, 2)‖1
div, mod = divmod(decimal, 2)‖return decimal_to_binary_recursive_helper(div) + str(mod)‖1
number = str(number).strip()‖if not number:‖1
if not number:‖"raise ValueError(""No input value was provided"")"‖1
"raise ValueError(""No input value was provided"")"‖"negative = ""-"" if number.startswith(""-"") else """""‖1
"negative = ""-"" if number.startswith(""-"") else """""‖"number = number.lstrip(""-"")"‖1
"number = number.lstrip(""-"")"‖if not number.isnumeric():‖1
if not number.isnumeric():‖"raise ValueError(""Input value is not an integer"")"‖1
"raise ValueError(""Input value is not an integer"")"‖"return f""{negative}0b{decimal_to_binary_recursive_helper(int(number))}"""‖1
def valid_coloring(‖neighbours: list[int], colored_vertices: list[int], color: int‖1
neighbours: list[int], colored_vertices: list[int], color: int‖) -> bool:‖1
return not any(‖neighbour == 1 and colored_vertices[i] == color‖1
neighbour == 1 and colored_vertices[i] == color‖for i, neighbour in enumerate(neighbours)‖1
for i, neighbour in enumerate(neighbours)‖)‖1
def util_color(‖graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int‖1
graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int‖) -> bool:‖1
if index == len(graph):‖return True‖1
for i in range(max_colors):‖if valid_coloring(graph[index], colored_vertices, i):‖1
if util_color(graph, max_colors, colored_vertices, index + 1):‖return True‖1
colored_vertices[index] = -1‖return False‖1
if util_color(graph, max_colors, colored_vertices, 0):‖return colored_vertices‖1
if pattern_index == len(pattern) and str_index == len(input_string):‖return True‖1
return True‖if pattern_index == len(pattern) or str_index == len(input_string):‖1
if pattern_index == len(pattern) or str_index == len(input_string):‖return False‖1
return False‖char = pattern[pattern_index]‖1
char = pattern[pattern_index]‖if char in pattern_map:‖1
if char in pattern_map:‖mapped_str = pattern_map[char]‖1
mapped_str = pattern_map[char]‖if input_string.startswith(mapped_str, str_index):‖1
if input_string.startswith(mapped_str, str_index):‖return backtrack(pattern_index + 1, str_index + len(mapped_str))‖1
return backtrack(pattern_index + 1, str_index + len(mapped_str))‖else:‖1
else:‖return False‖7
return False‖for end in range(str_index + 1, len(input_string) + 1):‖1
for end in range(str_index + 1, len(input_string) + 1):‖substr = input_string[str_index:end]‖1
substr = input_string[str_index:end]‖if substr in str_map:‖1
if substr in str_map:‖continue‖1
continue‖pattern_map[char] = substr‖1
pattern_map[char] = substr‖str_map[substr] = char‖1
str_map[substr] = char‖if backtrack(pattern_index + 1, end):‖1
if backtrack(pattern_index + 1, end):‖return True‖1
return True‖del pattern_map[char]‖1
del pattern_map[char]‖del str_map[substr]‖1
del str_map[substr]‖return False‖1
pattern_map: dict[str, str] = {}‖str_map: dict[str, str] = {}‖1
str_map: dict[str, str] = {}‖return backtrack(0, 0)‖1
if not isinstance(number, int) or number < 0:‖"raise ValueError(""Input must be a non-negative integer"")"‖3
"raise ValueError(""Input must be a non-negative integer"")"‖if number == 0:‖1
if number == 0:‖return 0‖1
return 0‖power = 1‖1
power = 1‖while power <= number:‖1
while power <= number:‖power <<= 1‖1
power <<= 1‖return power >> 1 if number > 1 else 1‖1
def construct_highway(‖number_of_cells: int,‖1
number_of_cells: int,‖frequency: int,‖1
frequency: int,‖initial_speed: int,‖1
initial_speed: int,‖random_frequency: bool = False,‖1
random_frequency: bool = False,‖random_speed: bool = False,‖1
random_speed: bool = False,‖max_speed: int = 5,‖1
max_speed: int = 5,‖) -> list:‖1
highway = [[-1] * number_of_cells]‖i = 0‖1
i = 0‖initial_speed = max(initial_speed, 0)‖1
initial_speed = max(initial_speed, 0)‖while i < number_of_cells:‖1
while i < number_of_cells:‖highway[0][i] = (‖1
highway[0][i] = (‖randint(0, max_speed) if random_speed else initial_speed‖1
randint(0, max_speed) if random_speed else initial_speed‖)‖1
)‖i += (‖1
i += (‖randint(1, max_speed * 2) if random_frequency else frequency‖1
randint(1, max_speed * 2) if random_frequency else frequency‖)‖1
)‖return highway‖1
distance = 0‖cells = highway_now[car_index + 1 :]‖1
cells = highway_now[car_index + 1 :]‖for cell in range(len(cells)):‖1
for cell in range(len(cells)):‖if cells[cell] != -1:‖1
if cells[cell] != -1:‖return distance‖1
return distance‖distance += 1‖1
for car_index in range(number_of_cells):‖if highway_now[car_index] != -1:‖1
next_highway[car_index] = min(next_highway[car_index], dn)‖if random() < probability:‖1
next_highway[car_index] = max(next_highway[car_index] - 1, 0)‖return next_highway‖1
def simulate(‖highway: list, number_of_update: int, probability: float, max_speed: int‖1
highway: list, number_of_update: int, probability: float, max_speed: int‖) -> list:‖1
for i in range(number_of_update):‖next_speeds_calculated = update(highway[i], probability, max_speed)‖1
next_speeds_calculated = update(highway[i], probability, max_speed)‖real_next_speeds = [-1] * number_of_cells‖1
for car_index in range(number_of_cells):‖speed = next_speeds_calculated[car_index]‖1
speed = next_speeds_calculated[car_index]‖if speed != -1:‖1
real_next_speeds[index] = speed‖highway.append(real_next_speeds)‖1
"print(""Making key files..."")"‖"make_key_files(""rsa"", 1024)"‖1
"make_key_files(""rsa"", 1024)"‖"print(""Key files generation successful."")"‖1
p = rabin_miller.generate_large_prime(key_size)‖q = rabin_miller.generate_large_prime(key_size)‖1
q = rabin_miller.generate_large_prime(key_size)‖n = p * q‖1
while True:‖e = random.randrange(2 ** (key_size - 1), 2 ** (key_size))‖1
e = random.randrange(2 ** (key_size - 1), 2 ** (key_size))‖if gcd_by_iterative(e, (p - 1) * (q - 1)) == 1:‖1
if gcd_by_iterative(e, (p - 1) * (q - 1)) == 1:‖break‖1
public_key = (n, e)‖private_key = (n, d)‖1
private_key = (n, d)‖return (public_key, private_key)‖1
"print(f""\nWriting public key to file {name}_pubkey.txt..."")"‖"with open(f""{name}_pubkey.txt"", ""w"") as out_file:"‖1
"with open(f""{name}_pubkey.txt"", ""w"") as out_file:"‖"out_file.write(f""{key_size},{public_key[0]},{public_key[1]}"")"‖1
"print(f""Writing private key to file {name}_privkey.txt..."")"‖"with open(f""{name}_privkey.txt"", ""w"") as out_file:"‖1
"with open(f""{name}_privkey.txt"", ""w"") as out_file:"‖"out_file.write(f""{key_size},{private_key[0]},{private_key[1]}"")"‖1
for r in range(1, modulus):‖li = []‖1
li = []‖for x in range(modulus - 1):‖1
for x in range(modulus - 1):‖val = pow(r, x, modulus)‖1
val = pow(r, x, modulus)‖if val in li:‖1
if val in li:‖break‖1
break‖li.append(val)‖1
li.append(val)‖else:‖1
else:‖return r‖1
return r‖return None‖1
"prime = int(input(""Enter a prime number q: ""))"‖primitive_root = find_primitive(prime)‖1
primitive_root = find_primitive(prime)‖if primitive_root is None:‖1
if primitive_root is None:‖"print(f""Cannot find the primitive for the value: {primitive_root!r}"")"‖1
"print(f""Cannot find the primitive for the value: {primitive_root!r}"")"‖else:‖1
else:‖"a_private = int(input(""Enter private key of A: ""))"‖1
"a_private = int(input(""Enter private key of A: ""))"‖a_public = pow(primitive_root, a_private, prime)‖1
a_public = pow(primitive_root, a_private, prime)‖"b_private = int(input(""Enter private key of B: ""))"‖1
"b_private = int(input(""Enter private key of B: ""))"‖b_public = pow(primitive_root, b_private, prime)‖1
a_secret = pow(b_public, a_private, prime)‖b_secret = pow(a_public, b_private, prime)‖1
"print(""The key value generated by A is: "", a_secret)"‖"print(""The key value generated by B is: "", b_secret)"‖1
encoded = []‖count = 1‖1
for i in range(len(text)):‖if i + 1 < len(text) and text[i] == text[i + 1]:‖1
if i + 1 < len(text) and text[i] == text[i + 1]:‖count += 1‖1
count += 1‖else:‖1
else:‖encoded.append((text[i], count))‖1
encoded.append((text[i], count))‖count = 1‖1
"if __name__ == ""__main__"":"‖from doctest import testmod‖94
"testmod(name=""run_length_encode"", verbose=True)"‖"testmod(name=""run_length_decode"", verbose=True)"‖1
if isinstance(num, float):‖"raise TypeError(""int() can't convert non-string with explicit base"")"‖1
"raise TypeError(""int() can't convert non-string with explicit base"")"‖if num < 0:‖1
if num < 0:‖"raise ValueError(""parameter must be positive int"")"‖1
"raise ValueError(""parameter must be positive int"")"‖if isinstance(base, str):‖1
if isinstance(base, str):‖"raise TypeError(""'str' object cannot be interpreted as an integer"")"‖1
"raise TypeError(""'str' object cannot be interpreted as an integer"")"‖if isinstance(base, float):‖1
if isinstance(base, float):‖"raise TypeError(""'float' object cannot be interpreted as an integer"")"‖1
"raise TypeError(""'float' object cannot be interpreted as an integer"")"‖if base in (0, 1):‖1
if base in (0, 1):‖"raise ValueError(""base must be >= 2"")"‖1
"raise ValueError(""base must be >= 2"")"‖if base > 36:‖1
if base > 36:‖"raise ValueError(""base must be <= 36"")"‖1
"raise ValueError(""base must be <= 36"")"‖"new_value = """""‖1
"new_value = """""‖mod = 0‖1
mod = 0‖div = 0‖1
div = 0‖while div != 1:‖1
while div != 1:‖div, mod = divmod(num, base)‖1
div, mod = divmod(num, base)‖if base >= 11 and 9 < mod < 36:‖1
if base >= 11 and 9 < mod < 36:‖actual_value = ALPHABET_VALUES[str(mod)]‖1
actual_value = ALPHABET_VALUES[str(mod)]‖else:‖1
else:‖actual_value = str(mod)‖1
actual_value = str(mod)‖new_value += actual_value‖1
new_value += actual_value‖div = num // base‖1
div = num // base‖num = div‖1
num = div‖if div == 0:‖1
if div == 0:‖return str(new_value[::-1])‖1
return str(new_value[::-1])‖elif div == 1:‖1
elif div == 1:‖new_value += str(div)‖1
new_value += str(div)‖return str(new_value[::-1])‖1
for base in range(2, 37):‖for num in range(1000):‖1
for num in range(1000):‖assert int(decimal_to_any(num, base), base) == num, (‖1
assert int(decimal_to_any(num, base), base) == num, (‖num,‖1
num,‖base,‖1
base,‖decimal_to_any(num, base),‖1
decimal_to_any(num, base),‖int(decimal_to_any(num, base), base),‖1
int(decimal_to_any(num, base), base),‖)‖1
if (len(data) % 2) != 0:‖raise ValueError(‖1
"if not set(data) <= set(""0123456789ABCDEF""):"‖raise ValueError(‖1
if n == 2:‖return True‖1
return True‖if not n % 2 or n < 2:‖1
if not n % 2 or n < 2:‖return False‖1
return False‖if n > 5 and n % 10 not in (1, 3, 7, 9):‖1
if n > 5 and n % 10 not in (1, 3, 7, 9):‖return False‖1
return False‖if n > 3_317_044_064_679_887_385_961_981 and not allow_probable:‖1
if n > 3_317_044_064_679_887_385_961_981 and not allow_probable:‖raise ValueError(‖1
raise ValueError(‖"""Warning: upper bound of deterministic test is exceeded. """‖1
"""Warning: upper bound of deterministic test is exceeded. """‖"""Pass allow_probable=True to allow probabilistic test. """‖1
"""Pass allow_probable=True to allow probabilistic test. """‖"""A return value of True indicates a probable prime."""‖1
"""A return value of True indicates a probable prime."""‖)‖1
bounds = [‖2_047,‖1
2_047,‖1_373_653,‖1
1_373_653,‖25_326_001,‖1
25_326_001,‖3_215_031_751,‖1
3_215_031_751,‖2_152_302_898_747,‖1
2_152_302_898_747,‖3_474_749_660_383,‖1
3_474_749_660_383,‖341_550_071_728_321,‖1
341_550_071_728_321,‖1,‖1
1,‖3_825_123_056_546_413_051,‖1
3_825_123_056_546_413_051,‖1,‖1
1,‖1,‖1
1,‖318_665_857_834_031_151_167_461,‖1
318_665_857_834_031_151_167_461,‖3_317_044_064_679_887_385_961_981,‖1
3_317_044_064_679_887_385_961_981,‖]‖1
primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]‖for idx, _p in enumerate(bounds, 1):‖1
for idx, _p in enumerate(bounds, 1):‖if n < _p:‖1
plist = primes[:idx]‖break‖1
break‖d, s = n - 1, 0‖1
while d % 2 == 0:‖d //= 2‖1
d //= 2‖s += 1‖1
s += 1‖for prime in plist:‖1
for prime in plist:‖pr = False‖1
pr = False‖for r in range(s):‖1
for r in range(s):‖m = pow(prime, d * 2**r, n)‖1
if (r == 0 and m == 1) or ((m + 1) % n == 0):‖pr = True‖1
break‖if pr:‖1
if pr:‖continue‖1
return False‖return True‖13
assert not miller_rabin(561)‖assert miller_rabin(563)‖1
assert not miller_rabin(838_201)‖assert miller_rabin(838_207)‖1
assert not miller_rabin(17_316_001)‖assert miller_rabin(17_316_017)‖1
assert not miller_rabin(3_078_386_641)‖assert miller_rabin(3_078_386_653)‖1
assert not miller_rabin(1_713_045_574_801)‖assert miller_rabin(1_713_045_574_819)‖1
assert not miller_rabin(2_779_799_728_307)‖assert miller_rabin(2_779_799_728_327)‖1
assert not miller_rabin(113_850_023_909_441)‖assert miller_rabin(113_850_023_909_527)‖1
assert not miller_rabin(1_275_041_018_848_804_351)‖assert miller_rabin(1_275_041_018_848_804_391)‖1
assert not miller_rabin(79_666_464_458_507_787_791_867)‖assert miller_rabin(79_666_464_458_507_787_791_951)‖1
assert not miller_rabin(552_840_677_446_647_897_660_333)‖assert miller_rabin(552_840_677_446_647_897_660_359)‖1
"if __name__ == ""__main__"":"‖test_miller_rabin()‖1
import math‖import random‖5
k = d * e - 1‖p = 0‖1
p = 0‖q = 0‖1
q = 0‖while p == 0:‖1
while p == 0:‖g = random.randint(2, n - 1)‖1
g = random.randint(2, n - 1)‖t = k‖1
t = k‖while True:‖1
while True:‖if t % 2 == 0:‖1
if t % 2 == 0:‖t = t // 2‖1
t = t // 2‖x = (g**t) % n‖1
x = (g**t) % n‖y = math.gcd(x - 1, n)‖1
y = math.gcd(x - 1, n)‖if x > 1 and y > 1:‖1
if x > 1 and y > 1:‖p = y‖1
p = y‖q = n // y‖1
q = n // y‖break‖1
break‖else:‖15
else:‖break‖5
break‖return sorted([p, q])‖1
y, x = position‖positions = [‖1
positions = [‖(y + 1, x + 2),‖1
(y + 1, x + 2),‖(y - 1, x + 2),‖1
(y - 1, x + 2),‖(y + 1, x - 2),‖1
(y + 1, x - 2),‖(y - 1, x - 2),‖1
(y - 1, x - 2),‖(y + 2, x + 1),‖1
(y + 2, x + 1),‖(y + 2, x - 1),‖1
(y + 2, x - 1),‖(y - 2, x + 1),‖1
(y - 2, x + 1),‖(y - 2, x - 1),‖1
(y - 2, x - 1),‖]‖1
]‖permissible_positions = []‖1
for inner_position in positions:‖y_test, x_test = inner_position‖1
y_test, x_test = inner_position‖if 0 <= y_test < n and 0 <= x_test < n:‖1
if 0 <= y_test < n and 0 <= x_test < n:‖permissible_positions.append(inner_position)‖1
def open_knight_tour_helper(‖board: list[list[int]], pos: tuple[int, int], curr: int‖1
board: list[list[int]], pos: tuple[int, int], curr: int‖) -> bool:‖1
if is_complete(board):‖return True‖1
for position in get_valid_pos(pos, len(board)):‖y, x = position‖1
if board[y][x] == 0:‖board[y][x] = curr + 1‖1
board[y][x] = curr + 1‖if open_knight_tour_helper(board, position, curr + 1):‖1
if open_knight_tour_helper(board, position, curr + 1):‖return True‖1
return True‖board[y][x] = 0‖1
for i in range(n):‖for j in range(n):‖8
for j in range(n):‖board[i][j] = 1‖1
board[i][j] = 1‖if open_knight_tour_helper(board, (i, j), 1):‖1
if open_knight_tour_helper(board, (i, j), 1):‖return board‖1
return board‖board[i][j] = 0‖1
"msg = f""Open Knight Tour cannot be performed on a board of size {n}"""‖raise ValueError(msg)‖1
import math‖import os‖2
import cv2‖import numpy as np‖8
def peak_signal_to_noise_ratio(original: float, contrast: float) -> float:‖mse = np.mean((original - contrast) ** 2)‖1
mse = np.mean((original - contrast) ** 2)‖if mse == 0:‖1
if mse == 0:‖return 100‖1
def main() -> None:‖dir_path = os.path.dirname(os.path.realpath(__file__))‖1
"original = cv2.imread(os.path.join(dir_path, ""image_data/original_image.png""))"‖"contrast = cv2.imread(os.path.join(dir_path, ""image_data/compressed_image.png""), 1)"‖1
"original2 = cv2.imread(os.path.join(dir_path, ""image_data/PSNR-example-base.png""))"‖contrast2 = cv2.imread(‖1
contrast2 = cv2.imread(‖"os.path.join(dir_path, ""image_data/PSNR-example-comp-10.jpg""), 1"‖1
"os.path.join(dir_path, ""image_data/PSNR-example-comp-10.jpg""), 1"‖)‖1
"print(""-- First Test --"")"‖"print(f""PSNR value is {peak_signal_to_noise_ratio(original, contrast)} dB"")"‖1
"print(""\n-- Second Test --"")"‖"print(f""PSNR value is {peak_signal_to_noise_ratio(original2, contrast2)} dB"")"‖1
from enum import Enum‖from typing import Literal‖1
class NumberingSystem(Enum):‖SHORT = (‖1
SHORT = (‖"(15, ""quadrillion""),"‖1
"(15, ""quadrillion""),"‖"(12, ""trillion""),"‖1
"(12, ""trillion""),"‖"(9, ""billion""),"‖1
"(9, ""billion""),"‖"(6, ""million""),"‖1
"(6, ""million""),"‖"(3, ""thousand""),"‖2
"(3, ""thousand""),"‖"(2, ""hundred""),"‖3
"(2, ""hundred""),"‖)‖3
LONG = (‖"(15, ""billiard""),"‖1
"(15, ""billiard""),"‖"(9, ""milliard""),"‖1
"(9, ""milliard""),"‖"(6, ""million""),"‖1
INDIAN = (‖"(14, ""crore crore""),"‖1
"(14, ""crore crore""),"‖"(12, ""lakh crore""),"‖1
"(12, ""lakh crore""),"‖"(7, ""crore""),"‖1
"(7, ""crore""),"‖"(5, ""lakh""),"‖1
"(5, ""lakh""),"‖"(3, ""thousand""),"‖1
@classmethod‖def max_value(cls, system: str) -> int:‖1
match system_enum := cls[system.upper()]:‖case cls.SHORT:‖1
case cls.SHORT:‖max_exp = system_enum.value[0][0] + 3‖1
max_exp = system_enum.value[0][0] + 3‖case cls.LONG:‖1
case cls.LONG:‖max_exp = system_enum.value[0][0] + 6‖1
max_exp = system_enum.value[0][0] + 6‖case cls.INDIAN:‖1
case cls.INDIAN:‖max_exp = 19‖1
max_exp = 19‖case _:‖1
case _:‖"raise ValueError(""Invalid numbering system"")"‖1
"raise ValueError(""Invalid numbering system"")"‖return 10**max_exp - 1‖1
class NumberWords(Enum):‖ONES = {‖1
ONES = {‖"0: """","‖1
"0: """","‖"1: ""one"","‖1
"1: ""one"","‖"2: ""two"","‖1
"2: ""two"","‖"3: ""three"","‖1
"3: ""three"","‖"4: ""four"","‖1
"4: ""four"","‖"5: ""five"","‖1
"5: ""five"","‖"6: ""six"","‖1
"6: ""six"","‖"7: ""seven"","‖1
"7: ""seven"","‖"8: ""eight"","‖1
"8: ""eight"","‖"9: ""nine"","‖1
"9: ""nine"","‖}‖1
TEENS = {‖"0: ""ten"","‖1
"0: ""ten"","‖"1: ""eleven"","‖1
"1: ""eleven"","‖"2: ""twelve"","‖1
"2: ""twelve"","‖"3: ""thirteen"","‖1
"3: ""thirteen"","‖"4: ""fourteen"","‖1
"4: ""fourteen"","‖"5: ""fifteen"","‖1
"5: ""fifteen"","‖"6: ""sixteen"","‖1
"6: ""sixteen"","‖"7: ""seventeen"","‖1
"7: ""seventeen"","‖"8: ""eighteen"","‖1
"8: ""eighteen"","‖"9: ""nineteen"","‖1
"9: ""nineteen"","‖}‖1
TENS = {‖"2: ""twenty"","‖1
"2: ""twenty"","‖"3: ""thirty"","‖1
"3: ""thirty"","‖"4: ""forty"","‖1
"4: ""forty"","‖"5: ""fifty"","‖1
"5: ""fifty"","‖"6: ""sixty"","‖1
"6: ""sixty"","‖"7: ""seventy"","‖1
"7: ""seventy"","‖"8: ""eighty"","‖1
"8: ""eighty"","‖"9: ""ninety"","‖1
"9: ""ninety"","‖}‖1
if num < 0:‖"raise ValueError(""This function only accepts non-negative integers"")"‖1
"raise ValueError(""This function only accepts non-negative integers"")"‖if num >= 100:‖1
if num >= 100:‖"raise ValueError(""This function only converts numbers less than 100"")"‖1
"raise ValueError(""This function only converts numbers less than 100"")"‖tens, ones = divmod(num, 10)‖1
tens, ones = divmod(num, 10)‖if tens == 0:‖1
if tens == 0:‖"return NumberWords.ONES.value[ones] or ""zero"""‖1
"return NumberWords.ONES.value[ones] or ""zero"""‖if tens == 1:‖1
if tens == 1:‖return NumberWords.TEENS.value[ones]‖1
return NumberWords.TEENS.value[ones]‖return (‖1
return (‖NumberWords.TENS.value[tens]‖1
NumberWords.TENS.value[tens]‖"+ (""-"" if NumberWords.ONES.value[ones] else """")"‖1
"+ (""-"" if NumberWords.ONES.value[ones] else """")"‖+ NumberWords.ONES.value[ones]‖1
+ NumberWords.ONES.value[ones]‖)‖1
def convert_number(‖"num: int, system: Literal[""short"", ""long"", ""indian""] = ""short"""‖1
"num: int, system: Literal[""short"", ""long"", ""indian""] = ""short"""‖) -> str:‖1
if num < 0:‖"word_groups.append(""negative"")"‖1
"word_groups.append(""negative"")"‖num *= -1‖1
if num > NumberingSystem.max_value(system):‖"raise ValueError(""Input number is too large"")"‖1
for power, unit in NumberingSystem[system.upper()].value:‖digit_group, num = divmod(num, 10**power)‖1
digit_group, num = divmod(num, 10**power)‖if digit_group > 0:‖1
if digit_group > 0:‖word_group = (‖1
word_group = (‖convert_number(digit_group, system)‖1
convert_number(digit_group, system)‖if digit_group >= 100‖1
if digit_group >= 100‖else convert_small_number(digit_group)‖1
else convert_small_number(digit_group)‖)‖1
)‖"word_groups.append(f""{word_group} {unit}"")"‖1
"word_groups.append(f""{word_group} {unit}"")"‖if num > 0 or not word_groups:‖1
if num > 0 or not word_groups:‖word_groups.append(convert_small_number(num))‖1
word_groups.append(convert_small_number(num))‖"return "" "".join(word_groups)"‖1
encode_dict = {‖"""a"": ""AAAAA"","‖1
"""a"": ""AAAAA"","‖"""b"": ""AAAAB"","‖1
"""b"": ""AAAAB"","‖"""c"": ""AAABA"","‖1
"""c"": ""AAABA"","‖"""d"": ""AAABB"","‖1
"""d"": ""AAABB"","‖"""e"": ""AABAA"","‖1
"""e"": ""AABAA"","‖"""f"": ""AABAB"","‖1
"""f"": ""AABAB"","‖"""g"": ""AABBA"","‖1
"""g"": ""AABBA"","‖"""h"": ""AABBB"","‖1
"""h"": ""AABBB"","‖"""i"": ""ABAAA"","‖1
"""i"": ""ABAAA"","‖"""j"": ""BBBAA"","‖1
"""j"": ""BBBAA"","‖"""k"": ""ABAAB"","‖1
"""k"": ""ABAAB"","‖"""l"": ""ABABA"","‖1
"""l"": ""ABABA"","‖"""m"": ""ABABB"","‖1
"""m"": ""ABABB"","‖"""n"": ""ABBAA"","‖1
"""n"": ""ABBAA"","‖"""o"": ""ABBAB"","‖1
"""o"": ""ABBAB"","‖"""p"": ""ABBBA"","‖1
"""p"": ""ABBBA"","‖"""q"": ""ABBBB"","‖1
"""q"": ""ABBBB"","‖"""r"": ""BAAAA"","‖1
"""r"": ""BAAAA"","‖"""s"": ""BAAAB"","‖1
"""s"": ""BAAAB"","‖"""t"": ""BAABA"","‖1
"""t"": ""BAABA"","‖"""u"": ""BAABB"","‖1
"""u"": ""BAABB"","‖"""v"": ""BBBAB"","‖1
"""v"": ""BBBAB"","‖"""w"": ""BABAA"","‖1
"""w"": ""BABAA"","‖"""x"": ""BABAB"","‖1
"""x"": ""BABAB"","‖"""y"": ""BABBA"","‖1
"""y"": ""BABBA"","‖"""z"": ""BABBB"","‖1
"""z"": ""BABBB"","‖""" "": "" "","‖1
""" "": "" "","‖}‖1
"encoded = """""‖for letter in word.lower():‖1
for letter in word.lower():‖"if letter.isalpha() or letter == "" "":"‖1
"if letter.isalpha() or letter == "" "":"‖encoded += encode_dict[letter]‖1
encoded += encode_dict[letter]‖else:‖1
else:‖"raise Exception(""encode() accepts only letters of the alphabet and spaces"")"‖1
"raise Exception(""encode() accepts only letters of the alphabet and spaces"")"‖return encoded‖1
"if set(coded) - {""A"", ""B"", "" ""} != set():"‖"raise Exception(""decode() accepts only 'A', 'B' and spaces"")"‖1
"raise Exception(""decode() accepts only 'A', 'B' and spaces"")"‖"decoded = """""‖1
"decoded = """""‖for word in coded.split():‖1
for word in coded.split():‖while len(word) != 0:‖1
while len(word) != 0:‖decoded += decode_dict[word[:5]]‖1
decoded += decode_dict[word[:5]]‖word = word[5:]‖1
word = word[5:]‖"decoded += "" """‖1
"decoded += "" """‖return decoded.strip()‖1
def decrypt_caesar_with_chi_squared(‖ciphertext: str,‖1
ciphertext: str,‖cipher_alphabet: list[str] | None = None,‖1
cipher_alphabet: list[str] | None = None,‖frequencies_dict: dict[str, float] | None = None,‖1
frequencies_dict: dict[str, float] | None = None,‖case_sensitive: bool = False,‖1
case_sensitive: bool = False,‖) -> tuple[int, float, str]:‖1
frequencies = {‖"""a"": 0.08497,"‖1
"""a"": 0.08497,"‖"""b"": 0.01492,"‖1
"""b"": 0.01492,"‖"""c"": 0.02202,"‖1
"""c"": 0.02202,"‖"""d"": 0.04253,"‖1
"""d"": 0.04253,"‖"""e"": 0.11162,"‖1
"""e"": 0.11162,"‖"""f"": 0.02228,"‖1
"""f"": 0.02228,"‖"""g"": 0.02015,"‖1
"""g"": 0.02015,"‖"""h"": 0.06094,"‖1
"""h"": 0.06094,"‖"""i"": 0.07546,"‖1
"""i"": 0.07546,"‖"""j"": 0.00153,"‖1
"""j"": 0.00153,"‖"""k"": 0.01292,"‖1
"""k"": 0.01292,"‖"""l"": 0.04025,"‖1
"""l"": 0.04025,"‖"""m"": 0.02406,"‖1
"""m"": 0.02406,"‖"""n"": 0.06749,"‖1
"""n"": 0.06749,"‖"""o"": 0.07507,"‖1
"""o"": 0.07507,"‖"""p"": 0.01929,"‖1
"""p"": 0.01929,"‖"""q"": 0.00095,"‖1
"""q"": 0.00095,"‖"""r"": 0.07587,"‖1
"""r"": 0.07587,"‖"""s"": 0.06327,"‖1
"""s"": 0.06327,"‖"""t"": 0.09356,"‖1
"""t"": 0.09356,"‖"""u"": 0.02758,"‖1
"""u"": 0.02758,"‖"""v"": 0.00978,"‖1
"""v"": 0.00978,"‖"""w"": 0.02560,"‖1
"""w"": 0.02560,"‖"""x"": 0.00150,"‖1
"""x"": 0.00150,"‖"""y"": 0.01994,"‖1
"""y"": 0.01994,"‖"""z"": 0.00077,"‖1
"""z"": 0.00077,"‖}‖1
}‖else:‖1
if not case_sensitive:‖ciphertext = ciphertext.lower()‖1
for shift in range(len(alphabet_letters)):‖"decrypted_with_shift = """""‖1
for letter in ciphertext:‖try:‖1
new_key = (alphabet_letters.index(letter.lower()) - shift) % len(‖alphabet_letters‖1
alphabet_letters‖)‖1
)‖decrypted_with_shift += (‖1
decrypted_with_shift += (‖alphabet_letters[new_key].upper()‖1
alphabet_letters[new_key].upper()‖if case_sensitive and letter.isupper()‖1
if case_sensitive and letter.isupper()‖else alphabet_letters[new_key]‖1
else alphabet_letters[new_key]‖)‖1
)‖except ValueError:‖1
for letter in decrypted_with_shift:‖if case_sensitive:‖1
if case_sensitive:‖letter = letter.lower()‖1
letter = letter.lower()‖if letter in frequencies:‖1
chi_squared_statistic += chi_letter_value‖elif letter.lower() in frequencies:‖1
chi_squared_statistic_values[shift] = (‖chi_squared_statistic,‖1
chi_squared_statistic,‖decrypted_with_shift,‖1
decrypted_with_shift,‖)‖1
def chi_squared_statistic_values_sorting_key(key: int) -> tuple[float, str]:‖return chi_squared_statistic_values[key]‖1
most_likely_cipher: int = min(‖chi_squared_statistic_values,‖1
chi_squared_statistic_values,‖key=chi_squared_statistic_values_sorting_key,‖1
key=chi_squared_statistic_values_sorting_key,‖)‖1
(‖most_likely_cipher_chi_squared_value,‖1
most_likely_cipher_chi_squared_value,‖decoded_most_likely_cipher,‖2
decoded_most_likely_cipher,‖) = chi_squared_statistic_values[most_likely_cipher]‖1
return (‖most_likely_cipher,‖1
most_likely_cipher,‖most_likely_cipher_chi_squared_value,‖1
decoded_most_likely_cipher,‖)‖1
from matplotlib import pyplot as plt‖from matplotlib.animation import FuncAnimation‖1
WIDTH = 80‖HEIGHT = 80‖1
self.board = [[True] * width for _ in range(height)]‖self.ant_position: tuple[int, int] = (width // 2, height // 2)‖1
directions = {‖0: (-1, 0),‖1
0: (-1, 0),‖1: (0, 1),‖1
1: (0, 1),‖2: (1, 0),‖1
2: (1, 0),‖3: (0, -1),‖1
3: (0, -1),‖}‖1
}‖x, y = self.ant_position‖1
self.ant_direction = (self.ant_direction + 1) % 4‖else:‖1
move_x, move_y = directions[self.ant_direction]‖self.ant_position = (x + move_x, y + move_y)‖1
axes.get_xaxis().set_ticks([])‖axes.get_yaxis().set_ticks([])‖1
axes.get_yaxis().set_ticks([])‖"axes.imshow(self.board, cmap=""gray"", interpolation=""nearest"")"‖1
self.animation = FuncAnimation(‖fig, partial(self.move_ant, ax, True), frames=frames, interval=1‖1
fig, partial(self.move_ant, ax, True), frames=frames, interval=1‖)‖1
)‖plt.show()‖1
def valid_connection(‖graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]‖1
graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]‖) -> bool:‖1
if graph[path[curr_ind - 1]][next_ver] == 0:‖return False‖1
for next_ver in range(len(graph)):‖if valid_connection(graph, next_ver, curr_ind, path):‖1
if util_hamilton_cycle(graph, path, curr_ind + 1):‖return True‖1
path[curr_ind] = -1‖return False‖1
import os‖import sys‖4
DEFAULT_BLOCK_SIZE = 128‖BYTE_SIZE = 256‖1
def get_blocks_from_text(‖message: str, block_size: int = DEFAULT_BLOCK_SIZE‖1
message: str, block_size: int = DEFAULT_BLOCK_SIZE‖) -> list[int]:‖1
) -> list[int]:‖"message_bytes = message.encode(""ascii"")"‖1
block_ints = []‖for block_start in range(0, len(message_bytes), block_size):‖1
for block_start in range(0, len(message_bytes), block_size):‖block_int = 0‖1
block_int = 0‖for i in range(block_start, min(block_start + block_size, len(message_bytes))):‖1
for i in range(block_start, min(block_start + block_size, len(message_bytes))):‖block_int += message_bytes[i] * (BYTE_SIZE ** (i % block_size))‖1
block_int += message_bytes[i] * (BYTE_SIZE ** (i % block_size))‖block_ints.append(block_int)‖1
block_ints.append(block_int)‖return block_ints‖1
def get_text_from_blocks(‖block_ints: list[int], message_length: int, block_size: int = DEFAULT_BLOCK_SIZE‖1
block_ints: list[int], message_length: int, block_size: int = DEFAULT_BLOCK_SIZE‖) -> str:‖1
) -> str:‖message: list[str] = []‖1
message: list[str] = []‖for block_int in block_ints:‖1
for block_int in block_ints:‖block_message: list[str] = []‖1
block_message: list[str] = []‖for i in range(block_size - 1, -1, -1):‖1
for i in range(block_size - 1, -1, -1):‖if len(message) + i < message_length:‖1
if len(message) + i < message_length:‖ascii_number = block_int // (BYTE_SIZE**i)‖1
ascii_number = block_int // (BYTE_SIZE**i)‖block_int = block_int % (BYTE_SIZE**i)‖1
block_int = block_int % (BYTE_SIZE**i)‖block_message.insert(0, chr(ascii_number))‖1
block_message.insert(0, chr(ascii_number))‖message.extend(block_message)‖1
message.extend(block_message)‖"return """".join(message)"‖1
def encrypt_message(‖message: str, key: tuple[int, int], block_size: int = DEFAULT_BLOCK_SIZE‖1
message: str, key: tuple[int, int], block_size: int = DEFAULT_BLOCK_SIZE‖) -> list[int]:‖1
) -> list[int]:‖encrypted_blocks = []‖1
encrypted_blocks = []‖n, e = key‖1
for block in get_blocks_from_text(message, block_size):‖encrypted_blocks.append(pow(block, e, n))‖1
encrypted_blocks.append(pow(block, e, n))‖return encrypted_blocks‖1
def decrypt_message(‖encrypted_blocks: list[int],‖1
encrypted_blocks: list[int],‖message_length: int,‖1
message_length: int,‖key: tuple[int, int],‖1
key: tuple[int, int],‖block_size: int = DEFAULT_BLOCK_SIZE,‖1
block_size: int = DEFAULT_BLOCK_SIZE,‖) -> str:‖2
) -> str:‖decrypted_blocks = []‖1
decrypted_blocks = []‖n, d = key‖1
n, d = key‖for block in encrypted_blocks:‖1
for block in encrypted_blocks:‖decrypted_blocks.append(pow(block, d, n))‖1
decrypted_blocks.append(pow(block, d, n))‖return get_text_from_blocks(decrypted_blocks, message_length, block_size)‖1
def read_key_file(key_filename: str) -> tuple[int, int, int]:‖with open(key_filename) as fo:‖1
with open(key_filename) as fo:‖content = fo.read()‖1
content = fo.read()‖"key_size, n, eor_d = content.split("","")"‖1
"key_size, n, eor_d = content.split("","")"‖return (int(key_size), int(n), int(eor_d))‖1
def encrypt_and_write_to_file(‖message_filename: str,‖1
message_filename: str,‖key_filename: str,‖1
key_filename: str,‖message: str,‖1
message: str,‖block_size: int = DEFAULT_BLOCK_SIZE,‖1
) -> str:‖key_size, n, e = read_key_file(key_filename)‖1
key_size, n, e = read_key_file(key_filename)‖if key_size < block_size * 8:‖1
if key_size < block_size * 8:‖sys.exit(‖2
sys.exit(‖"f""ERROR: Block size is {block_size * 8} bits and key size is {key_size} """‖2
"f""ERROR: Block size is {block_size * 8} bits and key size is {key_size} """‖"""bits. The RSA cipher requires the block size to be equal to or greater """‖2
"""bits. The RSA cipher requires the block size to be equal to or greater """‖"""than the key size. Either decrease the block size or use different keys."""‖1
"""than the key size. Either decrease the block size or use different keys."""‖)‖1
"encrypted_content = "","".join(encrypted_blocks)"‖"encrypted_content = f""{len(message)}_{block_size}_{encrypted_content}"""‖1
"encrypted_content = f""{len(message)}_{block_size}_{encrypted_content}"""‖"with open(message_filename, ""w"") as fo:"‖1
"with open(message_filename, ""w"") as fo:"‖fo.write(encrypted_content)‖1
fo.write(encrypted_content)‖return encrypted_content‖1
def read_from_file_and_decrypt(message_filename: str, key_filename: str) -> str:‖key_size, n, d = read_key_file(key_filename)‖1
key_size, n, d = read_key_file(key_filename)‖with open(message_filename) as fo:‖1
with open(message_filename) as fo:‖content = fo.read()‖1
content = fo.read()‖"message_length_str, block_size_str, encrypted_message = content.split(""_"")"‖1
"message_length_str, block_size_str, encrypted_message = content.split(""_"")"‖message_length = int(message_length_str)‖1
message_length = int(message_length_str)‖block_size = int(block_size_str)‖1
"""bits. The RSA cipher requires the block size to be equal to or greater """‖"""than the key size. Were the correct key file and encrypted file specified?"""‖1
"""than the key size. Were the correct key file and encrypted file specified?"""‖)‖1
encrypted_blocks = []‖"for block in encrypted_message.split("",""):"‖1
"for block in encrypted_message.split("",""):"‖encrypted_blocks.append(int(block))‖1
def main() -> None:‖"filename = ""encrypted_file.txt"""‖1
"filename = ""encrypted_file.txt"""‖"response = input(r""Encrypt\Decrypt [e\d]: "")"‖1
"if response.lower().startswith(""e""):"‖"mode = ""encrypt"""‖1
"mode = ""encrypt"""‖"elif response.lower().startswith(""d""):"‖1
"elif response.lower().startswith(""d""):"‖"mode = ""decrypt"""‖1
"if mode == ""encrypt"":"‖"if not os.path.exists(""rsa_pubkey.txt""):"‖1
"if not os.path.exists(""rsa_pubkey.txt""):"‖"rkg.make_key_files(""rsa"", 1024)"‖1
"message = input(""\nEnter message: "")"‖"pubkey_filename = ""rsa_pubkey.txt"""‖1
"pubkey_filename = ""rsa_pubkey.txt"""‖"print(f""Encrypting and writing to {filename}..."")"‖1
"print(f""Encrypting and writing to {filename}..."")"‖encrypted_text = encrypt_and_write_to_file(filename, pubkey_filename, message)‖1
"print(""\nEncrypted text:"")"‖print(encrypted_text)‖1
"elif mode == ""decrypt"":"‖"privkey_filename = ""rsa_privkey.txt"""‖1
"privkey_filename = ""rsa_privkey.txt"""‖"print(f""Reading from {filename} and decrypting..."")"‖1
"print(f""Reading from {filename} and decrypting..."")"‖decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)‖1
decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)‖"print(""writing decryption to rsa_decryption.txt..."")"‖1
"print(""writing decryption to rsa_decryption.txt..."")"‖"with open(""rsa_decryption.txt"", ""w"") as dec:"‖1
"with open(""rsa_decryption.txt"", ""w"") as dec:"‖dec.write(decrypted_text)‖1
"print(""\nDecryption:"")"‖print(decrypted_text)‖1
from collections.abc import Sequence‖from typing import Literal‖1
list1 = list(string1)‖list2 = list(string2)‖2
list2 = list(string2)‖count = 0‖1
count = 0‖for i in range(len(list1)):‖1
for i in range(len(list1)):‖if list1[i] != list2[i]:‖1
if list1[i] != list2[i]:‖count += 1‖1
count += 1‖"list1[i] = ""_"""‖1
"list1[i] = ""_"""‖if count > 1:‖1
if count > 1:‖return False‖1
return False‖else:‖6
else:‖"return """".join(list1)"‖1
pi = []‖while True:‖1
while True:‖"check1 = [""$""] * len(binary)"‖1
"check1 = [""$""] * len(binary)"‖temp = []‖1
temp = []‖for i in range(len(binary)):‖1
for i in range(len(binary)):‖for j in range(i + 1, len(binary)):‖1
for j in range(i + 1, len(binary)):‖k = compare_string(binary[i], binary[j])‖1
k = compare_string(binary[i], binary[j])‖if k is False:‖1
if k is False:‖"check1[i] = ""*"""‖1
"check1[i] = ""*"""‖"check1[j] = ""*"""‖1
"check1[j] = ""*"""‖"temp.append(""X"")"‖1
"temp.append(""X"")"‖for i in range(len(binary)):‖1
for i in range(len(binary)):‖"if check1[i] == ""$"":"‖1
"if check1[i] == ""$"":"‖pi.append(binary[i])‖1
pi.append(binary[i])‖if len(temp) == 0:‖1
if len(temp) == 0:‖return pi‖1
return pi‖binary = list(set(temp))‖1
temp = []‖for minterm in minterms:‖1
for minterm in minterms:‖"string = """""‖1
"string = """""‖for _ in range(no_of_variable):‖1
for _ in range(no_of_variable):‖string = str(minterm % 2) + string‖1
string = str(minterm % 2) + string‖minterm //= 2‖1
minterm //= 2‖temp.append(string)‖1
temp.append(string)‖return temp‖1
list2 = list(string2)‖count_n = sum(item1 != item2 for item1, item2 in zip(list1, list2))‖1
count_n = sum(item1 != item2 for item1, item2 in zip(list1, list2))‖return count_n == count‖1
temp = []‖select = [0] * len(chart)‖1
select = [0] * len(chart)‖for i in range(len(chart[0])):‖1
for i in range(len(chart[0])):‖count = sum(row[i] == 1 for row in chart)‖1
count = sum(row[i] == 1 for row in chart)‖if count == 1:‖1
if count == 1:‖rem = max(j for j, row in enumerate(chart) if row[i] == 1)‖1
rem = max(j for j, row in enumerate(chart) if row[i] == 1)‖select[rem] = 1‖1
select[rem] = 1‖for i, item in enumerate(select):‖1
for i, item in enumerate(select):‖if item != 1:‖1
if item != 1:‖continue‖1
continue‖for j in range(len(chart[0])):‖1
for j in range(len(chart[0])):‖if chart[i][j] != 1:‖1
if chart[i][j] != 1:‖continue‖1
continue‖for row in chart:‖1
for row in chart:‖row[j] = 0‖1
row[j] = 0‖temp.append(prime_implicants[i])‖1
temp.append(prime_implicants[i])‖while True:‖1
while True:‖counts = [chart[i].count(1) for i in range(len(chart))]‖1
counts = [chart[i].count(1) for i in range(len(chart))]‖max_n = max(counts)‖1
max_n = max(counts)‖rem = counts.index(max_n)‖1
if max_n == 0:‖return temp‖1
for j in range(len(chart[0])):‖if chart[rem][j] != 1:‖1
if chart[rem][j] != 1:‖continue‖1
continue‖for i in range(len(chart)):‖1
for i in range(len(chart)):‖chart[i][j] = 0‖1
def prime_implicant_chart(‖prime_implicants: list[str], binary: list[str]‖1
prime_implicants: list[str], binary: list[str]‖) -> list[list[int]]:‖1
chart = [[0 for x in range(len(binary))] for x in range(len(prime_implicants))]‖for i in range(len(prime_implicants)):‖1
for i in range(len(prime_implicants)):‖"count = prime_implicants[i].count(""_"")"‖1
"count = prime_implicants[i].count(""_"")"‖for j in range(len(binary)):‖1
for j in range(len(binary)):‖if is_for_table(prime_implicants[i], binary[j], count):‖1
if is_for_table(prime_implicants[i], binary[j], count):‖chart[i][j] = 1‖1
def main() -> None:‖"no_of_variable = int(input(""Enter the no. of variables\n""))"‖1
"no_of_variable = int(input(""Enter the no. of variables\n""))"‖minterms = [‖1
minterms = [‖float(x)‖1
float(x)‖for x in input(‖1
for x in input(‖"""Enter the decimal representation of Minterms 'Spaces Separated'\n"""‖1
"""Enter the decimal representation of Minterms 'Spaces Separated'\n"""‖).split()‖1
).split()‖]‖1
]‖binary = decimal_to_binary(no_of_variable, minterms)‖1
prime_implicants = check(binary)‖"print(""Prime Implicants are:"")"‖1
"print(""Prime Implicants are:"")"‖print(prime_implicants)‖1
print(prime_implicants)‖chart = prime_implicant_chart(prime_implicants, binary)‖1
essential_prime_implicants = selection(chart, prime_implicants)‖"print(""Essential Prime Implicants are:"")"‖1
"print(""Essential Prime Implicants are:"")"‖print(essential_prime_implicants)‖1
doctest.testmod()‖main()‖23
"__version__ = ""0.1"""‖"__author__ = ""Lucia Harcekova"""‖1
@dataclass‖class Token:‖1
offset: int‖length: int‖1
length: int‖indicator: str‖1
def __init__(self, window_size: int = 13, lookahead_buffer_size: int = 6) -> None:‖self.window_size = window_size‖1
self.window_size = window_size‖self.lookahead_buffer_size = lookahead_buffer_size‖1
self.lookahead_buffer_size = lookahead_buffer_size‖self.search_buffer_size = self.window_size - self.lookahead_buffer_size‖1
output = []‖"search_buffer = """""‖1
search_buffer += text[: token.length + 1]‖if len(search_buffer) > self.search_buffer_size:‖1
if len(search_buffer) > self.search_buffer_size:‖search_buffer = search_buffer[-self.search_buffer_size :]‖1
for token in tokens:‖for _ in range(token.length):‖1
for _ in range(token.length):‖output += output[-token.offset]‖1
output += output[-token.offset]‖output += token.indicator‖1
if not text:‖"raise ValueError(""We need some text to work with."")"‖1
if not search_buffer:‖return Token(offset, length, text[length])‖1
for i, character in enumerate(search_buffer):‖found_offset = len(search_buffer) - i‖1
found_offset = len(search_buffer) - i‖if character == text[0]:‖1
if character == text[0]:‖found_length = self._match_length_from_index(text, search_buffer, 0, i)‖1
if found_length >= length:‖offset, length = found_offset, found_length‖1
def _match_length_from_index(‖self, text: str, window: str, text_index: int, window_index: int‖1
self, text: str, window: str, text_index: int, window_index: int‖) -> int:‖1
if not text or text[text_index] != window[window_index]:‖return 0‖1
return 0‖return 1 + self._match_length_from_index(‖1
return 1 + self._match_length_from_index(‖text, window + text[text_index], text_index + 1, window_index + 1‖1
text, window + text[text_index], text_index + 1, window_index + 1‖)‖1
"TEXT = ""cabracadabrarrarrad"""‖compressed_text = lz77_compressor.compress(TEXT)‖1
compressed_text = lz77_compressor.compress(TEXT)‖"print(lz77_compressor.compress(""ababcbababaa""))"‖1
"print(lz77_compressor.compress(""ababcbababaa""))"‖decompressed_text = lz77_compressor.decompress(compressed_text)‖1
decompressed_text = lz77_compressor.decompress(compressed_text)‖"assert decompressed_text == TEXT, ""The LZ77 algorithm returned the invalid result."""‖1
if not isinstance(plaintext, str):‖"raise TypeError(""plaintext must be a string"")"‖1
"raise TypeError(""plaintext must be a string"")"‖if not isinstance(key, str):‖1
if not isinstance(key, str):‖"raise TypeError(""key must be a string"")"‖2
if not plaintext:‖"raise ValueError(""plaintext is empty"")"‖1
"raise ValueError(""plaintext is empty"")"‖if not key:‖1
if not key:‖"raise ValueError(""key is empty"")"‖2
key += plaintext‖plaintext = plaintext.lower()‖1
plaintext = plaintext.lower()‖key = key.lower()‖1
key = key.lower()‖plaintext_iterator = 0‖1
plaintext_iterator = 0‖key_iterator = 0‖1
key_iterator = 0‖"ciphertext = """""‖1
"ciphertext = """""‖while plaintext_iterator < len(plaintext):‖1
while plaintext_iterator < len(plaintext):‖if (‖1
if (‖ord(plaintext[plaintext_iterator]) < 97‖1
ord(plaintext[plaintext_iterator]) < 97‖or ord(plaintext[plaintext_iterator]) > 122‖1
or ord(plaintext[plaintext_iterator]) > 122‖):‖1
):‖ciphertext += plaintext[plaintext_iterator]‖1
ciphertext += plaintext[plaintext_iterator]‖plaintext_iterator += 1‖1
plaintext_iterator += 1‖elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:‖1
elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:‖key_iterator += 1‖1
key_iterator += 1‖else:‖1
else:‖ciphertext += chr(‖1
ciphertext += chr(‖(‖1
(‖(ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))‖1
(ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))‖- 97‖1
- 97‖)‖1
)‖% 26‖1
% 26‖+ 97‖1
+ 97‖)‖3
)‖key_iterator += 1‖2
key_iterator += 1‖plaintext_iterator += 1‖1
plaintext_iterator += 1‖return ciphertext‖1
if not isinstance(ciphertext, str):‖"raise TypeError(""ciphertext must be a string"")"‖1
"raise TypeError(""ciphertext must be a string"")"‖if not isinstance(key, str):‖1
if not ciphertext:‖"raise ValueError(""ciphertext is empty"")"‖1
"raise ValueError(""ciphertext is empty"")"‖if not key:‖1
key = key.lower()‖ciphertext_iterator = 0‖1
ciphertext_iterator = 0‖key_iterator = 0‖1
key_iterator = 0‖"plaintext = """""‖1
"plaintext = """""‖while ciphertext_iterator < len(ciphertext):‖1
while ciphertext_iterator < len(ciphertext):‖if (‖1
if (‖ord(ciphertext[ciphertext_iterator]) < 97‖1
ord(ciphertext[ciphertext_iterator]) < 97‖or ord(ciphertext[ciphertext_iterator]) > 122‖1
or ord(ciphertext[ciphertext_iterator]) > 122‖):‖1
):‖plaintext += ciphertext[ciphertext_iterator]‖1
plaintext += ciphertext[ciphertext_iterator]‖else:‖1
else:‖plaintext += chr(‖1
plaintext += chr(‖(ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26‖1
(ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26‖+ 97‖2
)‖key += chr(‖1
key += chr(‖(ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26‖1
key_iterator += 1‖ciphertext_iterator += 1‖1
ciphertext_iterator += 1‖return plaintext‖1
doctest.testmod()‖"operation = int(input(""Type 1 to encrypt or 2 to decrypt:""))"‖1
"operation = int(input(""Type 1 to encrypt or 2 to decrypt:""))"‖if operation == 1:‖1
if operation == 1:‖"plaintext = input(""Typeplaintext to be encrypted:\n"")"‖1
"plaintext = input(""Typeplaintext to be encrypted:\n"")"‖"key = input(""Type the key:\n"")"‖1
"key = input(""Type the key:\n"")"‖print(encrypt(plaintext, key))‖1
print(encrypt(plaintext, key))‖elif operation == 2:‖1
elif operation == 2:‖"ciphertext = input(""Type the ciphertext to be decrypted:\n"")"‖1
"ciphertext = input(""Type the ciphertext to be decrypted:\n"")"‖"key = input(""Type the key:\n"")"‖1
"key = input(""Type the key:\n"")"‖print(decrypt(ciphertext, key))‖1
print(decrypt(ciphertext, key))‖"decrypt(""jsqqs avvwo"", ""coffee"")"‖1
def bin_to_octal(bin_string: str) -> str:‖"if not all(char in ""01"" for char in bin_string):"‖1
"if not all(char in ""01"" for char in bin_string):"‖"raise ValueError(""Non-binary value was passed to the function"")"‖2
"raise ValueError(""Non-binary value was passed to the function"")"‖if not bin_string:‖1
if not bin_string:‖"raise ValueError(""Empty string was passed to the function"")"‖2
"raise ValueError(""Empty string was passed to the function"")"‖"oct_string = """""‖1
"oct_string = """""‖while len(bin_string) % 3 != 0:‖1
while len(bin_string) % 3 != 0:‖"bin_string = ""0"" + bin_string"‖1
"bin_string = ""0"" + bin_string"‖bin_string_in_3_list = [‖1
bin_string_in_3_list = [‖bin_string[index : index + 3]‖1
bin_string[index : index + 3]‖for index in range(len(bin_string))‖1
for index in range(len(bin_string))‖if index % 3 == 0‖1
if index % 3 == 0‖]‖1
]‖for bin_group in bin_string_in_3_list:‖1
for bin_group in bin_string_in_3_list:‖oct_val = 0‖1
oct_val = 0‖for index, val in enumerate(bin_group):‖1
for index, val in enumerate(bin_group):‖oct_val += int(2 ** (2 - index) * int(val))‖1
oct_val += int(2 ** (2 - index) * int(val))‖oct_string += str(oct_val)‖1
oct_string += str(oct_val)‖return oct_string‖1
def find_mod_inverse(a: int, m: int) -> int:‖if gcd_by_iterative(a, m) != 1:‖1
if gcd_by_iterative(a, m) != 1:‖"msg = f""mod inverse of {a!r} and {m!r} does not exist"""‖1
"msg = f""mod inverse of {a!r} and {m!r} does not exist"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖u1, u2, u3 = 1, 0, a‖1
u1, u2, u3 = 1, 0, a‖v1, v2, v3 = 0, 1, m‖1
v1, v2, v3 = 0, 1, m‖while v3 != 0:‖1
while v3 != 0:‖q = u3 // v3‖1
q = u3 // v3‖v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3‖1
v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3‖return u1 % m‖1
if number > 0:‖"raise ValueError(""input must be a negative integer"")"‖1
"raise ValueError(""input must be a negative integer"")"‖binary_number_length = len(bin(number)[3:])‖1
binary_number_length = len(bin(number)[3:])‖twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]‖1
twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]‖twos_complement_number = (‖1
twos_complement_number = (‖(‖1
(‖"""1"""‖1
"""1"""‖"+ ""0"" * (binary_number_length - len(twos_complement_number))"‖1
"+ ""0"" * (binary_number_length - len(twos_complement_number))"‖+ twos_complement_number‖1
+ twos_complement_number‖)‖1
)‖if number < 0‖1
if number < 0‖"else ""0"""‖1
"else ""0"""‖)‖1
)‖"return ""0b"" + twos_complement_number"‖1
"out = """""‖for c in s:‖1
for c in s:‖"if ""A"" <= c <= ""Z"":"‖1
"if ""A"" <= c <= ""Z"":"‖"out += chr(ord(""A"") + (ord(c) - ord(""A"") + n) % 26)"‖1
"out += chr(ord(""A"") + (ord(c) - ord(""A"") + n) % 26)"‖"elif ""a"" <= c <= ""z"":"‖1
"elif ""a"" <= c <= ""z"":"‖"out += chr(ord(""a"") + (ord(c) - ord(""a"") + n) % 26)"‖1
"out += chr(ord(""a"") + (ord(c) - ord(""a"") + n) % 26)"‖else:‖1
else:‖out += c‖1
out += c‖return out‖1
def main() -> None:‖"s0 = input(""Enter message: "")"‖1
s1 = dencrypt(s0, 13)‖"print(""Encryption:"", s1)"‖1
s2 = dencrypt(s1, 13)‖"print(""Decryption: "", s2)"‖1
import math‖import sys‖4
"result = """""‖try:‖2
try:‖"with open(file_path, ""rb"") as binary_file:"‖2
"with open(file_path, ""rb"") as binary_file:"‖data = binary_file.read()‖2
data = binary_file.read()‖for dat in data:‖2
for dat in data:‖"curr_byte = f""{dat:08b}"""‖2
"curr_byte = f""{dat:08b}"""‖result += curr_byte‖2
result += curr_byte‖return result‖2
return result‖except OSError:‖2
except OSError:‖"print(""File not accessible"")"‖4
"print(""File not accessible"")"‖sys.exit()‖4
"lexicon = {""0"": ""0"", ""1"": ""1""}"‖"result, curr_string = """", """""‖2
"result, curr_string = """", """""‖index = len(lexicon)‖2
for i in range(len(data_bits)):‖curr_string += data_bits[i]‖2
curr_string += data_bits[i]‖if curr_string not in lexicon:‖2
if curr_string not in lexicon:‖continue‖2
last_match_id = lexicon[curr_string]‖result += last_match_id‖3
result += last_match_id‖"lexicon[curr_string] = last_match_id + ""0"""‖1
if math.log2(index).is_integer():‖new_lex = {}‖1
new_lex = {}‖for curr_key in list(lexicon):‖1
for curr_key in list(lexicon):‖"new_lex[""0"" + curr_key] = lexicon.pop(curr_key)"‖1
"new_lex[""0"" + curr_key] = lexicon.pop(curr_key)"‖lexicon = new_lex‖1
"lexicon[bin(index)[2:]] = last_match_id + ""1"""‖index += 1‖1
index += 1‖"curr_string = """""‖2
"curr_string = """""‖return result‖1
byte_length = 8‖try:‖2
try:‖"with open(file_path, ""wb"") as opened_file:"‖2
"with open(file_path, ""wb"") as opened_file:"‖result_byte_array = [‖2
result_byte_array = [‖to_write[i : i + byte_length]‖2
to_write[i : i + byte_length]‖for i in range(0, len(to_write), byte_length)‖2
for i in range(0, len(to_write), byte_length)‖]‖2
if len(result_byte_array[-1]) % byte_length == 0:‖"result_byte_array.append(""10000000"")"‖2
"result_byte_array.append(""10000000"")"‖else:‖2
else:‖"result_byte_array[-1] += ""1"" + ""0"" * ("‖2
"result_byte_array[-1] += ""1"" + ""0"" * ("‖byte_length - len(result_byte_array[-1]) - 1‖2
byte_length - len(result_byte_array[-1]) - 1‖)‖2
for elem in result_byte_array[:-1]:‖"opened_file.write(int(elem, 2).to_bytes(1, byteorder=""big""))"‖1
"opened_file.write(int(elem, 2).to_bytes(1, byteorder=""big""))"‖except OSError:‖2
counter = 0‖for letter in data_bits:‖1
for letter in data_bits:‖"if letter == ""1"":"‖1
"if letter == ""1"":"‖break‖1
break‖counter += 1‖1
data_bits = data_bits[counter:]‖data_bits = data_bits[counter + 1 :]‖1
data_bits = data_bits[counter + 1 :]‖return data_bits‖1
data_bits = read_file_binary(source_path)‖data_bits = remove_prefix(data_bits)‖1
data_bits = remove_prefix(data_bits)‖decompressed = decompress_data(data_bits)‖1
decompressed = decompress_data(data_bits)‖write_file_binary(destination_path, decompressed)‖1
"if __name__ == ""__main__"":"‖compress(sys.argv[1], sys.argv[2])‖2
"output = """""‖for i in sequence:‖1
for i in sequence:‖extract = ord(i)‖1
extract = ord(i)‖if 65 <= extract <= 90:‖1
if 65 <= extract <= 90:‖output += chr(155 - extract)‖1
output += chr(155 - extract)‖elif 97 <= extract <= 122:‖1
elif 97 <= extract <= 122:‖output += chr(219 - extract)‖1
output += chr(219 - extract)‖else:‖1
else:‖output += i‖1
output += i‖return output‖1
letters = string.ascii_letters‖letters_reversed = string.ascii_lowercase[::-1] + string.ascii_uppercase[::-1]‖1
letters_reversed = string.ascii_lowercase[::-1] + string.ascii_uppercase[::-1]‖"return """".join("‖1
"return """".join("‖letters_reversed[letters.index(c)] if c in letters else c for c in sequence‖1
letters_reversed[letters.index(c)] if c in letters else c for c in sequence‖)‖1
"print(""Running performance benchmarks..."")"‖"setup = ""from string import printable ; from __main__ import atbash, atbash_slow"""‖1
"setup = ""from string import printable ; from __main__ import atbash, atbash_slow"""‖"print(f""> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds"")"‖1
"print(f""> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds"")"‖"print(f"">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds"")"‖1
"if __name__ == ""__main__"":"‖"for example in (""ABCDEFGH"", ""123GGjj"", ""testStringtest"", ""with space""):"‖1
"for example in (""ABCDEFGH"", ""123GGjj"", ""testStringtest"", ""with space""):"‖"print(f""{example} encrypted in atbash: {atbash(example)}"")"‖1
"print(f""{example} encrypted in atbash: {atbash(example)}"")"‖benchmark()‖1
for character in input_string:‖if character not in alpha:‖1
result += character‖else:‖1
"if __name__ == ""__main__"":"‖while True:‖1
while True:‖"print(f""\n{'-' * 10}\n Menu\n{'-' * 10}"")"‖1
"print(f""\n{'-' * 10}\n Menu\n{'-' * 10}"")"‖"print(*[""1.Encrypt"", ""2.Decrypt"", ""3.BruteForce"", ""4.Quit""], sep=""\n"")"‖1
"if choice not in (""1"", ""2"", ""3"", ""4""):"‖"print(""Invalid choice, please enter a valid choice"")"‖1
"print(""Invalid choice, please enter a valid choice"")"‖"elif choice == ""1"":"‖1
"elif choice == ""1"":"‖"input_string = input(""Please enter the string to be encrypted: "")"‖1
"input_string = input(""Please enter the string to be encrypted: "")"‖"key = int(input(""Please enter off-set: "").strip())"‖1
print(encrypt(input_string, key))‖"elif choice == ""2"":"‖1
"elif choice == ""2"":"‖"input_string = input(""Please enter the string to be decrypted: "")"‖1
"input_string = input(""Please enter the string to be decrypted: "")"‖"key = int(input(""Please enter off-set: "").strip())"‖1
print(decrypt(input_string, key))‖"elif choice == ""3"":"‖1
"elif choice == ""3"":"‖"input_string = input(""Please enter the string to be decrypted: "")"‖1
"input_string = input(""Please enter the string to be decrypted: "")"‖brute_force_data = brute_force(input_string)‖1
for key, value in brute_force_data.items():‖"print(f""Key: {key} | Message: {value}"")"‖1
"elif choice == ""4"":"‖"print(""Goodbye."")"‖1
"print(""Goodbye."")"‖break‖1
BITS_TO_HEX = {‖"""0000"": ""0"","‖1
"""0000"": ""0"","‖"""0001"": ""1"","‖1
"""0001"": ""1"","‖"""0010"": ""2"","‖1
"""0010"": ""2"","‖"""0011"": ""3"","‖1
"""0011"": ""3"","‖"""0100"": ""4"","‖1
"""0100"": ""4"","‖"""0101"": ""5"","‖1
"""0101"": ""5"","‖"""0110"": ""6"","‖1
"""0110"": ""6"","‖"""0111"": ""7"","‖1
"""0111"": ""7"","‖"""1000"": ""8"","‖1
"""1000"": ""8"","‖"""1001"": ""9"","‖1
"""1001"": ""9"","‖"""1010"": ""a"","‖1
"""1010"": ""a"","‖"""1011"": ""b"","‖1
"""1011"": ""b"","‖"""1100"": ""c"","‖1
"""1100"": ""c"","‖"""1101"": ""d"","‖1
"""1101"": ""d"","‖"""1110"": ""e"","‖1
"""1110"": ""e"","‖"""1111"": ""f"","‖1
"""1111"": ""f"","‖}‖1
if not binary_str:‖"raise ValueError(""Empty string was passed to the function"")"‖1
"raise ValueError(""Empty string was passed to the function"")"‖"is_negative = binary_str[0] == ""-"""‖1
"is_negative = binary_str[0] == ""-"""‖binary_str = binary_str[1:] if is_negative else binary_str‖1
binary_str = binary_str[1:] if is_negative else binary_str‖"if not all(char in ""01"" for char in binary_str):"‖1
"if not all(char in ""01"" for char in binary_str):"‖"raise ValueError(""Non-binary value was passed to the function"")"‖1
binary_str = (‖"""0"" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str"‖1
"""0"" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str"‖)‖1
hexadecimal = []‖for x in range(0, len(binary_str), 4):‖1
for x in range(0, len(binary_str), 4):‖hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])‖1
hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])‖"hexadecimal_str = ""0x"" + """".join(hexadecimal)"‖1
temp_grid: list[list[str]] = [[] for _ in range(key)]‖lowest = key - 1‖1
if key <= 0:‖"raise ValueError(""Height of grid can't be 0 or negative"")"‖2
"raise ValueError(""Height of grid can't be 0 or negative"")"‖if key == 1 or len(input_string) <= key:‖1
if key == 1 or len(input_string) <= key:‖return input_string‖1
for position, character in enumerate(input_string):‖num = position % (lowest * 2)‖1
num = position % (lowest * 2)‖num = min(num, lowest * 2 - num)‖3
num = min(num, lowest * 2 - num)‖temp_grid[num].append(character)‖1
temp_grid[num].append(character)‖"grid = ["""".join(row) for row in temp_grid]"‖1
"grid = ["""".join(row) for row in temp_grid]"‖"output_string = """".join(grid)"‖1
grid = []‖lowest = key - 1‖1
"raise ValueError(""Height of grid can't be 0 or negative"")"‖if key == 1:‖1
if key == 1:‖return input_string‖1
temp_grid: list[list[str]] = [[] for _ in range(key)]‖for position in range(len(input_string)):‖1
for position in range(len(input_string)):‖num = position % (lowest * 2)‖2
num = min(num, lowest * 2 - num)‖"temp_grid[num].append(""*"")"‖1
counter = 0‖for row in temp_grid:‖1
for row in temp_grid:‖splice = input_string[counter : counter + len(row)]‖1
splice = input_string[counter : counter + len(row)]‖grid.append(list(splice))‖1
grid.append(list(splice))‖counter += len(row)‖1
"output_string = """""‖for position in range(len(input_string)):‖1
num = min(num, lowest * 2 - num)‖output_string += grid[num][0]‖1
output_string += grid[num][0]‖grid[num].pop(0)‖1
grid[num].pop(0)‖return output_string‖1
results = {}‖for key_guess in range(1, len(input_string)):‖1
for key_guess in range(1, len(input_string)):‖results[key_guess] = decrypt(input_string, key_guess)‖1
results[key_guess] = decrypt(input_string, key_guess)‖return results‖1
if not isinstance(number, int):‖"raise TypeError(""number must be an integer"")"‖1
"raise TypeError(""number must be an integer"")"‖if number <= 0:‖1
if number <= 0:‖"raise ValueError(""number must be positive"")"‖1
"raise ValueError(""number must be positive"")"‖if number & (number - 1) == 0:‖1
if number & (number - 1) == 0:‖c = 0‖1
c = 0‖while number:‖1
while number:‖c += 1‖1
c += 1‖number >>= 1‖1
number >>= 1‖return c % 2 == 1‖1
return c % 2 == 1‖else:‖1
def add_key_to_lexicon(‖lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str‖1
lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str‖) -> None:‖1
lexicon.pop(curr_string)‖"lexicon[curr_string + ""0""] = last_match_id"‖1
if math.log2(index).is_integer():‖for curr_key, value in lexicon.items():‖1
for curr_key, value in lexicon.items():‖"lexicon[curr_key] = f""0{value}"""‖1
result += last_match_id‖add_key_to_lexicon(lexicon, curr_string, index, last_match_id)‖1
add_key_to_lexicon(lexicon, curr_string, index, last_match_id)‖index += 1‖1
"while curr_string != """" and curr_string not in lexicon:"‖"curr_string += ""0"""‖1
"if curr_string != """":"‖last_match_id = lexicon[curr_string]‖1
file_length = os.path.getsize(source_path)‖file_length_binary = bin(file_length)[2:]‖1
file_length_binary = bin(file_length)[2:]‖length_length = len(file_length_binary)‖1
for elem in result_byte_array:‖"opened_file.write(int(elem, 2).to_bytes(1, byteorder=""big""))"‖1
data_bits = read_file_binary(source_path)‖compressed = compress_data(data_bits)‖1
compressed = compress_data(data_bits)‖compressed = add_file_length(source_path, compressed)‖1
compressed = add_file_length(source_path, compressed)‖write_file_binary(destination_path, compressed)‖1
for key in range(len(string.ascii_uppercase)):‖"translated = """""‖1
"translated = """""‖for symbol in message:‖1
for symbol in message:‖if symbol in string.ascii_uppercase:‖1
if symbol in string.ascii_uppercase:‖num = string.ascii_uppercase.find(symbol)‖1
num = string.ascii_uppercase.find(symbol)‖num = num - key‖1
num = num - key‖if num < 0:‖1
if num < 0:‖num = num + len(string.ascii_uppercase)‖1
num = num + len(string.ascii_uppercase)‖translated = translated + string.ascii_uppercase[num]‖1
translated = translated + string.ascii_uppercase[num]‖else:‖1
else:‖translated = translated + symbol‖1
translated = translated + symbol‖"print(f""Decryption using Key #{key}: {translated}"")"‖1
def main() -> None:‖"message = input(""Encrypted message: "")"‖1
"message = input(""Encrypted message: "")"‖message = message.upper()‖1
message = message.upper()‖decrypt(message)‖1
bin_string = str(bin_string).strip()‖if not bin_string:‖1
"raise ValueError(""Empty string was passed to the function"")"‖"is_negative = bin_string[0] == ""-"""‖1
"is_negative = bin_string[0] == ""-"""‖if is_negative:‖1
if is_negative:‖bin_string = bin_string[1:]‖1
bin_string = bin_string[1:]‖"if not all(char in ""01"" for char in bin_string):"‖1
"raise ValueError(""Non-binary value was passed to the function"")"‖decimal_number = 0‖1
decimal_number = 0‖for char in bin_string:‖1
for char in bin_string:‖decimal_number = 2 * decimal_number + int(char)‖1
decimal_number = 2 * decimal_number + int(char)‖return -decimal_number if is_negative else decimal_number‖1
if number < 0 or shift_amount < 0:‖"raise ValueError(""both inputs must be positive integers"")"‖2
binary_number = str(bin(number))‖"binary_number += ""0"" * shift_amount"‖1
"binary_number += ""0"" * shift_amount"‖return binary_number‖1
binary_number = str(bin(number))[2:]‖if shift_amount >= len(binary_number):‖1
if shift_amount >= len(binary_number):‖"return ""0b0"""‖1
"return ""0b0"""‖shifted_binary_number = binary_number[: len(binary_number) - shift_amount]‖1
shifted_binary_number = binary_number[: len(binary_number) - shift_amount]‖"return ""0b"" + shifted_binary_number"‖1
if number >= 0:‖"binary_number = ""0"" + str(bin(number)).strip(""-"")[2:]"‖1
"binary_number = ""0"" + str(bin(number)).strip(""-"")[2:]"‖else:‖1
else:‖binary_number_length = len(bin(number)[3:])‖1
binary_number_length = len(bin(number)[3:])‖binary_number = bin(abs(number) - (1 << binary_number_length))[3:]‖1
binary_number = bin(abs(number) - (1 << binary_number_length))[3:]‖binary_number = (‖1
binary_number = (‖"""1"" + ""0"" * (binary_number_length - len(binary_number)) + binary_number"‖1
"""1"" + ""0"" * (binary_number_length - len(binary_number)) + binary_number"‖)‖1
if shift_amount >= len(binary_number):‖"return ""0b"" + binary_number[0] * len(binary_number)"‖1
"return ""0b"" + binary_number[0] * len(binary_number)"‖return (‖1
return (‖"""0b"""‖1
"""0b"""‖+ binary_number[0] * shift_amount‖1
+ binary_number[0] * shift_amount‖+ binary_number[: len(binary_number) - shift_amount]‖1
+ binary_number[: len(binary_number) - shift_amount]‖)‖1
def rabin_miller(num: int) -> bool:‖s = num - 1‖1
s = num - 1‖t = 0‖1
while s % 2 == 0:‖s = s // 2‖1
s = s // 2‖t += 1‖1
for _ in range(5):‖a = random.randrange(2, num - 1)‖1
a = random.randrange(2, num - 1)‖v = pow(a, s, num)‖1
v = pow(a, s, num)‖if v != 1:‖1
if v != 1:‖i = 0‖1
i = 0‖while v != (num - 1):‖1
while v != (num - 1):‖if i == t - 1:‖1
if i == t - 1:‖return False‖1
else:‖i = i + 1‖1
i = i + 1‖v = (v**2) % num‖1
v = (v**2) % num‖return True‖1
def is_prime_low_num(num: int) -> bool:‖if num < 2:‖1
if num < 2:‖return False‖1
low_primes = [‖2,‖1
2,‖3,‖1
3,‖5,‖1
5,‖7,‖1
7,‖11,‖1
11,‖13,‖1
13,‖17,‖1
17,‖19,‖1
19,‖23,‖1
23,‖29,‖1
29,‖31,‖1
31,‖37,‖1
37,‖41,‖1
41,‖43,‖1
43,‖47,‖1
47,‖53,‖1
53,‖59,‖1
59,‖61,‖1
61,‖67,‖1
67,‖71,‖1
71,‖73,‖1
73,‖79,‖1
79,‖83,‖1
83,‖89,‖1
89,‖97,‖1
97,‖101,‖1
101,‖103,‖1
103,‖107,‖1
107,‖109,‖1
109,‖113,‖1
113,‖127,‖1
127,‖131,‖1
131,‖137,‖1
137,‖139,‖1
139,‖149,‖1
149,‖151,‖1
151,‖157,‖1
157,‖163,‖1
163,‖167,‖1
167,‖173,‖1
173,‖179,‖1
179,‖181,‖1
181,‖191,‖1
191,‖193,‖1
193,‖197,‖1
197,‖199,‖1
199,‖211,‖1
211,‖223,‖1
223,‖227,‖1
227,‖229,‖1
229,‖233,‖1
233,‖239,‖1
239,‖241,‖1
241,‖251,‖1
251,‖257,‖1
257,‖263,‖1
263,‖269,‖1
269,‖271,‖1
271,‖277,‖1
277,‖281,‖1
281,‖283,‖1
283,‖293,‖1
293,‖307,‖1
307,‖311,‖1
311,‖313,‖1
313,‖317,‖1
317,‖331,‖1
331,‖337,‖1
337,‖347,‖1
347,‖349,‖1
349,‖353,‖1
353,‖359,‖1
359,‖367,‖1
367,‖373,‖1
373,‖379,‖1
379,‖383,‖1
383,‖389,‖1
389,‖397,‖1
397,‖401,‖1
401,‖409,‖1
409,‖419,‖1
419,‖421,‖1
421,‖431,‖1
431,‖433,‖1
433,‖439,‖1
439,‖443,‖1
443,‖449,‖1
449,‖457,‖1
457,‖461,‖1
461,‖463,‖1
463,‖467,‖1
467,‖479,‖1
479,‖487,‖1
487,‖491,‖1
491,‖499,‖1
499,‖503,‖1
503,‖509,‖1
509,‖521,‖1
521,‖523,‖1
523,‖541,‖1
541,‖547,‖1
547,‖557,‖1
557,‖563,‖1
563,‖569,‖1
569,‖571,‖1
571,‖577,‖1
577,‖587,‖1
587,‖593,‖1
593,‖599,‖1
599,‖601,‖1
601,‖607,‖1
607,‖613,‖1
613,‖617,‖1
617,‖619,‖1
619,‖631,‖1
631,‖641,‖1
641,‖643,‖1
643,‖647,‖1
647,‖653,‖1
653,‖659,‖1
659,‖661,‖1
661,‖673,‖1
673,‖677,‖1
677,‖683,‖1
683,‖691,‖1
691,‖701,‖1
701,‖709,‖1
709,‖719,‖1
719,‖727,‖1
727,‖733,‖1
733,‖739,‖1
739,‖743,‖1
743,‖751,‖1
751,‖757,‖1
757,‖761,‖1
761,‖769,‖1
769,‖773,‖1
773,‖787,‖1
787,‖797,‖1
797,‖809,‖1
809,‖811,‖1
811,‖821,‖1
821,‖823,‖1
823,‖827,‖1
827,‖829,‖1
829,‖839,‖1
839,‖853,‖1
853,‖857,‖1
857,‖859,‖1
859,‖863,‖1
863,‖877,‖1
877,‖881,‖1
881,‖883,‖1
883,‖887,‖1
887,‖907,‖1
907,‖911,‖1
911,‖919,‖1
919,‖929,‖1
929,‖937,‖1
937,‖941,‖1
941,‖947,‖1
947,‖953,‖1
953,‖967,‖1
967,‖971,‖1
971,‖977,‖1
977,‖983,‖1
983,‖991,‖1
991,‖997,‖1
997,‖]‖1
if num in low_primes:‖return True‖1
for prime in low_primes:‖if (num % prime) == 0:‖1
if (num % prime) == 0:‖return False‖1
def generate_large_prime(keysize: int = 1024) -> int:‖while True:‖1
while True:‖num = random.randrange(2 ** (keysize - 1), 2 ** (keysize))‖1
num = random.randrange(2 ** (keysize - 1), 2 ** (keysize))‖if is_prime_low_num(num):‖1
if is_prime_low_num(num):‖return num‖1
"if __name__ == ""__main__"":"‖num = generate_large_prime()‖1
num = generate_large_prime()‖"print((""Prime number:"", num))"‖1
"print((""Prime number:"", num))"‖"print((""is_prime_low_num:"", is_prime_low_num(num)))"‖1
class Letter:‖def __init__(self, letter: str, freq: int):‖1
def __init__(self, letter: str, freq: int):‖self.letter: str = letter‖1
self.letter: str = letter‖self.freq: int = freq‖1
self.freq: int = freq‖self.bitstring: dict[str, str] = {}‖1
def __repr__(self) -> str:‖"return f""{self.letter}:{self.freq}"""‖1
class TreeNode:‖def __init__(self, freq: int, left: Letter | TreeNode, right: Letter | TreeNode):‖1
def __init__(self, freq: int, left: Letter | TreeNode, right: Letter | TreeNode):‖self.freq: int = freq‖1
self.freq: int = freq‖self.left: Letter | TreeNode = left‖1
self.left: Letter | TreeNode = left‖self.right: Letter | TreeNode = right‖1
chars: dict[str, int] = {}‖with open(file_path) as f:‖1
with open(file_path) as f:‖while True:‖2
while True:‖c = f.read(1)‖2
c = f.read(1)‖if not c:‖2
if not c:‖break‖2
break‖chars[c] = chars[c] + 1 if c in chars else 1‖1
chars[c] = chars[c] + 1 if c in chars else 1‖return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)‖1
response: list[Letter | TreeNode] = list(letters)‖while len(response) > 1:‖1
while len(response) > 1:‖left = response.pop(0)‖1
left = response.pop(0)‖right = response.pop(0)‖1
right = response.pop(0)‖total_freq = left.freq + right.freq‖1
total_freq = left.freq + right.freq‖node = TreeNode(total_freq, left, right)‖1
node = TreeNode(total_freq, left, right)‖response.append(node)‖1
response.append(node)‖response.sort(key=lambda x: x.freq)‖1
response.sort(key=lambda x: x.freq)‖return response[0]‖1
if isinstance(root, Letter):‖root.bitstring[root.letter] = bitstring‖1
root.bitstring[root.letter] = bitstring‖return [root]‖1
return [root]‖treenode: TreeNode = root‖1
treenode: TreeNode = root‖letters = []‖1
letters = []‖"letters += traverse_tree(treenode.left, bitstring + ""0"")"‖1
"letters += traverse_tree(treenode.left, bitstring + ""0"")"‖"letters += traverse_tree(treenode.right, bitstring + ""1"")"‖1
"letters += traverse_tree(treenode.right, bitstring + ""1"")"‖return letters‖1
letters_list = parse_file(file_path)‖root = build_tree(letters_list)‖1
root = build_tree(letters_list)‖letters = {‖1
letters = {‖"k: v for letter in traverse_tree(root, """") for k, v in letter.bitstring.items()"‖1
"k: v for letter in traverse_tree(root, """") for k, v in letter.bitstring.items()"‖}‖1
}‖"print(f""Huffman Coding  of {file_path}: "")"‖1
"print(f""Huffman Coding  of {file_path}: "")"‖with open(file_path) as f:‖1
break‖"print(letters[c], end="" "")"‖1
"print(letters[c], end="" "")"‖print()‖1
SQUARE = [‖"[""a"", ""b"", ""c"", ""d"", ""e""],"‖2
"[""a"", ""b"", ""c"", ""d"", ""e""],"‖"[""f"", ""g"", ""h"", ""i"", ""k""],"‖2
"[""f"", ""g"", ""h"", ""i"", ""k""],"‖"[""l"", ""m"", ""n"", ""o"", ""p""],"‖2
"[""l"", ""m"", ""n"", ""o"", ""p""],"‖"[""q"", ""r"", ""s"", ""t"", ""u""],"‖2
"[""q"", ""r"", ""s"", ""t"", ""u""],"‖"[""v"", ""w"", ""x"", ""y"", ""z""],"‖2
"[""v"", ""w"", ""x"", ""y"", ""z""],"‖]‖2
class BifidCipher:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self.SQUARE = np.array(SQUARE)‖2
index1, index2 = np.where(letter == self.SQUARE)‖indexes = np.concatenate([index1 + 1, index2 + 1])‖2
indexes = np.concatenate([index1 + 1, index2 + 1])‖return indexes‖2
letter = self.SQUARE[index1 - 1, index2 - 1]‖return letter‖1
message = message.lower()‖"message = message.replace("" "", """")"‖1
"message = message.replace("" "", """")"‖"message = message.replace(""j"", ""i"")"‖1
first_step = np.empty((2, len(message)))‖for letter_index in range(len(message)):‖1
for letter_index in range(len(message)):‖numbers = self.letter_to_numbers(message[letter_index])‖2
first_step[0, letter_index] = numbers[0]‖first_step[1, letter_index] = numbers[1]‖1
second_step = first_step.reshape(2 * len(message))‖"encoded_message = """""‖1
"encoded_message = """""‖for numbers_index in range(len(message)):‖1
for numbers_index in range(len(message)):‖index1 = int(second_step[numbers_index * 2])‖1
index1 = int(second_step[numbers_index * 2])‖index2 = int(second_step[(numbers_index * 2) + 1])‖1
index2 = int(second_step[(numbers_index * 2) + 1])‖letter = self.numbers_to_letter(index1, index2)‖1
letter = self.numbers_to_letter(index1, index2)‖encoded_message = encoded_message + letter‖1
message = message.lower()‖"message.replace("" "", """")"‖1
"message.replace("" "", """")"‖first_step = np.empty(2 * len(message))‖1
first_step = np.empty(2 * len(message))‖for letter_index in range(len(message)):‖1
numbers = self.letter_to_numbers(message[letter_index])‖first_step[letter_index * 2] = numbers[0]‖1
first_step[letter_index * 2] = numbers[0]‖first_step[letter_index * 2 + 1] = numbers[1]‖1
second_step = first_step.reshape((2, len(message)))‖"decoded_message = """""‖1
"decoded_message = """""‖for numbers_index in range(len(message)):‖1
for numbers_index in range(len(message)):‖index1 = int(second_step[0, numbers_index])‖1
index1 = int(second_step[0, numbers_index])‖index2 = int(second_step[1, numbers_index])‖1
index2 = int(second_step[1, numbers_index])‖letter = self.numbers_to_letter(index1, index2)‖1
letter = self.numbers_to_letter(index1, index2)‖decoded_message = decoded_message + letter‖1
from abc import abstractmethod‖from math import pi‖1
from math import pi‖from typing import Protocol‖1
import matplotlib.pyplot as plt‖import numpy as np‖7
class FilterType(Protocol):‖@abstractmethod‖1
@abstractmethod‖def process(self, sample: float) -> float:‖1
def process(self, sample: float) -> float:‖pass‖1
def get_bounds(‖fft_results: np.ndarray, samplerate: int‖1
fft_results: np.ndarray, samplerate: int‖) -> tuple[int | float, int | float]:‖1
lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])‖highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])‖1
highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])‖return lowest, highest‖1
size = 512‖inputs = [1] + [0] * (size - 1)‖2
inputs = [1] + [0] * (size - 1)‖outputs = [filter_type.process(item) for item in inputs]‖2
filler = [0] * (samplerate - size)‖outputs += filler‖2
outputs += filler‖fft_out = np.abs(np.fft.fft(outputs))‖1
fft_out = np.abs(np.fft.fft(outputs))‖fft_db = 20 * np.log10(fft_out)‖1
plt.xlim(24, samplerate / 2 - 1)‖"plt.xlabel(""Frequency (Hz)"")"‖2
"plt.xlabel(""Frequency (Hz)"")"‖"plt.xscale(""log"")"‖2
bounds = get_bounds(fft_db, samplerate)‖plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))‖1
plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))‖"plt.ylabel(""Gain (dB)"")"‖1
plt.plot(fft_db)‖plt.show()‖1
outputs += filler‖fft_out = np.angle(np.fft.fft(outputs))‖1
plt.ylim(-2 * pi, 2 * pi)‖"plt.ylabel(""Phase shift (Radians)"")"‖1
"plt.ylabel(""Phase shift (Radians)"")"‖plt.plot(np.unwrap(fft_out, -2 * pi))‖1
plt.plot(np.unwrap(fft_out, -2 * pi))‖plt.show()‖1
UNIT_SYMBOL = {‖"""meter"": ""m"","‖1
"""meter"": ""m"","‖"""kilometer"": ""km"","‖2
"""kilometer"": ""km"","‖"""megametre"": ""Mm"","‖1
"""megametre"": ""Mm"","‖"""gigametre"": ""Gm"","‖1
"""gigametre"": ""Gm"","‖"""terametre"": ""Tm"","‖1
"""terametre"": ""Tm"","‖"""petametre"": ""Pm"","‖1
"""petametre"": ""Pm"","‖"""exametre"": ""Em"","‖1
"""exametre"": ""Em"","‖"""zettametre"": ""Zm"","‖1
"""zettametre"": ""Zm"","‖"""yottametre"": ""Ym"","‖1
"""yottametre"": ""Ym"","‖}‖1
METRIC_CONVERSION = {‖"""m"": 0,"‖1
"""m"": 0,"‖"""km"": 3,"‖1
"""km"": 3,"‖"""Mm"": 6,"‖1
"""Mm"": 6,"‖"""Gm"": 9,"‖1
"""Gm"": 9,"‖"""Tm"": 12,"‖1
"""Tm"": 12,"‖"""Pm"": 15,"‖1
"""Pm"": 15,"‖"""Em"": 18,"‖1
"""Em"": 18,"‖"""Zm"": 21,"‖1
"""Zm"": 21,"‖"""Ym"": 24,"‖1
"""Ym"": 24,"‖}‖1
"from_sanitized = from_type.lower().strip(""s"")"‖"to_sanitized = to_type.lower().strip(""s"")"‖1
from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)‖to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)‖1
if from_sanitized not in METRIC_CONVERSION:‖msg = (‖1
msg = (‖"f""Invalid 'from_type' value: {from_type!r}.\n"""‖2
"f""Invalid 'from_type' value: {from_type!r}.\n"""‖"f""Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}"""‖2
"f""Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}"""‖)‖4
)‖raise ValueError(msg)‖33
raise ValueError(msg)‖if to_sanitized not in METRIC_CONVERSION:‖1
if to_sanitized not in METRIC_CONVERSION:‖msg = (‖1
msg = (‖"f""Invalid 'to_type' value: {to_type!r}.\n"""‖2
"f""Invalid 'to_type' value: {to_type!r}.\n"""‖"f""Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}"""‖2
raise ValueError(msg)‖from_exponent = METRIC_CONVERSION[from_sanitized]‖1
from_exponent = METRIC_CONVERSION[from_sanitized]‖to_exponent = METRIC_CONVERSION[to_sanitized]‖1
to_exponent = METRIC_CONVERSION[to_sanitized]‖exponent = 1‖1
if from_exponent > to_exponent:‖exponent = from_exponent - to_exponent‖1
exponent = from_exponent - to_exponent‖else:‖1
else:‖exponent = -(to_exponent - from_exponent)‖1
alphabet = {‖"""A"": (""ABCDEFGHIJKLM"", ""NOPQRSTUVWXYZ""),"‖1
"""A"": (""ABCDEFGHIJKLM"", ""NOPQRSTUVWXYZ""),"‖"""B"": (""ABCDEFGHIJKLM"", ""NOPQRSTUVWXYZ""),"‖1
"""B"": (""ABCDEFGHIJKLM"", ""NOPQRSTUVWXYZ""),"‖"""C"": (""ABCDEFGHIJKLM"", ""ZNOPQRSTUVWXY""),"‖1
"""C"": (""ABCDEFGHIJKLM"", ""ZNOPQRSTUVWXY""),"‖"""D"": (""ABCDEFGHIJKLM"", ""ZNOPQRSTUVWXY""),"‖1
"""D"": (""ABCDEFGHIJKLM"", ""ZNOPQRSTUVWXY""),"‖"""E"": (""ABCDEFGHIJKLM"", ""YZNOPQRSTUVWX""),"‖1
"""E"": (""ABCDEFGHIJKLM"", ""YZNOPQRSTUVWX""),"‖"""F"": (""ABCDEFGHIJKLM"", ""YZNOPQRSTUVWX""),"‖1
"""F"": (""ABCDEFGHIJKLM"", ""YZNOPQRSTUVWX""),"‖"""G"": (""ABCDEFGHIJKLM"", ""XYZNOPQRSTUVW""),"‖1
"""G"": (""ABCDEFGHIJKLM"", ""XYZNOPQRSTUVW""),"‖"""H"": (""ABCDEFGHIJKLM"", ""XYZNOPQRSTUVW""),"‖1
"""H"": (""ABCDEFGHIJKLM"", ""XYZNOPQRSTUVW""),"‖"""I"": (""ABCDEFGHIJKLM"", ""WXYZNOPQRSTUV""),"‖1
"""I"": (""ABCDEFGHIJKLM"", ""WXYZNOPQRSTUV""),"‖"""J"": (""ABCDEFGHIJKLM"", ""WXYZNOPQRSTUV""),"‖1
"""J"": (""ABCDEFGHIJKLM"", ""WXYZNOPQRSTUV""),"‖"""K"": (""ABCDEFGHIJKLM"", ""VWXYZNOPQRSTU""),"‖1
"""K"": (""ABCDEFGHIJKLM"", ""VWXYZNOPQRSTU""),"‖"""L"": (""ABCDEFGHIJKLM"", ""VWXYZNOPQRSTU""),"‖1
"""L"": (""ABCDEFGHIJKLM"", ""VWXYZNOPQRSTU""),"‖"""M"": (""ABCDEFGHIJKLM"", ""UVWXYZNOPQRST""),"‖1
"""M"": (""ABCDEFGHIJKLM"", ""UVWXYZNOPQRST""),"‖"""N"": (""ABCDEFGHIJKLM"", ""UVWXYZNOPQRST""),"‖1
"""N"": (""ABCDEFGHIJKLM"", ""UVWXYZNOPQRST""),"‖"""O"": (""ABCDEFGHIJKLM"", ""TUVWXYZNOPQRS""),"‖1
"""O"": (""ABCDEFGHIJKLM"", ""TUVWXYZNOPQRS""),"‖"""P"": (""ABCDEFGHIJKLM"", ""TUVWXYZNOPQRS""),"‖1
"""P"": (""ABCDEFGHIJKLM"", ""TUVWXYZNOPQRS""),"‖"""Q"": (""ABCDEFGHIJKLM"", ""STUVWXYZNOPQR""),"‖1
"""Q"": (""ABCDEFGHIJKLM"", ""STUVWXYZNOPQR""),"‖"""R"": (""ABCDEFGHIJKLM"", ""STUVWXYZNOPQR""),"‖1
"""R"": (""ABCDEFGHIJKLM"", ""STUVWXYZNOPQR""),"‖"""S"": (""ABCDEFGHIJKLM"", ""RSTUVWXYZNOPQ""),"‖1
"""S"": (""ABCDEFGHIJKLM"", ""RSTUVWXYZNOPQ""),"‖"""T"": (""ABCDEFGHIJKLM"", ""RSTUVWXYZNOPQ""),"‖1
"""T"": (""ABCDEFGHIJKLM"", ""RSTUVWXYZNOPQ""),"‖"""U"": (""ABCDEFGHIJKLM"", ""QRSTUVWXYZNOP""),"‖1
"""U"": (""ABCDEFGHIJKLM"", ""QRSTUVWXYZNOP""),"‖"""V"": (""ABCDEFGHIJKLM"", ""QRSTUVWXYZNOP""),"‖1
"""V"": (""ABCDEFGHIJKLM"", ""QRSTUVWXYZNOP""),"‖"""W"": (""ABCDEFGHIJKLM"", ""PQRSTUVWXYZNO""),"‖1
"""W"": (""ABCDEFGHIJKLM"", ""PQRSTUVWXYZNO""),"‖"""X"": (""ABCDEFGHIJKLM"", ""PQRSTUVWXYZNO""),"‖1
"""X"": (""ABCDEFGHIJKLM"", ""PQRSTUVWXYZNO""),"‖"""Y"": (""ABCDEFGHIJKLM"", ""OPQRSTUVWXYZN""),"‖1
"""Y"": (""ABCDEFGHIJKLM"", ""OPQRSTUVWXYZN""),"‖"""Z"": (""ABCDEFGHIJKLM"", ""OPQRSTUVWXYZN""),"‖1
"""Z"": (""ABCDEFGHIJKLM"", ""OPQRSTUVWXYZN""),"‖}‖1
"cipher = """""‖count = 0‖1
count = 0‖table = generate_table(key)‖1
table = generate_table(key)‖for char in words.upper():‖1
for char in words.upper():‖cipher += get_opponent(table[count], char)‖1
cipher += get_opponent(table[count], char)‖count = (count + 1) % len(table)‖1
count = (count + 1) % len(table)‖return cipher‖1
row = 0 if char in table[0] else 1‖col = table[row].index(char)‖1
col = table[row].index(char)‖return row, col‖1
row, col = get_position(table, char.upper())‖if row == 1:‖1
if row == 1:‖return table[0][col]‖1
return table[0][col]‖else:‖1
else:‖return table[1][col] if row == 0 else char‖1
"key = input(""Enter key: "").strip()"‖"text = input(""Enter text to encrypt: "").strip()"‖1
"text = input(""Enter text to encrypt: "").strip()"‖cipher_text = encrypt(key, text)‖1
"print(f""Encrypted: {cipher_text}"")"‖"print(f""Decrypted with key: {decrypt(key, cipher_text)}"")"‖1
dict1 = {char: i for i, char in enumerate(ascii_uppercase)}‖dict2 = dict(enumerate(ascii_uppercase))‖1
x = len(message)‖i = 0‖1
i = 0‖while True:‖2
while True:‖if x == i:‖1
if x == i:‖i = 0‖1
i = 0‖if len(key) == len(message):‖1
if len(key) == len(message):‖break‖1
break‖key += key[i]‖1
key += key[i]‖i += 1‖1
i += 1‖return key‖1
"cipher_text = """""‖i = 0‖1
i = 0‖for letter in message:‖1
for letter in message:‖"if letter == "" "":"‖1
"if letter == "" "":"‖"cipher_text += "" """‖1
"cipher_text += "" """‖else:‖1
else:‖x = (dict1[letter] - dict1[key_new[i]]) % 26‖1
x = (dict1[letter] - dict1[key_new[i]]) % 26‖i += 1‖1
i += 1‖cipher_text += dict2[x]‖1
cipher_text += dict2[x]‖return cipher_text‖1
"or_txt = """""‖i = 0‖1
i = 0‖for letter in cipher_text:‖1
for letter in cipher_text:‖"if letter == "" "":"‖1
"if letter == "" "":"‖"or_txt += "" """‖1
"or_txt += "" """‖else:‖1
else:‖x = (dict1[letter] + dict1[key_new[i]] + 26) % 26‖1
x = (dict1[letter] + dict1[key_new[i]] + 26) % 26‖i += 1‖1
i += 1‖or_txt += dict2[x]‖1
or_txt += dict2[x]‖return or_txt‖1
def main() -> None:‖"message = ""THE GERMAN ATTACK"""‖1
"message = ""THE GERMAN ATTACK"""‖"key = ""SECRET"""‖1
"key = ""SECRET"""‖key_new = generate_key(message, key)‖1
key_new = generate_key(message, key)‖s = cipher_text(message, key_new)‖1
s = cipher_text(message, key_new)‖"print(f""Encrypted Text = {s}"")"‖1
"print(f""Encrypted Text = {s}"")"‖"print(f""Original Text = {original_text(s, key_new)}"")"‖1
class BWTTransformDict(TypedDict):‖bwt_string: str‖1
bwt_string: str‖idx_original_string: int‖1
if not isinstance(s, str):‖"raise TypeError(""The parameter s type must be str."")"‖2
"raise TypeError(""The parameter s type must be str."")"‖if not s:‖1
if not s:‖"raise ValueError(""The parameter s must not be empty."")"‖1
rotations = all_rotations(s)‖rotations.sort()‖1
response: BWTTransformDict = {‖"""bwt_string"": """".join([word[-1] for word in rotations]),"‖1
"""bwt_string"": """".join([word[-1] for word in rotations]),"‖"""idx_original_string"": rotations.index(s),"‖1
"""idx_original_string"": rotations.index(s),"‖}‖1
}‖return response‖1
if not isinstance(bwt_string, str):‖"raise TypeError(""The parameter bwt_string type must be str."")"‖1
"raise TypeError(""The parameter bwt_string type must be str."")"‖if not bwt_string:‖1
if not bwt_string:‖"raise ValueError(""The parameter bwt_string must not be empty."")"‖1
"raise ValueError(""The parameter bwt_string must not be empty."")"‖try:‖1
try:‖idx_original_string = int(idx_original_string)‖1
idx_original_string = int(idx_original_string)‖except ValueError:‖1
except ValueError:‖raise TypeError(‖1
raise TypeError(‖"""The parameter idx_original_string type must be int or passive"""‖1
"""The parameter idx_original_string type must be int or passive"""‖""" of cast to int."""‖1
""" of cast to int."""‖)‖1
)‖if idx_original_string < 0:‖1
if idx_original_string < 0:‖"raise ValueError(""The parameter idx_original_string must not be lower than 0."")"‖1
"raise ValueError(""The parameter idx_original_string must not be lower than 0."")"‖if idx_original_string >= len(bwt_string):‖1
if idx_original_string >= len(bwt_string):‖raise ValueError(‖1
raise ValueError(‖"""The parameter idx_original_string must be lower than len(bwt_string)."""‖1
"""The parameter idx_original_string must be lower than len(bwt_string)."""‖)‖1
"ordered_rotations = [""""] * len(bwt_string)"‖for _ in range(len(bwt_string)):‖1
for _ in range(len(bwt_string)):‖for i in range(len(bwt_string)):‖1
for i in range(len(bwt_string)):‖ordered_rotations[i] = bwt_string[i] + ordered_rotations[i]‖1
ordered_rotations[i] = bwt_string[i] + ordered_rotations[i]‖ordered_rotations.sort()‖1
ordered_rotations.sort()‖return ordered_rotations[idx_original_string]‖1
"if __name__ == ""__main__"":"‖"entry_msg = ""Provide a string that I will generate its BWT transform: """‖1
"entry_msg = ""Provide a string that I will generate its BWT transform: """‖s = input(entry_msg).strip()‖1
s = input(entry_msg).strip()‖result = bwt_transform(s)‖1
result = bwt_transform(s)‖print(‖1
print(‖"f""Burrows Wheeler transform for string '{s}' results """‖1
"f""Burrows Wheeler transform for string '{s}' results """‖"f""in '{result['bwt_string']}'"""‖1
"f""in '{result['bwt_string']}'"""‖)‖1
)‖"original_string = reverse_bwt(result[""bwt_string""], result[""idx_original_string""])"‖1
"original_string = reverse_bwt(result[""bwt_string""], result[""idx_original_string""])"‖print(‖1
print(‖"f""Reversing Burrows Wheeler transform for entry '{result['bwt_string']}' """‖1
"f""Reversing Burrows Wheeler transform for entry '{result['bwt_string']}' """‖"f""we get original string '{original_string}'"""‖1
"f""we get original string '{original_string}'"""‖)‖1
if start == len(input_string):‖return True‖1
for end in range(start + 1, len(input_string) + 1):‖if input_string[start:end] in word_dict and backtrack(‖1
if input_string[start:end] in word_dict and backtrack(‖input_string, word_dict, end‖1
input_string, word_dict, end‖):‖1
):‖return True‖3
"return ""\n"".join("‖(‖1
(‖"""Truth Table of NOR Gate:"","‖1
"""Truth Table of NOR Gate:"","‖"make_table_row((""Input 1"", ""Input 2"", ""Output"")),"‖1
"make_table_row((""Input 1"", ""Input 2"", ""Output"")),"‖*[make_table_row((i, j, func(i, j))) for i in (0, 1) for j in (0, 1)],‖1
*[make_table_row((i, j, func(i, j))) for i in (0, 1) for j in (0, 1)],‖)‖1
)‖)‖31
doctest.testmod()‖print(truth_table(nor_gate))‖1
if a < 0 or b < 0:‖"raise ValueError(""the value of both inputs must be positive"")"‖3
"raise ValueError(""the value of both inputs must be positive"")"‖a_binary = str(bin(a))[2:]‖1
a_binary = str(bin(a))[2:]‖b_binary = str(bin(b))[2:]‖2
b_binary = str(bin(b))[2:]‖max_len = max(len(a_binary), len(b_binary))‖1
max_len = max(len(a_binary), len(b_binary))‖"return ""0b"" + """".join("‖1
"return ""0b"" + """".join("‖"str(int(""1"" in (char_a, char_b)))"‖1
"str(int(""1"" in (char_a, char_b)))"‖for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))‖1
for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))‖)‖3
def depth_first_search(‖possible_board: list[int],‖1
possible_board: list[int],‖diagonal_right_collisions: list[int],‖1
diagonal_right_collisions: list[int],‖diagonal_left_collisions: list[int],‖1
diagonal_left_collisions: list[int],‖boards: list[list[str]],‖1
boards: list[list[str]],‖n: int,‖1
n: int,‖) -> None:‖1
"boards.append(["". "" * i + ""Q "" + "". "" * (n - 1 - i) for i in possible_board])"‖return‖1
if (‖col in possible_board‖1
col in possible_board‖or row - col in diagonal_right_collisions‖1
or row - col in diagonal_right_collisions‖or row + col in diagonal_left_collisions‖1
or row + col in diagonal_left_collisions‖):‖1
):‖continue‖5
depth_first_search(‖[*possible_board, col],‖1
[*possible_board, col],‖[*diagonal_right_collisions, row - col],‖1
[*diagonal_right_collisions, row - col],‖[*diagonal_left_collisions, row + col],‖1
[*diagonal_left_collisions, row + col],‖boards,‖1
boards,‖n,‖1
n,‖)‖1
def n_queens_solution(n: int) -> None:‖boards: list[list[str]] = []‖1
boards: list[list[str]] = []‖depth_first_search([], [], [], boards, n)‖1
for board in boards:‖for column in board:‖1
for column in board:‖print(column)‖1
print(column)‖"print("""")"‖1
doctest.testmod()‖n_queens_solution(4)‖1
def _base10_to_85(d: int) -> str:‖"return """".join(chr(d % 85 + 33)) + _base10_to_85(d // 85) if d > 0 else """""‖1
def _base85_to_10(digits: list) -> int:‖return sum(char * 85**i for i, char in enumerate(reversed(digits)))‖1
"binary_data = """".join(bin(ord(d))[2:].zfill(8) for d in data.decode(""utf-8""))"‖null_values = (32 * ((len(binary_data) // 32) + 1) - len(binary_data)) // 8‖1
null_values = (32 * ((len(binary_data) // 32) + 1) - len(binary_data)) // 8‖"binary_data = binary_data.ljust(32 * ((len(binary_data) // 32) + 1), ""0"")"‖1
"binary_data = binary_data.ljust(32 * ((len(binary_data) // 32) + 1), ""0"")"‖"b85_chunks = [int(_s, 2) for _s in map("""".join, zip(*[iter(binary_data)] * 32))]"‖1
"b85_chunks = [int(_s, 2) for _s in map("""".join, zip(*[iter(binary_data)] * 32))]"‖"result = """".join(_base10_to_85(chunk)[::-1] for chunk in b85_chunks)"‖1
"result = """".join(_base10_to_85(chunk)[::-1] for chunk in b85_chunks)"‖"return bytes(result[:-null_values] if null_values % 4 != 0 else result, ""utf-8"")"‖1
null_values = 5 * ((len(data) // 5) + 1) - len(data)‖"binary_data = data.decode(""utf-8"") + ""u"" * null_values"‖1
"binary_data = data.decode(""utf-8"") + ""u"" * null_values"‖"b85_chunks = map("""".join, zip(*[iter(binary_data)] * 5))"‖1
"b85_chunks = map("""".join, zip(*[iter(binary_data)] * 5))"‖b85_segments = [[ord(_s) - 33 for _s in chunk] for chunk in b85_chunks]‖1
b85_segments = [[ord(_s) - 33 for _s in chunk] for chunk in b85_chunks]‖results = [bin(_base85_to_10(chunk))[2::].zfill(32) for chunk in b85_segments]‖1
results = [bin(_base85_to_10(chunk))[2::].zfill(32) for chunk in b85_segments]‖char_chunks = [‖1
char_chunks = [‖"[chr(int(_s, 2)) for _s in map("""".join, zip(*[iter(r)] * 8))] for r in results"‖1
"[chr(int(_s, 2)) for _s in map("""".join, zip(*[iter(r)] * 8))] for r in results"‖]‖1
]‖"result = """".join("""".join(char) for char in char_chunks)"‖1
"result = """".join("""".join(char) for char in char_chunks)"‖offset = int(null_values % 5 == 0)‖1
offset = int(null_values % 5 == 0)‖"return bytes(result[: offset - null_values], ""utf-8"")"‖1
class PolybiusCipher:‖def __init__(self) -> None:‖1
message = message.lower()‖"message = message.replace(""j"", ""i"")"‖1
"encoded_message = """""‖for letter_index in range(len(message)):‖1
for letter_index in range(len(message)):‖"if message[letter_index] != "" "":"‖1
"if message[letter_index] != "" "":"‖numbers = self.letter_to_numbers(message[letter_index])‖1
numbers = self.letter_to_numbers(message[letter_index])‖encoded_message = encoded_message + str(numbers[0]) + str(numbers[1])‖1
encoded_message = encoded_message + str(numbers[0]) + str(numbers[1])‖"elif message[letter_index] == "" "":"‖1
"elif message[letter_index] == "" "":"‖"encoded_message = encoded_message + "" """‖1
"message = message.replace("" "", ""  "")"‖"decoded_message = """""‖1
"decoded_message = """""‖for numbers_index in range(int(len(message) / 2)):‖1
for numbers_index in range(int(len(message) / 2)):‖"if message[numbers_index * 2] != "" "":"‖1
"if message[numbers_index * 2] != "" "":"‖index1 = message[numbers_index * 2]‖1
index1 = message[numbers_index * 2]‖index2 = message[numbers_index * 2 + 1]‖1
letter = self.numbers_to_letter(int(index1), int(index2))‖decoded_message = decoded_message + letter‖1
decoded_message = decoded_message + letter‖"elif message[numbers_index * 2] == "" "":"‖1
"elif message[numbers_index * 2] == "" "":"‖"decoded_message = decoded_message + "" """‖1
"num = """""‖for digit in str(max(0, number)):‖1
for digit in str(max(0, number)):‖num += str(bin(int(digit) + 3))[2:].zfill(4)‖1
num += str(bin(int(digit) + 3))[2:].zfill(4)‖"return ""0b"" + num"‖1
def backtrack(‖partial: str, open_count: int, close_count: int, n: int, result: list[str]‖1
partial: str, open_count: int, close_count: int, n: int, result: list[str]‖) -> None:‖1
result.append(partial)‖return‖1
result: list[str] = []‖"backtrack("""", 0, 0, n, result)"‖1
"backtrack("""", 0, 0, n, result)"‖return result‖1
import numpy as np‖from PIL import Image‖4
arr = np.array(arr)‖if arr.shape[0] != arr.shape[1]:‖2
if arr.shape[0] != arr.shape[1]:‖"raise ValueError(""The input array is not a square matrix"")"‖2
"raise ValueError(""The input array is not a square matrix"")"‖i = 0‖2
i = 0‖j = 0‖2
j = 0‖mat_i = 0‖2
mat_i = 0‖mat_j = 0‖2
maxpool_shape = (arr.shape[0] - size) // stride + 1‖updated_arr = np.zeros((maxpool_shape, maxpool_shape))‖1
while i < arr.shape[0]:‖if i + size > arr.shape[0]:‖1
break‖while j < arr.shape[1]:‖2
if j + size > arr.shape[1]:‖break‖2
j += stride‖mat_j += 1‖2
i += stride‖mat_i += 1‖2
j = 0‖mat_j = 0‖2
if i + size > arr.shape[0]:‖break‖1
if isinstance(number, float):‖"raise TypeError(""Input value must be a 'int' type"")"‖1
"raise TypeError(""Input value must be a 'int' type"")"‖if number <= 0:‖1
if number <= 0:‖return 0‖1
return 0‖res = 1‖1
res = 1‖while (res << 1) <= number:‖1
while (res << 1) <= number:‖res <<= 1‖1
res <<= 1‖return res‖1
if not isinstance(data, bytes):‖"msg = f""a bytes-like object is required, not '{data.__class__.__name__}'"""‖1
"msg = f""a bytes-like object is required, not '{data.__class__.__name__}'"""‖raise TypeError(msg)‖1
"binary_stream += ""0"" * (6 - len(binary_stream) % 6)"‖else:‖1
else:‖"padding = b"""""‖1
return (‖""""".join("‖1
""""".join("‖B64_CHARSET[int(binary_stream[index : index + 6], 2)]‖1
B64_CHARSET[int(binary_stream[index : index + 6], 2)]‖for index in range(0, len(binary_stream), 6)‖1
for index in range(0, len(binary_stream), 6)‖).encode()‖1
).encode()‖+ padding‖1
+ padding‖)‖1
if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):‖msg = (‖1
msg = (‖"""argument should be a bytes-like object or ASCII string, """‖1
"""argument should be a bytes-like object or ASCII string, """‖"f""not '{encoded_data.__class__.__name__}'"""‖1
"f""not '{encoded_data.__class__.__name__}'"""‖)‖1
if isinstance(encoded_data, bytes):‖try:‖1
try:‖"encoded_data = encoded_data.decode(""utf-8"")"‖1
"encoded_data = encoded_data.decode(""utf-8"")"‖except UnicodeDecodeError:‖1
except UnicodeDecodeError:‖"raise ValueError(""base64 encoded data should only contain ASCII characters"")"‖1
if padding:‖assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (‖1
assert all(char in B64_CHARSET for char in encoded_data[:-padding]), (‖"""Invalid base64 character(s) found."""‖1
"""Invalid base64 character(s) found."""‖)‖2
)‖else:‖19
else:‖assert all(char in B64_CHARSET for char in encoded_data), (‖1
assert all(char in B64_CHARSET for char in encoded_data), (‖"""Invalid base64 character(s) found."""‖1
"binary_stream = """".join("‖bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data‖2
bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data‖)[: -padding * 2]‖1
)[: -padding * 2]‖else:‖1
else:‖"binary_stream = """".join("‖1
bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data‖)‖1
data = [‖int(binary_stream[index : index + 8], 2)‖1
int(binary_stream[index : index + 8], 2)‖for index in range(0, len(binary_stream), 8)‖1
for index in range(0, len(binary_stream), 8)‖]‖1
def backtrack(‖current_word: str, path: list[str], end_word: str, word_set: set[str]‖1
current_word: str, path: list[str], end_word: str, word_set: set[str]‖) -> list[str]:‖1
if current_word == end_word:‖return path‖1
for i in range(len(current_word)):‖for c in string.ascii_lowercase:‖1
for c in string.ascii_lowercase:‖transformed_word = current_word[:i] + c + current_word[i + 1 :]‖1
transformed_word = current_word[:i] + c + current_word[i + 1 :]‖if transformed_word in word_set:‖1
if transformed_word in word_set:‖word_set.remove(transformed_word)‖1
result = backtrack(‖transformed_word, [*path, transformed_word], end_word, word_set‖1
transformed_word, [*path, transformed_word], end_word, word_set‖)‖1
)‖if result:‖1
if result:‖return result‖1
return result‖word_set.add(transformed_word)‖1
if end_word not in word_set:‖return []‖1
import itertools‖import string‖1
import string‖from collections.abc import Generator, Iterable‖1
def chunker(seq: Iterable[str], size: int) -> Generator[tuple[str, ...]]:‖it = iter(seq)‖1
it = iter(seq)‖while True:‖1
while True:‖chunk = tuple(itertools.islice(it, size))‖1
chunk = tuple(itertools.islice(it, size))‖if not chunk:‖1
if not chunk:‖return‖1
return‖yield chunk‖1
"dirty = """".join([c.upper() for c in dirty if c in string.ascii_letters])"‖"clean = """""‖1
if len(dirty) < 2:‖return dirty‖1
for i in range(len(dirty) - 1):‖clean += dirty[i]‖1
if dirty[i] == dirty[i + 1]:‖"clean += ""X"""‖1
if len(clean) & 1:‖"clean += ""X"""‖1
for char in key.upper():‖if char not in table and char in alphabet:‖1
if char not in table and char in alphabet:‖table.append(char)‖1
for char in alphabet:‖if char not in table:‖1
if char not in table:‖table.append(char)‖1
table = generate_table(key)‖plaintext = prepare_input(plaintext)‖1
plaintext = prepare_input(plaintext)‖"ciphertext = """""‖1
for char1, char2 in chunker(plaintext, 2):‖row1, col1 = divmod(table.index(char1), 5)‖1
row1, col1 = divmod(table.index(char1), 5)‖row2, col2 = divmod(table.index(char2), 5)‖2
if row1 == row2:‖ciphertext += table[row1 * 5 + (col1 + 1) % 5]‖1
ciphertext += table[row1 * 5 + (col1 + 1) % 5]‖ciphertext += table[row2 * 5 + (col2 + 1) % 5]‖1
ciphertext += table[row2 * 5 + (col2 + 1) % 5]‖elif col1 == col2:‖1
elif col1 == col2:‖ciphertext += table[((row1 + 1) % 5) * 5 + col1]‖1
ciphertext += table[((row1 + 1) % 5) * 5 + col1]‖ciphertext += table[((row2 + 1) % 5) * 5 + col2]‖1
ciphertext += table[((row2 + 1) % 5) * 5 + col2]‖else:‖1
else:‖ciphertext += table[row1 * 5 + col2]‖1
ciphertext += table[row1 * 5 + col2]‖ciphertext += table[row2 * 5 + col1]‖1
table = generate_table(key)‖"plaintext = """""‖1
for char1, char2 in chunker(ciphertext, 2):‖row1, col1 = divmod(table.index(char1), 5)‖1
if row1 == row2:‖plaintext += table[row1 * 5 + (col1 - 1) % 5]‖1
plaintext += table[row1 * 5 + (col1 - 1) % 5]‖plaintext += table[row2 * 5 + (col2 - 1) % 5]‖1
plaintext += table[row2 * 5 + (col2 - 1) % 5]‖elif col1 == col2:‖1
elif col1 == col2:‖plaintext += table[((row1 - 1) % 5) * 5 + col1]‖1
plaintext += table[((row1 - 1) % 5) * 5 + col1]‖plaintext += table[((row2 - 1) % 5) * 5 + col2]‖1
plaintext += table[((row2 - 1) % 5) * 5 + col2]‖else:‖1
else:‖plaintext += table[row1 * 5 + col2]‖1
plaintext += table[row1 * 5 + col2]‖plaintext += table[row2 * 5 + col1]‖1
"print(""Encoded:"", encode(""BYE AND THANKS"", ""GREETING""))"‖"print(""Decoded:"", decode(""CXRBANRLBALQ"", ""GREETING""))"‖1
class XORCipher:‖def __init__(self, key: int = 0):‖1
assert isinstance(key, int)‖assert isinstance(content, str)‖4
for ch in content:‖ans += chr(ord(ch) ^ key)‖2
assert isinstance(file, str)‖assert isinstance(key, int)‖2
try:‖"with open(file) as fin, open(""encrypt.out"", ""w+"") as fout:"‖1
for line in fin:‖fout.write(self.encrypt_string(line, key))‖1
except OSError:‖return False‖2
try:‖"with open(file) as fin, open(""decrypt.out"", ""w+"") as fout:"‖1
for line in fin:‖fout.write(self.decrypt_string(line, key))‖1
import glob‖import os‖2
import random‖from string import ascii_lowercase, digits‖2
OUTPUT_SIZE = (720, 1280)‖SCALE_RANGE = (0.4, 0.6)‖1
SCALE_RANGE = (0.4, 0.6)‖FILTER_TINY_SCALE = 1 / 100‖1
FILTER_TINY_SCALE = 1 / 100‖"LABEL_DIR = """""‖1
"LABEL_DIR = """""‖"IMG_DIR = """""‖1
"IMG_DIR = """""‖"OUTPUT_DIR = """""‖1
"OUTPUT_DIR = """""‖NUMBER_IMAGES = 250‖1
img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)‖for index in range(NUMBER_IMAGES):‖1
for index in range(NUMBER_IMAGES):‖idxs = random.sample(range(len(annos)), 4)‖1
idxs = random.sample(range(len(annos)), 4)‖new_image, new_annos, path = update_image_and_anno(‖1
new_image, new_annos, path = update_image_and_anno(‖img_paths,‖1
img_paths,‖annos,‖1
annos,‖idxs,‖1
idxs,‖OUTPUT_SIZE,‖1
OUTPUT_SIZE,‖SCALE_RANGE,‖1
SCALE_RANGE,‖filter_scale=FILTER_TINY_SCALE,‖1
filter_scale=FILTER_TINY_SCALE,‖)‖1
letter_code = random_chars(32)‖"file_name = path.split(os.sep)[-1].rsplit(""."", 1)[0]"‖1
"file_name = path.split(os.sep)[-1].rsplit(""."", 1)[0]"‖"file_root = f""{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}"""‖1
"file_root = f""{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}"""‖"cv2.imwrite(f""{file_root}.jpg"", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])"‖1
"cv2.imwrite(f""{file_root}.jpg"", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])"‖"print(f""Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}"")"‖1
"print(f""Succeeded {index + 1}/{NUMBER_IMAGES} with {file_name}"")"‖annos_list = []‖1
annos_list = []‖for anno in new_annos:‖1
for anno in new_annos:‖width = anno[3] - anno[1]‖1
width = anno[3] - anno[1]‖height = anno[4] - anno[2]‖1
height = anno[4] - anno[2]‖x_center = anno[1] + width / 2‖1
x_center = anno[1] + width / 2‖y_center = anno[2] + height / 2‖1
y_center = anno[2] + height / 2‖"obj = f""{anno[0]} {x_center} {y_center} {width} {height}"""‖1
"obj = f""{anno[0]} {x_center} {y_center} {width} {height}"""‖annos_list.append(obj)‖1
annos_list.append(obj)‖"with open(f""{file_root}.txt"", ""w"") as outfile:"‖2
"with open(f""{file_root}.txt"", ""w"") as outfile:"‖"outfile.write(""\n"".join(line for line in annos_list))"‖2
img_paths = []‖labels = []‖2
labels = []‖"for label_file in glob.glob(os.path.join(label_dir, ""*.txt"")):"‖2
"for label_file in glob.glob(os.path.join(label_dir, ""*.txt"")):"‖"label_name = label_file.split(os.sep)[-1].rsplit(""."", 1)[0]"‖2
"label_name = label_file.split(os.sep)[-1].rsplit(""."", 1)[0]"‖with open(label_file) as in_file:‖2
with open(label_file) as in_file:‖obj_lists = in_file.readlines()‖2
obj_lists = in_file.readlines()‖"img_path = os.path.join(img_dir, f""{label_name}.jpg"")"‖2
boxes = []‖for obj_list in obj_lists:‖2
for obj_list in obj_lists:‖"obj = obj_list.rstrip(""\n"").split("" "")"‖2
"obj = obj_list.rstrip(""\n"").split("" "")"‖xmin = float(obj[1]) - float(obj[3]) / 2‖1
xmin = float(obj[1]) - float(obj[3]) / 2‖ymin = float(obj[2]) - float(obj[4]) / 2‖1
ymin = float(obj[2]) - float(obj[4]) / 2‖xmax = float(obj[1]) + float(obj[3]) / 2‖1
xmax = float(obj[1]) + float(obj[3]) / 2‖ymax = float(obj[2]) + float(obj[4]) / 2‖1
boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])‖if not boxes:‖1
if not boxes:‖continue‖2
continue‖img_paths.append(img_path)‖2
img_paths.append(img_path)‖labels.append(boxes)‖2
labels.append(boxes)‖return img_paths, labels‖2
def update_image_and_anno(‖all_img_list: list,‖1
all_img_list: list,‖all_annos: list,‖1
all_annos: list,‖idxs: list[int],‖1
idxs: list[int],‖output_size: tuple[int, int],‖1
output_size: tuple[int, int],‖scale_range: tuple[float, float],‖1
scale_range: tuple[float, float],‖filter_scale: float = 0.0,‖1
filter_scale: float = 0.0,‖) -> tuple[list, list, str]:‖1
output_img = np.zeros([output_size[0], output_size[1], 3], dtype=np.uint8)‖scale_x = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])‖1
scale_x = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])‖scale_y = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])‖1
scale_y = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])‖divid_point_x = int(scale_x * output_size[1])‖1
divid_point_x = int(scale_x * output_size[1])‖divid_point_y = int(scale_y * output_size[0])‖1
new_anno = []‖path_list = []‖1
path_list = []‖for i, index in enumerate(idxs):‖1
for i, index in enumerate(idxs):‖path = all_img_list[index]‖1
path = all_img_list[index]‖path_list.append(path)‖1
path_list.append(path)‖img_annos = all_annos[index]‖1
img_annos = all_annos[index]‖img = cv2.imread(path)‖1
img = cv2.imread(path)‖if i == 0:‖1
if i == 0:‖img = cv2.resize(img, (divid_point_x, divid_point_y))‖1
img = cv2.resize(img, (divid_point_x, divid_point_y))‖output_img[:divid_point_y, :divid_point_x, :] = img‖1
output_img[:divid_point_y, :divid_point_x, :] = img‖for bbox in img_annos:‖1
for bbox in img_annos:‖xmin = bbox[1] * scale_x‖2
xmin = bbox[1] * scale_x‖ymin = bbox[2] * scale_y‖1
ymin = bbox[2] * scale_y‖xmax = bbox[3] * scale_x‖1
xmax = bbox[3] * scale_x‖ymax = bbox[4] * scale_y‖1
ymax = bbox[4] * scale_y‖new_anno.append([bbox[0], xmin, ymin, xmax, ymax])‖2
new_anno.append([bbox[0], xmin, ymin, xmax, ymax])‖elif i == 1:‖1
elif i == 1:‖img = cv2.resize(img, (output_size[1] - divid_point_x, divid_point_y))‖1
img = cv2.resize(img, (output_size[1] - divid_point_x, divid_point_y))‖output_img[:divid_point_y, divid_point_x : output_size[1], :] = img‖1
output_img[:divid_point_y, divid_point_x : output_size[1], :] = img‖for bbox in img_annos:‖1
for bbox in img_annos:‖xmin = scale_x + bbox[1] * (1 - scale_x)‖2
xmin = scale_x + bbox[1] * (1 - scale_x)‖ymin = bbox[2] * scale_y‖1
ymin = bbox[2] * scale_y‖xmax = scale_x + bbox[3] * (1 - scale_x)‖1
xmax = scale_x + bbox[3] * (1 - scale_x)‖ymax = bbox[4] * scale_y‖1
new_anno.append([bbox[0], xmin, ymin, xmax, ymax])‖elif i == 2:‖1
elif i == 2:‖img = cv2.resize(img, (divid_point_x, output_size[0] - divid_point_y))‖1
img = cv2.resize(img, (divid_point_x, output_size[0] - divid_point_y))‖output_img[divid_point_y : output_size[0], :divid_point_x, :] = img‖1
output_img[divid_point_y : output_size[0], :divid_point_x, :] = img‖for bbox in img_annos:‖1
xmin = bbox[1] * scale_x‖ymin = scale_y + bbox[2] * (1 - scale_y)‖1
ymin = scale_y + bbox[2] * (1 - scale_y)‖xmax = bbox[3] * scale_x‖1
xmax = bbox[3] * scale_x‖ymax = scale_y + bbox[4] * (1 - scale_y)‖1
ymax = scale_y + bbox[4] * (1 - scale_y)‖new_anno.append([bbox[0], xmin, ymin, xmax, ymax])‖2
new_anno.append([bbox[0], xmin, ymin, xmax, ymax])‖else:‖1
else:‖img = cv2.resize(‖1
img = cv2.resize(‖img, (output_size[1] - divid_point_x, output_size[0] - divid_point_y)‖1
img, (output_size[1] - divid_point_x, output_size[0] - divid_point_y)‖)‖1
)‖output_img[‖1
output_img[‖divid_point_y : output_size[0], divid_point_x : output_size[1], :‖1
divid_point_y : output_size[0], divid_point_x : output_size[1], :‖] = img‖1
] = img‖for bbox in img_annos:‖1
xmin = scale_x + bbox[1] * (1 - scale_x)‖ymin = scale_y + bbox[2] * (1 - scale_y)‖1
ymin = scale_y + bbox[2] * (1 - scale_y)‖xmax = scale_x + bbox[3] * (1 - scale_x)‖1
xmax = scale_x + bbox[3] * (1 - scale_x)‖ymax = scale_y + bbox[4] * (1 - scale_y)‖1
if filter_scale > 0:‖new_anno = [‖1
new_anno = [‖anno‖1
anno‖for anno in new_anno‖1
for anno in new_anno‖if filter_scale < (anno[3] - anno[1]) and filter_scale < (anno[4] - anno[2])‖1
if filter_scale < (anno[3] - anno[1]) and filter_scale < (anno[4] - anno[2])‖]‖1
"assert number_char > 1, ""The number of character should greater than 1"""‖letter_code = ascii_lowercase + digits‖2
letter_code = ascii_lowercase + digits‖"return """".join(random.choice(letter_code) for _ in range(number_char))"‖2
main()‖"print(""DONE ✅"")"‖2
"a_binary = format(a, ""b"")"‖"b_binary = format(b, ""b"")"‖1
"return ""0b"" + """".join("‖"str(int(char_a == ""1"" and char_b == ""1""))"‖1
"str(int(char_a == ""1"" and char_b == ""1""))"‖for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))‖1
if number < 0:‖"raise ValueError(""the value of input must not be negative"")"‖2
"raise ValueError(""the value of input must not be negative"")"‖result = 0‖2
result = 0‖while number:‖2
while number:‖number &= number - 1‖1
number &= number - 1‖result += 1‖1
result += 1‖return result‖1
while number:‖if number % 2 == 1:‖1
if number % 2 == 1:‖result += 1‖1
result += 1‖number >>= 1‖1
number >>= 1‖return result‖1
def do_benchmark(number: int) -> None:‖"setup = ""import __main__ as z"""‖1
"setup = ""import __main__ as z"""‖"print(f""Benchmark when {number = }:"")"‖1
"print(f""Benchmark when {number = }:"")"‖"print(f""{get_set_bits_count_using_modulo_operator(number) = }"")"‖1
"print(f""{get_set_bits_count_using_modulo_operator(number) = }"")"‖timing = timeit(‖1
timing = timeit(‖"f""z.get_set_bits_count_using_modulo_operator({number})"", setup=setup"‖1
"f""z.get_set_bits_count_using_modulo_operator({number})"", setup=setup"‖)‖1
)‖"print(f""timeit() runs in {timing} seconds"")"‖2
"print(f""timeit() runs in {timing} seconds"")"‖"print(f""{get_set_bits_count_using_brian_kernighans_algorithm(number) = }"")"‖1
"print(f""{get_set_bits_count_using_brian_kernighans_algorithm(number) = }"")"‖timing = timeit(‖1
timing = timeit(‖"f""z.get_set_bits_count_using_brian_kernighans_algorithm({number})"","‖1
"f""z.get_set_bits_count_using_brian_kernighans_algorithm({number})"","‖setup=setup,‖1
setup=setup,‖)‖1
for number in (25, 37, 58, 0):‖do_benchmark(number)‖1
do_benchmark(number)‖print()‖1
doctest.testmod()‖benchmark()‖6
def is_valid(‖puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool‖1
puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool‖) -> bool:‖1
for i in range(len(word)):‖if vertical:‖2
if vertical:‖"if row + i >= len(puzzle) or puzzle[row + i][col] != """":"‖1
"if row + i >= len(puzzle) or puzzle[row + i][col] != """":"‖return False‖1
return False‖"elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != """":"‖1
"elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != """":"‖return False‖1
def place_word(‖puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool‖1
puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool‖) -> None:‖2
for i, char in enumerate(word):‖if vertical:‖1
if vertical:‖puzzle[row + i][col] = char‖1
puzzle[row + i][col] = char‖else:‖1
else:‖puzzle[row][col + i] = char‖1
def remove_word(‖puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool‖1
if vertical:‖"puzzle[row + i][col] = """""‖1
"puzzle[row + i][col] = """""‖else:‖1
else:‖"puzzle[row][col + i] = """""‖1
for row in range(len(puzzle)):‖for col in range(len(puzzle[0])):‖1
for col in range(len(puzzle[0])):‖"if puzzle[row][col] == """":"‖1
"if puzzle[row][col] == """":"‖for word in words:‖1
for word in words:‖for vertical in [True, False]:‖1
for vertical in [True, False]:‖if is_valid(puzzle, word, row, col, vertical):‖1
if is_valid(puzzle, word, row, col, vertical):‖place_word(puzzle, word, row, col, vertical)‖1
place_word(puzzle, word, row, col, vertical)‖words.remove(word)‖1
words.remove(word)‖if solve_crossword(puzzle, words):‖1
if solve_crossword(puzzle, words):‖return True‖1
return True‖words.append(word)‖1
words.append(word)‖remove_word(puzzle, word, row, col, vertical)‖1
remove_word(puzzle, word, row, col, vertical)‖return False‖1
"if __name__ == ""__main__"":"‖"PUZZLE = [[""""] * 3 for _ in range(3)]"‖1
"PUZZLE = [[""""] * 3 for _ in range(3)]"‖"WORDS = [""cat"", ""dog"", ""car""]"‖1
if solve_crossword(PUZZLE, WORDS):‖"print(""Solution found:"")"‖1
"print(""Solution found:"")"‖for row in PUZZLE:‖1
for row in PUZZLE:‖"print("" "".join(row))"‖1
"print("" "".join(row))"‖else:‖1
else:‖"print(""No solution found:"")"‖1
block_sizes = [‖block_size‖1
block_size‖for block_size in range(2, message_length + 1)‖1
for block_size in range(2, message_length + 1)‖if message_length % block_size == 0‖1
if message_length % block_size == 0‖]‖1
]‖return random.choice(block_sizes)‖1
digits = list(range(block_size))‖random.shuffle(digits)‖1
random.shuffle(digits)‖return digits‖1
def encrypt(‖message: str, key: list[int] | None = None, block_size: int | None = None‖1
message: str, key: list[int] | None = None, block_size: int | None = None‖) -> tuple[str, list[int]]:‖1
message = message.upper()‖message_length = len(message)‖1
if key is None or block_size is None:‖block_size = generate_valid_block_size(message_length)‖1
block_size = generate_valid_block_size(message_length)‖key = generate_permutation_key(block_size)‖1
for i in range(0, message_length, block_size):‖block = message[i : i + block_size]‖1
block = message[i : i + block_size]‖rearranged_block = [block[digit] for digit in key]‖1
rearranged_block = [block[digit] for digit in key]‖"encrypted_message += """".join(rearranged_block)"‖1
key_length = len(key)‖"decrypted_message = """""‖1
for i in range(0, len(encrypted_message), key_length):‖block = encrypted_message[i : i + key_length]‖1
block = encrypted_message[i : i + key_length]‖"original_block = [""""] * key_length"‖1
"original_block = [""""] * key_length"‖for j, digit in enumerate(key):‖1
for j, digit in enumerate(key):‖original_block[digit] = block[j]‖1
original_block[digit] = block[j]‖"decrypted_message += """".join(original_block)"‖1
"message = ""HELLO WORLD"""‖encrypted_message, key = encrypt(message)‖1
decrypted_message = decrypt(encrypted_message, key)‖"print(f""Decrypted message: {decrypted_message}"")"‖1
def check_keys(key_a: int, key_b: int, mode: str) -> None:‖"if mode == ""encrypt"":"‖1
"if mode == ""encrypt"":"‖if key_a == 1:‖1
if key_a == 1:‖sys.exit(‖1
sys.exit(‖"""The affine cipher becomes weak when key """‖2
"""The affine cipher becomes weak when key """‖"""A is set to 1. Choose different key"""‖1
"""A is set to 1. Choose different key"""‖)‖1
)‖if key_b == 0:‖1
if key_b == 0:‖sys.exit(‖1
"""The affine cipher becomes weak when key """‖"""B is set to 0. Choose different key"""‖1
"""B is set to 0. Choose different key"""‖)‖1
)‖if key_a < 0 or key_b < 0 or key_b > len(SYMBOLS) - 1:‖1
if key_a < 0 or key_b < 0 or key_b > len(SYMBOLS) - 1:‖sys.exit(‖1
sys.exit(‖"""Key A must be greater than 0 and key B must """‖1
"""Key A must be greater than 0 and key B must """‖"f""be between 0 and {len(SYMBOLS) - 1}."""‖1
"f""be between 0 and {len(SYMBOLS) - 1}."""‖)‖1
)‖if gcd_by_iterative(key_a, len(SYMBOLS)) != 1:‖1
if gcd_by_iterative(key_a, len(SYMBOLS)) != 1:‖sys.exit(‖1
sys.exit(‖"f""Key A {key_a} and the symbol set size {len(SYMBOLS)} """‖1
"f""Key A {key_a} and the symbol set size {len(SYMBOLS)} """‖"""are not relatively prime. Choose a different key."""‖1
"""are not relatively prime. Choose a different key."""‖)‖1
key_a, key_b = divmod(key, len(SYMBOLS))‖"check_keys(key_a, key_b, ""encrypt"")"‖1
"check_keys(key_a, key_b, ""encrypt"")"‖"cipher_text = """""‖1
"cipher_text = """""‖for symbol in message:‖1
for symbol in message:‖if symbol in SYMBOLS:‖2
if symbol in SYMBOLS:‖sym_index = SYMBOLS.find(symbol)‖2
sym_index = SYMBOLS.find(symbol)‖cipher_text += SYMBOLS[(sym_index * key_a + key_b) % len(SYMBOLS)]‖1
cipher_text += SYMBOLS[(sym_index * key_a + key_b) % len(SYMBOLS)]‖else:‖1
else:‖cipher_text += symbol‖1
cipher_text += symbol‖return cipher_text‖1
key_a, key_b = divmod(key, len(SYMBOLS))‖"check_keys(key_a, key_b, ""decrypt"")"‖1
"check_keys(key_a, key_b, ""decrypt"")"‖"plain_text = """""‖1
"plain_text = """""‖mod_inverse_of_key_a = cryptomath.find_mod_inverse(key_a, len(SYMBOLS))‖1
mod_inverse_of_key_a = cryptomath.find_mod_inverse(key_a, len(SYMBOLS))‖for symbol in message:‖1
sym_index = SYMBOLS.find(symbol)‖plain_text += SYMBOLS[‖1
plain_text += SYMBOLS[‖(sym_index - key_b) * mod_inverse_of_key_a % len(SYMBOLS)‖1
(sym_index - key_b) * mod_inverse_of_key_a % len(SYMBOLS)‖]‖1
]‖else:‖1
else:‖plain_text += symbol‖1
plain_text += symbol‖return plain_text‖1
def get_random_key() -> int:‖while True:‖1
while True:‖key_b = random.randint(2, len(SYMBOLS))‖1
key_b = random.randint(2, len(SYMBOLS))‖key_b = random.randint(2, len(SYMBOLS))‖1
key_b = random.randint(2, len(SYMBOLS))‖if gcd_by_iterative(key_b, len(SYMBOLS)) == 1 and key_b % len(SYMBOLS) != 0:‖1
if gcd_by_iterative(key_b, len(SYMBOLS)) == 1 and key_b % len(SYMBOLS) != 0:‖return key_b * len(SYMBOLS) + key_b‖1
"message = input(""Enter message: "").strip()"‖"key = int(input(""Enter key [2000 - 9000]: "").strip())"‖1
"key = int(input(""Enter key [2000 - 9000]: "").strip())"‖"mode = input(""Encrypt/Decrypt [E/D]: "").strip().lower()"‖1
"if mode.startswith(""e""):"‖"mode = ""encrypt"""‖1
"mode = ""encrypt"""‖translated = encrypt_message(key, message)‖3
translated = encrypt_message(key, message)‖"elif mode.startswith(""d""):"‖1
"elif mode.startswith(""d""):"‖"mode = ""decrypt"""‖1
"mode = ""decrypt"""‖translated = decrypt_message(key, message)‖3
translated = decrypt_message(key, message)‖"print(f""\n{mode.title()}ed text: \n{translated}"")"‖1
intermediate = number & ~(number - 1)‖index = 0‖1
index = 0‖while intermediate:‖1
while intermediate:‖intermediate >>= 1‖1
intermediate >>= 1‖index += 1‖1
index += 1‖return index - 1‖1
def main() -> None:‖"message = input(""Enter message: "")"‖3
"message = input(""Enter message: "")"‖"key = input(""Enter key [alphanumeric]: "")"‖1
"key = input(""Enter key [alphanumeric]: "")"‖"mode = input(""Encrypt/Decrypt [e/d]: "")"‖1
"if mode.lower().startswith(""e""):"‖"mode = ""encrypt"""‖1
translated = encrypt_message(key, message)‖"elif mode.lower().startswith(""d""):"‖1
"elif mode.lower().startswith(""d""):"‖"mode = ""decrypt"""‖1
"print(f""\n{mode.title()}ed message:"")"‖print(translated)‖1
def translate_message(key: str, message: str, mode: str) -> str:‖translated = []‖1
translated = []‖key_index = 0‖1
key_index = 0‖key = key.upper()‖1
for symbol in message:‖num = LETTERS.find(symbol.upper())‖1
num = LETTERS.find(symbol.upper())‖if num != -1:‖1
if num != -1:‖"if mode == ""encrypt"":"‖1
"if mode == ""encrypt"":"‖num += LETTERS.find(key[key_index])‖1
num += LETTERS.find(key[key_index])‖"elif mode == ""decrypt"":"‖1
"elif mode == ""decrypt"":"‖num -= LETTERS.find(key[key_index])‖1
if symbol.isupper():‖translated.append(LETTERS[num])‖1
translated.append(LETTERS[num])‖elif symbol.islower():‖1
elif symbol.islower():‖translated.append(LETTERS[num].lower())‖1
key_index += 1‖if key_index == len(key):‖1
if key_index == len(key):‖key_index = 0‖1
key_index = 0‖else:‖1
else:‖translated.append(symbol)‖1
translated.append(symbol)‖"return """".join(translated)"‖1
if all(i in (0, 1) for i in (input0, input1, select)):‖return input1 if select else input0‖1
return input1 if select else input0‖"raise ValueError(""Inputs and select signal must be 0 or 1"")"‖1
def minimax(‖depth: int, node_index: int, is_max: bool, scores: list[int], height: float‖1
depth: int, node_index: int, is_max: bool, scores: list[int], height: float‖) -> int:‖1
if depth < 0:‖"raise ValueError(""Depth cannot be less than 0"")"‖1
"raise ValueError(""Depth cannot be less than 0"")"‖if len(scores) == 0:‖1
if len(scores) == 0:‖"raise ValueError(""Scores cannot be empty"")"‖1
if depth == height:‖return scores[node_index]‖1
if is_max:‖return max(‖1
return max(‖minimax(depth + 1, node_index * 2, False, scores, height),‖1
minimax(depth + 1, node_index * 2, False, scores, height),‖minimax(depth + 1, node_index * 2 + 1, False, scores, height),‖1
minimax(depth + 1, node_index * 2 + 1, False, scores, height),‖)‖1
return min(‖minimax(depth + 1, node_index * 2, True, scores, height),‖1
minimax(depth + 1, node_index * 2, True, scores, height),‖minimax(depth + 1, node_index * 2 + 1, True, scores, height),‖1
minimax(depth + 1, node_index * 2 + 1, True, scores, height),‖)‖1
scores = [90, 23, 6, 33, 21, 65, 123, 34423]‖height = math.log(len(scores), 2)‖1
"print(""Optimal value : "", end="""")"‖print(minimax(0, 0, True, scores, height))‖1
height, width = image.size‖mean = 0‖1
mean = 0‖pixels = image.load()‖1
pixels = image.load()‖for i in range(width):‖1
for i in range(width):‖for j in range(height):‖1
for j in range(height):‖pixel = pixels[j, i]‖1
pixel = pixels[j, i]‖mean += pixel‖1
mean += pixel‖mean //= width * height‖1
for j in range(width):‖for i in range(height):‖1
for i in range(height):‖pixels[i, j] = 255 if pixels[i, j] > mean else 0‖1
pixels[i, j] = 255 if pixels[i, j] > mean else 0‖return image‖1
"if __name__ == ""__main__"":"‖"image = mean_threshold(Image.open(""path_to_image"").convert(""L""))"‖1
"image = mean_threshold(Image.open(""path_to_image"").convert(""L""))"‖"image.save(""output_image_path"")"‖1
def solve_maze(‖maze: list[list[int]],‖1
maze: list[list[int]],‖source_row: int,‖1
source_row: int,‖source_column: int,‖1
source_column: int,‖destination_row: int,‖1
destination_row: int,‖destination_column: int,‖2
destination_column: int,‖) -> list[list[int]]:‖1
if not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or (‖not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)‖1
not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)‖):‖1
):‖"raise ValueError(""Invalid source or destination coordinates"")"‖1
solutions = [[1 for _ in range(size)] for _ in range(size)]‖solved = run_maze(‖1
solved = run_maze(‖maze, source_row, source_column, destination_row, destination_column, solutions‖1
maze, source_row, source_column, destination_row, destination_column, solutions‖)‖1
)‖if solved:‖1
if solved:‖return solutions‖1
return solutions‖else:‖1
else:‖"raise ValueError(""No solution exists!"")"‖1
def run_maze(‖maze: list[list[int]],‖1
maze: list[list[int]],‖i: int,‖1
i: int,‖j: int,‖1
j: int,‖destination_row: int,‖1
destination_column: int,‖solutions: list[list[int]],‖1
solutions: list[list[int]],‖) -> bool:‖1
if i == destination_row and j == destination_column and maze[i][j] == 0:‖solutions[i][j] = 0‖1
solutions[i][j] = 0‖return True‖1
lower_flag = (not i < 0) and (not j < 0)‖upper_flag = (i < size) and (j < size)‖1
block_flag = (solutions[i][j]) and (not maze[i][j])‖if block_flag:‖1
if (‖run_maze(maze, i + 1, j, destination_row, destination_column, solutions)‖1
run_maze(maze, i + 1, j, destination_row, destination_column, solutions)‖or run_maze(‖1
or run_maze(‖maze, i, j + 1, destination_row, destination_column, solutions‖1
maze, i, j + 1, destination_row, destination_column, solutions‖)‖1
)‖or run_maze(‖2
or run_maze(‖maze, i - 1, j, destination_row, destination_column, solutions‖1
maze, i - 1, j, destination_row, destination_column, solutions‖)‖1
or run_maze(‖maze, i, j - 1, destination_row, destination_column, solutions‖1
maze, i, j - 1, destination_row, destination_column, solutions‖)‖1
)‖):‖1
solutions[i][j] = 1‖return False‖1
return False‖return False‖1
count = 0‖while number:‖1
number &= number - 1‖count += 1‖1
count += 1‖return count‖4
class Onepad:‖@staticmethod‖1
@staticmethod‖def encrypt(text: str) -> tuple[list[int], list[int]]:‖1
plain = [ord(i) for i in text]‖key = []‖1
key = []‖cipher = []‖1
cipher = []‖for i in plain:‖1
for i in plain:‖k = random.randint(1, 300)‖1
k = random.randint(1, 300)‖c = (i + k) * k‖1
c = (i + k) * k‖cipher.append(c)‖1
cipher.append(c)‖key.append(k)‖1
key.append(k)‖return cipher, key‖1
@staticmethod‖def decrypt(cipher: list[int], key: list[int]) -> str:‖1
plain = []‖for i in range(len(key)):‖1
for i in range(len(key)):‖p = int((cipher[i] - (key[i]) ** 2) / key[i])‖1
p = int((cipher[i] - (key[i]) ** 2) / key[i])‖plain.append(chr(p))‖1
plain.append(chr(p))‖"return """".join(plain)"‖1
"if __name__ == ""__main__"":"‖"c, k = Onepad().encrypt(""Hello"")"‖1
"c, k = Onepad().encrypt(""Hello"")"‖print(c, k)‖1
print(c, k)‖print(Onepad().decrypt(c, k))‖1
"return ""0b"" + """".join("‖str(bin(int(digit)))[2:].zfill(4) for digit in str(max(0, number))‖1
str(bin(int(digit)))[2:].zfill(4) for digit in str(max(0, number))‖)‖1
simplified_f = []‖for a, row in enumerate(kmap):‖1
for a, row in enumerate(kmap):‖for b, item in enumerate(row):‖1
for b, item in enumerate(row):‖if item:‖1
if item:‖"term = (""A"" if a else ""A'"") + (""B"" if b else ""B'"")"‖1
"term = (""A"" if a else ""A'"") + (""B"" if b else ""B'"")"‖simplified_f.append(term)‖1
simplified_f.append(term)‖"return "" + "".join(simplified_f)"‖1
for row in kmap:‖print(row)‖1
"print(""Simplified Expression:"")"‖print(simplify_kmap(kmap))‖1
main()‖"print(f""{simplify_kmap(kmap=[[0, 1], [1, 1]]) = }"")"‖1
if a < 0:‖"raise ValueError(""Input value must be a positive integer"")"‖2
"raise ValueError(""Input value must be a positive integer"")"‖elif isinstance(a, float):‖2
elif isinstance(a, float):‖"raise TypeError(""Input value must be a 'int' type"")"‖2
"raise TypeError(""Input value must be a 'int' type"")"‖return 0 if (a == 0) else int(log2(a & -a))‖1
"ciphertext = """""‖for i in range(len(plaintext)):‖1
for i in range(len(plaintext)):‖ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65‖1
ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65‖while ct > 25:‖1
while ct > 25:‖ct = ct - 26‖1
ct = ct - 26‖ciphertext += chr(65 + ct)‖1
ciphertext += chr(65 + ct)‖return ciphertext‖1
"decrypted_text = """""‖for i in range(len(ciphertext)):‖1
for i in range(len(ciphertext)):‖ct = ord(ciphertext[i]) - ord(key[i % len(key)])‖1
ct = ord(ciphertext[i]) - ord(key[i % len(key)])‖while ct < 0:‖1
while ct < 0:‖ct = 26 + ct‖1
ct = 26 + ct‖decrypted_text += chr(65 + ct)‖1
decrypted_text += chr(65 + ct)‖return decrypted_text‖1
"plaintext = ""HELLO"""‖"key = ""KEY"""‖1
"key = ""KEY"""‖encrypted_text = vernam_encrypt(plaintext, key)‖1
encrypted_text = vernam_encrypt(plaintext, key)‖decrypted_text = vernam_decrypt(encrypted_text, key)‖1
decrypted_text = vernam_decrypt(encrypted_text, key)‖"print(""\n\n"")"‖1
"print(""\n\n"")"‖"print(""Plaintext:"", plaintext)"‖1
"print(""Plaintext:"", plaintext)"‖"print(""Encrypted:"", encrypted_text)"‖1
"print(""Encrypted:"", encrypted_text)"‖"print(""Decrypted:"", decrypted_text)"‖1
for i, threshold in enumerate(thresholds):‖segmented[image > threshold] = i + 1‖1
"image_path = ""path_to_image"""‖"original_image = Image.open(image_path).convert(""L"")"‖1
"original_image = Image.open(image_path).convert(""L"")"‖image_array = np.array(original_image)‖1
plt.subplot(1, 2, 1)‖"plt.title(""Original Image"")"‖1
"plt.title(""Original Image"")"‖"plt.imshow(image_array, cmap=""gray"")"‖1
"plt.imshow(image_array, cmap=""gray"")"‖"plt.axis(""off"")"‖1
plt.subplot(1, 2, 2)‖"plt.title(""Segmented Image"")"‖1
"plt.title(""Segmented Image"")"‖"plt.imshow(segmented_image, cmap=""tab20"")"‖1
"plt.imshow(segmented_image, cmap=""tab20"")"‖"plt.axis(""off"")"‖1
def generate_all_permutations(sequence: list[int | str]) -> None:‖create_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])‖1
def create_state_space_tree(‖sequence: list[int | str],‖1
sequence: list[int | str],‖current_sequence: list[int | str],‖1
current_sequence: list[int | str],‖index: int,‖1
index: int,‖index_used: list[int],‖1
index_used: list[int],‖) -> None:‖1
if index == len(sequence):‖print(current_sequence)‖1
print(current_sequence)‖return‖1
for i in range(len(sequence)):‖if not index_used[i]:‖1
if not index_used[i]:‖current_sequence.append(sequence[i])‖1
current_sequence.append(sequence[i])‖index_used[i] = True‖1
index_used[i] = True‖create_state_space_tree(sequence, current_sequence, index + 1, index_used)‖1
create_state_space_tree(sequence, current_sequence, index + 1, index_used)‖current_sequence.pop()‖1
current_sequence.pop()‖index_used[i] = False‖1
sequence: list[int | str] = [3, 1, 2, 4]‖generate_all_permutations(sequence)‖1
"sequence_2: list[int | str] = [""A"", ""B"", ""C""]"‖generate_all_permutations(sequence_2)‖1
if not isinstance(number, int) or not isinstance(other_number, int):‖"raise TypeError(""Both arguments MUST be integers!"")"‖1
if number < 0 or other_number < 0:‖"raise ValueError(""Both arguments MUST be non-negative!"")"‖1
bitwise_sum = number ^ other_number‖carry = number & other_number‖1
if carry == 0:‖return bitwise_sum‖1
MORSE_CODE_DICT = {‖"""A"": "".-"", ""B"": ""-..."", ""C"": ""-.-."", ""D"": ""-.."", ""E"": ""."", ""F"": ""..-."", ""G"": ""--."","‖1
"""A"": "".-"", ""B"": ""-..."", ""C"": ""-.-."", ""D"": ""-.."", ""E"": ""."", ""F"": ""..-."", ""G"": ""--."","‖"""H"": ""...."", ""I"": "".."", ""J"": "".---"", ""K"": ""-.-"", ""L"": "".-.."", ""M"": ""--"", ""N"": ""-."","‖1
"""H"": ""...."", ""I"": "".."", ""J"": "".---"", ""K"": ""-.-"", ""L"": "".-.."", ""M"": ""--"", ""N"": ""-."","‖"""O"": ""---"", ""P"": "".--."", ""Q"": ""--.-"", ""R"": "".-."", ""S"": ""..."", ""T"": ""-"", ""U"": ""..-"","‖1
"""O"": ""---"", ""P"": "".--."", ""Q"": ""--.-"", ""R"": "".-."", ""S"": ""..."", ""T"": ""-"", ""U"": ""..-"","‖"""V"": ""...-"", ""W"": "".--"", ""X"": ""-..-"", ""Y"": ""-.--"", ""Z"": ""--.."", ""1"": "".----"","‖1
"""V"": ""...-"", ""W"": "".--"", ""X"": ""-..-"", ""Y"": ""-.--"", ""Z"": ""--.."", ""1"": "".----"","‖"""2"": ""..---"", ""3"": ""...--"", ""4"": ""....-"", ""5"": ""....."", ""6"": ""-...."", ""7"": ""--..."","‖1
"""2"": ""..---"", ""3"": ""...--"", ""4"": ""....-"", ""5"": ""....."", ""6"": ""-...."", ""7"": ""--..."","‖"""8"": ""---.."", ""9"": ""----."", ""0"": ""-----"", ""&"": "".-..."", ""@"": "".--.-."","‖1
"""8"": ""---.."", ""9"": ""----."", ""0"": ""-----"", ""&"": "".-..."", ""@"": "".--.-."","‖""":"": ""---..."", "","": ""--..--"", ""."": "".-.-.-"", ""'"": "".----."", '""': "".-..-."","‖1
""":"": ""---..."", "","": ""--..--"", ""."": "".-.-.-"", ""'"": "".----."", '""': "".-..-."","‖"""?"": ""..--.."", ""/"": ""-..-."", ""="": ""-...-"", ""+"": "".-.-."", ""-"": ""-....-"","‖1
"""?"": ""..--.."", ""/"": ""-..-."", ""="": ""-...-"", ""+"": "".-.-."", ""-"": ""-....-"","‖"""("": ""-.--."", "")"": ""-.--.-"", ""!"": ""-.-.--"", "" "": ""/"""‖1
"""("": ""-.--."", "")"": ""-.--.-"", ""!"": ""-.-.--"", "" "": ""/"""‖}‖1
"message = ""Morse code here!"""‖print(message)‖1
print(message)‖message = encrypt(message)‖1
message = encrypt(message)‖print(message)‖1
print(message)‖message = decrypt(message)‖1
message = decrypt(message)‖print(message)‖1
"octets = [int(octet) for octet in ipv4_address.split(""."")]"‖if len(octets) != 4:‖1
if len(octets) != 4:‖"raise ValueError(""Invalid IPv4 address format"")"‖1
decimal_ipv4 = 0‖for octet in octets:‖1
for octet in octets:‖if not 0 <= octet <= 255:‖1
if not 0 <= octet <= 255:‖"raise ValueError(f""Invalid IPv4 octet {octet}"")"‖1
"raise ValueError(f""Invalid IPv4 octet {octet}"")"‖decimal_ipv4 = (decimal_ipv4 << 8) + int(octet)‖1
if not (0 <= decimal_ipv4 <= 4294967295):‖"raise ValueError(""Invalid decimal IPv4 address"")"‖1
ip_parts = []‖for _ in range(4):‖1
for _ in range(4):‖ip_parts.append(str(decimal_ipv4 & 255))‖1
ip_parts.append(str(decimal_ipv4 & 255))‖decimal_ipv4 >>= 8‖1
def generate_sum_of_subsets_soln(nums: list[int], max_sum: int) -> list[list[int]]:‖result: list[list[int]] = []‖1
result: list[list[int]] = []‖path: list[int] = []‖1
path: list[int] = []‖num_index = 0‖1
num_index = 0‖remaining_nums_sum = sum(nums)‖1
remaining_nums_sum = sum(nums)‖create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)‖1
create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)‖return result‖1
def create_state_space_tree(‖nums: list[int],‖1
nums: list[int],‖max_sum: int,‖1
max_sum: int,‖num_index: int,‖1
num_index: int,‖path: list[int],‖1
path: list[int],‖result: list[list[int]],‖1
result: list[list[int]],‖remaining_nums_sum: int,‖1
remaining_nums_sum: int,‖) -> None:‖1
if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:‖return‖1
return‖if sum(path) == max_sum:‖1
if sum(path) == max_sum:‖result.append(path)‖1
result.append(path)‖return‖1
return‖for index in range(num_index, len(nums)):‖1
for index in range(num_index, len(nums)):‖create_state_space_tree(‖1
create_state_space_tree(‖nums,‖1
nums,‖max_sum,‖1
max_sum,‖index + 1,‖1
index + 1,‖[*path, nums[index]],‖1
[*path, nums[index]],‖result,‖1
result,‖remaining_nums_sum - nums[index],‖1
remaining_nums_sum - nums[index],‖)‖1
nums = [3, 34, 4, 12, 5, 2]‖max_sum = 9‖1
max_sum = 9‖result = generate_sum_of_subsets_soln(nums, max_sum)‖1
result = generate_sum_of_subsets_soln(nums, max_sum)‖print(*result)‖1
def main() -> None:‖"encoded = encode(input(""-> "").strip().lower())"‖1
"encoded = encode(input(""-> "").strip().lower())"‖"print(""Encoded: "", encoded)"‖1
"print(""Encoded: "", encoded)"‖"print(""Decoded:"", decode(encoded))"‖1
def generate_all_subsequences(sequence: list[Any]) -> None:‖create_state_space_tree(sequence, [], 0)‖1
def create_state_space_tree(‖sequence: list[Any], current_subsequence: list[Any], index: int‖1
sequence: list[Any], current_subsequence: list[Any], index: int‖) -> None:‖1
if index == len(sequence):‖print(current_subsequence)‖1
print(current_subsequence)‖return‖1
create_state_space_tree(sequence, current_subsequence, index + 1)‖current_subsequence.append(sequence[index])‖1
current_subsequence.append(sequence[index])‖create_state_space_tree(sequence, current_subsequence, index + 1)‖1
create_state_space_tree(sequence, current_subsequence, index + 1)‖current_subsequence.pop()‖1
"if __name__ == ""__main__"":"‖seq: list[Any] = [1, 2, 3]‖1
seq: list[Any] = [1, 2, 3]‖generate_all_subsequences(seq)‖1
seq.clear()‖"seq.extend([""A"", ""B"", ""C""])"‖1
"seq.extend([""A"", ""B"", ""C""])"‖generate_all_subsequences(seq)‖1
def backtrack(‖needed_sum: int,‖1
needed_sum: int,‖power: int,‖1
power: int,‖current_number: int,‖1
current_number: int,‖current_sum: int,‖1
current_sum: int,‖solutions_count: int,‖1
solutions_count: int,‖) -> tuple[int, int]:‖1
solutions_count += 1‖return current_sum, solutions_count‖1
i_to_n = current_number**power‖if current_sum + i_to_n <= needed_sum:‖1
current_sum += i_to_n‖current_sum, solutions_count = backtrack(‖1
current_sum, solutions_count = backtrack(‖needed_sum, power, current_number + 1, current_sum, solutions_count‖2
needed_sum, power, current_number + 1, current_sum, solutions_count‖)‖2
)‖current_sum -= i_to_n‖1
current_sum -= i_to_n‖if i_to_n < needed_sum:‖1
)‖return current_sum, solutions_count‖1
if not (1 <= needed_sum <= 1000 and 2 <= power <= 10):‖raise ValueError(‖1
raise ValueError(‖"""Invalid input\n"""‖1
"""Invalid input\n"""‖"""needed_sum must be between 1 and 1000, power between 2 and 10."""‖1
"""needed_sum must be between 1 and 1000, power between 2 and 10."""‖)‖1
TEST_CHARACTER_TO_NUMBER = {‖"""A"": ""111"", ""B"": ""112"", ""C"": ""113"", ""D"": ""121"", ""E"": ""122"", ""F"": ""123"", ""G"": ""131"","‖1
"""A"": ""111"", ""B"": ""112"", ""C"": ""113"", ""D"": ""121"", ""E"": ""122"", ""F"": ""123"", ""G"": ""131"","‖"""H"": ""132"", ""I"": ""133"", ""J"": ""211"", ""K"": ""212"", ""L"": ""213"", ""M"": ""221"", ""N"": ""222"","‖1
"""H"": ""132"", ""I"": ""133"", ""J"": ""211"", ""K"": ""212"", ""L"": ""213"", ""M"": ""221"", ""N"": ""222"","‖"""O"": ""223"", ""P"": ""231"", ""Q"": ""232"", ""R"": ""233"", ""S"": ""311"", ""T"": ""312"", ""U"": ""313"","‖1
"""O"": ""223"", ""P"": ""231"", ""Q"": ""232"", ""R"": ""233"", ""S"": ""311"", ""T"": ""312"", ""U"": ""313"","‖"""V"": ""321"", ""W"": ""322"", ""X"": ""323"", ""Y"": ""331"", ""Z"": ""332"", ""+"": ""333"","‖1
"""V"": ""321"", ""W"": ""322"", ""X"": ""323"", ""Y"": ""331"", ""Z"": ""332"", ""+"": ""333"","‖}‖1
"one, two, three = """", """", """""‖for each in (character_to_number[character] for character in message_part):‖1
for each in (character_to_number[character] for character in message_part):‖one += each[0]‖1
one += each[0]‖two += each[1]‖1
two += each[1]‖three += each[2]‖1
def __decrypt_part(‖message_part: str, character_to_number: dict[str, str]‖1
message_part: str, character_to_number: dict[str, str]‖) -> tuple[str, str, str]:‖1
"this_part = """".join(character_to_number[character] for character in message_part)"‖result = []‖1
result = []‖"tmp = """""‖1
"tmp = """""‖for digit in this_part:‖1
for digit in this_part:‖tmp += digit‖1
tmp += digit‖if len(tmp) == len(message_part):‖1
if len(tmp) == len(message_part):‖result.append(tmp)‖1
result.append(tmp)‖"tmp = """""‖1
def __prepare(‖message: str, alphabet: str‖1
message: str, alphabet: str‖) -> tuple[str, str, dict[str, str], dict[str, str]]:‖1
"alphabet = alphabet.replace("" "", """").upper()"‖"message = message.replace("" "", """").upper()"‖1
if len(alphabet) != 27:‖"raise KeyError(""Length of alphabet has to be 27."")"‖1
"raise KeyError(""Length of alphabet has to be 27."")"‖if any(char not in alphabet for char in message):‖1
if any(char not in alphabet for char in message):‖"raise ValueError(""Each message character has to be included in alphabet!"")"‖1
character_to_number = dict(zip(alphabet, TEST_CHARACTER_TO_NUMBER.values()))‖number_to_character = {‖1
number_to_character = {‖number: letter for letter, number in character_to_number.items()‖1
number: letter for letter, number in character_to_number.items()‖}‖1
def encrypt_message(‖"message: str, alphabet: str = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ."", period: int = 5"‖1
"message: str, alphabet: str = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ."", period: int = 5"‖) -> str:‖2
message, alphabet, character_to_number, number_to_character = __prepare(‖message, alphabet‖2
message, alphabet‖)‖2
"encrypted_numeric = """""‖for i in range(0, len(message) + 1, period):‖1
for i in range(0, len(message) + 1, period):‖encrypted_numeric += __encrypt_part(‖1
encrypted_numeric += __encrypt_part(‖message[i : i + period], character_to_number‖1
message[i : i + period], character_to_number‖)‖1
"encrypted = """""‖for i in range(0, len(encrypted_numeric), 3):‖1
for i in range(0, len(encrypted_numeric), 3):‖encrypted += number_to_character[encrypted_numeric[i : i + 3]]‖1
encrypted += number_to_character[encrypted_numeric[i : i + 3]]‖return encrypted‖1
def decrypt_message(‖"message: str, alphabet: str = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ."", period: int = 5"‖1
decrypted_numeric = []‖for i in range(0, len(message), period):‖1
for i in range(0, len(message), period):‖a, b, c = __decrypt_part(message[i : i + period], character_to_number)‖1
for j in range(len(a)):‖decrypted_numeric.append(a[j] + b[j] + c[j])‖1
doctest.testmod()‖"msg = ""DEFEND THE EAST WALL OF THE CASTLE."""‖1
"msg = ""DEFEND THE EAST WALL OF THE CASTLE."""‖"encrypted = encrypt_message(msg, ""EPSDUCVWYM.ZLKXNBTFGORIJHAQ"")"‖1
"encrypted = encrypt_message(msg, ""EPSDUCVWYM.ZLKXNBTFGORIJHAQ"")"‖"decrypted = decrypt_message(encrypted, ""EPSDUCVWYM.ZLKXNBTFGORIJHAQ"")"‖1
"decrypted = decrypt_message(encrypted, ""EPSDUCVWYM.ZLKXNBTFGORIJHAQ"")"‖"print(f""Encrypted: {encrypted}\nDecrypted: {decrypted}"")"‖1
import numpy as np‖from scipy.ndimage import convolve‖1
def warp(‖image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray‖1
image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray‖) -> np.ndarray:‖1
grid = np.stack(‖np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2‖1
np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2‖)‖1
)‖grid = np.round(grid - flow).astype(np.int32)‖1
invalid = (grid < 0) | (grid >= np.array([image.shape[1], image.shape[0]]))‖grid[invalid] = 0‖1
def horn_schunck(‖image0: np.ndarray,‖1
image0: np.ndarray,‖image1: np.ndarray,‖1
image1: np.ndarray,‖num_iter: SupportsIndex,‖1
num_iter: SupportsIndex,‖alpha: float | None = None,‖1
alpha: float | None = None,‖) -> tuple[np.ndarray, np.ndarray]:‖1
if alpha is None:‖alpha = 0.1‖1
horizontal_flow = np.zeros_like(image0)‖vertical_flow = np.zeros_like(image0)‖1
kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25‖kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25‖1
kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25‖kernel_t = np.array([[1, 1], [1, 1]]) * 0.25‖1
kernel_t = np.array([[1, 1], [1, 1]]) * 0.25‖kernel_laplacian = np.array(‖1
kernel_laplacian = np.array(‖[[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]‖1
[[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]‖)‖1
for _ in range(num_iter):‖warped_image = warp(image0, horizontal_flow, vertical_flow)‖1
warped_image = warp(image0, horizontal_flow, vertical_flow)‖derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)‖1
derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)‖derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)‖1
derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)‖derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)‖1
avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)‖avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)‖1
update = (‖derivative_x * avg_horizontal_velocity‖1
derivative_x * avg_horizontal_velocity‖+ derivative_y * avg_vertical_velocity‖1
+ derivative_y * avg_vertical_velocity‖+ derivative_t‖1
+ derivative_t‖)‖1
)‖update = update / (alpha**2 + derivative_x**2 + derivative_y**2)‖1
horizontal_flow = avg_horizontal_velocity - derivative_x * update‖vertical_flow = avg_vertical_velocity - derivative_y * update‖1
import numpy as np‖from matplotlib import pyplot as plt‖7
from matplotlib import pyplot as plt‖from matplotlib.colors import ListedColormap‖1
choice = [0] * 100 + [1] * 10‖random.shuffle(choice)‖1
def create_canvas(size: int) -> list[list[bool]]:‖canvas = [[False for i in range(size)] for j in range(size)]‖1
canvas = [[False for i in range(size)] for j in range(size)]‖return canvas‖1
def seed(canvas: list[list[bool]]) -> None:‖for i, row in enumerate(canvas):‖1
for i, row in enumerate(canvas):‖for j, _ in enumerate(row):‖1
for j, _ in enumerate(row):‖canvas[i][j] = bool(random.getrandbits(1))‖1
current_canvas = np.array(canvas)‖next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))‖1
next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))‖for r, row in enumerate(current_canvas):‖1
for r, row in enumerate(current_canvas):‖for c, pt in enumerate(row):‖1
for c, pt in enumerate(row):‖next_gen_canvas[r][c] = __judge_point(‖1
next_gen_canvas[r][c] = __judge_point(‖pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]‖1
pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]‖)‖1
def __judge_point(pt: bool, neighbours: list[list[bool]]) -> bool:‖dead = 0‖1
dead = 0‖alive = 0‖1
for i in neighbours:‖for status in i:‖1
for status in i:‖if status:‖1
if status:‖alive += 1‖1
alive += 1‖else:‖1
else:‖dead += 1‖1
if pt:‖alive -= 1‖1
alive -= 1‖else:‖1
else:‖dead -= 1‖1
state = pt‖if pt:‖1
if pt:‖if alive < 2:‖1
if alive < 2:‖state = False‖1
state = False‖elif alive in {2, 3}:‖1
elif alive in {2, 3}:‖state = True‖1
state = True‖elif alive > 3:‖1
elif alive > 3:‖state = False‖1
state = False‖elif alive == 3:‖1
elif alive == 3:‖state = True‖1
"if __name__ == ""__main__"":"‖if len(sys.argv) != 2:‖2
if len(sys.argv) != 2:‖raise Exception(usage_doc)‖1
c = create_canvas(canvas_size)‖seed(c)‖1
seed(c)‖fig, ax = plt.subplots()‖1
fig, ax = plt.subplots()‖fig.show()‖1
fig.show()‖"cmap = ListedColormap([""w"", ""k""])"‖1
"cmap = ListedColormap([""w"", ""k""])"‖try:‖1
try:‖while True:‖2
while True:‖c = run(c)‖1
c = run(c)‖ax.matshow(c, cmap=cmap)‖1
ax.matshow(c, cmap=cmap)‖fig.canvas.draw()‖1
fig.canvas.draw()‖ax.cla()‖1
ax.cla()‖except KeyboardInterrupt:‖1
"return ""0b"" + """".join("‖str(int(char_a != char_b))‖1
str(int(char_a != char_b))‖for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))‖1
def translate_message(‖"key: str, message: str, mode: Literal[""encrypt"", ""decrypt""]"‖1
"key: str, message: str, mode: Literal[""encrypt"", ""decrypt""]"‖) -> str:‖1
"chars_a = LETTERS if mode == ""decrypt"" else key"‖"chars_b = key if mode == ""decrypt"" else LETTERS"‖1
"chars_b = key if mode == ""decrypt"" else LETTERS"‖"translated = """""‖1
for symbol in message:‖if symbol.upper() in chars_a:‖2
sym_index = chars_a.find(symbol.upper())‖if symbol.isupper():‖2
if symbol.isupper():‖translated += chars_b[sym_index].upper()‖2
translated += chars_b[sym_index].upper()‖else:‖2
else:‖translated += chars_b[sym_index].lower()‖2
translated += chars_b[sym_index].lower()‖else:‖2
translated += symbol‖return translated‖1
def main() -> None:‖"message = ""Hello World"""‖1
"message = ""Hello World"""‖"key = ""QWERTYUIOPASDFGHJKLZXCVBNM"""‖1
"key = ""QWERTYUIOPASDFGHJKLZXCVBNM"""‖"mode = ""decrypt"""‖1
"if mode == ""encrypt"":"‖translated = encrypt_message(key, message)‖1
translated = encrypt_message(key, message)‖"elif mode == ""decrypt"":"‖1
"elif mode == ""decrypt"":"‖translated = decrypt_message(key, message)‖1
translated = decrypt_message(key, message)‖"print(f""Using the key {key}, the {mode}ed message is: {translated}"")"‖1
hex_num = hex_num.strip()‖if not hex_num:‖1
if not hex_num:‖"raise ValueError(""No value was passed to the function"")"‖1
"is_negative = hex_num[0] == ""-"""‖if is_negative:‖1
if is_negative:‖hex_num = hex_num[1:]‖1
try:‖int_num = int(hex_num, 16)‖1
int_num = int(hex_num, 16)‖except ValueError:‖1
except ValueError:‖"raise ValueError(""Invalid value was passed to the function"")"‖1
"bin_str = """""‖while int_num > 0:‖1
while int_num > 0:‖bin_str = str(int_num % 2) + bin_str‖1
bin_str = str(int_num % 2) + bin_str‖int_num >>= 1‖1
initial_grid: Matrix = [‖[3, 0, 6, 5, 0, 8, 4, 0, 0],‖1
[3, 0, 6, 5, 0, 8, 4, 0, 0],‖[5, 2, 0, 0, 0, 0, 0, 0, 0],‖1
[5, 2, 0, 0, 0, 0, 0, 0, 0],‖[0, 8, 7, 0, 0, 0, 0, 3, 1],‖1
[0, 8, 7, 0, 0, 0, 0, 3, 1],‖[0, 0, 3, 0, 1, 0, 0, 8, 0],‖1
[0, 0, 3, 0, 1, 0, 0, 8, 0],‖[9, 0, 0, 8, 6, 3, 0, 0, 5],‖2
[9, 0, 0, 8, 6, 3, 0, 0, 5],‖[0, 5, 0, 0, 9, 0, 6, 0, 0],‖2
[0, 5, 0, 0, 9, 0, 6, 0, 0],‖[1, 3, 0, 0, 0, 0, 2, 5, 0],‖2
[1, 3, 0, 0, 0, 0, 2, 5, 0],‖[0, 0, 0, 0, 0, 0, 0, 7, 4],‖2
[0, 0, 0, 0, 0, 0, 0, 7, 4],‖[0, 0, 5, 2, 0, 6, 3, 0, 0],‖2
[0, 0, 5, 2, 0, 6, 3, 0, 0],‖]‖2
no_solution: Matrix = [‖[5, 0, 6, 5, 0, 8, 4, 0, 3],‖1
[5, 0, 6, 5, 0, 8, 4, 0, 3],‖[5, 2, 0, 0, 0, 0, 0, 0, 2],‖1
[5, 2, 0, 0, 0, 0, 0, 0, 2],‖[1, 8, 7, 0, 0, 0, 0, 3, 1],‖1
[1, 8, 7, 0, 0, 0, 0, 3, 1],‖[0, 0, 3, 0, 1, 0, 0, 8, 0],‖1
for i in range(9):‖if n in {grid[row][i], grid[i][column]}:‖1
if n in {grid[row][i], grid[i][column]}:‖return False‖1
for i in range(3):‖for j in range(3):‖3
for j in range(3):‖if grid[(row - row % 3) + i][(column - column % 3) + j] == n:‖1
if grid[(row - row % 3) + i][(column - column % 3) + j] == n:‖return False‖1
for i in range(9):‖for j in range(9):‖1
for j in range(9):‖if grid[i][j] == 0:‖1
if grid[i][j] == 0:‖return i, j‖1
return i, j‖return None‖1
if location := find_empty_location(grid):‖row, column = location‖1
row, column = location‖else:‖1
for digit in range(1, 10):‖if is_safe(grid, row, column, digit):‖1
if is_safe(grid, row, column, digit):‖grid[row][column] = digit‖1
if sudoku(grid) is not None:‖return grid‖1
for row in grid:‖for cell in row:‖1
for cell in row:‖"print(cell, end="" "")"‖1
"print(cell, end="" "")"‖print()‖1
for example_grid in (initial_grid, no_solution):‖"print(""\nExample grid:\n"" + ""="" * 20)"‖1
"print(""\nExample grid:\n"" + ""="" * 20)"‖print_solution(example_grid)‖1
print_solution(example_grid)‖"print(""\nExample grid solution:"")"‖1
"print(""\nExample grid solution:"")"‖solution = sudoku(example_grid)‖1
solution = sudoku(example_grid)‖if solution is not None:‖1
if solution is not None:‖print_solution(solution)‖1
print_solution(solution)‖else:‖1
else:‖"print(""Cannot find a solution."")"‖1
import sys‖import time‖1
def main() -> None:‖"input_file = ""./prehistoric_men.txt"""‖1
"input_file = ""./prehistoric_men.txt"""‖"output_file = ""./Output.txt"""‖1
"output_file = ""./Output.txt"""‖"key = int(input(""Enter key: ""))"‖1
"key = int(input(""Enter key: ""))"‖"mode = input(""Encrypt/Decrypt [e/d]: "")"‖1
if not os.path.exists(input_file):‖"print(f""File {input_file} does not exist. Quitting..."")"‖1
"print(f""File {input_file} does not exist. Quitting..."")"‖sys.exit()‖1
sys.exit()‖if os.path.exists(output_file):‖1
if os.path.exists(output_file):‖"print(f""Overwrite {output_file}? [y/n]"")"‖1
"print(f""Overwrite {output_file}? [y/n]"")"‖"response = input(""> "")"‖1
"response = input(""> "")"‖"if not response.lower().startswith(""y""):"‖1
"if not response.lower().startswith(""y""):"‖sys.exit()‖1
start_time = time.time()‖"if mode.lower().startswith(""e""):"‖1
"if mode.lower().startswith(""e""):"‖with open(input_file) as f:‖1
with open(input_file) as f:‖content = f.read()‖1
content = f.read()‖translated = trans_cipher.encrypt_message(key, content)‖1
translated = trans_cipher.encrypt_message(key, content)‖"elif mode.lower().startswith(""d""):"‖1
"elif mode.lower().startswith(""d""):"‖with open(output_file) as f:‖1
with open(output_file) as f:‖content = f.read()‖1
content = f.read()‖translated = trans_cipher.decrypt_message(key, content)‖1
"with open(output_file, ""w"") as output_obj:"‖output_obj.write(translated)‖1
total_time = round(time.time() - start_time, 2)‖"print((""Done ("", total_time, ""seconds )""))"‖1
if k < 0:‖"raise ValueError(""k must not be negative"")"‖1
"raise ValueError(""k must not be negative"")"‖if n < 0:‖1
if n < 0:‖"raise ValueError(""n must not be negative"")"‖1
result: list[list[int]] = []‖create_all_state(1, n, k, [], result)‖1
create_all_state(1, n, k, [], result)‖return result‖1
def create_all_state(‖increment: int,‖1
increment: int,‖total_number: int,‖1
total_number: int,‖level: int,‖1
level: int,‖current_list: list[int],‖1
current_list: list[int],‖total_list: list[list[int]],‖1
total_list: list[list[int]],‖) -> None:‖1
if level == 0:‖total_list.append(current_list[:])‖1
total_list.append(current_list[:])‖return‖1
for i in range(increment, total_number - level + 2):‖current_list.append(i)‖1
current_list.append(i)‖create_all_state(i + 1, total_number, level - 1, current_list, total_list)‖1
create_all_state(i + 1, total_number, level - 1, current_list, total_list)‖current_list.pop()‖1
testmod()‖print(generate_all_combinations(n=4, k=2))‖1
print(generate_all_combinations(n=4, k=2))‖tests = ((n, k) for n in range(1, 5) for k in range(1, 5))‖1
tests = ((n, k) for n in range(1, 5) for k in range(1, 5))‖for n, k in tests:‖1
for n, k in tests:‖print(n, k, generate_all_combinations(n, k) == combination_lists(n, k))‖1
"print(""Benchmark:"")"‖from timeit import timeit‖1
"for func in (""combination_lists"", ""generate_all_combinations""):"‖"print(f""{func:>25}(): {timeit(f'{func}(n=4, k = 2)', globals=globals())}"")"‖1
def mixed_keyword(‖keyword: str, plaintext: str, verbose: bool = False, alphabet: str = ascii_uppercase‖1
keyword: str, plaintext: str, verbose: bool = False, alphabet: str = ascii_uppercase‖) -> str:‖1
keyword = keyword.upper()‖plaintext = plaintext.upper()‖1
plaintext = plaintext.upper()‖alphabet_set = set(alphabet)‖1
unique_chars = []‖for char in keyword:‖1
for char in keyword:‖if char in alphabet_set and char not in unique_chars:‖1
if char in alphabet_set and char not in unique_chars:‖unique_chars.append(char)‖1
shifted_alphabet = unique_chars + [‖char for char in alphabet if char not in unique_chars‖1
char for char in alphabet if char not in unique_chars‖]‖1
modified_alphabet = [‖shifted_alphabet[k : k + num_unique_chars_in_keyword]‖1
shifted_alphabet[k : k + num_unique_chars_in_keyword]‖for k in range(0, 26, num_unique_chars_in_keyword)‖1
for k in range(0, 26, num_unique_chars_in_keyword)‖]‖1
mapping = {}‖letter_index = 0‖1
letter_index = 0‖for column in range(num_unique_chars_in_keyword):‖1
for column in range(num_unique_chars_in_keyword):‖for row in modified_alphabet:‖1
if len(row) <= column:‖break‖1
mapping[alphabet[letter_index]] = row[column]‖letter_index += 1‖1
if verbose:‖print(mapping)‖1
class HarrisCorner:‖def __init__(self, k: float, window_size: int):‖1
if k in (0.04, 0.06):‖self.k = k‖1
self.k = k‖self.window_size = window_size‖1
self.window_size = window_size‖else:‖1
else:‖"raise ValueError(""invalid k value"")"‖1
def __str__(self) -> str:‖return str(self.k)‖1
img = cv2.imread(img_path, 0)‖h, w = img.shape‖1
h, w = img.shape‖corner_list: list[list[int]] = []‖1
corner_list: list[list[int]] = []‖color_img = img.copy()‖1
color_img = img.copy()‖color_img = cv2.cvtColor(color_img, cv2.COLOR_GRAY2RGB)‖1
color_img = cv2.cvtColor(color_img, cv2.COLOR_GRAY2RGB)‖dy, dx = np.gradient(img)‖1
dy, dx = np.gradient(img)‖ixx = dx**2‖1
ixx = dx**2‖iyy = dy**2‖1
iyy = dy**2‖ixy = dx * dy‖1
ixy = dx * dy‖k = 0.04‖1
k = 0.04‖offset = self.window_size // 2‖1
offset = self.window_size // 2‖for y in range(offset, h - offset):‖1
for y in range(offset, h - offset):‖for x in range(offset, w - offset):‖1
for x in range(offset, w - offset):‖wxx = ixx[‖1
wxx = ixx[‖y - offset : y + offset + 1, x - offset : x + offset + 1‖1
y - offset : y + offset + 1, x - offset : x + offset + 1‖].sum()‖3
].sum()‖wyy = iyy[‖1
wyy = iyy[‖y - offset : y + offset + 1, x - offset : x + offset + 1‖1
].sum()‖wxy = ixy[‖1
wxy = ixy[‖y - offset : y + offset + 1, x - offset : x + offset + 1‖1
det = (wxx * wyy) - (wxy**2)‖trace = wxx + wyy‖1
trace = wxx + wyy‖r = det - k * (trace**2)‖1
if r > 0.5:‖corner_list.append([x, y, r])‖1
corner_list.append([x, y, r])‖color_img.itemset((y, x, 0), 0)‖1
color_img.itemset((y, x, 0), 0)‖color_img.itemset((y, x, 1), 0)‖1
color_img.itemset((y, x, 1), 0)‖color_img.itemset((y, x, 2), 255)‖1
color_img.itemset((y, x, 2), 255)‖return color_img, corner_list‖1
"if __name__ == ""__main__"":"‖edge_detect = HarrisCorner(0.04, 3)‖1
edge_detect = HarrisCorner(0.04, 3)‖"color_img, _ = edge_detect.detect(""path_to_image"")"‖1
"color_img, _ = edge_detect.detect(""path_to_image"")"‖"cv2.imwrite(""detect.png"", color_img)"‖1
hex_string = hex_string.strip().lower()‖if not hex_string:‖1
if not hex_string:‖"raise ValueError(""Empty string was passed to the function"")"‖1
"raise ValueError(""Empty string was passed to the function"")"‖"is_negative = hex_string[0] == ""-"""‖1
"is_negative = hex_string[0] == ""-"""‖if is_negative:‖1
if is_negative:‖hex_string = hex_string[1:]‖1
hex_string = hex_string[1:]‖if not all(char in hex_table for char in hex_string):‖1
if not all(char in hex_table for char in hex_string):‖"raise ValueError(""Non-hexadecimal value was passed to the function"")"‖1
"raise ValueError(""Non-hexadecimal value was passed to the function"")"‖decimal_number = 0‖1
decimal_number = 0‖for char in hex_string:‖1
for char in hex_string:‖decimal_number = 16 * decimal_number + hex_table[char]‖1
decimal_number = 16 * decimal_number + hex_table[char]‖return -decimal_number if is_negative else decimal_number‖1
from collections.abc import Callable‖from random import randint, shuffle‖1
from random import randint, shuffle‖from time import sleep‖1
from time import sleep‖from typing import Literal‖1
WIDTH = 50‖HEIGHT = 50‖1
PREY_INITIAL_COUNT = 30‖PREY_REPRODUCTION_TIME = 5‖1
PREDATOR_FOOD_VALUE = 5‖PREDATOR_REPRODUCTION_TIME = 20‖1
MAX_ENTITIES = 500‖DELETE_UNBALANCED_ENTITIES = 50‖1
def __init__(self, prey: bool, coords: tuple[int, int]) -> None:‖self.prey = prey‖1
self.remaining_reproduction_time = (‖PREY_REPRODUCTION_TIME if prey else PREDATOR_REPRODUCTION_TIME‖1
PREY_REPRODUCTION_TIME if prey else PREDATOR_REPRODUCTION_TIME‖)‖1
)‖self.energy_value = None if prey is True else PREDATOR_INITIAL_ENERGY_VALUE‖1
self.energy_value = None if prey is True else PREDATOR_INITIAL_ENERGY_VALUE‖self.alive = True‖1
self.remaining_reproduction_time = (‖PREY_REPRODUCTION_TIME if self.prey is True else PREDATOR_REPRODUCTION_TIME‖1
PREY_REPRODUCTION_TIME if self.prey is True else PREDATOR_REPRODUCTION_TIME‖)‖1
repr_ = (‖"f""Entity(prey={self.prey}, coords={self.coords}, """‖1
"f""Entity(prey={self.prey}, coords={self.coords}, """‖"f""remaining_reproduction_time={self.remaining_reproduction_time}"""‖1
"f""remaining_reproduction_time={self.remaining_reproduction_time}"""‖)‖1
)‖if self.energy_value is not None:‖1
if self.energy_value is not None:‖"repr_ += f"", energy_value={self.energy_value}"""‖1
"repr_ += f"", energy_value={self.energy_value}"""‖"return f""{repr_})"""‖1
def __init__(self, width: int, height: int) -> None:‖self.width = width‖1
self.width = width‖self.height = height‖2
self.height = height‖self.time_passed = None‖1
for _ in range(PREY_INITIAL_COUNT):‖self.add_entity(prey=True)‖1
self.add_entity(prey=True)‖for _ in range(PREDATOR_INITIAL_COUNT):‖1
for _ in range(PREDATOR_INITIAL_COUNT):‖self.add_entity(prey=False)‖1
self.add_entity(prey=False)‖self.set_planet(self.planet)‖1
self.planet = planet‖self.width = len(planet[0])‖1
self.width = len(planet[0])‖self.height = len(planet)‖1
while True:‖row, col = randint(0, self.height - 1), randint(0, self.width - 1)‖1
row, col = randint(0, self.height - 1), randint(0, self.width - 1)‖if self.planet[row][col] is None:‖1
if self.planet[row][col] is None:‖self.planet[row][col] = Entity(prey=prey, coords=(row, col))‖1
self.planet[row][col] = Entity(prey=prey, coords=(row, col))‖return‖1
entities = self.get_entities()‖shuffle(entities)‖1
if len(entities) >= MAX_ENTITIES - MAX_ENTITIES / 10:‖prey = [entity for entity in entities if entity.prey]‖1
prey = [entity for entity in entities if entity.prey]‖predators = [entity for entity in entities if not entity.prey]‖1
entities_to_purge = (‖prey[:DELETE_UNBALANCED_ENTITIES]‖1
prey[:DELETE_UNBALANCED_ENTITIES]‖if prey_count > predator_count‖1
if prey_count > predator_count‖else predators[:DELETE_UNBALANCED_ENTITIES]‖1
else predators[:DELETE_UNBALANCED_ENTITIES]‖)‖1
)‖for entity in entities_to_purge:‖1
for entity in entities_to_purge:‖self.planet[entity.coords[0]][entity.coords[1]] = None‖1
row, col = entity.coords‖adjacent: list[tuple[int, int]] = [‖1
adjacent: list[tuple[int, int]] = [‖(row - 1, col),‖1
(row - 1, col),‖(row + 1, col),‖1
(row + 1, col),‖(row, col - 1),‖1
(row, col - 1),‖(row, col + 1),‖1
(row, col + 1),‖]‖1
return [‖ent‖1
ent‖for r, c in adjacent‖1
for r, c in adjacent‖if 0 <= r < self.height‖1
if 0 <= r < self.height‖and 0 <= c < self.width‖1
and 0 <= c < self.width‖and (ent := self.planet[r][c]) is not None‖1
and (ent := self.planet[r][c]) is not None‖and ent.prey‖1
and ent.prey‖]‖1
def move_and_reproduce(‖"self, entity: Entity, direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]]"‖1
"self, entity: Entity, direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]]"‖) -> None:‖2
) -> None:‖row, col = coords = entity.coords‖1
"adjacent_squares: dict[Literal[""N"", ""E"", ""S"", ""W""], tuple[int, int]] = {"‖"""N"": (row - 1, col),"‖1
"""N"": (row - 1, col),"‖"""S"": (row + 1, col),"‖1
"""S"": (row + 1, col),"‖"""W"": (row, col - 1),"‖1
"""W"": (row, col - 1),"‖"""E"": (row, col + 1),"‖1
"""E"": (row, col + 1),"‖}‖1
adjacent: list[tuple[int, int]] = []‖for order in direction_orders:‖1
for order in direction_orders:‖adjacent.append(adjacent_squares[order])‖1
for r, c in adjacent:‖if (‖1
if (‖0 <= r < self.height‖1
0 <= r < self.height‖and 0 <= c < self.width‖1
and 0 <= c < self.width‖and self.planet[r][c] is None‖1
and self.planet[r][c] is None‖):‖1
self.planet[r][c] = entity‖self.planet[row][col] = None‖1
self.planet[row][col] = None‖entity.coords = (r, c)‖1
entity.coords = (r, c)‖break‖1
self.planet[row][col] = Entity(prey=entity.prey, coords=coords)‖entity.reset_reproduction_time()‖1
entity.reset_reproduction_time()‖else:‖1
else:‖entity.remaining_reproduction_time -= 1‖1
def perform_prey_actions(‖"self, entity: Entity, direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]]"‖1
def perform_predator_actions(‖self,‖1
self,‖entity: Entity,‖1
entity: Entity,‖occupied_by_prey_coords: tuple[int, int] | None,‖1
occupied_by_prey_coords: tuple[int, int] | None,‖"direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]],"‖1
"direction_orders: list[Literal[""N"", ""E"", ""S"", ""W""]],"‖) -> None:‖1
if entity.energy_value == 0:‖self.planet[entity.coords[0]][entity.coords[1]] = None‖1
self.planet[entity.coords[0]][entity.coords[1]] = None‖return‖1
prey = self.planet[occupied_by_prey_coords[0]][occupied_by_prey_coords[1]]‖assert prey is not None‖1
assert prey is not None‖prey.alive = False‖1
self.planet[occupied_by_prey_coords[0]][occupied_by_prey_coords[1]] = entity‖self.planet[entity.coords[0]][entity.coords[1]] = None‖1
entity.energy_value += PREDATOR_FOOD_VALUE‖else:‖1
for __ in range(len(all_entities)):‖entity = all_entities.pop(randint(0, len(all_entities) - 1))‖1
entity = all_entities.pop(randint(0, len(all_entities) - 1))‖if entity.alive is False:‖1
if entity.alive is False:‖continue‖1
"directions: list[Literal[""N"", ""E"", ""S"", ""W""]] = [""N"", ""E"", ""S"", ""W""]"‖shuffle(directions)‖1
if entity.prey:‖self.perform_prey_actions(entity, directions)‖1
self.perform_prey_actions(entity, directions)‖else:‖1
surrounding_prey = self.get_surrounding_prey(entity)‖surrounding_prey_coords = None‖1
shuffle(surrounding_prey)‖surrounding_prey_coords = surrounding_prey[0].coords‖1
self.perform_predator_actions(‖entity, surrounding_prey_coords, directions‖1
entity, surrounding_prey_coords, directions‖)‖1
if colour:‖"__import__(""os"").system("""")"‖1
"__import__(""os"").system("""")"‖"print(""\x1b[0;0H\x1b[2J\x1b[?25l"")"‖1
"reprint = ""\x1b[0;0H"" if colour else """""‖"ansi_colour_end = ""\x1b[0m "" if colour else "" """‖1
planet = wt.planet‖"output = """""‖1
for row in planet:‖for entity in row:‖1
for entity in row:‖if entity is None:‖1
if entity is None:‖"output += "" . """‖1
"output += "" . """‖else:‖1
else:‖if colour is True:‖1
if colour is True:‖output += (‖1
output += (‖"""\x1b[38;2;96;241;151m"""‖1
"""\x1b[38;2;96;241;151m"""‖if entity.prey‖1
if entity.prey‖"else ""\x1b[38;2;255;255;15m"""‖1
"else ""\x1b[38;2;255;255;15m"""‖)‖1
)‖"output += f"" {'#' if entity.prey else 'x'}{ansi_colour_end}"""‖1
entities = wt.get_entities()‖prey_count = sum(entity.prey for entity in entities)‖1
print(‖"f""{output}\n Iteration: {iter_number} | Prey count: {prey_count} | """‖1
"f""{output}\n Iteration: {iter_number} | Prey count: {prey_count} | """‖"f""Predator count: {len(entities) - prey_count} | {reprint}"""‖1
"f""Predator count: {len(entities) - prey_count} | {reprint}"""‖)‖1
wt = WaTor(WIDTH, HEIGHT)‖wt.time_passed = visualise‖1
wt.time_passed = visualise‖wt.run(iteration_count=100_000)‖1
GLIDER = [‖[0, 1, 0, 0, 0, 0, 0, 0],‖1
[0, 1, 0, 0, 0, 0, 0, 0],‖[0, 0, 1, 0, 0, 0, 0, 0],‖1
[0, 0, 1, 0, 0, 0, 0, 0],‖[1, 1, 1, 0, 0, 0, 0, 0],‖1
[1, 1, 1, 0, 0, 0, 0, 0],‖[0, 0, 0, 0, 0, 0, 0, 0],‖1
[0, 0, 0, 0, 0, 0, 0, 0],‖[0, 0, 0, 0, 0, 0, 0, 0],‖4
[0, 0, 0, 0, 0, 0, 0, 0],‖]‖1
next_generation = []‖for i in range(len(cells)):‖1
for i in range(len(cells)):‖next_generation_row = []‖1
next_generation_row = []‖for j in range(len(cells[i])):‖1
neighbour_count = 0‖if i > 0 and j > 0:‖1
if i > 0 and j > 0:‖neighbour_count += cells[i - 1][j - 1]‖1
neighbour_count += cells[i - 1][j - 1]‖if i > 0:‖1
if i > 0:‖neighbour_count += cells[i - 1][j]‖1
neighbour_count += cells[i - 1][j]‖if i > 0 and j < len(cells[i]) - 1:‖1
if i > 0 and j < len(cells[i]) - 1:‖neighbour_count += cells[i - 1][j + 1]‖1
neighbour_count += cells[i - 1][j + 1]‖if j > 0:‖1
if j > 0:‖neighbour_count += cells[i][j - 1]‖1
neighbour_count += cells[i][j - 1]‖if j < len(cells[i]) - 1:‖1
if j < len(cells[i]) - 1:‖neighbour_count += cells[i][j + 1]‖1
neighbour_count += cells[i][j + 1]‖if i < len(cells) - 1 and j > 0:‖1
if i < len(cells) - 1 and j > 0:‖neighbour_count += cells[i + 1][j - 1]‖1
neighbour_count += cells[i + 1][j - 1]‖if i < len(cells) - 1:‖1
if i < len(cells) - 1:‖neighbour_count += cells[i + 1][j]‖1
neighbour_count += cells[i + 1][j]‖if i < len(cells) - 1 and j < len(cells[i]) - 1:‖1
if i < len(cells) - 1 and j < len(cells[i]) - 1:‖neighbour_count += cells[i + 1][j + 1]‖1
alive = cells[i][j] == 1‖if (alive and 2 <= neighbour_count <= 3) or (‖1
if (alive and 2 <= neighbour_count <= 3) or (‖not alive and neighbour_count == 3‖1
not alive and neighbour_count == 3‖):‖1
):‖next_generation_row.append(1)‖1
next_generation_row.append(1)‖else:‖1
else:‖next_generation_row.append(0)‖1
next_generation.append(next_generation_row)‖return next_generation‖1
images = []‖for _ in range(frames):‖1
"img = Image.new(""RGB"", (len(cells[0]), len(cells)))"‖pixels = img.load()‖2
for x in range(len(cells)):‖for y in range(len(cells[0])):‖1
for y in range(len(cells[0])):‖colour = 255 - cells[y][x] * 255‖1
colour = 255 - cells[y][x] * 255‖pixels[x, y] = (colour, colour, colour)‖1
images.append(img)‖cells = new_generation(cells)‖1
cells = new_generation(cells)‖return images‖1
"if __name__ == ""__main__"":"‖images = generate_images(GLIDER, 16)‖1
images = generate_images(GLIDER, 16)‖"images[0].save(""out.gif"", save_all=True, append_images=images[1:])"‖1
def make_lowpass(‖frequency: int,‖1
frequency: int,‖samplerate: int,‖7
samplerate: int,‖q_factor: float = 1 / sqrt(2),‖4
q_factor: float = 1 / sqrt(2),‖) -> IIRFilter:‖7
w0 = tau * frequency / samplerate‖_sin = sin(w0)‖7
_sin = sin(w0)‖_cos = cos(w0)‖7
_cos = cos(w0)‖alpha = _sin / (2 * q_factor)‖7
b0 = (1 - _cos) / 2‖b1 = 1 - _cos‖1
a0 = 1 + alpha‖a1 = -2 * _cos‖3
a1 = -2 * _cos‖a2 = 1 - alpha‖3
filt = IIRFilter(2)‖filt.set_coefficients([a0, a1, a2], [b0, b1, b0])‖2
filt.set_coefficients([a0, a1, a2], [b0, b1, b0])‖return filt‖2
def make_highpass(‖frequency: int,‖1
b0 = (1 + _cos) / 2‖b1 = -1 - _cos‖1
def make_bandpass(‖frequency: int,‖1
b0 = _sin / 2‖b1 = 0‖1
b1 = 0‖b2 = -b0‖1
filt = IIRFilter(2)‖filt.set_coefficients([a0, a1, a2], [b0, b1, b2])‖4
filt.set_coefficients([a0, a1, a2], [b0, b1, b2])‖return filt‖4
def make_allpass(‖frequency: int,‖1
b0 = 1 - alpha‖b1 = -2 * _cos‖1
b1 = -2 * _cos‖b2 = 1 + alpha‖1
filt = IIRFilter(2)‖filt.set_coefficients([b2, b1, b0], [b0, b1, b2])‖1
filt.set_coefficients([b2, b1, b0], [b0, b1, b2])‖return filt‖1
def make_peak(‖frequency: int,‖1
samplerate: int,‖gain_db: float,‖3
gain_db: float,‖q_factor: float = 1 / sqrt(2),‖3
alpha = _sin / (2 * q_factor)‖big_a = 10 ** (gain_db / 40)‖3
b0 = 1 + alpha * big_a‖b1 = -2 * _cos‖1
b1 = -2 * _cos‖b2 = 1 - alpha * big_a‖1
b2 = 1 - alpha * big_a‖a0 = 1 + alpha / big_a‖1
a0 = 1 + alpha / big_a‖a1 = -2 * _cos‖1
a1 = -2 * _cos‖a2 = 1 - alpha / big_a‖1
def make_lowshelf(‖frequency: int,‖1
big_a = 10 ** (gain_db / 40)‖pmc = (big_a + 1) - (big_a - 1) * _cos‖2
pmc = (big_a + 1) - (big_a - 1) * _cos‖ppmc = (big_a + 1) + (big_a - 1) * _cos‖2
ppmc = (big_a + 1) + (big_a - 1) * _cos‖mpc = (big_a - 1) - (big_a + 1) * _cos‖2
mpc = (big_a - 1) - (big_a + 1) * _cos‖pmpc = (big_a - 1) + (big_a + 1) * _cos‖2
pmpc = (big_a - 1) + (big_a + 1) * _cos‖aa2 = 2 * sqrt(big_a) * alpha‖2
b0 = big_a * (pmc + aa2)‖b1 = 2 * big_a * mpc‖1
b1 = 2 * big_a * mpc‖b2 = big_a * (pmc - aa2)‖1
b2 = big_a * (pmc - aa2)‖a0 = ppmc + aa2‖1
a0 = ppmc + aa2‖a1 = -2 * pmpc‖1
a1 = -2 * pmpc‖a2 = ppmc - aa2‖1
def make_highshelf(‖frequency: int,‖1
b0 = big_a * (ppmc + aa2)‖b1 = -2 * big_a * pmpc‖1
b1 = -2 * big_a * pmpc‖b2 = big_a * (ppmc - aa2)‖1
b2 = big_a * (ppmc - aa2)‖a0 = pmc + aa2‖1
a0 = pmc + aa2‖a1 = 2 * mpc‖1
a1 = 2 * mpc‖a2 = pmc - aa2‖1
"message = input(""Enter message: "")"‖"key = int(input(f""Enter key [2-{len(message) - 1}]: ""))"‖1
"key = int(input(f""Enter key [2-{len(message) - 1}]: ""))"‖"mode = input(""Encryption/Decryption [e/d]: "")"‖1
"if mode.lower().startswith(""e""):"‖text = encrypt_message(key, message)‖1
text = encrypt_message(key, message)‖"elif mode.lower().startswith(""d""):"‖1
"elif mode.lower().startswith(""d""):"‖text = decrypt_message(key, message)‖1
"cipher_text = [""""] * key"‖for col in range(key):‖1
for col in range(key):‖pointer = col‖1
pointer = col‖while pointer < len(message):‖1
while pointer < len(message):‖cipher_text[col] += message[pointer]‖1
cipher_text[col] += message[pointer]‖pointer += key‖1
pointer += key‖"return """".join(cipher_text)"‖1
num_cols = math.ceil(len(message) / key)‖num_rows = key‖1
num_rows = key‖num_shaded_boxes = (num_cols * num_rows) - len(message)‖1
num_shaded_boxes = (num_cols * num_rows) - len(message)‖"plain_text = [""""] * num_cols"‖1
"plain_text = [""""] * num_cols"‖col = 0‖1
col = 0‖row = 0‖1
for symbol in message:‖plain_text[col] += symbol‖1
plain_text[col] += symbol‖col += 1‖1
if (col == num_cols) or (‖(col == num_cols - 1) and (row >= num_rows - num_shaded_boxes)‖1
(col == num_cols - 1) and (row >= num_rows - num_shaded_boxes)‖):‖1
):‖col = 0‖1
col = 0‖row += 1‖1
class HillCipher:‖key_string = string.ascii_uppercase + string.digits‖1
self.encrypt_key = self.modulus(encrypt_key)‖self.check_determinant()‖1
self.check_determinant()‖self.break_key = encrypt_key.shape[0]‖1
if det < 0:‖det = det % len(self.key_string)‖2
req_l = len(self.key_string)‖if greatest_common_divisor(det, len(self.key_string)) != 1:‖1
if greatest_common_divisor(det, len(self.key_string)) != 1:‖msg = (‖1
msg = (‖"f""determinant modular {req_l} of encryption key({det}) """‖1
"f""determinant modular {req_l} of encryption key({det}) """‖"f""is not co prime w.r.t {req_l}.\nTry another key."""‖1
"f""is not co prime w.r.t {req_l}.\nTry another key."""‖)‖1
last = chars[-1]‖while len(chars) % self.break_key != 0:‖1
while len(chars) % self.break_key != 0:‖chars.append(last)‖1
text = self.process_text(text.upper())‖"encrypted = """""‖1
for i in range(0, len(text) - self.break_key + 1, self.break_key):‖batch = text[i : i + self.break_key]‖2
batch = text[i : i + self.break_key]‖vec = [self.replace_letters(char) for char in batch]‖2
vec = [self.replace_letters(char) for char in batch]‖batch_vec = np.array([vec]).T‖2
batch_vec = np.array([vec]).T‖batch_encrypted = self.modulus(self.encrypt_key.dot(batch_vec)).T.tolist()[‖1
batch_encrypted = self.modulus(self.encrypt_key.dot(batch_vec)).T.tolist()[‖0‖1
0‖]‖1
]‖"encrypted_batch = """".join("‖1
"encrypted_batch = """".join("‖self.replace_digits(num) for num in batch_encrypted‖1
self.replace_digits(num) for num in batch_encrypted‖)‖1
)‖encrypted += encrypted_batch‖1
det = det % len(self.key_string)‖det_inv = None‖1
det_inv = None‖for i in range(len(self.key_string)):‖1
for i in range(len(self.key_string)):‖if (det * i) % len(self.key_string) == 1:‖1
if (det * i) % len(self.key_string) == 1:‖det_inv = i‖1
det_inv = i‖break‖1
inv_key = (‖det_inv * np.linalg.det(self.encrypt_key) * np.linalg.inv(self.encrypt_key)‖1
det_inv * np.linalg.det(self.encrypt_key) * np.linalg.inv(self.encrypt_key)‖)‖1
decrypt_key = self.make_decrypt_key()‖text = self.process_text(text.upper())‖1
text = self.process_text(text.upper())‖"decrypted = """""‖1
batch_vec = np.array([vec]).T‖batch_decrypted = self.modulus(decrypt_key.dot(batch_vec)).T.tolist()[0]‖1
batch_decrypted = self.modulus(decrypt_key.dot(batch_vec)).T.tolist()[0]‖"decrypted_batch = """".join("‖1
"decrypted_batch = """".join("‖self.replace_digits(num) for num in batch_decrypted‖1
self.replace_digits(num) for num in batch_decrypted‖)‖1
)‖decrypted += decrypted_batch‖1
def main() -> None:‖"n = int(input(""Enter the order of the encryption key: ""))"‖1
"n = int(input(""Enter the order of the encryption key: ""))"‖hill_matrix = []‖1
"print(""Enter each row of the encryption key with space separated integers"")"‖for _ in range(n):‖1
for _ in range(n):‖row = [int(x) for x in input().split()]‖1
row = [int(x) for x in input().split()]‖hill_matrix.append(row)‖1
"print(""Would you like to encrypt or decrypt some text? (1 or 2)"")"‖"option = input(""\n1. Encrypt\n2. Decrypt\n"")"‖1
"option = input(""\n1. Encrypt\n2. Decrypt\n"")"‖"if option == ""1"":"‖1
"if option == ""1"":"‖"text_e = input(""What text would you like to encrypt?: "")"‖1
"text_e = input(""What text would you like to encrypt?: "")"‖"print(""Your encrypted text is:"")"‖1
"print(""Your encrypted text is:"")"‖print(hc.encrypt(text_e))‖1
print(hc.encrypt(text_e))‖"elif option == ""2"":"‖1
"elif option == ""2"":"‖"text_d = input(""What text would you like to decrypt?: "")"‖1
"text_d = input(""What text would you like to decrypt?: "")"‖"print(""Your decrypted text is:"")"‖1
"print(""Your decrypted text is:"")"‖print(hc.decrypt(text_d))‖1
def exits_word(‖board: list[list[str]],‖1
board: list[list[str]],‖word: str,‖1
word: str,‖row: int,‖1
row: int,‖column: int,‖1
column: int,‖word_index: int,‖1
word_index: int,‖visited_points_set: set[int],‖1
visited_points_set: set[int],‖) -> bool:‖1
if board[row][column] != word[word_index]:‖return False‖1
if word_index == len(word) - 1:‖return True‖1
traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]‖len_board = len(board)‖1
len_board = len(board)‖len_board_column = len(board[0])‖1
len_board_column = len(board[0])‖for direction in traverts_directions:‖1
for direction in traverts_directions:‖next_i = row + direction[0]‖1
next_i = row + direction[0]‖next_j = column + direction[1]‖1
next_j = column + direction[1]‖if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):‖1
if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):‖continue‖1
key = get_point_key(len_board, len_board_column, next_i, next_j)‖if key in visited_points_set:‖1
if key in visited_points_set:‖continue‖1
visited_points_set.add(key)‖if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):‖1
if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):‖return True‖1
board_error_message = (‖"""The board should be a non empty matrix of single chars strings."""‖1
"""The board should be a non empty matrix of single chars strings."""‖)‖1
len_board = len(board)‖if not isinstance(board, list) or len(board) == 0:‖1
if not isinstance(board, list) or len(board) == 0:‖raise ValueError(board_error_message)‖1
for row in board:‖if not isinstance(row, list) or len(row) == 0:‖1
if not isinstance(row, list) or len(row) == 0:‖raise ValueError(board_error_message)‖1
for item in row:‖if not isinstance(item, str) or len(item) != 1:‖1
if not isinstance(item, str) or len(item) != 1:‖raise ValueError(board_error_message)‖1
if not isinstance(word, str) or len(word) == 0:‖raise ValueError(‖1
raise ValueError(‖"""The word parameter should be a string of length greater than 0."""‖1
"""The word parameter should be a string of length greater than 0."""‖)‖1
len_board_column = len(board[0])‖for i in range(len_board):‖1
for i in range(len_board):‖for j in range(len_board_column):‖1
for j in range(len_board_column):‖if exits_word(‖1
if exits_word(‖board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)}‖1
board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)}‖):‖1
import imageio.v2 as imageio‖import numpy as np‖1
def normalize_image(‖image: np.ndarray, cap: float = 255.0, data_type: np.dtype = np.uint8‖1
image: np.ndarray, cap: float = 255.0, data_type: np.dtype = np.uint8‖) -> np.ndarray:‖1
normalized = (image - np.min(image)) / (np.max(image) - np.min(image)) * cap‖return normalized.astype(data_type)‖1
diff = np.max(array) - np.min(array)‖return (array - np.min(array)) / (1 if diff == 0 else diff) * cap‖1
def transform(‖image: np.ndarray, kind: str, kernel: np.ndarray | None = None‖1
image: np.ndarray, kind: str, kernel: np.ndarray | None = None‖) -> np.ndarray:‖1
if kernel is None:‖kernel = np.ones((3, 3))‖2
"if kind == ""erosion"":"‖constant = 1‖1
constant = 1‖apply = np.max‖1
apply = np.max‖else:‖1
else:‖constant = 0‖1
constant = 0‖apply = np.min‖1
transformed = np.zeros(image.shape, dtype=np.uint8)‖"padded = np.pad(image, 1, ""constant"", constant_values=constant)"‖1
for x in range(center_x, padded.shape[0] - center_x):‖for y in range(center_y, padded.shape[1] - center_y):‖1
for y in range(center_y, padded.shape[1] - center_y):‖center = padded[‖1
center = padded[‖x - center_x : x + center_x + 1, y - center_y : y + center_y + 1‖1
x - center_x : x + center_x + 1, y - center_y : y + center_y + 1‖]‖1
if kernel is None:‖np.ones((3, 3))‖1
kernel = np.ones((3, 3))‖"return transform(transform(image, ""erosion"", kernel), ""dilation"", kernel)"‖1
def binary_mask(‖image_gray: np.ndarray, image_map: np.ndarray‖1
image_gray: np.ndarray, image_map: np.ndarray‖) -> tuple[np.ndarray, np.ndarray]:‖1
true_mask, false_mask = image_gray.copy(), image_gray.copy()‖true_mask[image_map == 1] = 1‖1
true_mask[image_map == 1] = 1‖false_mask[image_map == 0] = 0‖1
for x in range(1, image.shape[0] - 1):‖for y in range(1, image.shape[1] - 1):‖1
for y in range(1, image.shape[1] - 1):‖base_pixel = image[x, y]‖1
base_pixel = image[x, y]‖offset_pixel = image[x + offset_x, y + offset_y]‖1
matrix[base_pixel, offset_pixel] += 1‖matrix_sum = np.sum(matrix)‖1
matrix_sum = np.sum(matrix)‖return matrix / (1 if matrix_sum == 0 else matrix_sum)‖1
prod = np.multiply(i, j)‖sub = np.subtract(i, j)‖1
correlation = prod * matrix‖energy = np.power(matrix, 2)‖1
energy = np.power(matrix, 2)‖contrast = matrix * np.power(sub, 2)‖1
dissimilarity = matrix * np.abs(sub)‖inverse_difference = matrix / (1 + np.abs(sub))‖1
inverse_difference = matrix / (1 + np.abs(sub))‖homogeneity = matrix / (1 + np.power(sub, 2))‖1
homogeneity = matrix / (1 + np.power(sub, 2))‖entropy = -(matrix[matrix > 0] * np.log(matrix[matrix > 0]))‖1
return [‖maximum_prob,‖1
maximum_prob,‖correlation.sum(),‖1
correlation.sum(),‖energy.sum(),‖1
energy.sum(),‖contrast.sum(),‖1
contrast.sum(),‖dissimilarity.sum(),‖1
dissimilarity.sum(),‖inverse_difference.sum(),‖1
inverse_difference.sum(),‖homogeneity.sum(),‖1
homogeneity.sum(),‖entropy.sum(),‖1
entropy.sum(),‖]‖1
def get_descriptors(‖masks: tuple[np.ndarray, np.ndarray], coordinate: tuple[int, int]‖1
masks: tuple[np.ndarray, np.ndarray], coordinate: tuple[int, int]‖) -> np.ndarray:‖1
descriptors = np.array(‖[haralick_descriptors(matrix_concurrency(mask, coordinate)) for mask in masks]‖1
[haralick_descriptors(matrix_concurrency(mask, coordinate)) for mask in masks]‖)‖1
distances = np.array(‖[euclidean(descriptor, descriptors[base]) for descriptor in descriptors]‖1
[euclidean(descriptor, descriptors[base]) for descriptor in descriptors]‖)‖1
normalized_distances: list[float] = normalize_array(distances, 1).tolist()‖enum_distances = list(enumerate(normalized_distances))‖1
enum_distances = list(enumerate(normalized_distances))‖enum_distances.sort(key=lambda tup: tup[1], reverse=True)‖1
enum_distances.sort(key=lambda tup: tup[1], reverse=True)‖return enum_distances‖1
index = int(input())‖q_value_list = [int(value) for value in input().split()]‖1
q_value_list = [int(value) for value in input().split()]‖q_value = (q_value_list[0], q_value_list[1])‖1
for _ in range(b_number):‖file = input().rstrip()‖1
file = input().rstrip()‖files.append(file)‖1
image = imageio.imread(file).astype(np.float32)‖gray = grayscale(image)‖1
gray = grayscale(image)‖"threshold = binarize(gray, parameters[""threshold""])"‖1
morphological = (‖opening_filter(threshold)‖1
opening_filter(threshold)‖"if parameters[""format""] == 1"‖1
"if parameters[""format""] == 1"‖else closing_filter(threshold)‖1
else closing_filter(threshold)‖)‖1
)‖masks = binary_mask(gray, morphological)‖1
masks = binary_mask(gray, morphological)‖descriptors.append(get_descriptors(masks, q_value))‖1
distances = get_distances(np.array(descriptors), index)‖indexed_distances = np.array(distances).astype(np.uint8)[:, 0]‖1
"print(f""Query: {files[index]}"")"‖"print(""Ranking:"")"‖1
"print(""Ranking:"")"‖for idx, file_idx in enumerate(indexed_distances):‖1
for idx, file_idx in enumerate(indexed_distances):‖"print(f""({idx}) {files[file_idx]}"", end=""\n"")"‖1
assert column_title.isupper()‖answer = 0‖1
answer = 0‖index = len(column_title) - 1‖1
index = len(column_title) - 1‖power = 0‖1
while index >= 0:‖value = (ord(column_title[index]) - 64) * pow(26, power)‖1
value = (ord(column_title[index]) - 64) * pow(26, power)‖answer += value‖1
answer += value‖power += 1‖1
power += 1‖index -= 1‖1
assert (‖c % greatest_common_divisor(a, b) == 0‖1
c % greatest_common_divisor(a, b) == 0‖)‖1
)‖(d, x, y) = extended_gcd(a, b)‖1
(d, x, y) = extended_gcd(a, b)‖r = c / d‖1
r = c / d‖return (r * x, r * y)‖1
(x0, y0) = diophantine(a, b, c)‖d = greatest_common_divisor(a, b)‖1
d = greatest_common_divisor(a, b)‖p = a // d‖1
p = a // d‖q = b // d‖1
for i in range(n):‖x = x0 + i * q‖1
x = x0 + i * q‖y = y0 - i * p‖1
y = y0 - i * p‖print(x, y)‖1
assert a >= 0‖assert b >= 0‖2
if b == 0:‖d, x, y = a, 1, 0‖2
d, x, y = a, 1, 0‖else:‖2
else:‖(d, p, q) = extended_gcd(b, a % b)‖2
(d, p, q) = extended_gcd(b, a % b)‖x = q‖2
x = q‖y = p - q * (a // b)‖2
assert a % d == 0‖assert b % d == 0‖2
assert b % d == 0‖assert d == a * x + b * y‖2
"testmod(name=""diophantine"", verbose=True)"‖"testmod(name=""diophantine_all_soln"", verbose=True)"‖1
"testmod(name=""diophantine_all_soln"", verbose=True)"‖"testmod(name=""extended_gcd"", verbose=True)"‖1
"testmod(name=""extended_gcd"", verbose=True)"‖"testmod(name=""greatest_common_divisor"", verbose=True)"‖1
CELLS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,‖0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]‖1
def new_generation(cells: list[list[int]], rule: list[int], time: int) -> list[int]:‖population = len(cells[0])‖1
population = len(cells[0])‖next_generation = []‖1
next_generation = []‖for i in range(population):‖1
left_neighbor = 0 if i == 0 else cells[time][i - 1]‖right_neighbor = 0 if i == population - 1 else cells[time][i + 1]‖1
"situation = 7 - int(f""{left_neighbor}{cells[time][i]}{right_neighbor}"", 2)"‖next_generation.append(rule[situation])‖1
next_generation.append(rule[situation])‖return next_generation‖1
for w in range(img.width):‖for h in range(img.height):‖1
for h in range(img.height):‖color = 255 - int(255 * cells[h][w])‖1
color = 255 - int(255 * cells[h][w])‖pixels[w, h] = (color, color, color)‖1
pixels[w, h] = (color, color, color)‖return img‖1
"if __name__ == ""__main__"":"‖"rule_num = bin(int(input(""Rule:\n"").strip()))[2:]"‖1
"rule_num = bin(int(input(""Rule:\n"").strip()))[2:]"‖rule = format_ruleset(int(rule_num))‖1
rule = format_ruleset(int(rule_num))‖for time in range(16):‖1
for time in range(16):‖CELLS.append(new_generation(CELLS, rule, time))‖1
CELLS.append(new_generation(CELLS, rule, time))‖img = generate_image(CELLS)‖1
ascii_len = len(ascii_uppercase)‖key_len = len(key)‖1
key_len = len(key)‖"encrypted_text = """""‖1
"encrypted_text = """""‖keys = [int(char) for char in key]‖1
keys = [int(char) for char in key]‖upper_case_text = text.upper()‖1
for i, char in enumerate(upper_case_text):‖if char in ascii_uppercase:‖1
if char in ascii_uppercase:‖new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len‖1
new_position = (ascii_uppercase.index(char) + keys[i % key_len]) % ascii_len‖shifted_letter = ascii_uppercase[new_position]‖1
shifted_letter = ascii_uppercase[new_position]‖encrypted_text += shifted_letter‖1
encrypted_text += shifted_letter‖else:‖1
else:‖encrypted_text += char‖1
"message = input(""Enter message: "")"‖"key = ""LFWOAYUISVKMNXPBDCRJTQEGHZ"""‖1
"key = ""LFWOAYUISVKMNXPBDCRJTQEGHZ"""‖"resp = input(""Encrypt/Decrypt [e/d]: "")"‖1
"if resp.lower().startswith(""e""):"‖"mode = ""encrypt"""‖1
translated = encrypt_message(key, message)‖"elif resp.lower().startswith(""d""):"‖1
"elif resp.lower().startswith(""d""):"‖"mode = ""decrypt"""‖1
def check_valid_key(key: str) -> None:‖key_list = list(key)‖1
key_list = list(key)‖letters_list = list(LETTERS)‖1
letters_list = list(LETTERS)‖key_list.sort()‖1
key_list.sort()‖letters_list.sort()‖1
if key_list != letters_list:‖"sys.exit(""Error in the key or symbol set."")"‖1
def translate_message(key: str, message: str, mode: str) -> str:‖"translated = """""‖1
"translated = """""‖chars_a = LETTERS‖1
chars_a = LETTERS‖chars_b = key‖1
"if mode == ""decrypt"":"‖chars_a, chars_b = chars_b, chars_a‖1
if symbol.upper() in chars_a:‖sym_index = chars_a.find(symbol.upper())‖1
else:‖translated += symbol‖1
def get_random_key() -> str:‖key = list(LETTERS)‖1
key = list(LETTERS)‖random.shuffle(key)‖1
random.shuffle(key)‖"return """".join(key)"‖1
"raise TypeError(""Input value must be a 'int' type"")"‖"return bin(a).count(""1"")"‖1
"LABEL_DIR = """""‖"IMAGE_DIR = """""‖1
"IMAGE_DIR = """""‖"OUTPUT_DIR = """""‖1
"OUTPUT_DIR = """""‖FLIP_TYPE = 1‖1
img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)‖"print(""Processing..."")"‖1
"print(""Processing..."")"‖new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)‖1
letter_code = random_chars(32)‖"file_name = paths[index].split(os.sep)[-1].rsplit(""."", 1)[0]"‖1
"file_name = paths[index].split(os.sep)[-1].rsplit(""."", 1)[0]"‖"file_root = f""{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}"""‖1
"file_root = f""{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}"""‖"cv2.imwrite(f""{file_root}.jpg"", image, [cv2.IMWRITE_JPEG_QUALITY, 85])"‖1
"cv2.imwrite(f""{file_root}.jpg"", image, [cv2.IMWRITE_JPEG_QUALITY, 85])"‖"print(f""Success {index + 1}/{len(new_images)} with {file_name}"")"‖1
"print(f""Success {index + 1}/{len(new_images)} with {file_name}"")"‖annos_list = []‖1
annos_list = []‖for anno in new_annos[index]:‖1
for anno in new_annos[index]:‖"obj = f""{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}"""‖1
"obj = f""{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}"""‖annos_list.append(obj)‖1
"obj = obj_list.rstrip(""\n"").split("" "")"‖boxes.append(‖1
boxes.append(‖[‖1
[‖int(obj[0]),‖1
int(obj[0]),‖float(obj[1]),‖1
float(obj[1]),‖float(obj[2]),‖1
float(obj[2]),‖float(obj[3]),‖1
float(obj[3]),‖float(obj[4]),‖1
float(obj[4]),‖]‖1
]‖)‖17
)‖if not boxes:‖1
def update_image_and_anno(‖img_list: list, anno_list: list, flip_type: int = 1‖1
img_list: list, anno_list: list, flip_type: int = 1‖) -> tuple[list, list, list]:‖1
new_annos_lists = []‖path_list = []‖1
path_list = []‖new_imgs_list = []‖1
new_imgs_list = []‖for idx in range(len(img_list)):‖1
for idx in range(len(img_list)):‖new_annos = []‖1
new_annos = []‖path = img_list[idx]‖1
path = img_list[idx]‖path_list.append(path)‖1
path_list.append(path)‖img_annos = anno_list[idx]‖1
img_annos = anno_list[idx]‖img = cv2.imread(path)‖1
img = cv2.imread(path)‖if flip_type == 1:‖1
if flip_type == 1:‖new_img = cv2.flip(img, flip_type)‖1
new_img = cv2.flip(img, flip_type)‖for bbox in img_annos:‖2
for bbox in img_annos:‖x_center_new = 1 - bbox[1]‖1
x_center_new = 1 - bbox[1]‖new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])‖1
new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])‖elif flip_type == 0:‖1
elif flip_type == 0:‖new_img = cv2.flip(img, flip_type)‖1
for bbox in img_annos:‖y_center_new = 1 - bbox[2]‖1
y_center_new = 1 - bbox[2]‖new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])‖1
new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])‖new_annos_lists.append(new_annos)‖1
new_annos_lists.append(new_annos)‖new_imgs_list.append(new_img)‖1
new_imgs_list.append(new_img)‖return new_imgs_list, new_annos_lists, path_list‖1
ENERGY_CONVERSION: dict[str, float] = {‖"""joule"": 1.0,"‖1
"""joule"": 1.0,"‖"""kilojoule"": 1_000,"‖1
"""kilojoule"": 1_000,"‖"""megajoule"": 1_000_000,"‖1
"""megajoule"": 1_000_000,"‖"""gigajoule"": 1_000_000_000,"‖1
"""gigajoule"": 1_000_000_000,"‖"""wattsecond"": 1.0,"‖1
"""wattsecond"": 1.0,"‖"""watthour"": 3_600,"‖1
"""watthour"": 3_600,"‖"""kilowatthour"": 3_600_000,"‖1
"""kilowatthour"": 3_600_000,"‖"""newtonmeter"": 1.0,"‖1
"""newtonmeter"": 1.0,"‖"""calorie_nutr"": 4_186.8,"‖1
"""calorie_nutr"": 4_186.8,"‖"""kilocalorie_nutr"": 4_186_800.00,"‖1
"""kilocalorie_nutr"": 4_186_800.00,"‖"""electronvolt"": 1.602_176_634e-19,"‖1
"""electronvolt"": 1.602_176_634e-19,"‖"""britishthermalunit_it"": 1_055.055_85,"‖1
"""britishthermalunit_it"": 1_055.055_85,"‖"""footpound"": 1.355_818,"‖1
"""footpound"": 1.355_818,"‖}‖1
if to_type not in ENERGY_CONVERSION or from_type not in ENERGY_CONVERSION:‖msg = (‖1
msg = (‖"f""Incorrect 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\n"""‖1
"f""Incorrect 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\n"""‖"f""Valid values are: {', '.join(ENERGY_CONVERSION)}"""‖1
"f""Valid values are: {', '.join(ENERGY_CONVERSION)}"""‖)‖1
raise ValueError(msg)‖return value * ENERGY_CONVERSION[from_type] / ENERGY_CONVERSION[to_type]‖1
MORSE_CODE_DICT = {‖"""A"": "".-"","‖1
"""A"": "".-"","‖"""B"": ""-..."","‖1
"""B"": ""-..."","‖"""C"": ""-.-."","‖1
"""C"": ""-.-."","‖"""D"": ""-.."","‖1
"""D"": ""-.."","‖"""E"": ""."","‖1
"""E"": ""."","‖"""F"": ""..-."","‖1
"""F"": ""..-."","‖"""G"": ""--."","‖1
"""G"": ""--."","‖"""H"": ""...."","‖1
"""H"": ""...."","‖"""I"": "".."","‖1
"""I"": "".."","‖"""J"": "".---"","‖1
"""J"": "".---"","‖"""K"": ""-.-"","‖1
"""K"": ""-.-"","‖"""L"": "".-.."","‖1
"""L"": "".-.."","‖"""M"": ""--"","‖1
"""M"": ""--"","‖"""N"": ""-."","‖1
"""N"": ""-."","‖"""O"": ""---"","‖1
"""O"": ""---"","‖"""P"": "".--."","‖1
"""P"": "".--."","‖"""Q"": ""--.-"","‖1
"""Q"": ""--.-"","‖"""R"": "".-."","‖1
"""R"": "".-."","‖"""S"": ""..."","‖1
"""S"": ""..."","‖"""T"": ""-"","‖1
"""T"": ""-"","‖"""U"": ""..-"","‖1
"""U"": ""..-"","‖"""V"": ""...-"","‖1
"""V"": ""...-"","‖"""W"": "".--"","‖1
"""W"": "".--"","‖"""X"": ""-..-"","‖1
"""X"": ""-..-"","‖"""Y"": ""-.--"","‖1
"""Y"": ""-.--"","‖"""Z"": ""--.."","‖1
"""Z"": ""--.."","‖""" "": """","‖1
""" "": """","‖}‖1
MORSE_COMBINATIONS = [‖"""..."","‖1
"""..."","‖"""..-"","‖1
"""..-"","‖"""..x"","‖1
"""..x"","‖""".-."","‖1
""".-."","‖""".--"","‖1
""".--"","‖""".-x"","‖1
""".-x"","‖""".x."","‖1
""".x."","‖""".x-"","‖1
""".x-"","‖""".xx"","‖1
""".xx"","‖"""-.."","‖1
"""-.."","‖"""-.-"","‖1
"""-.-"","‖"""-.x"","‖1
"""-.x"","‖"""--."","‖1
"""--."","‖"""---"","‖1
"""---"","‖"""--x"","‖1
"""--x"","‖"""-x."","‖1
"""-x."","‖"""-x-"","‖1
"""-x-"","‖"""-xx"","‖1
"""-xx"","‖"""x.."","‖1
"""x.."","‖"""x.-"","‖1
"""x.-"","‖"""x.x"","‖1
"""x.x"","‖"""x-."","‖1
"""x-."","‖"""x--"","‖1
"""x--"","‖"""x-x"","‖1
"""x-x"","‖"""xx."","‖1
"""xx."","‖"""xx-"","‖1
"""xx-"","‖"""xxx"","‖1
"""xxx"","‖]‖1
morse_code = encode_to_morse(plaintext)‖key = key.upper() + string.ascii_uppercase‖1
key = key.upper() + string.ascii_uppercase‖"key = """".join(sorted(set(key), key=key.find))"‖2
padding_length = 3 - (len(morse_code) % 3)‖"morse_code += ""x"" * padding_length"‖1
fractionated_morse_dict = {v: k for k, v in zip(key, MORSE_COMBINATIONS)}‖"fractionated_morse_dict[""xxx""] = """""‖1
"fractionated_morse_dict[""xxx""] = """""‖"encrypted_text = """".join("‖1
"encrypted_text = """".join("‖[‖1
[‖fractionated_morse_dict[morse_code[i : i + 3]]‖1
fractionated_morse_dict[morse_code[i : i + 3]]‖for i in range(0, len(morse_code), 3)‖1
for i in range(0, len(morse_code), 3)‖]‖1
)‖return encrypted_text‖1
inverse_fractionated_morse_dict = dict(zip(key, MORSE_COMBINATIONS))‖"morse_code = """".join("‖1
"morse_code = """".join("‖"[inverse_fractionated_morse_dict.get(letter, """") for letter in ciphertext]"‖1
"[inverse_fractionated_morse_dict.get(letter, """") for letter in ciphertext]"‖)‖1
)‖"decrypted_text = """".join("‖1
"decrypted_text = """".join("‖"[REVERSE_DICT[code] for code in morse_code.split(""x"")]"‖1
"[REVERSE_DICT[code] for code in morse_code.split(""x"")]"‖).strip()‖1
).strip()‖return decrypted_text‖1
"plaintext = ""defend the east"""‖"print(""Plain Text:"", plaintext)"‖1
"print(""Plain Text:"", plaintext)"‖"key = ""ROUNDTABLE"""‖1
ciphertext = encrypt_fractionated_morse(plaintext, key)‖"print(""Encrypted:"", ciphertext)"‖1
decrypted_text = decrypt_fractionated_morse(ciphertext, key)‖"print(""Decrypted:"", decrypted_text)"‖1
"key_no_dups = """""‖for ch in key:‖1
for ch in key:‖"if ch == "" "" or (ch not in key_no_dups and ch.isalpha()):"‖1
"if ch == "" "" or (ch not in key_no_dups and ch.isalpha()):"‖key_no_dups += ch‖1
key_no_dups += ch‖return key_no_dups‖1
key = remove_duplicates(key.upper())‖offset = len(key)‖1
for i in range(len(cipher_alphabet), 26):‖char = alphabet[i - offset]‖1
while char in key:‖offset -= 1‖1
offset -= 1‖char = alphabet[i - offset]‖1
char = alphabet[i - offset]‖cipher_alphabet[alphabet[i]] = char‖1
cipher_alphabet[alphabet[i]] = char‖return cipher_alphabet‖1
rev_cipher_map = {v: k for k, v in cipher_map.items()}‖"return """".join(rev_cipher_map.get(ch, ch) for ch in message.upper())"‖1
"message = input(""Enter message to encode or decode: "").strip()"‖"key = input(""Enter keyword: "").strip()"‖1
"key = input(""Enter keyword: "").strip()"‖"option = input(""Encipher or decipher? E/D:"").strip()[0].lower()"‖1
"option = input(""Encipher or decipher? E/D:"").strip()[0].lower()"‖try:‖1
try:‖"func = {""e"": encipher, ""d"": decipher}[option]"‖1
"func = {""e"": encipher, ""d"": decipher}[option]"‖except KeyError:‖1
except KeyError:‖"raise KeyError(""invalid input option"")"‖1
"raise KeyError(""invalid input option"")"‖cipher_map = create_cipher_map(key)‖1
cipher_map = create_cipher_map(key)‖print(func(message, cipher_map))‖1
low = min(nums)‖high = max(nums)‖1
high = max(nums)‖missing_number = high‖1
for i in range(low, high):‖missing_number ^= i ^ nums[i - low]‖1
import tensorflow as tf‖from keras import layers, models‖1
classifier.add(‖"layers.Conv2D(32, (3, 3), input_shape=(64, 64, 3), activation=""relu"")"‖1
"layers.Conv2D(32, (3, 3), input_shape=(64, 64, 3), activation=""relu"")"‖)‖1
"classifier.add(layers.Conv2D(32, (3, 3), activation=""relu""))"‖classifier.add(layers.MaxPooling2D(pool_size=(2, 2)))‖1
"classifier.add(layers.Dense(units=128, activation=""relu""))"‖"classifier.add(layers.Dense(units=1, activation=""sigmoid""))"‖1
classifier.compile(‖"optimizer=""adam"", loss=""binary_crossentropy"", metrics=[""accuracy""]"‖1
"optimizer=""adam"", loss=""binary_crossentropy"", metrics=[""accuracy""]"‖)‖1
train_datagen = tf.keras.preprocessing.image.ImageDataGenerator(‖rescale=1.0 / 255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True‖1
rescale=1.0 / 255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True‖)‖1
training_set = train_datagen.flow_from_directory(‖"""dataset/training_set"", target_size=(64, 64), batch_size=32, class_mode=""binary"""‖1
"""dataset/training_set"", target_size=(64, 64), batch_size=32, class_mode=""binary"""‖)‖1
test_set = test_datagen.flow_from_directory(‖"""dataset/test_set"", target_size=(64, 64), batch_size=32, class_mode=""binary"""‖1
"""dataset/test_set"", target_size=(64, 64), batch_size=32, class_mode=""binary"""‖)‖1
classifier.fit_generator(‖training_set, steps_per_epoch=5, epochs=30, validation_data=test_set‖1
training_set, steps_per_epoch=5, epochs=30, validation_data=test_set‖)‖1
test_image = tf.keras.preprocessing.image.load_img(‖"""dataset/single_prediction/image.png"", target_size=(64, 64)"‖1
"""dataset/single_prediction/image.png"", target_size=(64, 64)"‖)‖1
)‖test_image = tf.keras.preprocessing.image.img_to_array(test_image)‖1
test_image = tf.keras.preprocessing.image.img_to_array(test_image)‖test_image = np.expand_dims(test_image, axis=0)‖1
test_image = np.expand_dims(test_image, axis=0)‖result = classifier.predict(test_image)‖1
if result[0][0] == 0:‖"prediction = ""Normal"""‖1
"prediction = ""Normal"""‖if result[0][0] == 1:‖1
if result[0][0] == 1:‖"prediction = ""Abnormality detected"""‖1
if not isinstance(number, int):‖"raise TypeError(""Input value must be an 'int' type"")"‖1
position = 0‖while number:‖1
while number:‖position += 1‖1
position += 1‖number >>= 1‖1
def backtrack(‖candidates: list, path: list, answer: list, target: int, previous_index: int‖1
candidates: list, path: list, answer: list, target: int, previous_index: int‖) -> None:‖1
if target == 0:‖answer.append(path.copy())‖1
answer.append(path.copy())‖else:‖1
else:‖for index in range(previous_index, len(candidates)):‖1
for index in range(previous_index, len(candidates)):‖if target >= candidates[index]:‖1
if target >= candidates[index]:‖path.append(candidates[index])‖1
path.append(candidates[index])‖backtrack(candidates, path, answer, target - candidates[index], index)‖1
backtrack(candidates, path, answer, target - candidates[index], index)‖path.pop(len(path) - 1)‖1
path = []‖answer = []‖1
answer = []‖backtrack(candidates, path, answer, target, 0)‖1
backtrack(candidates, path, answer, target, 0)‖return answer‖1
def main() -> None:‖print(combination_sum([-8, 2.3, 0], 1))‖1
def __init__(self, order: int) -> None:‖self.order = order‖1
if len(a_coeffs) < self.order:‖a_coeffs = [1.0, *a_coeffs]‖1
if len(a_coeffs) != self.order + 1:‖msg = (‖1
msg = (‖"f""Expected a_coeffs to have {self.order + 1} elements """‖1
"f""Expected a_coeffs to have {self.order + 1} elements """‖"f""for {self.order}-order filter, got {len(a_coeffs)}"""‖1
"f""for {self.order}-order filter, got {len(a_coeffs)}"""‖)‖2
if len(b_coeffs) != self.order + 1:‖msg = (‖1
msg = (‖"f""Expected b_coeffs to have {self.order + 1} elements """‖1
"f""Expected b_coeffs to have {self.order + 1} elements """‖"f""for {self.order}-order filter, got {len(a_coeffs)}"""‖1
self.a_coeffs = a_coeffs‖self.b_coeffs = b_coeffs‖1
for i in range(1, self.order + 1):‖result += (‖1
result += (‖self.b_coeffs[i] * self.input_history[i - 1]‖1
self.b_coeffs[i] * self.input_history[i - 1]‖- self.a_coeffs[i] * self.output_history[i - 1]‖1
- self.a_coeffs[i] * self.output_history[i - 1]‖)‖1
self.input_history[1:] = self.input_history[:-1]‖self.output_history[1:] = self.output_history[:-1]‖1
self.input_history[0] = sample‖self.output_history[0] = result‖1
octal = 0‖counter = 0‖1
counter = 0‖while num > 0:‖1
while num > 0:‖remainder = num % 8‖1
remainder = num % 8‖octal = octal + (remainder * math.floor(math.pow(10, counter)))‖1
octal = octal + (remainder * math.floor(math.pow(10, counter)))‖counter += 1‖1
counter += 1‖num = math.floor(num / 8)‖1
def main() -> None:‖"print(""\n2 in octal is:"")"‖1
"print(""\n2 in octal is:"")"‖print(decimal_to_octal(2))‖1
print(decimal_to_octal(2))‖"print(""\n8 in octal is:"")"‖1
"print(""\n8 in octal is:"")"‖print(decimal_to_octal(8))‖1
print(decimal_to_octal(8))‖"print(""\n65 in octal is:"")"‖1
"print(""\n65 in octal is:"")"‖print(decimal_to_octal(65))‖1
print(decimal_to_octal(65))‖"print(""\n216 in octal is:"")"‖1
"print(""\n216 in octal is:"")"‖print(decimal_to_octal(216))‖1
print(decimal_to_octal(216))‖"print(""\n512 in octal is:"")"‖1
"print(""\n512 in octal is:"")"‖print(decimal_to_octal(512))‖1
print(decimal_to_octal(512))‖"print(""\n"")"‖1
doctest.testmod()‖for i in (-1, 0, 1, 2, 3, 4, 23, 24):‖1
for i in (-1, 0, 1, 2, 3, 4, 23, 24):‖"print(show_bits(i, swap_odd_even_bits(i)), ""\n"")"‖1
RotorPositionT = tuple[int, int, int]‖RotorSelectionT = tuple[str, str, str]‖1
"rotor1 = ""EGZWVONAHDCLFQMSIPJBYUKXTR"""‖"rotor2 = ""FOBHMDKEXQNRAULPGSJVTYICZW"""‖1
"rotor2 = ""FOBHMDKEXQNRAULPGSJVTYICZW"""‖"rotor3 = ""ZJXESIUQLHAVRMDOYGTNFWPBKC"""‖1
reflector = {‖"""A"": ""N"","‖1
"""A"": ""N"","‖"""N"": ""A"","‖1
"""N"": ""A"","‖"""B"": ""O"","‖1
"""B"": ""O"","‖"""O"": ""B"","‖1
"""O"": ""B"","‖"""C"": ""P"","‖1
"""C"": ""P"","‖"""P"": ""C"","‖1
"""P"": ""C"","‖"""D"": ""Q"","‖1
"""D"": ""Q"","‖"""Q"": ""D"","‖1
"""Q"": ""D"","‖"""E"": ""R"","‖1
"""E"": ""R"","‖"""R"": ""E"","‖1
"""R"": ""E"","‖"""F"": ""S"","‖1
"""F"": ""S"","‖"""S"": ""F"","‖1
"""S"": ""F"","‖"""G"": ""T"","‖1
"""G"": ""T"","‖"""T"": ""G"","‖1
"""T"": ""G"","‖"""H"": ""U"","‖1
"""H"": ""U"","‖"""U"": ""H"","‖1
"""U"": ""H"","‖"""I"": ""V"","‖1
"""I"": ""V"","‖"""V"": ""I"","‖1
"""V"": ""I"","‖"""J"": ""W"","‖1
"""J"": ""W"","‖"""W"": ""J"","‖1
"""W"": ""J"","‖"""K"": ""X"","‖1
"""K"": ""X"","‖"""X"": ""K"","‖1
"""X"": ""K"","‖"""L"": ""Y"","‖1
"""L"": ""Y"","‖"""Y"": ""L"","‖1
"""Y"": ""L"","‖"""M"": ""Z"","‖1
"""M"": ""Z"","‖"""Z"": ""M"","‖1
"""Z"": ""M"","‖}‖1
"rotor4 = ""RMDJXFUWGISLHVTCQNKYPBEZOA"""‖"rotor5 = ""SGLCPQWZHKXAREONTFBVIYJUDM"""‖1
"rotor5 = ""SGLCPQWZHKXAREONTFBVIYJUDM"""‖"rotor6 = ""HVSICLTYKQUBXDWAJZOMFGPREN"""‖1
"rotor6 = ""HVSICLTYKQUBXDWAJZOMFGPREN"""‖"rotor7 = ""RZWQHFMVDBKICJLNTUXAGYPSOE"""‖1
"rotor7 = ""RZWQHFMVDBKICJLNTUXAGYPSOE"""‖"rotor8 = ""LFKIJODBEGAMQPXVUHYSTCZRWN"""‖1
"rotor8 = ""LFKIJODBEGAMQPXVUHYSTCZRWN"""‖"rotor9 = ""KOAEGVDHXPQZMLFTYWJNBRCIUS"""‖1
def _validator(‖rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str‖1
rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str‖) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:‖1
if (unique_rotsel := len(set(rotsel))) < 3:‖"msg = f""Please use 3 unique rotors (not {unique_rotsel})"""‖1
"msg = f""Please use 3 unique rotors (not {unique_rotsel})"""‖raise Exception(msg)‖1
rotorpos1, rotorpos2, rotorpos3 = rotpos‖if not 0 < rotorpos1 <= len(abc):‖1
if not 0 < rotorpos1 <= len(abc):‖"msg = f""First rotor position is not within range of 1..26 ({rotorpos1}"""‖1
"msg = f""First rotor position is not within range of 1..26 ({rotorpos1}"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖if not 0 < rotorpos2 <= len(abc):‖1
if not 0 < rotorpos2 <= len(abc):‖"msg = f""Second rotor position is not within range of 1..26 ({rotorpos2})"""‖1
"msg = f""Second rotor position is not within range of 1..26 ({rotorpos2})"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖if not 0 < rotorpos3 <= len(abc):‖1
if not 0 < rotorpos3 <= len(abc):‖"msg = f""Third rotor position is not within range of 1..26 ({rotorpos3})"""‖1
"msg = f""Third rotor position is not within range of 1..26 ({rotorpos3})"""‖raise ValueError(msg)‖1
if not isinstance(pbstring, str):‖"msg = f""Plugboard setting isn't type string ({type(pbstring)})"""‖1
"msg = f""Plugboard setting isn't type string ({type(pbstring)})"""‖raise TypeError(msg)‖1
raise TypeError(msg)‖elif len(pbstring) % 2 != 0:‖1
elif len(pbstring) % 2 != 0:‖"msg = f""Odd number of symbols ({len(pbstring)})"""‖1
"msg = f""Odd number of symbols ({len(pbstring)})"""‖raise Exception(msg)‖1
raise Exception(msg)‖"elif pbstring == """":"‖1
"elif pbstring == """":"‖return {}‖1
tmppbl = set()‖for i in pbstring:‖1
for i in pbstring:‖if i not in abc:‖1
if i not in abc:‖"msg = f""'{i}' not in list of symbols"""‖1
"msg = f""'{i}' not in list of symbols"""‖raise Exception(msg)‖1
raise Exception(msg)‖elif i in tmppbl:‖1
elif i in tmppbl:‖"msg = f""Duplicate symbol ({i})"""‖1
"msg = f""Duplicate symbol ({i})"""‖raise Exception(msg)‖1
raise Exception(msg)‖else:‖1
else:‖tmppbl.add(i)‖1
tmppbl.add(i)‖del tmppbl‖1
pb = {}‖for j in range(0, len(pbstring) - 1, 2):‖1
for j in range(0, len(pbstring) - 1, 2):‖pb[pbstring[j]] = pbstring[j + 1]‖1
pb[pbstring[j]] = pbstring[j + 1]‖pb[pbstring[j + 1]] = pbstring[j]‖1
def enigma(‖text: str,‖1
text: str,‖rotor_position: RotorPositionT,‖1
rotor_position: RotorPositionT,‖rotor_selection: RotorSelectionT = (rotor1, rotor2, rotor3),‖1
rotor_selection: RotorSelectionT = (rotor1, rotor2, rotor3),‖"plugb: str = """","‖1
"plugb: str = """","‖) -> str:‖1
text = text.upper()‖rotor_position, rotor_selection, plugboard = _validator(‖1
rotor_position, rotor_selection, plugboard = _validator(‖rotor_position, rotor_selection, plugb.upper()‖1
rotor_position, rotor_selection, plugb.upper()‖)‖1
rotorpos1, rotorpos2, rotorpos3 = rotor_position‖rotor1, rotor2, rotor3 = rotor_selection‖1
rotor1, rotor2, rotor3 = rotor_selection‖rotorpos1 -= 1‖1
rotorpos1 -= 1‖rotorpos2 -= 1‖1
rotorpos2 -= 1‖rotorpos3 -= 1‖1
for symbol in text:‖if symbol in abc:‖1
if symbol in plugboard:‖symbol = plugboard[symbol]‖2
index = abc.index(symbol) + rotorpos1‖symbol = rotor1[index % len(abc)]‖1
index = abc.index(symbol) + rotorpos2‖symbol = rotor2[index % len(abc)]‖1
index = abc.index(symbol) + rotorpos3‖symbol = rotor3[index % len(abc)]‖1
symbol = abc[rotor3.index(symbol) - rotorpos3]‖symbol = abc[rotor2.index(symbol) - rotorpos2]‖1
symbol = abc[rotor2.index(symbol) - rotorpos2]‖symbol = abc[rotor1.index(symbol) - rotorpos1]‖1
rotorpos1 += 1‖if rotorpos1 >= len(abc):‖1
if rotorpos1 >= len(abc):‖rotorpos1 = 0‖1
rotorpos1 = 0‖rotorpos2 += 1‖1
rotorpos2 += 1‖if rotorpos2 >= len(abc):‖1
if rotorpos2 >= len(abc):‖rotorpos2 = 0‖1
rotorpos2 = 0‖rotorpos3 += 1‖1
rotorpos3 += 1‖if rotorpos3 >= len(abc):‖1
if rotorpos3 >= len(abc):‖rotorpos3 = 0‖1
"if __name__ == ""__main__"":"‖"message = ""This is my Python script that emulates the Enigma machine from WWII."""‖1
"message = ""This is my Python script that emulates the Enigma machine from WWII."""‖rotor_pos = (1, 1, 1)‖1
rotor_pos = (1, 1, 1)‖"pb = ""pictures"""‖1
"pb = ""pictures"""‖rotor_sel = (rotor2, rotor4, rotor8)‖1
rotor_sel = (rotor2, rotor4, rotor8)‖en = enigma(message, rotor_pos, rotor_sel, pb)‖1
"print(""Encrypted message:"", en)"‖"print(""Decrypted message:"", enigma(en, rotor_pos, rotor_sel, pb))"‖1
class FromTo(NamedTuple):‖from_factor: float‖3
from_factor: float‖to_factor: float‖3
TYPE_CONVERSION = {‖"""millimeter"": ""mm"","‖1
"""millimeter"": ""mm"","‖"""centimeter"": ""cm"","‖1
"""centimeter"": ""cm"","‖"""meter"": ""m"","‖1
"""kilometer"": ""km"","‖"""inch"": ""in"","‖1
"""inch"": ""in"","‖"""inche"": ""in"","‖1
"""inche"": ""in"","‖"""feet"": ""ft"","‖1
"""feet"": ""ft"","‖"""foot"": ""ft"","‖1
"""foot"": ""ft"","‖"""yard"": ""yd"","‖1
"""yard"": ""yd"","‖"""mile"": ""mi"","‖1
"""mile"": ""mi"","‖}‖1
METRIC_CONVERSION = {‖"""mm"": FromTo(0.001, 1000),"‖1
"""mm"": FromTo(0.001, 1000),"‖"""cm"": FromTo(0.01, 100),"‖1
"""cm"": FromTo(0.01, 100),"‖"""m"": FromTo(1, 1),"‖1
"""m"": FromTo(1, 1),"‖"""km"": FromTo(1000, 0.001),"‖1
"""km"": FromTo(1000, 0.001),"‖"""in"": FromTo(0.0254, 39.3701),"‖1
"""in"": FromTo(0.0254, 39.3701),"‖"""ft"": FromTo(0.3048, 3.28084),"‖1
"""ft"": FromTo(0.3048, 3.28084),"‖"""yd"": FromTo(0.9144, 1.09361),"‖1
"""yd"": FromTo(0.9144, 1.09361),"‖"""mi"": FromTo(1609.34, 0.000621371),"‖1
"""mi"": FromTo(1609.34, 0.000621371),"‖}‖1
"new_from = from_type.lower().rstrip(""s"")"‖new_from = TYPE_CONVERSION.get(new_from, new_from)‖1
new_from = TYPE_CONVERSION.get(new_from, new_from)‖"new_to = to_type.lower().rstrip(""s"")"‖1
"new_to = to_type.lower().rstrip(""s"")"‖new_to = TYPE_CONVERSION.get(new_to, new_to)‖1
new_to = TYPE_CONVERSION.get(new_to, new_to)‖if new_from not in METRIC_CONVERSION:‖1
if new_from not in METRIC_CONVERSION:‖msg = (‖1
raise ValueError(msg)‖if new_to not in METRIC_CONVERSION:‖1
if new_to not in METRIC_CONVERSION:‖msg = (‖1
raise ValueError(msg)‖return (‖1
return (‖value‖3
value‖* METRIC_CONVERSION[new_from].from_factor‖1
* METRIC_CONVERSION[new_from].from_factor‖* METRIC_CONVERSION[new_to].to_factor‖1
* METRIC_CONVERSION[new_to].to_factor‖)‖1
if not isinstance(octal, str):‖"raise TypeError(""Expected a string as input"")"‖1
"raise TypeError(""Expected a string as input"")"‖"if octal.startswith(""0o""):"‖1
"if octal.startswith(""0o""):"‖octal = octal[2:]‖1
octal = octal[2:]‖"if octal == """":"‖1
"if octal == """":"‖"raise ValueError(""Empty string was passed to the function"")"‖1
"raise ValueError(""Empty string was passed to the function"")"‖"if any(char not in ""01234567"" for char in octal):"‖1
"if any(char not in ""01234567"" for char in octal):"‖"raise ValueError(""Not a Valid Octal Number"")"‖1
decimal = 0‖for char in octal:‖1
for char in octal:‖decimal <<= 3‖1
decimal <<= 3‖decimal |= int(char)‖1
"revhex = """""‖while decimal:‖1
while decimal:‖revhex += hex_char[decimal & 15]‖1
revhex += hex_char[decimal & 15]‖decimal >>= 4‖1
for num in nums:‖hexadecimal = octal_to_hex(num)‖1
hexadecimal = octal_to_hex(num)‖"expected = ""0x"" + hex(int(num, 8))[2:].upper()"‖1
"print(f""Hex of '0o{num}' is: {hexadecimal}"")"‖"print(f""Expected was: {expected}"")"‖1
"print(f""Expected was: {expected}"")"‖"print(""---"")"‖1
from enum import Enum, unique‖from typing import TypeVar‖1
@unique‖class BinaryUnit(Enum):‖1
class BinaryUnit(Enum):‖yotta = 80‖1
yotta = 80‖zetta = 70‖1
zetta = 70‖exa = 60‖1
exa = 60‖peta = 50‖1
peta = 50‖tera = 40‖1
tera = 40‖giga = 30‖1
giga = 30‖mega = 20‖1
mega = 20‖kilo = 10‖1
@unique‖class SIUnit(Enum):‖1
class SIUnit(Enum):‖yotta = 24‖2
yotta = 24‖zetta = 21‖2
zetta = 21‖exa = 18‖2
exa = 18‖peta = 15‖2
peta = 15‖tera = 12‖2
tera = 12‖giga = 9‖2
giga = 9‖mega = 6‖2
mega = 6‖kilo = 3‖2
kilo = 3‖hecto = 2‖2
hecto = 2‖deca = 1‖2
deca = 1‖deci = -1‖2
deci = -1‖centi = -2‖2
centi = -2‖milli = -3‖2
milli = -3‖micro = -6‖2
micro = -6‖nano = -9‖2
nano = -9‖pico = -12‖2
pico = -12‖femto = -15‖2
femto = -15‖atto = -18‖2
atto = -18‖zepto = -21‖2
zepto = -21‖yocto = -24‖2
@classmethod‖def get_positive(cls: type[T]) -> dict:‖1
@classmethod‖def get_negative(cls: type[T]) -> dict:‖1
prefixes = SIUnit.get_positive() if value > 0 else SIUnit.get_negative()‖for name_prefix, value_prefix in prefixes.items():‖1
for name_prefix, value_prefix in prefixes.items():‖numerical_part = value / (10**value_prefix)‖1
numerical_part = value / (10**value_prefix)‖if numerical_part > 1:‖1
if numerical_part > 1:‖"return f""{numerical_part!s} {name_prefix}"""‖1
"return f""{numerical_part!s} {name_prefix}"""‖return str(value)‖1
for prefix in BinaryUnit:‖numerical_part = value / (2**prefix.value)‖1
numerical_part = value / (2**prefix.value)‖if numerical_part > 1:‖1
if numerical_part > 1:‖"return f""{numerical_part!s} {prefix.name}"""‖1
"return f""{numerical_part!s} {prefix.name}"""‖return str(value)‖1
ROMAN = [‖"(1000, ""M""),"‖1
"(1000, ""M""),"‖"(900, ""CM""),"‖1
"(900, ""CM""),"‖"(500, ""D""),"‖1
"(500, ""D""),"‖"(400, ""CD""),"‖1
"(400, ""CD""),"‖"(100, ""C""),"‖1
"(100, ""C""),"‖"(90, ""XC""),"‖1
"(90, ""XC""),"‖"(50, ""L""),"‖1
"(50, ""L""),"‖"(40, ""XL""),"‖1
"(40, ""XL""),"‖"(10, ""X""),"‖1
"(10, ""X""),"‖"(9, ""IX""),"‖1
"(9, ""IX""),"‖"(5, ""V""),"‖1
"(5, ""V""),"‖"(4, ""IV""),"‖1
"(4, ""IV""),"‖"(1, ""I""),"‖1
"(1, ""I""),"‖]‖1
"vals = {""I"": 1, ""V"": 5, ""X"": 10, ""L"": 50, ""C"": 100, ""D"": 500, ""M"": 1000}"‖total = 0‖1
total = 0‖place = 0‖1
place = 0‖while place < len(roman):‖1
while place < len(roman):‖if (place + 1 < len(roman)) and (vals[roman[place]] < vals[roman[place + 1]]):‖1
if (place + 1 < len(roman)) and (vals[roman[place]] < vals[roman[place + 1]]):‖total += vals[roman[place + 1]] - vals[roman[place]]‖1
total += vals[roman[place + 1]] - vals[roman[place]]‖place += 2‖1
place += 2‖else:‖1
else:‖total += vals[roman[place]]‖1
total += vals[roman[place]]‖place += 1‖1
place += 1‖return total‖1
result = []‖for arabic, roman in ROMAN:‖1
for arabic, roman in ROMAN:‖(factor, number) = divmod(number, arabic)‖1
(factor, number) = divmod(number, arabic)‖result.append(roman * factor)‖1
result.append(roman * factor)‖if number == 0:‖1
if number == 0:‖break‖1
break‖"return """".join(result)"‖1
def pressure_and_volume_to_temperature(‖pressure: float, moles: float, volume: float‖1
pressure: float, moles: float, volume: float‖) -> float:‖1
if not octal_number:‖"raise ValueError(""Empty string was passed to the function"")"‖1
"binary_number = """""‖"octal_digits = ""01234567"""‖1
"octal_digits = ""01234567"""‖for digit in octal_number:‖1
for digit in octal_number:‖if digit not in octal_digits:‖1
if digit not in octal_digits:‖"raise ValueError(""Non-octal value was passed to the function"")"‖1
"binary_digit = """""‖value = int(digit)‖1
value = int(digit)‖for _ in range(3):‖1
for _ in range(3):‖binary_digit = str(value % 2) + binary_digit‖1
binary_digit = str(value % 2) + binary_digit‖value //= 2‖1
value //= 2‖binary_number += binary_digit‖1
mod = round(math.sqrt((real**2) + (img**2)), 2)‖ang = round(math.degrees(math.atan2(img, real)), 2)‖1
ang = round(math.degrees(math.atan2(img, real)), 2)‖return (mod, ang)‖1
speed_chart: dict[str, float] = {‖"""km/h"": 1.0,"‖1
"""km/h"": 1.0,"‖"""m/s"": 3.6,"‖1
"""m/s"": 3.6,"‖"""mph"": 1.609344,"‖1
"""mph"": 1.609344,"‖"""knot"": 1.852,"‖1
"""knot"": 1.852,"‖}‖1
speed_chart_inverse: dict[str, float] = {‖"""km/h"": 1.0,"‖1
"""km/h"": 1.0,"‖"""m/s"": 0.277777778,"‖1
"""m/s"": 0.277777778,"‖"""mph"": 0.621371192,"‖1
"""mph"": 0.621371192,"‖"""knot"": 0.539956803,"‖1
"""knot"": 0.539956803,"‖}‖1
if unit_to not in speed_chart or unit_from not in speed_chart_inverse:‖msg = (‖1
msg = (‖"f""Incorrect 'from_type' or 'to_type' value: {unit_from!r}, {unit_to!r}\n"""‖1
"f""Incorrect 'from_type' or 'to_type' value: {unit_from!r}, {unit_to!r}\n"""‖"f""Valid values are: {', '.join(speed_chart_inverse)}"""‖1
"f""Valid values are: {', '.join(speed_chart_inverse)}"""‖)‖1
raise ValueError(msg)‖return round(speed * speed_chart[unit_from] * speed_chart_inverse[unit_to], 3)‖1
if hue < 0 or hue > 360:‖"raise Exception(""hue should be between 0 and 360"")"‖1
if saturation < 0 or saturation > 1:‖"raise Exception(""saturation should be between 0 and 1"")"‖1
if value < 0 or value > 1:‖"raise Exception(""value should be between 0 and 1"")"‖1
chroma = value * saturation‖hue_section = hue / 60‖1
hue_section = hue / 60‖second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))‖1
second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))‖match_value = value - chroma‖1
if hue_section >= 0 and hue_section <= 1:‖red = round(255 * (chroma + match_value))‖1
red = round(255 * (chroma + match_value))‖green = round(255 * (second_largest_component + match_value))‖1
green = round(255 * (second_largest_component + match_value))‖blue = round(255 * (match_value))‖1
blue = round(255 * (match_value))‖elif hue_section > 1 and hue_section <= 2:‖1
elif hue_section > 1 and hue_section <= 2:‖red = round(255 * (second_largest_component + match_value))‖1
red = round(255 * (second_largest_component + match_value))‖green = round(255 * (chroma + match_value))‖1
green = round(255 * (chroma + match_value))‖blue = round(255 * (match_value))‖1
blue = round(255 * (match_value))‖elif hue_section > 2 and hue_section <= 3:‖1
elif hue_section > 2 and hue_section <= 3:‖red = round(255 * (match_value))‖1
red = round(255 * (match_value))‖green = round(255 * (chroma + match_value))‖1
green = round(255 * (chroma + match_value))‖blue = round(255 * (second_largest_component + match_value))‖1
blue = round(255 * (second_largest_component + match_value))‖elif hue_section > 3 and hue_section <= 4:‖1
elif hue_section > 3 and hue_section <= 4:‖red = round(255 * (match_value))‖1
red = round(255 * (match_value))‖green = round(255 * (second_largest_component + match_value))‖1
green = round(255 * (second_largest_component + match_value))‖blue = round(255 * (chroma + match_value))‖1
blue = round(255 * (chroma + match_value))‖elif hue_section > 4 and hue_section <= 5:‖1
elif hue_section > 4 and hue_section <= 5:‖red = round(255 * (second_largest_component + match_value))‖1
red = round(255 * (second_largest_component + match_value))‖green = round(255 * (match_value))‖1
green = round(255 * (match_value))‖blue = round(255 * (chroma + match_value))‖1
blue = round(255 * (chroma + match_value))‖else:‖1
else:‖red = round(255 * (chroma + match_value))‖1
red = round(255 * (chroma + match_value))‖green = round(255 * (match_value))‖1
green = round(255 * (match_value))‖blue = round(255 * (second_largest_component + match_value))‖1
if red < 0 or red > 255:‖"raise Exception(""red should be between 0 and 255"")"‖1
if green < 0 or green > 255:‖"raise Exception(""green should be between 0 and 255"")"‖1
if blue < 0 or blue > 255:‖"raise Exception(""blue should be between 0 and 255"")"‖1
float_red = red / 255‖float_green = green / 255‖1
float_green = green / 255‖float_blue = blue / 255‖1
float_blue = blue / 255‖value = max(float_red, float_green, float_blue)‖1
value = max(float_red, float_green, float_blue)‖chroma = value - min(float_red, float_green, float_blue)‖1
chroma = value - min(float_red, float_green, float_blue)‖saturation = 0 if value == 0 else chroma / value‖1
if chroma == 0:‖hue = 0.0‖1
hue = 0.0‖elif value == float_red:‖1
elif value == float_red:‖hue = 60 * (0 + (float_green - float_blue) / chroma)‖1
hue = 60 * (0 + (float_green - float_blue) / chroma)‖elif value == float_green:‖1
elif value == float_green:‖hue = 60 * (2 + (float_blue - float_red) / chroma)‖1
hue = 60 * (2 + (float_blue - float_red) / chroma)‖else:‖1
else:‖hue = 60 * (4 + (float_red - float_green) / chroma)‖1
check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2‖check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002‖1
check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002‖check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002‖1
total_sum = sum(arr)‖left_sum = 0‖1
for i, value in enumerate(arr):‖total_sum -= value‖1
total_sum -= value‖if left_sum == total_sum:‖1
if left_sum == total_sum:‖return i‖1
return i‖left_sum += value‖1
oct_string = str(oct_string).strip()‖if not oct_string:‖1
if not oct_string:‖"raise ValueError(""Empty string was passed to the function"")"‖1
"raise ValueError(""Empty string was passed to the function"")"‖"is_negative = oct_string[0] == ""-"""‖1
"is_negative = oct_string[0] == ""-"""‖if is_negative:‖1
if is_negative:‖oct_string = oct_string[1:]‖1
oct_string = oct_string[1:]‖if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):‖1
if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):‖"raise ValueError(""Non-octal value was passed to the function"")"‖1
"raise ValueError(""Non-octal value was passed to the function"")"‖decimal_number = 0‖1
decimal_number = 0‖for char in oct_string:‖1
for char in oct_string:‖decimal_number = 8 * decimal_number + int(char)‖1
decimal_number = 8 * decimal_number + int(char)‖if is_negative:‖1
if is_negative:‖decimal_number = -decimal_number‖1
decimal_number = -decimal_number‖return decimal_number‖1
time_chart: dict[str, float] = {‖"""seconds"": 1.0,"‖1
"""seconds"": 1.0,"‖"""minutes"": 60.0,"‖1
"""minutes"": 60.0,"‖"""hours"": 3600.0,"‖1
"""hours"": 3600.0,"‖"""days"": 86400.0,"‖1
"""days"": 86400.0,"‖"""weeks"": 604800.0,"‖1
"""weeks"": 604800.0,"‖"""months"": 2629800.0,"‖1
"""months"": 2629800.0,"‖"""years"": 31557600.0,"‖1
"""years"": 31557600.0,"‖}‖1
time_chart_inverse: dict[str, float] = {‖key: 1 / value for key, value in time_chart.items()‖1
key: 1 / value for key, value in time_chart.items()‖}‖1
if not isinstance(time_value, (int, float)) or time_value < 0:‖"msg = ""'time_value' must be a non-negative number."""‖1
"msg = ""'time_value' must be a non-negative number."""‖raise ValueError(msg)‖1
unit_from = unit_from.lower()‖unit_to = unit_to.lower()‖1
unit_to = unit_to.lower()‖if unit_from not in time_chart or unit_to not in time_chart:‖1
if unit_from not in time_chart or unit_to not in time_chart:‖invalid_unit = unit_from if unit_from not in time_chart else unit_to‖1
invalid_unit = unit_from if unit_from not in time_chart else unit_to‖"msg = f""Invalid unit {invalid_unit} is not in {', '.join(time_chart)}."""‖1
"msg = f""Invalid unit {invalid_unit} is not in {', '.join(time_chart)}."""‖raise ValueError(msg)‖1
return round(‖time_value * time_chart[unit_from] * time_chart_inverse[unit_to],‖1
time_value * time_chart[unit_from] * time_chart_inverse[unit_to],‖3,‖1
3,‖)‖1
doctest.testmod()‖"print(f""{convert_time(3600,'seconds', 'hours') = :,}"")"‖1
"print(f""{convert_time(3600,'seconds', 'hours') = :,}"")"‖"print(f""{convert_time(360, 'days', 'months') = :,}"")"‖1
"print(f""{convert_time(360, 'days', 'months') = :,}"")"‖"print(f""{convert_time(360, 'months', 'years') = :,}"")"‖1
"print(f""{convert_time(360, 'months', 'years') = :,}"")"‖"print(f""{convert_time(1, 'years', 'seconds') = :,}"")"‖1
if (‖not isinstance(r_input, int)‖1
not isinstance(r_input, int)‖or not isinstance(g_input, int)‖1
or not isinstance(g_input, int)‖or not isinstance(b_input, int)‖1
or not isinstance(b_input, int)‖):‖1
):‖"msg = f""Expected int, found {type(r_input), type(g_input), type(b_input)}"""‖1
"msg = f""Expected int, found {type(r_input), type(g_input), type(b_input)}"""‖raise ValueError(msg)‖1
if not 0 <= r_input < 256 or not 0 <= g_input < 256 or not 0 <= b_input < 256:‖"raise ValueError(""Expected int of the range 0..255"")"‖1
r = r_input / 255‖g = g_input / 255‖1
g = g_input / 255‖b = b_input / 255‖1
if k == 1:‖return 0, 0, 0, 100‖1
c = round(100 * (1 - r - k) / (1 - k))‖m = round(100 * (1 - g - k) / (1 - k))‖1
m = round(100 * (1 - g - k) / (1 - k))‖y = round(100 * (1 - b - k) / (1 - k))‖1
y = round(100 * (1 - b - k) / (1 - k))‖k = round(100 * k)‖1
METRIC_CONVERSION = {‖"""cubic meter"": FromTo(1, 1),"‖1
"""cubic meter"": FromTo(1, 1),"‖"""litre"": FromTo(0.001, 1000),"‖1
"""litre"": FromTo(0.001, 1000),"‖"""kilolitre"": FromTo(1, 1),"‖1
"""kilolitre"": FromTo(1, 1),"‖"""gallon"": FromTo(0.00454, 264.172),"‖1
"""gallon"": FromTo(0.00454, 264.172),"‖"""cubic yard"": FromTo(0.76455, 1.30795),"‖1
"""cubic yard"": FromTo(0.76455, 1.30795),"‖"""cubic foot"": FromTo(0.028, 35.3147),"‖1
"""cubic foot"": FromTo(0.028, 35.3147),"‖"""cup"": FromTo(0.000236588, 4226.75),"‖1
"""cup"": FromTo(0.000236588, 4226.75),"‖}‖1
if from_type not in METRIC_CONVERSION:‖raise ValueError(‖1
raise ValueError(‖"f""Invalid 'from_type' value: {from_type!r}  Supported values are:\n"""‖2
"f""Invalid 'from_type' value: {from_type!r}  Supported values are:\n"""‖"+ "", "".join(METRIC_CONVERSION)"‖1
"+ "", "".join(METRIC_CONVERSION)"‖)‖2
)‖if to_type not in METRIC_CONVERSION:‖1
if to_type not in METRIC_CONVERSION:‖raise ValueError(‖1
raise ValueError(‖"f""Invalid 'to_type' value: {to_type!r}.  Supported values are:\n"""‖2
"f""Invalid 'to_type' value: {to_type!r}.  Supported values are:\n"""‖"+ "", "".join(METRIC_CONVERSION)"‖1
)‖return (‖2
value‖* METRIC_CONVERSION[from_type].from_factor‖1
* METRIC_CONVERSION[from_type].from_factor‖* METRIC_CONVERSION[to_type].to_factor‖1
* METRIC_CONVERSION[to_type].to_factor‖)‖1
PRESSURE_CONVERSION = {‖"""atm"": FromTo(1, 1),"‖1
"""atm"": FromTo(1, 1),"‖"""pascal"": FromTo(0.0000098, 101325),"‖1
"""pascal"": FromTo(0.0000098, 101325),"‖"""bar"": FromTo(0.986923, 1.01325),"‖1
"""bar"": FromTo(0.986923, 1.01325),"‖"""kilopascal"": FromTo(0.00986923, 101.325),"‖1
"""kilopascal"": FromTo(0.00986923, 101.325),"‖"""megapascal"": FromTo(9.86923, 0.101325),"‖1
"""megapascal"": FromTo(9.86923, 0.101325),"‖"""psi"": FromTo(0.068046, 14.6959),"‖1
"""psi"": FromTo(0.068046, 14.6959),"‖"""inHg"": FromTo(0.0334211, 29.9213),"‖1
"""inHg"": FromTo(0.0334211, 29.9213),"‖"""torr"": FromTo(0.00131579, 760),"‖1
"""torr"": FromTo(0.00131579, 760),"‖}‖1
if from_type not in PRESSURE_CONVERSION:‖raise ValueError(‖1
"f""Invalid 'from_type' value: {from_type!r}  Supported values are:\n"""‖"+ "", "".join(PRESSURE_CONVERSION)"‖1
"+ "", "".join(PRESSURE_CONVERSION)"‖)‖2
)‖if to_type not in PRESSURE_CONVERSION:‖1
if to_type not in PRESSURE_CONVERSION:‖raise ValueError(‖1
"f""Invalid 'to_type' value: {to_type!r}.  Supported values are:\n"""‖"+ "", "".join(PRESSURE_CONVERSION)"‖1
value‖* PRESSURE_CONVERSION[from_type].from_factor‖1
* PRESSURE_CONVERSION[from_type].from_factor‖* PRESSURE_CONVERSION[to_type].to_factor‖1
* PRESSURE_CONVERSION[to_type].to_factor‖)‖1
from collections.abc import Iterable, Iterator‖from dataclasses import dataclass‖4
from dataclasses import dataclass‖from typing import Any, Self‖2
@dataclass‖class Node:‖19
class Node:‖value: int‖1
value: int‖left: Node | None = None‖2
left: Node | None = None‖right: Node | None = None‖10
right: Node | None = None‖parent: Node | None = None‖1
yield from self.left or []‖yield self.value‖1
yield self.value‖yield from self.right or []‖1
def __repr__(self) -> str:‖from pprint import pformat‖3
if self.left is None and self.right is None:‖return str(self.value)‖1
return str(self.value)‖"return pformat({f""{self.value}"": (self.left, self.right)}, indent=1)"‖1
@property‖def is_right(self) -> bool:‖1
def is_right(self) -> bool:‖return bool(self.parent and self is self.parent.right)‖1
@dataclass‖class BinarySearchTree:‖1
class BinarySearchTree:‖root: Node | None = None‖1
def __bool__(self) -> bool:‖return bool(self.root)‖1
def __iter__(self) -> Iterator[int]:‖yield from self.root or []‖1
def __reassign_nodes(self, node: Node, new_children: Node | None) -> None:‖if new_children is not None:‖1
if new_children is not None:‖new_children.parent = node.parent‖1
new_children.parent = node.parent‖if node.parent is not None:‖1
if node.parent is not None:‖if node.is_right:‖1
if node.is_right:‖node.parent.right = new_children‖1
node.parent.right = new_children‖else:‖2
else:‖node.parent.left = new_children‖2
node.parent.left = new_children‖else:‖2
else:‖self.root = new_children‖2
new_node = Node(value)‖if self.empty():‖1
if self.empty():‖self.root = new_node‖1
self.root = new_node‖else:‖1
else:‖parent_node = self.root‖1
parent_node = self.root‖if parent_node is None:‖1
if parent_node is None:‖return‖1
return‖while True:‖1
while True:‖if value < parent_node.value:‖1
if value < parent_node.value:‖if parent_node.left is None:‖1
if parent_node.left is None:‖parent_node.left = new_node‖1
parent_node.left = new_node‖break‖1
else:‖parent_node = parent_node.left‖1
parent_node = parent_node.left‖elif parent_node.right is None:‖1
elif parent_node.right is None:‖parent_node.right = new_node‖1
parent_node.right = new_node‖break‖1
else:‖parent_node = parent_node.right‖1
parent_node = parent_node.right‖new_node.parent = parent_node‖1
def insert(self, *values) -> Self:‖for value in values:‖1
for value in values:‖self.__insert(value)‖1
self.__insert(value)‖return self‖1
if self.empty():‖"raise IndexError(""Warning: Tree is empty! please use another."")"‖1
"raise IndexError(""Warning: Tree is empty! please use another."")"‖else:‖1
else:‖node = self.root‖1
while node is not None and node.value is not value:‖node = node.left if value < node.value else node.right‖1
node = node.left if value < node.value else node.right‖return node‖1
if node is None:‖if self.root is None:‖1
if self.root is None:‖return None‖2
return None‖node = self.root‖1
if not self.empty():‖while node.right is not None:‖1
while node.right is not None:‖node = node.right‖2
node = node.right‖return node‖1
if node is None:‖node = self.root‖1
node = self.root‖if self.root is None:‖1
return None‖if not self.empty():‖1
if not self.empty():‖node = self.root‖1
node = self.root‖while node.left is not None:‖2
while node.left is not None:‖node = node.left‖2
node = node.left‖return node‖1
node = self.search(value)‖if node is None:‖1
if node is None:‖"msg = f""Value {value} not found"""‖1
"msg = f""Value {value} not found"""‖raise ValueError(msg)‖1
if node.left is None and node.right is None:‖self.__reassign_nodes(node, None)‖1
self.__reassign_nodes(node, None)‖elif node.left is None:‖1
elif node.left is None:‖self.__reassign_nodes(node, node.right)‖1
self.__reassign_nodes(node, node.right)‖elif node.right is None:‖1
elif node.right is None:‖self.__reassign_nodes(node, node.left)‖1
self.__reassign_nodes(node, node.left)‖else:‖1
else:‖predecessor = self.get_max(‖1
predecessor = self.get_max(‖node.left‖1
node.left‖)‖1
)‖self.remove(predecessor.value)‖1
self.remove(predecessor.value)‖node.value = (‖1
node.value = (‖predecessor.value‖1
predecessor.value‖)‖1
def preorder_traverse(self, node: Node | None) -> Iterable:‖if node is not None:‖1
if node is not None:‖yield node‖2
yield node‖yield from self.preorder_traverse(node.left)‖1
yield from self.preorder_traverse(node.left)‖yield from self.preorder_traverse(node.right)‖1
if traversal_function is None:‖return self.preorder_traverse(self.root)‖1
return self.preorder_traverse(self.root)‖else:‖1
else:‖return traversal_function(self.root)‖1
if node:‖self.inorder(arr, node.left)‖1
self.inorder(arr, node.left)‖arr.append(node.value)‖1
arr.append(node.value)‖self.inorder(arr, node.right)‖1
arr: list[int] = []‖self.inorder(arr, node)‖1
self.inorder(arr, node)‖return arr[k - 1]‖1
node_list = []‖if curr_node is not None:‖2
if curr_node is not None:‖node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]‖1
node_list = [*inorder(curr_node.left), curr_node, *inorder(curr_node.right)]‖return node_list‖1
if curr_node is not None:‖node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]‖1
node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]‖return node_list‖1
if not nums1 and not nums2:‖"raise ValueError(""Both input arrays are empty."")"‖1
merged = sorted(nums1 + nums2)‖total = len(merged)‖1
if total % 2 == 1:‖return float(merged[total // 2])‖1
middle1 = merged[total // 2 - 1]‖middle2 = merged[total // 2]‖1
middle2 = merged[total // 2]‖return (float(middle1) + float(middle2)) / 2.0‖1
class BinaryUnit(Enum):‖yotta = 8‖1
yotta = 8‖zetta = 7‖1
zetta = 7‖exa = 6‖1
exa = 6‖peta = 5‖1
peta = 5‖tera = 4‖1
tera = 4‖giga = 3‖1
giga = 3‖mega = 2‖1
mega = 2‖kilo = 1‖1
def convert_si_prefix(‖known_amount: float,‖1
known_amount: float,‖known_prefix: str | SIUnit,‖1
known_prefix: str | SIUnit,‖unknown_prefix: str | SIUnit,‖1
unknown_prefix: str | SIUnit,‖) -> float:‖1
if isinstance(known_prefix, str):‖known_prefix = SIUnit[known_prefix.lower()]‖1
known_prefix = SIUnit[known_prefix.lower()]‖if isinstance(unknown_prefix, str):‖1
if isinstance(unknown_prefix, str):‖unknown_prefix = SIUnit[unknown_prefix.lower()]‖1
unknown_prefix = SIUnit[unknown_prefix.lower()]‖unknown_amount: float = known_amount * (‖1
unknown_amount: float = known_amount * (‖10 ** (known_prefix.value - unknown_prefix.value)‖1
10 ** (known_prefix.value - unknown_prefix.value)‖)‖1
)‖return unknown_amount‖2
def convert_binary_prefix(‖known_amount: float,‖1
known_amount: float,‖known_prefix: str | BinaryUnit,‖1
known_prefix: str | BinaryUnit,‖unknown_prefix: str | BinaryUnit,‖1
unknown_prefix: str | BinaryUnit,‖) -> float:‖1
if isinstance(known_prefix, str):‖known_prefix = BinaryUnit[known_prefix.lower()]‖1
known_prefix = BinaryUnit[known_prefix.lower()]‖if isinstance(unknown_prefix, str):‖1
if isinstance(unknown_prefix, str):‖unknown_prefix = BinaryUnit[unknown_prefix.lower()]‖1
unknown_prefix = BinaryUnit[unknown_prefix.lower()]‖unknown_amount: float = known_amount * (‖1
unknown_amount: float = known_amount * (‖2 ** ((known_prefix.value - unknown_prefix.value) * 10)‖1
2 ** ((known_prefix.value - unknown_prefix.value) * 10)‖)‖1
KILOGRAM_CHART: dict[str, float] = {‖"""kilogram"": 1,"‖1
"""kilogram"": 1,"‖"""gram"": pow(10, 3),"‖1
"""gram"": pow(10, 3),"‖"""milligram"": pow(10, 6),"‖1
"""milligram"": pow(10, 6),"‖"""metric-ton"": pow(10, -3),"‖1
"""metric-ton"": pow(10, -3),"‖"""long-ton"": 0.0009842073,"‖1
"""long-ton"": 0.0009842073,"‖"""short-ton"": 0.0011023122,"‖1
"""short-ton"": 0.0011023122,"‖"""pound"": 2.2046244202,"‖1
"""pound"": 2.2046244202,"‖"""stone"": 0.1574731728,"‖1
"""stone"": 0.1574731728,"‖"""ounce"": 35.273990723,"‖1
"""ounce"": 35.273990723,"‖"""carrat"": 5000,"‖1
"""carrat"": 5000,"‖"""atomic-mass-unit"": 6.022136652e26,"‖1
"""atomic-mass-unit"": 6.022136652e26,"‖}‖1
WEIGHT_TYPE_CHART: dict[str, float] = {‖"""kilogram"": 1,"‖1
"""kilogram"": 1,"‖"""gram"": pow(10, -3),"‖1
"""gram"": pow(10, -3),"‖"""milligram"": pow(10, -6),"‖1
"""milligram"": pow(10, -6),"‖"""metric-ton"": pow(10, 3),"‖1
"""metric-ton"": pow(10, 3),"‖"""long-ton"": 1016.04608,"‖1
"""long-ton"": 1016.04608,"‖"""short-ton"": 907.184,"‖1
"""short-ton"": 907.184,"‖"""pound"": 0.453592,"‖1
"""pound"": 0.453592,"‖"""stone"": 6.35029,"‖1
"""stone"": 6.35029,"‖"""ounce"": 0.0283495,"‖1
"""ounce"": 0.0283495,"‖"""carrat"": 0.0002,"‖1
"""carrat"": 0.0002,"‖"""atomic-mass-unit"": 1.660540199e-27,"‖1
"""atomic-mass-unit"": 1.660540199e-27,"‖}‖1
def weight_conversion(from_type: str, to_type: str, value: float) -> float:‖if to_type not in KILOGRAM_CHART or from_type not in WEIGHT_TYPE_CHART:‖1
if to_type not in KILOGRAM_CHART or from_type not in WEIGHT_TYPE_CHART:‖msg = (‖1
msg = (‖"f""Invalid 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\n"""‖1
"f""Invalid 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\n"""‖"f""Supported values are: {', '.join(WEIGHT_TYPE_CHART)}"""‖1
"f""Supported values are: {', '.join(WEIGHT_TYPE_CHART)}"""‖)‖1
raise ValueError(msg)‖return value * KILOGRAM_CHART[to_type] * WEIGHT_TYPE_CHART[from_type]‖1
def binary_tree_mirror_dict(binary_tree_mirror_dictionary: dict, root: int):‖if not root or root not in binary_tree_mirror_dictionary:‖1
if not root or root not in binary_tree_mirror_dictionary:‖return‖1
return‖left_child, right_child = binary_tree_mirror_dictionary[root][:2]‖1
left_child, right_child = binary_tree_mirror_dictionary[root][:2]‖binary_tree_mirror_dictionary[root] = [right_child, left_child]‖1
binary_tree_mirror_dictionary[root] = [right_child, left_child]‖binary_tree_mirror_dict(binary_tree_mirror_dictionary, left_child)‖1
binary_tree_mirror_dict(binary_tree_mirror_dictionary, left_child)‖binary_tree_mirror_dict(binary_tree_mirror_dictionary, right_child)‖1
if not binary_tree:‖"raise ValueError(""binary tree cannot be empty"")"‖1
"raise ValueError(""binary tree cannot be empty"")"‖if root not in binary_tree:‖1
if root not in binary_tree:‖"msg = f""root {root} is not present in the binary_tree"""‖1
"msg = f""root {root} is not present in the binary_tree"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖binary_tree_mirror_dictionary = dict(binary_tree)‖1
binary_tree_mirror_dictionary = dict(binary_tree)‖binary_tree_mirror_dict(binary_tree_mirror_dictionary, root)‖1
binary_tree_mirror_dict(binary_tree_mirror_dictionary, root)‖return binary_tree_mirror_dictionary‖1
"if __name__ == ""__main__"":"‖binary_tree = {1: [2, 3], 2: [4, 5], 3: [6, 7], 7: [8, 9]}‖1
binary_tree = {1: [2, 3], 2: [4, 5], 3: [6, 7], 7: [8, 9]}‖"print(f""Binary tree: {binary_tree}"")"‖1
"print(f""Binary tree: {binary_tree}"")"‖binary_tree_mirror_dictionary = binary_tree_mirror(binary_tree, 5)‖1
binary_tree_mirror_dictionary = binary_tree_mirror(binary_tree, 5)‖"print(f""Binary tree mirror: {binary_tree_mirror_dictionary}"")"‖1
import random‖from typing import Any‖3
class MyQueue:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self.data: list[Any] = []‖1
self.data: list[Any] = []‖self.head: int = 0‖1
self.head: int = 0‖self.tail: int = 0‖1
def is_empty(self) -> bool:‖return self.head == self.tail‖1
def push(self, data: Any) -> None:‖self.data.append(data)‖1
self.data.append(data)‖self.tail = self.tail + 1‖1
def pop(self) -> Any:‖ret = self.data[self.head]‖1
ret = self.data[self.head]‖self.head = self.head + 1‖1
self.head = self.head + 1‖return ret‖1
def count(self) -> int:‖return self.tail - self.head‖1
def print_queue(self) -> None:‖print(self.data)‖1
print(self.data)‖"print(""**************"")"‖1
"print(""**************"")"‖print(self.data[self.head : self.tail])‖1
class MyNode:‖def __init__(self, data: Any) -> None:‖1
def __init__(self, data: Any) -> None:‖self.data = data‖1
self.data = data‖self.left: MyNode | None = None‖1
self.left: MyNode | None = None‖self.right: MyNode | None = None‖1
self.right: MyNode | None = None‖self.height: int = 1‖1
def get_data(self) -> Any:‖return self.data‖1
def get_left(self) -> MyNode | None:‖return self.left‖1
def get_right(self) -> MyNode | None:‖return self.right‖1
def get_height(self) -> int:‖return self.height‖1
def set_data(self, data: Any) -> None:‖self.data = data‖1
def set_left(self, node: MyNode | None) -> None:‖self.left = node‖1
def set_right(self, node: MyNode | None) -> None:‖self.right = node‖1
def set_height(self, height: int) -> None:‖self.height = height‖1
def get_height(node: MyNode | None) -> int:‖if node is None:‖1
if node is None:‖return 0‖6
return 0‖return node.get_height()‖1
def my_max(a: int, b: int) -> int:‖if a > b:‖1
if a > b:‖return a‖1
return a‖return b‖1
"print(""left rotation node:"", node.get_data())"‖ret = node.get_left()‖1
ret = node.get_left()‖assert ret is not None‖1
assert ret is not None‖node.set_left(ret.get_right())‖1
node.set_left(ret.get_right())‖ret.set_right(node)‖1
ret.set_right(node)‖h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1‖1
h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1‖node.set_height(h1)‖3
node.set_height(h1)‖h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1‖2
h2 = my_max(get_height(ret.get_right()), get_height(ret.get_left())) + 1‖ret.set_height(h2)‖2
ret.set_height(h2)‖return ret‖2
"print(""right rotation node:"", node.get_data())"‖ret = node.get_right()‖1
ret = node.get_right()‖assert ret is not None‖1
assert ret is not None‖node.set_right(ret.get_left())‖1
node.set_right(ret.get_left())‖ret.set_left(node)‖1
ret.set_left(node)‖h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1‖1
left_child = node.get_left()‖assert left_child is not None‖2
assert left_child is not None‖node.set_left(left_rotation(left_child))‖1
node.set_left(left_rotation(left_child))‖return right_rotation(node)‖1
def rl_rotation(node: MyNode) -> MyNode:‖right_child = node.get_right()‖1
right_child = node.get_right()‖assert right_child is not None‖2
assert right_child is not None‖node.set_right(right_rotation(right_child))‖1
node.set_right(right_rotation(right_child))‖return left_rotation(node)‖1
def insert_node(node: MyNode | None, data: Any) -> MyNode | None:‖if node is None:‖1
if node is None:‖return MyNode(data)‖1
return MyNode(data)‖if data < node.get_data():‖1
if data < node.get_data():‖node.set_left(insert_node(node.get_left(), data))‖1
node.set_left(insert_node(node.get_left(), data))‖if (‖1
if (‖get_height(node.get_left()) - get_height(node.get_right()) == 2‖1
get_height(node.get_left()) - get_height(node.get_right()) == 2‖):  # an unbalance detected‖1
):  # an unbalance detected‖left_child = node.get_left()‖1
assert left_child is not None‖if (‖1
if (‖data < left_child.get_data()‖1
data < left_child.get_data()‖):  # new node is the left child of the left child‖1
):  # new node is the left child of the left child‖node = right_rotation(node)‖1
node = right_rotation(node)‖else:‖1
else:‖node = lr_rotation(node)‖1
node = lr_rotation(node)‖else:‖1
else:‖node.set_right(insert_node(node.get_right(), data))‖1
node.set_right(insert_node(node.get_right(), data))‖if get_height(node.get_right()) - get_height(node.get_left()) == 2:‖1
if get_height(node.get_right()) - get_height(node.get_left()) == 2:‖right_child = node.get_right()‖1
assert right_child is not None‖if data < right_child.get_data():‖1
if data < right_child.get_data():‖node = rl_rotation(node)‖1
node = rl_rotation(node)‖else:‖1
else:‖node = left_rotation(node)‖1
node = left_rotation(node)‖h1 = my_max(get_height(node.get_right()), get_height(node.get_left())) + 1‖1
node.set_height(h1)‖return node‖1
def get_right_most(root: MyNode) -> Any:‖while True:‖1
while True:‖right_child = root.get_right()‖1
right_child = root.get_right()‖if right_child is None:‖1
if right_child is None:‖break‖1
break‖root = right_child‖1
root = right_child‖return root.get_data()‖1
def get_left_most(root: MyNode) -> Any:‖while True:‖1
while True:‖left_child = root.get_left()‖1
left_child = root.get_left()‖if left_child is None:‖1
if left_child is None:‖break‖1
break‖root = left_child‖1
root = left_child‖return root.get_data()‖1
def del_node(root: MyNode, data: Any) -> MyNode | None:‖left_child = root.get_left()‖1
left_child = root.get_left()‖right_child = root.get_right()‖1
right_child = root.get_right()‖if root.get_data() == data:‖1
if root.get_data() == data:‖if left_child is not None and right_child is not None:‖1
if left_child is not None and right_child is not None:‖temp_data = get_left_most(right_child)‖1
temp_data = get_left_most(right_child)‖root.set_data(temp_data)‖1
root.set_data(temp_data)‖root.set_right(del_node(right_child, temp_data))‖1
root.set_right(del_node(right_child, temp_data))‖elif left_child is not None:‖1
elif left_child is not None:‖root = left_child‖1
root = left_child‖elif right_child is not None:‖1
elif right_child is not None:‖root = right_child‖1
root = right_child‖else:‖1
else:‖return None‖4
return None‖elif root.get_data() > data:‖1
elif root.get_data() > data:‖if left_child is None:‖1
if left_child is None:‖"print(""No such data"")"‖1
"print(""No such data"")"‖return root‖1
return root‖else:‖2
else:‖root.set_left(del_node(left_child, data))‖1
elif right_child is None:‖return root‖1
else:‖root.set_right(del_node(right_child, data))‖1
if get_height(right_child) - get_height(left_child) == 2:‖assert right_child is not None‖1
assert right_child is not None‖if get_height(right_child.get_right()) > get_height(right_child.get_left()):‖1
if get_height(right_child.get_right()) > get_height(right_child.get_left()):‖root = left_rotation(root)‖1
root = left_rotation(root)‖else:‖1
else:‖root = rl_rotation(root)‖1
root = rl_rotation(root)‖elif get_height(right_child) - get_height(left_child) == -2:‖1
elif get_height(right_child) - get_height(left_child) == -2:‖assert left_child is not None‖1
assert left_child is not None‖if get_height(left_child.get_left()) > get_height(left_child.get_right()):‖1
if get_height(left_child.get_left()) > get_height(left_child.get_right()):‖root = right_rotation(root)‖1
root = right_rotation(root)‖else:‖1
else:‖root = lr_rotation(root)‖1
root = lr_rotation(root)‖height = my_max(get_height(root.get_right()), get_height(root.get_left())) + 1‖1
height = my_max(get_height(root.get_right()), get_height(root.get_left())) + 1‖root.set_height(height)‖1
root.set_height(height)‖return root‖1
def __init__(self) -> None:‖self.root: MyNode | None = None‖1
def get_height(self) -> int:‖return get_height(self.root)‖1
def insert(self, data: Any) -> None:‖"print(""insert:"" + str(data))"‖1
"print(""insert:"" + str(data))"‖self.root = insert_node(self.root, data)‖1
def del_node(self, data: Any) -> None:‖"print(""delete:"" + str(data))"‖1
"print(""delete:"" + str(data))"‖if self.root is None:‖1
if self.root is None:‖"print(""Tree is empty!"")"‖1
"print(""Tree is empty!"")"‖return‖1
return‖self.root = del_node(self.root, data)‖1
def __str__(‖self,‖1
self,‖) -> str:‖1
) -> str:‖"output = """""‖1
"output = """""‖q = MyQueue()‖1
q = MyQueue()‖q.push(self.root)‖1
q.push(self.root)‖layer = self.get_height()‖1
layer = self.get_height()‖if layer == 0:‖1
if layer == 0:‖return output‖1
return output‖cnt = 0‖1
cnt = 0‖while not q.is_empty():‖1
while not q.is_empty():‖node = q.pop()‖1
node = q.pop()‖"space = "" "" * int(math.pow(2, layer - 1))"‖1
"space = "" "" * int(math.pow(2, layer - 1))"‖output += space‖1
output += space‖if node is None:‖1
if node is None:‖"output += ""*"""‖1
"output += ""*"""‖q.push(None)‖1
q.push(None)‖q.push(None)‖1
q.push(None)‖else:‖1
else:‖output += str(node.get_data())‖1
output += str(node.get_data())‖q.push(node.get_left())‖1
q.push(node.get_left())‖q.push(node.get_right())‖1
q.push(node.get_right())‖output += space‖1
output += space‖cnt = cnt + 1‖1
cnt = cnt + 1‖for i in range(100):‖1
for i in range(100):‖if cnt == math.pow(2, i) - 1:‖1
if cnt == math.pow(2, i) - 1:‖layer = layer - 1‖1
layer = layer - 1‖if layer == 0:‖1
if layer == 0:‖"output += ""\n*************************************"""‖1
"output += ""\n*************************************"""‖return output‖2
return output‖"output += ""\n"""‖1
"output += ""\n"""‖break‖1
break‖"output += ""\n*************************************"""‖1
def _test() -> None:‖import doctest‖1
"if __name__ == ""__main__"":"‖_test()‖1
_test()‖t = AVLtree()‖1
t = AVLtree()‖lst = list(range(10))‖1
lst = list(range(10))‖random.shuffle(lst)‖1
random.shuffle(lst)‖for i in lst:‖2
for i in lst:‖t.insert(i)‖1
t.insert(i)‖print(str(t))‖1
print(str(t))‖random.shuffle(lst)‖1
for i in lst:‖t.del_node(i)‖1
t.del_node(i)‖print(str(t))‖1
return [‖list(x)‖1
list(x)‖for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})‖1
for x in sorted({abc for abc in combinations(sorted(nums), 3) if not sum(abc)})‖]‖1
combination_array = sorted([item, other_item, required_value])‖if combination_array not in output_arr:‖1
if combination_array not in output_arr:‖output_arr.append(combination_array)‖1
total_sum = 0‖for ele in arr:‖1
for ele in arr:‖total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele‖1
total_sum += product_sum(ele, depth + 1) if isinstance(ele, list) else ele‖return total_sum * depth‖1
return all(nums[i] <= nums[i + 1] for i in range(len(nums) - 1)) or all(‖nums[i] >= nums[i + 1] for i in range(len(nums) - 1)‖1
nums[i] >= nums[i + 1] for i in range(len(nums) - 1)‖)‖1
print(is_monotonic([1, 2, 2, 3]))‖print(is_monotonic([6, 5, 4, 4]))‖1
print(is_monotonic([6, 5, 4, 4]))‖print(is_monotonic([1, 3, 2]))‖1
pivot = arr[high]‖i = low - 1‖1
i = low - 1‖for j in range(low, high):‖1
for j in range(low, high):‖if arr[j] >= pivot:‖1
if arr[j] >= pivot:‖i += 1‖1
i += 1‖arr[i], arr[j] = arr[j], arr[i]‖1
arr[i], arr[j] = arr[j], arr[i]‖arr[i + 1], arr[high] = arr[high], arr[i + 1]‖1
arr[i + 1], arr[high] = arr[high], arr[i + 1]‖return i + 1‖1
if not arr:‖return -1‖1
return -1‖if not isinstance(position, int):‖1
if not isinstance(position, int):‖"raise ValueError(""The position should be an integer"")"‖1
"raise ValueError(""The position should be an integer"")"‖if not 1 <= position <= len(arr):‖1
if not 1 <= position <= len(arr):‖"raise ValueError(""Invalid value of 'position'"")"‖1
"raise ValueError(""Invalid value of 'position'"")"‖low, high = 0, len(arr) - 1‖1
low, high = 0, len(arr) - 1‖while low <= high:‖1
while low <= high:‖if low > len(arr) - 1 or high < 0:‖1
if low > len(arr) - 1 or high < 0:‖return -1‖1
return -1‖pivot_index = partition(arr, low, high)‖1
pivot_index = partition(arr, low, high)‖if pivot_index == position - 1:‖1
if pivot_index == position - 1:‖return arr[pivot_index]‖1
return arr[pivot_index]‖elif pivot_index > position - 1:‖1
elif pivot_index > position - 1:‖high = pivot_index - 1‖1
high = pivot_index - 1‖else:‖1
else:‖low = pivot_index + 1‖1
low = pivot_index + 1‖return -1‖1
result: list[list[int]] = []‖if len(nums) == 0:‖1
if len(nums) == 0:‖return [[]]‖1
return [[]]‖for _ in range(len(nums)):‖1
for _ in range(len(nums)):‖n = nums.pop(0)‖1
n = nums.pop(0)‖permutations = permute_recursive(nums.copy())‖1
permutations = permute_recursive(nums.copy())‖for perm in permutations:‖1
for perm in permutations:‖perm.append(n)‖1
perm.append(n)‖result.extend(permutations)‖1
result.extend(permutations)‖nums.append(n)‖1
nums.append(n)‖return result‖1
def backtrack(start: int) -> None:‖if start == len(nums) - 1:‖1
if start == len(nums) - 1:‖output.append(nums[:])‖1
output.append(nums[:])‖else:‖1
else:‖for i in range(start, len(nums)):‖1
for i in range(start, len(nums)):‖nums[start], nums[i] = nums[i], nums[start]‖1
nums[start], nums[i] = nums[i], nums[start]‖backtrack(start + 1)‖1
backtrack(start + 1)‖nums[start], nums[i] = nums[i], nums[start]‖1
output: list[list[int]] = []‖backtrack(0)‖1
backtrack(0)‖return output‖1
result = permute_backtrack([1, 2, 3])‖print(result)‖1
print(result)‖doctest.testmod()‖1
class PrefixSum:‖def __init__(self, array: list[int]) -> None:‖1
def __init__(self, array: list[int]) -> None:‖len_array = len(array)‖1
len_array = len(array)‖self.prefix_sum = [0] * len_array‖1
if len_array > 0:‖self.prefix_sum[0] = array[0]‖1
for i in range(1, len_array):‖self.prefix_sum[i] = self.prefix_sum[i - 1] + array[i]‖1
if start == 0:‖return self.prefix_sum[end]‖1
sums = {0}‖for sum_item in self.prefix_sum:‖1
for sum_item in self.prefix_sum:‖if sum_item - target_sum in sums:‖1
if sum_item - target_sum in sums:‖return True‖1
from collections.abc import Iterator‖from dataclasses import dataclass‖13
@dataclass‖class Index2DArrayIterator:‖1
class Index2DArrayIterator:‖matrix: list[list[int]]‖1
for row in self.matrix:‖yield from row‖1
rows = len(array)‖cols = len(array[0])‖1
if rows == 0 or cols == 0:‖"raise ValueError(""no items in array"")"‖1
if index < 0 or index >= rows * cols:‖"raise ValueError(""index out of range"")"‖1
class Node:‖data: int‖8
data: int‖left: Node | None = None‖5
if self.left:‖yield from self.left‖6
yield from self.left‖yield self.data‖3
yield self.data‖if self.right:‖3
if self.right:‖yield from self.right‖6
@property‖def is_sum_node(self) -> bool:‖1
if not self.left and not self.right:‖return True‖1
return True‖left_sum = sum(self.left) if self.left else 0‖1
left_sum = sum(self.left) if self.left else 0‖right_sum = sum(self.right) if self.right else 0‖1
right_sum = sum(self.right) if self.right else 0‖return all(‖1
return all(‖(‖1
(‖self.data == left_sum + right_sum,‖1
self.data == left_sum + right_sum,‖self.left.is_sum_node if self.left else True,‖1
self.left.is_sum_node if self.left else True,‖self.right.is_sum_node if self.right else True,‖1
self.right.is_sum_node if self.right else True,‖)‖1
@dataclass‖class BinaryTree:‖2
class BinaryTree:‖root: Node‖2
@property‖def is_sum_tree(self) -> bool:‖1
@classmethod‖def build_a_tree(cls) -> BinaryTree:‖1
tree = BinaryTree(Node(11))‖root = tree.root‖1
root = tree.root‖root.left = Node(2)‖1
root.left = Node(2)‖root.right = Node(29)‖1
root.right = Node(29)‖root.left.left = Node(1)‖1
root.left.left = Node(1)‖root.left.right = Node(7)‖1
root.left.right = Node(7)‖root.right.left = Node(15)‖1
root.right.left = Node(15)‖root.right.right = Node(40)‖1
root.right.right = Node(40)‖root.right.right.left = Node(35)‖1
root.right.right.left = Node(35)‖return tree‖1
@classmethod‖def build_a_sum_tree(cls) -> BinaryTree:‖1
tree = BinaryTree(Node(26))‖root = tree.root‖1
root = tree.root‖root.left = Node(10)‖1
root.left = Node(10)‖root.right = Node(3)‖1
root.right = Node(3)‖root.left.left = Node(4)‖2
root.left.left = Node(4)‖root.left.right = Node(6)‖1
root.left.right = Node(6)‖root.right.right = Node(3)‖1
root.right.right = Node(3)‖return tree‖1
testmod()‖tree = BinaryTree.build_a_tree()‖1
tree = BinaryTree.build_a_tree()‖"print(f""{tree} has {len(tree)} nodes and {tree.is_sum_tree = }."")"‖1
"print(f""{tree} has {len(tree)} nodes and {tree.is_sum_tree = }."")"‖tree = BinaryTree.build_a_sum_tree()‖1
tree = BinaryTree.build_a_sum_tree()‖"print(f""{tree} has {len(tree)} nodes and {tree.is_sum_tree = }."")"‖1
if not number_list:‖"raise ValueError(""empty number list not allowed"")"‖1
row = int(log2(length)) + 1‖sparse_table = [[0 for i in range(length)] for j in range(row)]‖1
for i, value in enumerate(number_list):‖sparse_table[0][i] = value‖1
sparse_table[0][i] = value‖j = 1‖1
while (1 << j) <= length:‖i = 0‖1
sparse_table[j][i] = min(‖sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]‖1
sparse_table[j - 1][i + (1 << (j - 1))], sparse_table[j - 1][i]‖)‖1
)‖i += 1‖1
i += 1‖j += 1‖1
j += 1‖return sparse_table‖1
if left_bound < 0 or right_bound >= len(sparse_table[0]):‖"raise IndexError(""list index out of range"")"‖1
testmod()‖"print(f""{query(build_sparse_table([3, 1, 9]), 2, 2) = }"")"‖1
def __iter__(self) -> Iterator[int]:‖if self.left:‖4
def __len__(self) -> int:‖return sum(1 for _ in self)‖8
def is_full(self) -> bool:‖if not self or (not self.left and not self.right):‖1
if not self or (not self.left and not self.right):‖return True‖1
return True‖if self.left and self.right:‖1
if self.left and self.right:‖return self.left.is_full() and self.right.is_full()‖1
return self.left.is_full() and self.right.is_full()‖return False‖1
def __iter__(self) -> Iterator[int]:‖return iter(self.root)‖1
def __len__(self) -> int:‖return len(self.root)‖1
@classmethod‖def small_tree(cls) -> BinaryTree:‖1
binary_tree = BinaryTree(Node(2))‖binary_tree.root.left = Node(1)‖1
binary_tree.root.left = Node(1)‖binary_tree.root.right = Node(3)‖1
binary_tree.root.right = Node(3)‖return binary_tree‖1
@classmethod‖def medium_tree(cls) -> BinaryTree:‖1
binary_tree = BinaryTree(Node(4))‖binary_tree.root.left = two = Node(2)‖1
binary_tree.root.left = two = Node(2)‖two.left = Node(1)‖1
two.left = Node(1)‖two.right = Node(3)‖1
two.right = Node(3)‖binary_tree.root.right = five = Node(5)‖1
binary_tree.root.right = five = Node(5)‖five.right = six = Node(6)‖1
five.right = six = Node(6)‖six.right = Node(7)‖1
six.right = Node(7)‖return binary_tree‖1
def _depth(self, node: Node | None) -> int:‖if not node:‖1
if not node:‖return 0‖1
return 0‖return 1 + max(self._depth(node.left), self._depth(node.right))‖1
def __init__(self, value: int) -> None:‖self.value = value‖2
self.value = value‖self.left: Node | None = None‖3
self.left: Node | None = None‖self.right: Node | None = None‖6
def __init__(self, tree: Node) -> None:‖self.tree = tree‖1
def depth_first_search(self, node: Node | None) -> int:‖if node is None:‖1
return 0‖return node.value + (‖1
return node.value + (‖self.depth_first_search(node.left) + self.depth_first_search(node.right)‖1
self.depth_first_search(node.left) + self.depth_first_search(node.right)‖)‖1
def __iter__(self) -> Iterator[int]:‖yield self.depth_first_search(self.tree)‖1
from dataclasses import dataclass‖from typing import NamedTuple‖1
@dataclass‖class TreeNode:‖5
class TreeNode:‖data: int‖1
data: int‖left: TreeNode | None = None‖1
left: TreeNode | None = None‖right: TreeNode | None = None‖4
class CoinsDistribResult(NamedTuple):‖moves: int‖1
moves: int‖excess: int‖1
if root is None:‖return 0‖1
if count_nodes(root) != count_coins(root):‖"raise ValueError(""The nodes number should be same as the number of coins"")"‖1
if node is None:‖return CoinsDistribResult(0, 1)‖1
left_distrib_moves, left_distrib_excess = get_distrib(node.left)‖right_distrib_moves, right_distrib_excess = get_distrib(node.right)‖1
coins_to_left = 1 - left_distrib_excess‖coins_to_right = 1 - right_distrib_excess‖1
result_moves = (‖left_distrib_moves‖1
left_distrib_moves‖+ right_distrib_moves‖1
+ right_distrib_moves‖+ abs(coins_to_left)‖1
+ abs(coins_to_left)‖+ abs(coins_to_right)‖1
+ abs(coins_to_right)‖)‖1
)‖result_excess = node.data - coins_to_left - coins_to_right‖1
from collections import deque‖from collections.abc import Generator‖1
from collections.abc import Generator‖from dataclasses import dataclass‖1
tree = Node(1)‖tree.left = Node(2)‖3
tree.left = Node(2)‖tree.right = Node(3)‖3
tree.right = Node(3)‖tree.left.left = Node(4)‖3
tree.left.left = Node(4)‖tree.left.right = Node(5)‖3
tree.left.right = Node(5)‖return tree‖1
if not root:‖return‖10
return‖yield root.data‖1
yield root.data‖yield from preorder(root.left)‖1
yield from preorder(root.left)‖yield from preorder(root.right)‖1
return‖yield from postorder(root.left)‖1
yield from postorder(root.left)‖yield from postorder(root.right)‖1
yield from postorder(root.right)‖yield root.data‖1
return‖yield from inorder(root.left)‖1
yield from inorder(root.left)‖yield root.data‖1
yield root.data‖yield from inorder(root.right)‖1
return‖yield from reverse_inorder(root.right)‖1
yield from reverse_inorder(root.right)‖yield root.data‖1
yield root.data‖yield from reverse_inorder(root.left)‖1
if root is None:‖return‖2
while process_queue:‖node = process_queue.popleft()‖1
node = process_queue.popleft()‖yield node.data‖1
if node.left:‖process_queue.append(node.left)‖1
process_queue.append(node.left)‖if node.right:‖1
if node.right:‖process_queue.append(node.right)‖1
def populate_output(root: Node | None, level: int) -> Generator[int]:‖if not root:‖2
return‖if level == 1:‖2
if level == 1:‖yield root.data‖2
yield root.data‖elif level > 1:‖2
elif level > 1:‖yield from populate_output(root.left, level - 1)‖1
yield from populate_output(root.left, level - 1)‖yield from populate_output(root.right, level - 1)‖1
elif level > 1:‖yield from populate_output(root.right, level - 1)‖1
yield from populate_output(root.right, level - 1)‖yield from populate_output(root.left, level - 1)‖1
flag = 0‖height_tree = height(root)‖1
for h in range(1, height_tree + 1):‖if not flag:‖1
if not flag:‖yield from get_nodes_from_left_to_right(root, h)‖1
yield from get_nodes_from_left_to_right(root, h)‖flag = 1‖1
flag = 1‖else:‖1
else:‖yield from get_nodes_from_right_to_left(root, h)‖1
yield from get_nodes_from_right_to_left(root, h)‖flag = 0‖1
"print(f""In-order Traversal: {list(inorder(root))}"")"‖"print(f""Reverse In-order Traversal: {list(reverse_inorder(root))}"")"‖1
"print(f""Reverse In-order Traversal: {list(reverse_inorder(root))}"")"‖"print(f""Pre-order Traversal: {list(preorder(root))}"")"‖1
"print(f""Pre-order Traversal: {list(preorder(root))}"")"‖"print(f""Post-order Traversal: {list(postorder(root))}"", ""\n"")"‖1
"print(""Complete Level Order Traversal: "")"‖"print(f""{list(level_order(root))} \n"")"‖1
for level in range(1, height(root) + 1):‖"print(f""Level {level}:"", list(get_nodes_from_left_to_right(root, level=level)))"‖1
"print(""\nZigZag order Traversal: "")"‖"print(f""{list(zigzag(root))}"")"‖1
import random‖import time‖1
"digits = ""123456789"""‖"rows = ""ABCDEFGHI"""‖1
"rows = ""ABCDEFGHI"""‖cols = digits‖1
cols = digits‖squares = cross(rows, cols)‖1
squares = cross(rows, cols)‖unitlist = (‖1
unitlist = (‖[cross(rows, c) for c in cols]‖1
[cross(rows, c) for c in cols]‖+ [cross(r, cols) for r in rows]‖1
+ [cross(r, cols) for r in rows]‖"+ [cross(rs, cs) for rs in (""ABC"", ""DEF"", ""GHI"") for cs in (""123"", ""456"", ""789"")]"‖1
"+ [cross(rs, cs) for rs in (""ABC"", ""DEF"", ""GHI"") for cs in (""123"", ""456"", ""789"")]"‖)‖1
)‖units = {s: [u for u in unitlist if s in u] for s in squares}‖1
units = {s: [u for u in unitlist if s in u] for s in squares}‖peers = {s: {x for u in units[s] for x in u} - {s} for s in squares}‖1
def test():‖"""A set of unit tests."""‖1
"""A set of unit tests."""‖assert len(squares) == 81‖1
assert len(squares) == 81‖assert len(unitlist) == 27‖1
assert len(unitlist) == 27‖assert all(len(units[s]) == 3 for s in squares)‖1
assert all(len(units[s]) == 3 for s in squares)‖assert all(len(peers[s]) == 20 for s in squares)‖1
assert all(len(peers[s]) == 20 for s in squares)‖"assert units[""C2""] == ["‖1
"assert units[""C2""] == ["‖"[""A2"", ""B2"", ""C2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2""],"‖1
"[""A2"", ""B2"", ""C2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2""],"‖"[""C1"", ""C2"", ""C3"", ""C4"", ""C5"", ""C6"", ""C7"", ""C8"", ""C9""],"‖1
"[""C1"", ""C2"", ""C3"", ""C4"", ""C5"", ""C6"", ""C7"", ""C8"", ""C9""],"‖"[""A1"", ""A2"", ""A3"", ""B1"", ""B2"", ""B3"", ""C1"", ""C2"", ""C3""],"‖1
"[""A1"", ""A2"", ""A3"", ""B1"", ""B2"", ""B3"", ""C1"", ""C2"", ""C3""],"‖]‖1
"assert peers[""C2""] == {"‖"""A2"", ""B2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2"", ""C1"", ""C3"","‖1
"""A2"", ""B2"", ""D2"", ""E2"", ""F2"", ""G2"", ""H2"", ""I2"", ""C1"", ""C3"","‖"""C4"", ""C5"", ""C6"", ""C7"", ""C8"", ""C9"", ""A1"", ""A3"", ""B1"", ""B3"""‖1
"""C4"", ""C5"", ""C6"", ""C7"", ""C8"", ""C9"", ""A1"", ""A3"", ""B1"", ""B3"""‖}‖1
values = {s: digits for s in squares}‖for s, d in grid_values(grid).items():‖1
for s, d in grid_values(grid).items():‖if d in digits and not assign(values, s, d):‖1
if d in digits and not assign(values, s, d):‖return False‖1
return False‖return values‖2
"chars = [c for c in grid if c in digits or c in ""0.""]"‖assert len(chars) == 81‖1
assert len(chars) == 81‖return dict(zip(squares, chars))‖1
"other_values = values[s].replace(d, """")"‖if all(eliminate(values, s, d2) for d2 in other_values):‖1
if all(eliminate(values, s, d2) for d2 in other_values):‖return values‖1
return values‖else:‖1
if d not in values[s]:‖return values‖1
return values‖"values[s] = values[s].replace(d, """")"‖1
if len(values[s]) == 0:‖return False‖1
return False‖elif len(values[s]) == 1:‖1
elif len(values[s]) == 1:‖d2 = values[s]‖1
d2 = values[s]‖if not all(eliminate(values, s2, d2) for s2 in peers[s]):‖1
if not all(eliminate(values, s2, d2) for s2 in peers[s]):‖return False‖1
for u in units[s]:‖dplaces = [s for s in u if d in values[s]]‖1
dplaces = [s for s in u if d in values[s]]‖if len(dplaces) == 0:‖1
if len(dplaces) == 0:‖return False‖1
elif len(dplaces) == 1 and not assign(values, dplaces[0], d):‖return False‖1
width = 1 + max(len(values[s]) for s in squares)‖"line = ""+"".join([""-"" * (width * 3)] * 3)"‖1
"line = ""+"".join([""-"" * (width * 3)] * 3)"‖for r in rows:‖1
for r in rows:‖print(‖1
print(‖""""".join("‖1
""""".join("‖"values[r + c].center(width) + (""|"" if c in ""36"" else """") for c in cols"‖1
"values[r + c].center(width) + (""|"" if c in ""36"" else """") for c in cols"‖)‖1
)‖"if r in ""CF"":"‖1
"if r in ""CF"":"‖print(line)‖1
print(line)‖print()‖1
def solve(grid):‖return search(parse_grid(grid))‖1
for e in seq:‖if e:‖1
if e:‖return e‖1
return e‖return False‖1
if values is False:‖return False‖1
return False‖if all(len(values[s]) == 1 for s in squares):‖1
if all(len(values[s]) == 1 for s in squares):‖return values‖1
n, s = min((len(values[s]), s) for s in squares if len(values[s]) > 1)‖return some(search(assign(values.copy(), s, d)) for d in values[s])‖1
def time_solve(grid):‖start = time.monotonic()‖1
start = time.monotonic()‖values = solve(grid)‖1
values = solve(grid)‖t = time.monotonic() - start‖1
if showif is not None and t > showif:‖display(grid_values(grid))‖1
display(grid_values(grid))‖if values:‖1
if values:‖display(values)‖1
display(values)‖"print(f""({t:.5f} seconds)\n"")"‖1
"print(f""({t:.5f} seconds)\n"")"‖return (t, solved(values))‖1
times, results = zip(*[time_solve(grid) for grid in grids])‖if (n := len(grids)) > 1:‖1
if (n := len(grids)) > 1:‖print(‖1
print(‖"""Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs)."""‖1
"""Solved %d of %d %s puzzles (avg %.2f secs (%d Hz), max %.2f secs)."""‖% (sum(results), n, name, sum(times) / n, n / sum(times), max(times))‖1
% (sum(results), n, name, sum(times) / n, n / sum(times), max(times))‖)‖1
def unitsolved(unit):‖return {values[s] for s in unit} == set(digits)‖1
with open(filename) as file:‖return file.read().strip().split(sep)‖1
values = {s: digits for s in squares}‖for s in shuffled(squares):‖1
for s in shuffled(squares):‖if not assign(values, s, random.choice(values[s])):‖1
if not assign(values, s, random.choice(values[s])):‖break‖1
break‖ds = [values[s] for s in squares if len(values[s]) == 1]‖1
ds = [values[s] for s in squares if len(values[s]) == 1]‖if len(ds) >= assignments and len(set(ds)) >= 8:‖1
if len(ds) >= assignments and len(set(ds)) >= 8:‖"return """".join(values[s] if len(values[s]) == 1 else ""."" for s in squares)"‖1
"return """".join(values[s] if len(values[s]) == 1 else ""."" for s in squares)"‖return random_puzzle(assignments)  ## Give up and make a new puzzle‖1
seq = list(seq)‖random.shuffle(seq)‖1
random.shuffle(seq)‖return seq‖1
grid1 = (‖"""003020600900305001001806400008102900700000008006708200002609500800203009005010300"""‖1
"""003020600900305001001806400008102900700000008006708200002609500800203009005010300"""‖)‖1
)‖grid2 = (‖1
grid2 = (‖"""4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......"""‖1
"""4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......"""‖)‖1
)‖hard1 = (‖1
hard1 = (‖""".....6....59.....82....8....45........3........6..3.54...325..6.................."""‖1
""".....6....59.....82....8....45........3........6..3.54...325..6.................."""‖)‖1
"if __name__ == ""__main__"":"‖test()‖1
"solve_all([random_puzzle() for _ in range(99)], ""random"", 100.0)"‖for puzzle in (grid1, grid2):‖1
for puzzle in (grid1, grid2):‖display(parse_grid(puzzle))‖1
display(parse_grid(puzzle))‖start = time.monotonic()‖1
start = time.monotonic()‖solve(puzzle)‖1
solve(puzzle)‖t = time.monotonic() - start‖1
t = time.monotonic() - start‖"print(f""Solved: {t:.5f} sec"")"‖1
if arr is None and size is not None:‖self.size = size‖1
self.size = size‖self.tree = [0] * size‖1
self.tree = [0] * size‖elif arr is not None:‖1
elif arr is not None:‖self.init(arr)‖1
self.init(arr)‖else:‖1
else:‖"raise ValueError(""Either arr or size must be specified"")"‖1
self.size = len(arr)‖self.tree = deepcopy(arr)‖1
self.tree = deepcopy(arr)‖for i in range(1, self.size):‖1
for i in range(1, self.size):‖j = self.next_(i)‖1
j = self.next_(i)‖if j < self.size:‖2
if j < self.size:‖self.tree[j] += self.tree[i]‖1
arr = self.tree[:]‖for i in range(self.size - 1, 0, -1):‖1
for i in range(self.size - 1, 0, -1):‖j = self.next_(i)‖1
if j < self.size:‖arr[j] -= arr[i]‖1
arr[j] -= arr[i]‖return arr‖1
@staticmethod‖def next_(index: int) -> int:‖1
def next_(index: int) -> int:‖return index + (index & (-index))‖1
@staticmethod‖def prev(index: int) -> int:‖1
def prev(index: int) -> int:‖return index - (index & (-index))‖1
if index == 0:‖self.tree[0] += value‖1
self.tree[0] += value‖return‖1
return‖while index < self.size:‖1
while index < self.size:‖self.tree[index] += value‖1
self.tree[index] += value‖index = self.next_(index)‖1
if right == 0:‖return 0‖1
return 0‖result = self.tree[0]‖1
result = self.tree[0]‖right -= 1‖1
right -= 1‖while right > 0:‖1
while right > 0:‖result += self.tree[right]‖1
result += self.tree[right]‖right = self.prev(right)‖1
right = self.prev(right)‖return result‖1
value -= self.tree[0]‖if value < 0:‖1
if value < 0:‖return -1‖1
j = 1‖while j * 2 < self.size:‖1
while j * 2 < self.size:‖j *= 2‖1
while j > 0:‖if i + j < self.size and self.tree[i + j] <= value:‖1
if i + j < self.size and self.tree[i + j] <= value:‖value -= self.tree[i + j]‖1
value -= self.tree[i + j]‖i += j‖1
i += j‖j //= 2‖1
j //= 2‖return i‖1
def __init__(self, data: int) -> None:‖self.data = data‖4
self.data = data‖self.left_child: BinaryTreeNode | None = None‖1
self.left_child: BinaryTreeNode | None = None‖self.right_child: BinaryTreeNode | None = None‖1
if node is None:‖node = BinaryTreeNode(new_value)‖1
node = BinaryTreeNode(new_value)‖return node‖1
if new_value < node.data:‖node.left_child = insert(node.left_child, new_value)‖1
node.left_child = insert(node.left_child, new_value)‖else:‖1
node.right_child = insert(node.right_child, new_value)‖return node‖1
if node:‖inorder_array = inorder(node.left_child)‖1
inorder_array = inorder(node.left_child)‖inorder_array = [*inorder_array, node.data]‖1
inorder_array = [*inorder_array, node.data]‖inorder_array = inorder_array + inorder(node.right_child)‖1
inorder_array = inorder_array + inorder(node.right_child)‖else:‖1
else:‖inorder_array = []‖1
inorder_array = []‖return inorder_array‖1
def make_tree() -> BinaryTreeNode | None:‖root = insert(None, 15)‖1
root = insert(None, 15)‖insert(root, 10)‖1
insert(root, 10)‖insert(root, 25)‖1
insert(root, 25)‖insert(root, 6)‖1
insert(root, 6)‖insert(root, 14)‖1
insert(root, 14)‖insert(root, 20)‖1
insert(root, 20)‖insert(root, 60)‖1
insert(root, 60)‖return root‖1
root = make_tree()‖"print(""Printing values of binary search tree in Inorder Traversal."")"‖1
"print(""Printing values of binary search tree in Inorder Traversal."")"‖inorder(root)‖1
def __init__(self) -> None:‖self.paths = 0‖1
def depth_first_search(self, node: Node | None, path_sum: int) -> None:‖if node is None:‖1
if node is None:‖return‖2
if path_sum == self.target:‖self.paths += 1‖1
if node.left:‖self.depth_first_search(node.left, path_sum + node.left.value)‖1
self.depth_first_search(node.left, path_sum + node.left.value)‖if node.right:‖1
if node.right:‖self.depth_first_search(node.right, path_sum + node.right.value)‖1
def path_sum(self, node: Node | None, target: int | None = None) -> int:‖if node is None:‖1
return 0‖if target is not None:‖1
if target is not None:‖self.target = target‖1
self.depth_first_search(node, node.value)‖self.path_sum(node.left)‖1
self.path_sum(node.left)‖self.path_sum(node.right)‖1
a ^= b‖b ^= a‖1
b ^= a‖a ^= b‖1
a ^= b‖return a, b‖1
j = 1‖while (1 << j) < max_node:‖1
while (1 << j) < max_node:‖for i in range(1, max_node + 1):‖1
for i in range(1, max_node + 1):‖parent[j][i] = parent[j - 1][parent[j - 1][i]]‖1
parent[j][i] = parent[j - 1][parent[j - 1][i]]‖j += 1‖1
j += 1‖return parent‖1
def lowest_common_ancestor(‖u: int, v: int, level: list[int], parent: list[list[int]]‖1
u: int, v: int, level: list[int], parent: list[list[int]]‖) -> int:‖1
if level[u] < level[v]:‖u, v = swap(u, v)‖1
for i in range(18, -1, -1):‖if level[u] - (1 << i) >= level[v]:‖1
if level[u] - (1 << i) >= level[v]:‖u = parent[i][u]‖1
if u == v:‖return u‖1
for i in range(18, -1, -1):‖if parent[i][u] not in [0, parent[i][v]]:‖1
if parent[i][u] not in [0, parent[i][v]]:‖u, v = parent[i][u], parent[i][v]‖1
def breadth_first_search(‖level: list[int],‖1
level: list[int],‖parent: list[list[int]],‖1
parent: list[list[int]],‖max_node: int,‖1
max_node: int,‖graph: dict[int, list[int]],‖1
graph: dict[int, list[int]],‖root: int = 1,‖1
root: int = 1,‖) -> tuple[list[int], list[list[int]]]:‖1
level[root] = 0‖q: Queue[int] = Queue(maxsize=max_node)‖1
q: Queue[int] = Queue(maxsize=max_node)‖q.put(root)‖1
q.put(root)‖while q.qsize() != 0:‖1
while q.qsize() != 0:‖u = q.get()‖1
u = q.get()‖for v in graph[u]:‖1
for v in graph[u]:‖if level[v] == -1:‖1
if level[v] == -1:‖level[v] = level[u] + 1‖1
level[v] = level[u] + 1‖q.put(v)‖1
q.put(v)‖parent[0][v] = u‖1
parent[0][v] = u‖return level, parent‖1
def main() -> None:‖max_node = 13‖1
level = [-1 for _ in range(max_node + 10)]‖graph: dict[int, list[int]] = {‖1
graph: dict[int, list[int]] = {‖1: [2, 3, 4],‖1
1: [2, 3, 4],‖2: [5],‖1
2: [5],‖3: [6, 7],‖1
3: [6, 7],‖4: [8],‖1
4: [8],‖5: [9, 10],‖1
5: [9, 10],‖6: [11],‖1
6: [11],‖7: [],‖1
7: [],‖8: [12, 13],‖1
8: [12, 13],‖9: [],‖1
9: [],‖10: [],‖1
10: [],‖11: [],‖1
11: [],‖12: [],‖1
12: [],‖13: [],‖1
13: [],‖}‖1
}‖level, parent = breadth_first_search(level, parent, max_node, graph, 1)‖1
level, parent = breadth_first_search(level, parent, max_node, graph, 1)‖parent = create_sparse(max_node, parent)‖1
parent = create_sparse(max_node, parent)‖"print(""LCA of node 1 and 3 is: "", lowest_common_ancestor(1, 3, level, parent))"‖1
"print(""LCA of node 1 and 3 is: "", lowest_common_ancestor(1, 3, level, parent))"‖"print(""LCA of node 5 and 6 is: "", lowest_common_ancestor(5, 6, level, parent))"‖1
"print(""LCA of node 5 and 6 is: "", lowest_common_ancestor(5, 6, level, parent))"‖"print(""LCA of node 7 and 11 is: "", lowest_common_ancestor(7, 11, level, parent))"‖1
"print(""LCA of node 7 and 11 is: "", lowest_common_ancestor(7, 11, level, parent))"‖"print(""LCA of node 6 and 7 is: "", lowest_common_ancestor(6, 7, level, parent))"‖1
"print(""LCA of node 6 and 7 is: "", lowest_common_ancestor(6, 7, level, parent))"‖"print(""LCA of node 4 and 12 is: "", lowest_common_ancestor(4, 12, level, parent))"‖1
"print(""LCA of node 4 and 12 is: "", lowest_common_ancestor(4, 12, level, parent))"‖"print(""LCA of node 8 and 8 is: "", lowest_common_ancestor(8, 8, level, parent))"‖1
left_depth = self.left.depth() if self.left else 0‖right_depth = self.right.depth() if self.right else 0‖2
right_depth = self.right.depth() if self.right else 0‖return max(left_depth, right_depth) + 1‖1
right_depth = self.right.depth() if self.right else 0‖return left_depth + right_depth + 1‖1
testmod()‖root = Node(1)‖1
root = Node(1)‖root.left = Node(2)‖3
root.left = Node(2)‖root.right = Node(3)‖1
root.left.left = Node(4)‖root.left.right = Node(5)‖1
"print(f""{root.diameter() = }"")  # 4"‖"print(f""{root.left.diameter() = }"")  # 3"‖1
"print(f""{root.left.diameter() = }"")  # 3"‖"print(f""{root.right.diameter() = }"")  # 1"‖1
self.data = data‖self.left: TreeNode | None = None‖1
self.left: TreeNode | None = None‖self.right: TreeNode | None = None‖1
root = TreeNode(1)‖root.left = TreeNode(2)‖2
root.left = TreeNode(2)‖root.right = TreeNode(5)‖1
root.right = TreeNode(5)‖root.left.left = TreeNode(3)‖1
root.left.left = TreeNode(3)‖root.left.right = TreeNode(4)‖1
root.left.right = TreeNode(4)‖root.right.right = TreeNode(6)‖1
root.right.right = TreeNode(6)‖return root‖1
root.right = root.left‖root.left = None‖1
current = root‖while current.right:‖1
while current.right:‖current = current.right‖1
current = root‖while current:‖1
while current:‖if current.right is None:‖1
if current.right is None:‖"print(current.data, end="""")"‖1
"print(current.data, end="""")"‖break‖1
break‖"print(current.data, end="" "")"‖1
"print(current.data, end="" "")"‖current = current.right‖1
"if __name__ == ""__main__"":"‖"print(""Flattened Linked List:"")"‖1
"print(""Flattened Linked List:"")"‖root = build_tree()‖1
root = build_tree()‖flatten(root)‖1
flatten(root)‖display_linked_list(root)‖1
import unittest‖from collections.abc import Iterator‖1
class Node:‖def __init__(self, label: int, parent: Node | None) -> None:‖1
def __init__(self, label: int, parent: Node | None) -> None:‖self.label = label‖1
self.label = label‖self.parent = parent‖2
self.parent = parent‖self.left: Node | None = None‖1
class BinarySearchTree:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self.root: Node | None = None‖1
def _put(self, node: Node | None, label: int, parent: Node | None = None) -> Node:‖if node is None:‖1
if node is None:‖node = Node(label, parent)‖1
node = Node(label, parent)‖elif label < node.label:‖1
elif label < node.label:‖node.left = self._put(node.left, label, node)‖1
node.left = self._put(node.left, label, node)‖elif label > node.label:‖1
elif label > node.label:‖node.right = self._put(node.right, label, node)‖1
node.right = self._put(node.right, label, node)‖else:‖1
else:‖"msg = f""Node with label {label} already exists"""‖1
"msg = f""Node with label {label} already exists"""‖raise ValueError(msg)‖1
def _search(self, node: Node | None, label: int) -> Node:‖if node is None:‖1
if node is None:‖"msg = f""Node with label {label} does not exist"""‖1
"msg = f""Node with label {label} does not exist"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖elif label < node.label:‖1
elif label < node.label:‖node = self._search(node.left, label)‖1
node = self._search(node.left, label)‖elif label > node.label:‖1
elif label > node.label:‖node = self._search(node.right, label)‖1
node = self.search(label)‖if node.right and node.left:‖1
if node.right and node.left:‖lowest_node = self._get_lowest_node(node.right)‖1
lowest_node = self._get_lowest_node(node.right)‖lowest_node.left = node.left‖1
lowest_node.left = node.left‖lowest_node.right = node.right‖1
lowest_node.right = node.right‖node.left.parent = lowest_node‖1
node.left.parent = lowest_node‖if node.right:‖1
if node.right:‖node.right.parent = lowest_node‖1
node.right.parent = lowest_node‖self._reassign_nodes(node, lowest_node)‖1
self._reassign_nodes(node, lowest_node)‖elif not node.right and node.left:‖1
elif not node.right and node.left:‖self._reassign_nodes(node, node.left)‖1
self._reassign_nodes(node, node.left)‖elif node.right and not node.left:‖1
elif node.right and not node.left:‖self._reassign_nodes(node, node.right)‖1
self._reassign_nodes(node, node.right)‖else:‖1
else:‖self._reassign_nodes(node, None)‖1
def _reassign_nodes(self, node: Node, new_children: Node | None) -> None:‖if new_children:‖1
if new_children:‖new_children.parent = node.parent‖1
if node.parent:‖if node.parent.right == node:‖1
if node.parent.right == node:‖node.parent.right = new_children‖1
def _get_lowest_node(self, node: Node) -> Node:‖if node.left:‖1
if node.left:‖lowest_node = self._get_lowest_node(node.left)‖1
lowest_node = self._get_lowest_node(node.left)‖else:‖1
else:‖lowest_node = node‖1
lowest_node = node‖self._reassign_nodes(node, node.right)‖1
try:‖self.search(label)‖1
self.search(label)‖return True‖1
return True‖except ValueError:‖1
except ValueError:‖return False‖1
if self.root is None:‖"raise ValueError(""Binary search tree is empty"")"‖2
node = self.root‖while node.right is not None:‖1
def _inorder_traversal(self, node: Node | None) -> Iterator[Node]:‖if node is not None:‖1
if node is not None:‖yield from self._inorder_traversal(node.left)‖1
yield from self._inorder_traversal(node.left)‖yield node‖1
yield node‖yield from self._inorder_traversal(node.right)‖1
def _preorder_traversal(self, node: Node | None) -> Iterator[Node]:‖if node is not None:‖1
yield node‖yield from self._preorder_traversal(node.left)‖1
yield from self._preorder_traversal(node.left)‖yield from self._preorder_traversal(node.right)‖1
class BinarySearchTreeTest(unittest.TestCase):‖@staticmethod‖1
@staticmethod‖def _get_binary_search_tree() -> BinarySearchTree:‖1
t = BinarySearchTree()‖t.put(8)‖2
t.put(8)‖t.put(3)‖2
t.put(3)‖t.put(6)‖2
t.put(6)‖t.put(1)‖2
t.put(1)‖t.put(10)‖2
t.put(10)‖t.put(14)‖2
t.put(14)‖t.put(13)‖2
t.put(13)‖t.put(4)‖2
t.put(4)‖t.put(7)‖2
t.put(7)‖t.put(5)‖2
def test_put(self) -> None:‖t = BinarySearchTree()‖1
t = BinarySearchTree()‖assert t.is_empty()‖1
assert t.root is not None‖assert t.root.parent is None‖1
assert t.root.parent is None‖assert t.root.label == 8‖1
assert t.root.right is not None‖assert t.root.right.parent == t.root‖1
assert t.root.right.parent == t.root‖assert t.root.right.label == 10‖1
assert t.root.left is not None‖assert t.root.left.parent == t.root‖1
assert t.root.left.parent == t.root‖assert t.root.left.label == 3‖1
assert t.root.left.right is not None‖assert t.root.left.right.parent == t.root.left‖1
assert t.root.left.right.parent == t.root.left‖assert t.root.left.right.label == 6‖1
assert t.root.left.left is not None‖assert t.root.left.left.parent == t.root.left‖1
assert t.root.left.left.parent == t.root.left‖assert t.root.left.left.label == 1‖1
with pytest.raises(ValueError):‖t.put(1)‖1
def test_search(self) -> None:‖t = self._get_binary_search_tree()‖1
node = t.search(6)‖assert node.label == 6‖1
node = t.search(13)‖assert node.label == 13‖1
with pytest.raises(ValueError):‖t.search(2)‖1
def test_remove(self) -> None:‖t = self._get_binary_search_tree()‖1
assert t.root is not None‖assert t.root.right is not None‖1
assert t.root.right is not None‖assert t.root.right.right is not None‖1
assert t.root.right.right is not None‖assert t.root.right.right.right is None‖1
assert t.root.right.right.right is None‖assert t.root.right.right.left is None‖1
assert t.root.left is not None‖assert t.root.left.right is not None‖1
assert t.root.left.right is not None‖assert t.root.left.right.left is not None‖2
assert t.root.left.right.left is not None‖assert t.root.left.right.right is None‖1
assert t.root.left.right.right is None‖assert t.root.left.right.left.label == 4‖1
assert t.root.left.left is not None‖assert t.root.left.right.right is not None‖1
assert t.root.left.right.right is not None‖assert t.root.left.left.label == 1‖1
assert t.root.left.left.label == 1‖assert t.root.left.right.label == 4‖1
assert t.root.left.right.label == 4‖assert t.root.left.right.right.label == 5‖1
assert t.root.left.right.right.label == 5‖assert t.root.left.right.left is None‖1
assert t.root.left.right.left is None‖assert t.root.left.left.parent == t.root.left‖1
assert t.root.left.left.parent == t.root.left‖assert t.root.left.right.parent == t.root.left‖2
assert t.root is not None‖assert t.root.left.label == 4‖1
assert t.root.left.label == 4‖assert t.root.left.right.label == 5‖1
assert t.root.left.right.label == 5‖assert t.root.left.left.label == 1‖1
assert t.root.left.left.label == 1‖assert t.root.left.parent == t.root‖2
assert t.root.left.parent == t.root‖assert t.root.left.left.parent == t.root.left‖2
assert t.root.left is not None‖assert t.root.left.left is not None‖2
assert t.root.left.left is not None‖assert t.root.left.label == 5‖1
assert t.root.left.label == 5‖assert t.root.left.right is None‖1
assert t.root.left.right is None‖assert t.root.left.left.label == 1‖1
def test_remove_2(self) -> None:‖t = self._get_binary_search_tree()‖1
assert t.root is not None‖assert t.root.left is not None‖1
assert t.root.left.left is not None‖assert t.root.left.right is not None‖1
assert t.root.left.right.left is not None‖assert t.root.left.right.right is not None‖1
assert t.root.left.right.right is not None‖assert t.root.left.label == 4‖1
assert t.root.left.label == 4‖assert t.root.left.right.label == 6‖1
assert t.root.left.right.label == 6‖assert t.root.left.left.label == 1‖1
assert t.root.left.left.label == 1‖assert t.root.left.right.right.label == 7‖1
assert t.root.left.right.right.label == 7‖assert t.root.left.right.left.label == 5‖1
assert t.root.left.right.left.label == 5‖assert t.root.left.parent == t.root‖1
assert t.root.left.parent == t.root‖assert t.root.left.right.parent == t.root.left‖1
assert t.root.left.right.parent == t.root.left‖assert t.root.left.left.parent == t.root.left‖1
assert t.root.left.left.parent == t.root.left‖assert t.root.left.right.left.parent == t.root.left.right‖1
def test_empty(self) -> None:‖t = self._get_binary_search_tree()‖1
t = self._get_binary_search_tree()‖t.empty()‖1
t.empty()‖assert t.root is None‖1
def test_is_empty(self) -> None:‖t = self._get_binary_search_tree()‖1
t = self._get_binary_search_tree()‖assert not t.is_empty()‖1
t.empty()‖assert t.is_empty()‖1
def test_exists(self) -> None:‖t = self._get_binary_search_tree()‖1
assert t.exists(6)‖assert not t.exists(-1)‖1
def test_get_max_label(self) -> None:‖t = self._get_binary_search_tree()‖1
t.empty()‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖t.get_max_label()‖1
def test_get_min_label(self) -> None:‖t = self._get_binary_search_tree()‖1
with pytest.raises(ValueError):‖t.get_min_label()‖1
def test_inorder_traversal(self) -> None:‖t = self._get_binary_search_tree()‖1
inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]‖assert inorder_traversal_nodes == [1, 3, 4, 5, 6, 7, 8, 10, 13, 14]‖1
def test_preorder_traversal(self) -> None:‖t = self._get_binary_search_tree()‖1
preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]‖assert preorder_traversal_nodes == [8, 3, 1, 6, 4, 5, 7, 10, 14, 13]‖1
"print(""Label 6 exists:"", t.exists(6))"‖"print(""Label 13 exists:"", t.exists(13))"‖1
"print(""Label 13 exists:"", t.exists(13))"‖"print(""Label -1 exists:"", t.exists(-1))"‖1
"print(""Label -1 exists:"", t.exists(-1))"‖"print(""Label 12 exists:"", t.exists(12))"‖1
inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]‖"print(""Inorder traversal:"", inorder_traversal_nodes)"‖1
preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]‖"print(""Preorder traversal:"", preorder_traversal_nodes)"‖1
"print(""Max. label:"", t.get_max_label())"‖"print(""Min. label:"", t.get_min_label())"‖2
"print(""\nDeleting elements 13, 10, 8, 3, 6, 14"")"‖print(‖1
print(‖t.remove(13)‖1
t.remove(13)‖t.remove(10)‖1
t.remove(10)‖t.remove(8)‖1
t.remove(8)‖t.remove(3)‖1
t.remove(3)‖t.remove(6)‖1
t.remove(6)‖t.remove(14)‖1
inorder_traversal_nodes = [i.label for i in t.inorder_traversal()]‖"print(""Inorder traversal after delete:"", inorder_traversal_nodes)"‖1
preorder_traversal_nodes = [i.label for i in t.preorder_traversal()]‖"print(""Preorder traversal after delete:"", preorder_traversal_nodes)"‖1
"if __name__ == ""__main__"":"‖binary_search_tree_example()‖1
class SegmentTree:‖def __init__(self, size: int) -> None:‖1
def __init__(self, size: int) -> None:‖self.size = size‖1
self.lazy = [0 for i in range(4 * size)]‖self.flag = [0 for i in range(4 * size)]‖1
def build(‖self, idx: int, left_element: int, right_element: int, a: list[int]‖1
self, idx: int, left_element: int, right_element: int, a: list[int]‖) -> None:‖1
) -> None:‖if left_element == right_element:‖1
if left_element == right_element:‖self.segment_tree[idx] = a[left_element - 1]‖1
self.segment_tree[idx] = a[left_element - 1]‖else:‖1
else:‖mid = (left_element + right_element) // 2‖1
mid = (left_element + right_element) // 2‖self.build(self.left(idx), left_element, mid, a)‖1
self.build(self.left(idx), left_element, mid, a)‖self.build(self.right(idx), mid + 1, right_element, a)‖1
self.build(self.right(idx), mid + 1, right_element, a)‖self.segment_tree[idx] = max(‖1
self.segment_tree[idx] = max(‖self.segment_tree[self.left(idx)], self.segment_tree[self.right(idx)]‖2
self.segment_tree[self.left(idx)], self.segment_tree[self.right(idx)]‖)‖2
def update(‖self, idx: int, left_element: int, right_element: int, a: int, b: int, val: int‖1
self, idx: int, left_element: int, right_element: int, a: int, b: int, val: int‖) -> bool:‖1
if self.flag[idx] is True:‖self.segment_tree[idx] = self.lazy[idx]‖2
self.segment_tree[idx] = self.lazy[idx]‖self.flag[idx] = False‖2
self.flag[idx] = False‖if left_element != right_element:‖2
if left_element != right_element:‖self.lazy[self.left(idx)] = self.lazy[idx]‖2
self.lazy[self.left(idx)] = self.lazy[idx]‖self.lazy[self.right(idx)] = self.lazy[idx]‖2
self.lazy[self.right(idx)] = self.lazy[idx]‖self.flag[self.left(idx)] = True‖2
self.flag[self.left(idx)] = True‖self.flag[self.right(idx)] = True‖3
if right_element < a or left_element > b:‖return True‖1
return True‖if left_element >= a and right_element <= b:‖1
if left_element >= a and right_element <= b:‖self.segment_tree[idx] = val‖1
self.segment_tree[idx] = val‖if left_element != right_element:‖1
if left_element != right_element:‖self.lazy[self.left(idx)] = val‖1
self.lazy[self.left(idx)] = val‖self.lazy[self.right(idx)] = val‖1
self.lazy[self.right(idx)] = val‖self.flag[self.left(idx)] = True‖1
self.flag[self.right(idx)] = True‖return True‖1
return True‖mid = (left_element + right_element) // 2‖1
mid = (left_element + right_element) // 2‖self.update(self.left(idx), left_element, mid, a, b, val)‖1
self.update(self.left(idx), left_element, mid, a, b, val)‖self.update(self.right(idx), mid + 1, right_element, a, b, val)‖1
self.update(self.right(idx), mid + 1, right_element, a, b, val)‖self.segment_tree[idx] = max(‖1
)‖return True‖1
def query(‖self, idx: int, left_element: int, right_element: int, a: int, b: int‖1
self, idx: int, left_element: int, right_element: int, a: int, b: int‖) -> int | float:‖1
self.flag[self.right(idx)] = True‖if right_element < a or left_element > b:‖1
if right_element < a or left_element > b:‖return -math.inf‖1
return -math.inf‖if left_element >= a and right_element <= b:‖1
if left_element >= a and right_element <= b:‖return self.segment_tree[idx]‖1
return self.segment_tree[idx]‖mid = (left_element + right_element) // 2‖1
mid = (left_element + right_element) // 2‖q1 = self.query(self.left(idx), left_element, mid, a, b)‖1
q1 = self.query(self.left(idx), left_element, mid, a, b)‖q2 = self.query(self.right(idx), mid + 1, right_element, a, b)‖1
q2 = self.query(self.right(idx), mid + 1, right_element, a, b)‖return max(q1, q2)‖1
def __str__(self) -> str:‖return str([self.query(1, 1, self.size, i, i) for i in range(1, self.size + 1)])‖1
"if __name__ == ""__main__"":"‖A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]‖2
A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]‖size = 15‖1
size = 15‖segt = SegmentTree(size)‖1
segt = SegmentTree(size)‖segt.build(1, 1, size, A)‖1
segt.build(1, 1, size, A)‖print(segt.query(1, 1, size, 4, 6))‖1
print(segt.query(1, 1, size, 4, 6))‖print(segt.query(1, 1, size, 7, 11))‖1
print(segt.query(1, 1, size, 7, 11))‖print(segt.query(1, 1, size, 7, 12))‖1
print(segt.query(1, 1, size, 7, 12))‖segt.update(1, 1, size, 1, 3, 111)‖1
segt.update(1, 1, size, 1, 3, 111)‖print(segt.query(1, 1, size, 1, 15))‖1
print(segt.query(1, 1, size, 1, 15))‖segt.update(1, 1, size, 7, 8, 235)‖1
segt.update(1, 1, size, 7, 8, 235)‖print(segt)‖1
from collections import defaultdict‖from dataclasses import dataclass‖1
class TreeNode:‖val: int‖1
val: int‖left: TreeNode | None = None‖1
def depth_first_search(‖root: TreeNode | None, depth: int, right_view: list[int]‖1
root: TreeNode | None, depth: int, right_view: list[int]‖) -> None:‖1
if depth == len(right_view):‖right_view.append(root.val)‖1
depth_first_search(root.right, depth + 1, right_view)‖depth_first_search(root.left, depth + 1, right_view)‖1
right_view: list = []‖if not root:‖1
if not root:‖return right_view‖1
depth_first_search(root, 0, right_view)‖return right_view‖1
def depth_first_search(‖root: TreeNode | None, depth: int, left_view: list[int]‖1
root: TreeNode | None, depth: int, left_view: list[int]‖) -> None:‖1
if depth == len(left_view):‖left_view.append(root.val)‖1
depth_first_search(root.left, depth + 1, left_view)‖depth_first_search(root.right, depth + 1, left_view)‖1
left_view: list = []‖if not root:‖1
if not root:‖return left_view‖1
depth_first_search(root, 0, left_view)‖return left_view‖1
queue = [(root, 0)]‖lookup = defaultdict(list)‖2
while queue:‖first = queue.pop(0)‖2
first = queue.pop(0)‖node, hd = first‖2
if node.left:‖queue.append((node.left, hd - 1))‖2
queue.append((node.left, hd - 1))‖if node.right:‖2
if node.right:‖queue.append((node.right, hd + 1))‖2
for pair in sorted(lookup.items(), key=lambda each: each[0]):‖top_view.append(pair[1][0])‖1
top_view: list = []‖if not root:‖1
if not root:‖return top_view‖1
breadth_first_search(root, top_view)‖return top_view‖1
node, hd = first‖lookup[hd].append(node.val)‖1
for pair in sorted(lookup.items(), key=lambda each: each[0]):‖bottom_view.append(pair[1][-1])‖1
bottom_view: list = []‖if not root:‖1
if not root:‖return bottom_view‖1
breadth_first_search(root, bottom_view)‖return bottom_view‖1
class Node:‖data: float‖1
data: float‖left: Node | None = None‖1
@property‖def is_sorted(self) -> bool:‖1
if self.left and (self.data < self.left.data or not self.left.is_sorted):‖return False‖1
return False‖return not (‖1
return not (‖self.right and (self.data > self.right.data or not self.right.is_sorted)‖1
self.right and (self.data > self.right.data or not self.right.is_sorted)‖)‖1
doctest.testmod()‖tree = Node(data=2.1, left=Node(data=2.0), right=Node(data=2.2))‖1
tree = Node(data=2.1, left=Node(data=2.0), right=Node(data=2.2))‖"print(f""Tree {list(tree)} is sorted: {tree.is_sorted = }."")"‖1
"print(f""Tree {list(tree)} is sorted: {tree.is_sorted = }."")"‖assert tree.right‖1
assert tree.right‖tree.right.data = 2.0‖1
tree.right.data = 2.0‖"print(f""Tree {list(tree)} is sorted: {tree.is_sorted = }."")"‖1
"print(f""Tree {list(tree)} is sorted: {tree.is_sorted = }."")"‖tree.right.data = 2.1‖1
tree.right.data = 2.1‖"print(f""Tree {list(tree)} is sorted: {tree.is_sorted = }."")"‖1
yield from self.left‖yield self.value‖1
yield self.value‖if self.right:‖1
self.left, self.right = self.right, self.left‖if self.left:‖1
if self.left:‖self.left.mirror()‖1
self.left.mirror()‖if self.right:‖1
if self.right:‖self.right.mirror()‖1
self.right.mirror()‖return self‖1
tree.left.right = Node(5)‖tree.right.left = Node(6)‖1
tree.right.left = Node(6)‖tree.right.right = Node(7)‖1
tree.right.right = Node(7)‖return tree‖1
tree.left.right = Node(5)‖tree.right.right = Node(6)‖1
tree.right.right = Node(6)‖tree.left.left.left = Node(7)‖1
tree.left.left.left = Node(7)‖tree.left.left.right = Node(8)‖1
tree.left.left.right = Node(8)‖tree.left.right.right = Node(9)‖1
tree.left.right.right = Node(9)‖return tree‖1
"trees = {""zero"": Node(0), ""seven"": make_tree_seven(), ""nine"": make_tree_nine()}"‖for name, tree in trees.items():‖1
for name, tree in trees.items():‖"print(f""      The {name} tree: {tuple(tree)}"")"‖1
import sys‖from dataclasses import dataclass‖1
INT_MIN = -sys.maxsize + 1‖INT_MAX = sys.maxsize - 1‖1
class TreeNode:‖val: int = 0‖1
val: int = 0‖left: TreeNode | None = None‖1
if not node:‖return True, INT_MAX, INT_MIN, 0‖1
is_left_valid, min_left, max_left, sum_left = solver(node.left)‖is_right_valid, min_right, max_right, sum_right = solver(node.right)‖1
if is_left_valid and is_right_valid and max_left < node.val < min_right:‖total_sum = sum_left + sum_right + node.val‖1
total_sum = sum_left + sum_right + node.val‖ans = max(ans, total_sum)‖1
ans = max(ans, total_sum)‖return True, min(min_left, node.val), max(max_right, node.val), total_sum‖1
return False, -1, -1, -1‖solver(root)‖1
solver(root)‖return ans‖1
class Node:‖key: int‖1
key: int‖left: Node | None = None‖1
yield from self.left‖yield self.key‖1
yield self.key‖if self.right:‖1
floor_val = None‖ceiling_val = None‖1
while root:‖if root.key == key:‖1
if root.key == key:‖floor_val = root.key‖1
floor_val = root.key‖ceiling_val = root.key‖1
ceiling_val = root.key‖break‖1
if key < root.key:‖ceiling_val = root.key‖1
ceiling_val = root.key‖root = root.left‖1
root = root.left‖else:‖1
else:‖floor_val = root.key‖1
floor_val = root.key‖root = root.right‖1
from collections.abc import Sequence‖from queue import Queue‖1
class SegmentTreeNode:‖def __init__(self, start, end, val, left=None, right=None):‖1
def __init__(self, start, end, val, left=None, right=None):‖self.start = start‖1
self.start = start‖self.end = end‖2
self.end = end‖self.val = val‖1
self.val = val‖self.mid = (start + end) // 2‖1
self.mid = (start + end) // 2‖self.left = left‖1
self.left = left‖self.right = right‖3
def __repr__(self):‖"return f""SegmentTreeNode(start={self.start}, end={self.end}, val={self.val})"""‖1
def __init__(self, collection: Sequence, function):‖self.collection = collection‖1
self.collection = collection‖self.fn = function‖1
self.fn = function‖if self.collection:‖1
if self.collection:‖self.root = self._build_tree(0, len(collection) - 1)‖1
def _build_tree(self, start, end):‖if start == end:‖1
if start == end:‖return SegmentTreeNode(start, end, self.collection[start])‖1
return SegmentTreeNode(start, end, self.collection[start])‖mid = (start + end) // 2‖1
mid = (start + end) // 2‖left = self._build_tree(start, mid)‖1
left = self._build_tree(start, mid)‖right = self._build_tree(mid + 1, end)‖1
right = self._build_tree(mid + 1, end)‖return SegmentTreeNode(start, end, self.fn(left.val, right.val), left, right)‖1
def _update_tree(self, node, i, val):‖if node.start == i and node.end == i:‖1
if node.start == i and node.end == i:‖node.val = val‖1
node.val = val‖return‖1
return‖if i <= node.mid:‖1
if i <= node.mid:‖self._update_tree(node.left, i, val)‖1
self._update_tree(node.left, i, val)‖else:‖1
else:‖self._update_tree(node.right, i, val)‖1
self._update_tree(node.right, i, val)‖node.val = self.fn(node.left.val, node.right.val)‖1
def _query_range(self, node, i, j):‖if node.start == i and node.end == j:‖1
if node.start == i and node.end == j:‖return node.val‖1
if i <= node.mid:‖if j <= node.mid:‖1
return self._query_range(node.left, i, j)‖else:‖1
return self.fn(‖self._query_range(node.left, i, node.mid),‖1
self._query_range(node.left, i, node.mid),‖self._query_range(node.right, node.mid + 1, j),‖1
self._query_range(node.right, node.mid + 1, j),‖)‖1
def traverse(self):‖if self.root is not None:‖1
if self.root is not None:‖queue = Queue()‖1
queue = Queue()‖queue.put(self.root)‖1
queue.put(self.root)‖while not queue.empty():‖1
while not queue.empty():‖node = queue.get()‖1
node = queue.get()‖yield node‖1
if node.left is not None:‖queue.put(node.left)‖1
if node.right is not None:‖queue.put(node.right)‖1
"if __name__ == ""__main__"":"‖import operator‖1
for fn in [operator.add, max, min]:‖"print(""*"" * 50)"‖1
"print(""*"" * 50)"‖arr = SegmentTree([2, 1, 5, 3, 4], fn)‖1
arr = SegmentTree([2, 1, 5, 3, 4], fn)‖for node in arr.traverse():‖1
for node in arr.traverse():‖print(node)‖2
print(node)‖print()‖2
arr.update(1, 5)‖for node in arr.traverse():‖1
print(arr.query_range(3, 4))‖print(arr.query_range(2, 2))‖1
print(arr.query_range(2, 2))‖print(arr.query_range(1, 3))‖1
print(arr.query_range(1, 3))‖print()‖1
def __init__(self, value: int = 0) -> None:‖self.value = value‖1
if tree1 is None:‖return tree2‖1
return tree2‖if tree2 is None:‖1
if tree2 is None:‖return tree1‖1
tree1.value = tree1.value + tree2.value‖tree1.left = merge_two_binary_trees(tree1.left, tree2.left)‖1
tree1.left = merge_two_binary_trees(tree1.left, tree2.left)‖tree1.right = merge_two_binary_trees(tree1.right, tree2.right)‖1
tree1.right = merge_two_binary_trees(tree1.right, tree2.right)‖return tree1‖1
if root:‖print(root.value)‖1
print(root.value)‖print_preorder(root.left)‖1
print_preorder(root.left)‖print_preorder(root.right)‖1
"if __name__ == ""__main__"":"‖tree1 = Node(1)‖1
tree1 = Node(1)‖tree1.left = Node(2)‖1
tree1.left = Node(2)‖tree1.right = Node(3)‖1
tree1.right = Node(3)‖tree1.left.left = Node(4)‖1
tree2 = Node(2)‖tree2.left = Node(4)‖1
tree2.left = Node(4)‖tree2.right = Node(6)‖1
tree2.right = Node(6)‖tree2.left.right = Node(9)‖1
tree2.left.right = Node(9)‖tree2.right.right = Node(5)‖1
"print(""Tree1 is: "")"‖print_preorder(tree1)‖1
print_preorder(tree1)‖"print(""Tree2 is: "")"‖1
"print(""Tree2 is: "")"‖print_preorder(tree2)‖1
print_preorder(tree2)‖merged_tree = merge_two_binary_trees(tree1, tree2)‖1
merged_tree = merge_two_binary_trees(tree1, tree2)‖"print(""Merged Tree is: "")"‖1
"print(""Merged Tree is: "")"‖print_preorder(merged_tree)‖1
from collections.abc import Iterator, MutableMapping‖from dataclasses import dataclass‖1
from dataclasses import dataclass‖from typing import Generic, TypeVar‖1
"KEY = TypeVar(""KEY"")"‖"VAL = TypeVar(""VAL"")"‖1
@dataclass(frozen=True, slots=True)‖class _Item(Generic[KEY, VAL]):‖1
class _Item(Generic[KEY, VAL]):‖key: KEY‖1
key: KEY‖val: VAL‖1
class _DeletedItem(_Item):‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖super().__init__(None, None)‖1
def __bool__(self) -> bool:‖return False‖1
def __init__(‖self, initial_block_size: int = 8, capacity_factor: float = 0.75‖1
self, initial_block_size: int = 8, capacity_factor: float = 0.75‖) -> None:‖1
) -> None:‖self._initial_block_size = initial_block_size‖1
self._initial_block_size = initial_block_size‖self._buckets: list[_Item | None] = [None] * initial_block_size‖1
self._buckets: list[_Item | None] = [None] * initial_block_size‖assert 0.0 < capacity_factor < 1.0‖1
assert 0.0 < capacity_factor < 1.0‖self._capacity_factor = capacity_factor‖1
self._capacity_factor = capacity_factor‖self._len = 0‖1
def _get_bucket_index(self, key: KEY) -> int:‖return hash(key) % len(self._buckets)‖1
stored = self._buckets[ind]‖if not stored:‖1
if not stored:‖self._buckets[ind] = _Item(key, val)‖1
self._buckets[ind] = _Item(key, val)‖self._len += 1‖1
self._len += 1‖return True‖1
return True‖elif stored.key == key:‖1
elif stored.key == key:‖self._buckets[ind] = _Item(key, val)‖1
self._buckets[ind] = _Item(key, val)‖return True‖1
return True‖else:‖2
limit = len(self._buckets) * self._capacity_factor‖return len(self) >= int(limit)‖1
if len(self._buckets) <= self._initial_block_size:‖return False‖1
return False‖limit = len(self._buckets) * self._capacity_factor / 2‖1
limit = len(self._buckets) * self._capacity_factor / 2‖return len(self) < limit‖1
def _resize(self, new_size: int) -> None:‖old_buckets = self._buckets‖1
old_buckets = self._buckets‖self._buckets = [None] * new_size‖1
self._buckets = [None] * new_size‖self._len = 0‖1
self._len = 0‖for item in old_buckets:‖1
for item in old_buckets:‖if item:‖1
if item:‖self._add_item(item.key, item.val)‖1
def _size_up(self) -> None:‖self._resize(len(self._buckets) * 2)‖1
def _size_down(self) -> None:‖self._resize(len(self._buckets) // 2)‖1
def _iterate_buckets(self, key: KEY) -> Iterator[int]:‖ind = self._get_bucket_index(key)‖1
ind = self._get_bucket_index(key)‖for _ in range(len(self._buckets)):‖1
for _ in range(len(self._buckets)):‖yield ind‖1
yield ind‖ind = self._get_next_ind(ind)‖1
for ind in self._iterate_buckets(key):‖if self._try_set(ind, key, val):‖1
if self._try_set(ind, key, val):‖break‖1
if self._is_full():‖self._size_up()‖1
for ind in self._iterate_buckets(key):‖item = self._buckets[ind]‖2
item = self._buckets[ind]‖if item is None:‖2
if item is None:‖raise KeyError(key)‖1
raise KeyError(key)‖if item is _deleted:‖1
if item is _deleted:‖continue‖2
continue‖if item.key == key:‖2
if item.key == key:‖self._buckets[ind] = _deleted‖1
self._buckets[ind] = _deleted‖self._len -= 1‖1
self._len -= 1‖break‖1
break‖if self._is_sparse():‖1
if self._is_sparse():‖self._size_down()‖1
if item is None:‖break‖1
break‖if item is _deleted:‖1
if item.key == key:‖return item.val‖1
return item.val‖raise KeyError(key)‖1
def __iter__(self) -> Iterator[KEY]:‖yield from (item.key for item in self._buckets if item)‖1
def __repr__(self) -> str:‖"val_string = "", "".join("‖1
"val_string = "", "".join("‖"f""{item.key}: {item.val}"" for item in self._buckets if item"‖1
"f""{item.key}: {item.val}"" for item in self._buckets if item"‖)‖1
)‖"return f""HashMap({val_string})"""‖1
for i in range(k):‖result *= n - i‖1
result *= n - i‖result //= i + 1‖1
result //= i + 1‖return result‖1
if n < 0:‖"raise ValueError(""factorial() not defined for negative values"")"‖2
"raise ValueError(""factorial() not defined for negative values"")"‖result = 1‖1
result = 1‖for i in range(1, n + 1):‖1
for i in range(1, n + 1):‖result *= i‖1
result *= i‖return result‖1
"if __name__ == ""__main__"":"‖"node_count = int(input(""Enter the number of nodes: "").strip() or 0)"‖1
"node_count = int(input(""Enter the number of nodes: "").strip() or 0)"‖if node_count <= 0:‖1
if node_count <= 0:‖"raise ValueError(""We need some nodes to work with."")"‖1
"raise ValueError(""We need some nodes to work with."")"‖print(‖1
print(‖"f""Given {node_count} nodes, there are {binary_tree_count(node_count)} """‖1
"f""Given {node_count} nodes, there are {binary_tree_count(node_count)} """‖"f""binary trees and {catalan_number(node_count)} binary search trees."""‖1
"f""binary trees and {catalan_number(node_count)} binary search trees."""‖)‖1
class Node:‖def __init__(self, length: int) -> None:‖1
def __init__(self, length: int) -> None:‖self.minn: int = -1‖1
self.minn: int = -1‖self.maxx: int = -1‖1
self.maxx: int = -1‖self.map_left: list[int] = [-1] * length‖1
self.map_left: list[int] = [-1] * length‖self.left: Node | None = None‖1
root = Node(len(arr))‖root.minn, root.maxx = min(arr), max(arr)‖1
if root.minn == root.maxx:‖return root‖1
left_arr: list[int] = []‖right_arr: list[int] = []‖1
for index, num in enumerate(arr):‖if num <= pivot:‖1
if num <= pivot:‖left_arr.append(num)‖1
left_arr.append(num)‖else:‖1
else:‖right_arr.append(num)‖1
right_arr.append(num)‖root.map_left[index] = len(left_arr)‖1
root.map_left[index] = len(left_arr)‖root.left = build_tree(left_arr)‖1
root.left = build_tree(left_arr)‖root.right = build_tree(right_arr)‖1
root.right = build_tree(right_arr)‖return root‖1
if index < 0 or node is None:‖return 0‖1
if node.minn == node.maxx:‖return index + 1 if node.minn == num else 0‖1
return index + 1 if node.minn == num else 0‖pivot = (node.minn + node.maxx) // 2‖1
pivot = (node.minn + node.maxx) // 2‖if num <= pivot:‖1
return rank_till_index(node.left, num, node.map_left[index] - 1)‖else:‖1
if start > end:‖return 0‖1
return 0‖rank_till_end = rank_till_index(node, num, end)‖1
rank_till_end = rank_till_index(node, num, end)‖rank_before_start = rank_till_index(node, num, start - 1)‖1
rank_before_start = rank_till_index(node, num, start - 1)‖return rank_till_end - rank_before_start‖1
if index > (end - start) or start > end or node is None:‖return -1‖1
if node.minn == node.maxx:‖return node.minn‖1
num_elements_in_left_tree = node.map_left[end] - (‖node.map_left[start - 1] if start else 0‖1
node.map_left[start - 1] if start else 0‖)‖1
)‖if num_elements_in_left_tree > index:‖1
if num_elements_in_left_tree > index:‖return quantile(‖1
return quantile(‖node.left,‖1
node.left,‖index,‖1
index,‖(node.map_left[start - 1] if start else 0),‖1
(node.map_left[start - 1] if start else 0),‖node.map_left[end] - 1,‖2
node.map_left[end] - 1,‖)‖1
else:‖return quantile(‖1
return quantile(‖node.right,‖1
node.right,‖index - num_elements_in_left_tree,‖1
index - num_elements_in_left_tree,‖start - (node.map_left[start - 1] if start else 0),‖1
start - (node.map_left[start - 1] if start else 0),‖end - node.map_left[end],‖2
end - node.map_left[end],‖)‖1
def range_counting(‖node: Node | None, start: int, end: int, start_num: int, end_num: int‖1
node: Node | None, start: int, end: int, start_num: int, end_num: int‖) -> int:‖1
if (‖start > end‖1
start > end‖or node is None‖1
or node is None‖or start_num > end_num‖1
or start_num > end_num‖or node.minn > end_num‖1
or node.minn > end_num‖or node.maxx < start_num‖1
or node.maxx < start_num‖):‖1
):‖return 0‖2
return 0‖if start_num <= node.minn and node.maxx <= end_num:‖1
if start_num <= node.minn and node.maxx <= end_num:‖return end - start + 1‖1
return end - start + 1‖left = range_counting(‖1
left = range_counting(‖node.left,‖1
node.left,‖(node.map_left[start - 1] if start else 0),‖1
node.map_left[end] - 1,‖start_num,‖1
start_num,‖end_num,‖2
end_num,‖)‖2
)‖right = range_counting(‖1
right = range_counting(‖node.right,‖1
node.right,‖start - (node.map_left[start - 1] if start else 0),‖1
end - node.map_left[end],‖start_num,‖1
)‖return left + right‖1
from collections.abc import Callable‖from typing import Any, Generic, TypeVar‖1
class SegmentTree(Generic[T]):‖def __init__(self, arr: list[T], fnc: Callable[[T, T], T]) -> None:‖1
self.N: int = len(arr)‖self.st: list[T] = [any_type for _ in range(self.N)] + arr‖1
self.st: list[T] = [any_type for _ in range(self.N)] + arr‖self.fn = fnc‖1
self.fn = fnc‖self.build()‖1
def build(self) -> None:‖for p in range(self.N - 1, 0, -1):‖1
for p in range(self.N - 1, 0, -1):‖self.st[p] = self.fn(self.st[p * 2], self.st[p * 2 + 1])‖1
p += self.N‖self.st[p] = v‖1
self.st[p] = v‖while p > 1:‖1
while p > 1:‖p = p // 2‖1
p = p // 2‖self.st[p] = self.fn(self.st[p * 2], self.st[p * 2 + 1])‖1
res: T | None = None‖while left <= right:‖1
while left <= right:‖if left % 2 == 1:‖1
if left % 2 == 1:‖res = self.st[left] if res is None else self.fn(res, self.st[left])‖1
res = self.st[left] if res is None else self.fn(res, self.st[left])‖if right % 2 == 0:‖1
if right % 2 == 0:‖res = self.st[right] if res is None else self.fn(res, self.st[right])‖1
res = self.st[right] if res is None else self.fn(res, self.st[right])‖left, right = (left + 1) // 2, (right - 1) // 2‖1
left, right = (left + 1) // 2, (right - 1) // 2‖return res‖1
"if __name__ == ""__main__"":"‖from functools import reduce‖1
test_updates = {‖0: 7,‖1
0: 7,‖1: 2,‖1
1: 2,‖2: 6,‖1
2: 6,‖3: -14,‖1
3: -14,‖4: 5,‖1
4: 5,‖5: 4,‖1
5: 4,‖6: 7,‖1
6: 7,‖7: -10,‖1
7: -10,‖8: 9,‖1
8: 9,‖9: 10,‖1
9: 10,‖10: 12,‖1
10: 12,‖11: 1,‖1
11: 1,‖}‖1
min_segment_tree = SegmentTree(test_array, min)‖max_segment_tree = SegmentTree(test_array, max)‖1
max_segment_tree = SegmentTree(test_array, max)‖sum_segment_tree = SegmentTree(test_array, lambda a, b: a + b)‖1
for i in range(len(test_array)):‖for j in range(i, len(test_array)):‖1
for j in range(i, len(test_array)):‖min_range = reduce(min, test_array[i : j + 1])‖1
min_range = reduce(min, test_array[i : j + 1])‖max_range = reduce(max, test_array[i : j + 1])‖1
max_range = reduce(max, test_array[i : j + 1])‖sum_range = reduce(lambda a, b: a + b, test_array[i : j + 1])‖1
sum_range = reduce(lambda a, b: a + b, test_array[i : j + 1])‖assert min_range == min_segment_tree.query(i, j)‖1
assert min_range == min_segment_tree.query(i, j)‖assert max_range == max_segment_tree.query(i, j)‖1
assert max_range == max_segment_tree.query(i, j)‖assert sum_range == sum_segment_tree.query(i, j)‖1
for index, value in test_updates.items():‖test_array[index] = value‖1
test_array[index] = value‖min_segment_tree.update(index, value)‖1
min_segment_tree.update(index, value)‖max_segment_tree.update(index, value)‖1
max_segment_tree.update(index, value)‖sum_segment_tree.update(index, value)‖1
sum_segment_tree.update(index, value)‖test_all_segments()‖1
class SegmentTree:‖def __init__(self, a):‖1
def __init__(self, a):‖self.A = a‖1
self.A = a‖self.N = len(self.A)‖1
self.N = len(self.A)‖self.st = [0] * (‖1
self.st = [0] * (‖4 * self.N‖1
4 * self.N‖)‖1
)‖if self.N:‖1
if self.N:‖self.build(1, 0, self.N - 1)‖1
def build(self, idx, left, right):‖if left == right:‖1
if left == right:‖self.st[idx] = self.A[left]‖1
self.st[idx] = self.A[left]‖else:‖1
else:‖mid = (left + right) // 2‖1
mid = (left + right) // 2‖self.build(self.left(idx), left, mid)‖1
self.build(self.left(idx), left, mid)‖self.build(self.right(idx), mid + 1, right)‖1
self.build(self.right(idx), mid + 1, right)‖self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])‖1
if right < a or left > b:‖return True‖1
return True‖if left == right:‖1
if left == right:‖self.st[idx] = val‖1
self.st[idx] = val‖return True‖1
return True‖mid = (left + right) // 2‖1
mid = (left + right) // 2‖self.update_recursive(self.left(idx), left, mid, a, b, val)‖1
self.update_recursive(self.left(idx), left, mid, a, b, val)‖self.update_recursive(self.right(idx), mid + 1, right, a, b, val)‖1
self.update_recursive(self.right(idx), mid + 1, right, a, b, val)‖self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])‖1
self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])‖return True‖1
if right < a or left > b:‖return -math.inf‖1
return -math.inf‖if left >= a and right <= b:‖1
if left >= a and right <= b:‖return self.st[idx]‖1
return self.st[idx]‖mid = (left + right) // 2‖1
mid = (left + right) // 2‖q1 = self.query_recursive(self.left(idx), left, mid, a, b)‖1
q1 = self.query_recursive(self.left(idx), left, mid, a, b)‖q2 = self.query_recursive(self.right(idx), mid + 1, right, a, b)‖1
q2 = self.query_recursive(self.right(idx), mid + 1, right, a, b)‖return max(q1, q2)‖1
def show_data(self):‖show_list = []‖1
show_list = []‖for i in range(1, self.N + 1):‖1
for i in range(1, self.N + 1):‖show_list += [self.query(i, i)]‖1
show_list += [self.query(i, i)]‖print(show_list)‖1
A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]‖N = 15‖1
N = 15‖segt = SegmentTree(A)‖1
segt = SegmentTree(A)‖print(segt.query(4, 6))‖1
print(segt.query(4, 6))‖print(segt.query(7, 11))‖1
print(segt.query(7, 11))‖print(segt.query(7, 12))‖1
print(segt.query(7, 12))‖segt.update(1, 3, 111)‖1
segt.update(1, 3, 111)‖print(segt.query(1, 15))‖1
print(segt.query(1, 15))‖segt.update(7, 8, 235)‖1
segt.update(7, 8, 235)‖segt.show_data()‖1
value: int = 0‖left: TreeNode | None = None‖1
def __post_init__(self):‖if not isinstance(self.value, int):‖1
if not isinstance(self.value, int):‖"raise TypeError(""Value must be an integer."")"‖1
yield self‖yield from self.left or ()‖1
yield from self.left or ()‖yield from self.right or ()‖1
@classmethod‖def five_tree(cls) -> TreeNode:‖1
root.left = TreeNode(2)‖root.right = TreeNode(3)‖1
root.right = TreeNode(3)‖root.right.left = TreeNode(4)‖1
root.right.left = TreeNode(4)‖root.right.right = TreeNode(5)‖1
root.right.right = TreeNode(5)‖return root‖1
if not data:‖"raise ValueError(""Data cannot be empty."")"‖1
"if value == ""null"":"‖return None‖1
node = TreeNode(int(value))‖node.left = build_tree()‖1
node.left = build_tree()‖node.right = build_tree()‖1
node.right = build_tree()‖return node‖1
def __init__(self, value: int | None = None):‖self.value = value‖1
self.value = value‖self.prior = random()‖1
self.prior = random()‖self.left: Node | None = None‖1
if self.left is None and self.right is None:‖"return f""'{self.value}: {self.prior:.5}'"""‖1
"return f""'{self.value}: {self.prior:.5}'"""‖else:‖1
else:‖return pformat(‖1
return pformat(‖"{f""{self.value}: {self.prior:.5}"": (self.left, self.right)}, indent=1"‖1
"{f""{self.value}: {self.prior:.5}"": (self.left, self.right)}, indent=1"‖)‖1
def __str__(self) -> str:‖"value = str(self.value) + "" """‖1
"value = str(self.value) + "" """‖"left = str(self.left or """")"‖1
"left = str(self.left or """")"‖"right = str(self.right or """")"‖1
"right = str(self.right or """")"‖return value + left + right‖1
if root is None or root.value is None:‖return None, None‖1
return None, None‖elif value < root.value:‖1
left, root.left = split(root.left, value)‖return left, root‖1
return left, root‖else:‖1
root.right, right = split(root.right, value)‖return root, right‖1
if (not left) or (not right):‖return left or right‖1
return left or right‖elif left.prior < right.prior:‖1
left.right = merge(left.right, right)‖return left‖1
return left‖else:‖1
right.left = merge(left, right.left)‖return right‖1
node = Node(value)‖left, right = split(root, value)‖1
left, right = split(root, value)‖return merge(merge(left, node), right)‖1
left, right = split(root, value - 1)‖_, right = split(right, value)‖1
_, right = split(right, value)‖return merge(left, right)‖1
return‖else:‖3
else:‖inorder(root.left)‖1
inorder(root.left)‖"print(root.value, end="","")"‖1
"print(root.value, end="","")"‖inorder(root.right)‖1
for arg in args.split():‖"if arg[0] == ""+"":"‖1
"if arg[0] == ""+"":"‖root = insert(root, int(arg[1:]))‖1
"elif arg[0] == ""-"":"‖root = erase(root, int(arg[1:]))‖1
else:‖"print(""Unknown command"")"‖1
root = None‖print(‖1
print(‖"""enter numbers to create a tree, + value to add value into treap, """‖1
"""enter numbers to create a tree, + value to add value into treap, """‖"""- value to erase all nodes with value. 'q' to quit. """‖1
"""- value to erase all nodes with value. 'q' to quit. """‖)‖1
args = input()‖"while args != ""q"":"‖1
"while args != ""q"":"‖root = interact_treap(root, args)‖1
root = interact_treap(root, args)‖print(root)‖1
print(root)‖args = input()‖1
def __init__(‖self,‖15
self,‖label: int | None = None,‖1
label: int | None = None,‖color: int = 0,‖1
color: int = 0,‖parent: RedBlackTree | None = None,‖1
parent: RedBlackTree | None = None,‖left: RedBlackTree | None = None,‖1
left: RedBlackTree | None = None,‖right: RedBlackTree | None = None,‖1
right: RedBlackTree | None = None,‖) -> None:‖1
self.parent = parent‖self.left = left‖1
self.right = right‖self.color = color‖1
parent = self.parent‖right = self.right‖1
right = self.right‖if right is None:‖1
if right is None:‖return self‖1
return self‖self.right = right.left‖1
self.right = right.left‖if self.right:‖1
if self.right:‖self.right.parent = self‖2
self.right.parent = self‖self.parent = right‖1
self.parent = right‖right.left = self‖1
right.left = self‖if parent is not None:‖1
if parent is not None:‖if parent.left == self:‖1
if parent.left == self:‖parent.left = right‖1
parent.left = right‖else:‖1
else:‖parent.right = right‖1
parent.right = right‖right.parent = parent‖1
right.parent = parent‖return right‖1
if self.left is None:‖return self‖1
return self‖parent = self.parent‖1
parent = self.parent‖left = self.left‖1
left = self.left‖self.left = left.right‖1
self.left = left.right‖if self.left:‖1
if self.left:‖self.left.parent = self‖2
self.left.parent = self‖self.parent = left‖1
self.parent = left‖left.right = self‖1
left.right = self‖if parent is not None:‖1
if parent is not None:‖if parent.right is self:‖1
if parent.right is self:‖parent.right = left‖1
parent.right = left‖else:‖1
else:‖parent.left = left‖1
parent.left = left‖left.parent = parent‖1
left.parent = parent‖return left‖1
self.label = label‖return self‖1
return self‖if self.label == label:‖1
if self.label == label:‖return self‖2
return self‖elif self.label > label:‖1
elif self.label > label:‖if self.left:‖1
if self.left:‖self.left.insert(label)‖1
self.left.insert(label)‖else:‖1
else:‖self.left = RedBlackTree(label, 1, self)‖1
self.left = RedBlackTree(label, 1, self)‖self.left._insert_repair()‖1
self.left._insert_repair()‖elif self.right:‖1
elif self.right:‖self.right.insert(label)‖1
self.right.insert(label)‖else:‖1
else:‖self.right = RedBlackTree(label, 1, self)‖1
self.right = RedBlackTree(label, 1, self)‖self.right._insert_repair()‖1
self.right._insert_repair()‖return self.parent or self‖1
self.color = 0‖elif color(self.parent) == 0:‖1
self.color = 1‖else:‖1
else:‖uncle = self.parent.sibling‖1
uncle = self.parent.sibling‖if color(uncle) == 0:‖1
if color(uncle) == 0:‖if self.is_left() and self.parent.is_right():‖1
if self.is_left() and self.parent.is_right():‖self.parent.rotate_right()‖1
self.parent.rotate_right()‖if self.right:‖1
if self.right:‖self.right._insert_repair()‖1
self.right._insert_repair()‖elif self.is_right() and self.parent.is_left():‖1
elif self.is_right() and self.parent.is_left():‖self.parent.rotate_left()‖1
self.parent.rotate_left()‖if self.left:‖1
if self.left:‖self.left._insert_repair()‖1
self.left._insert_repair()‖elif self.is_left():‖1
elif self.is_left():‖if self.grandparent:‖1
if self.grandparent:‖self.grandparent.rotate_right()‖1
self.grandparent.rotate_right()‖self.parent.color = 0‖1
self.parent.color = 0‖if self.parent.right:‖1
if self.parent.right:‖self.parent.right.color = 1‖1
self.parent.right.color = 1‖else:‖1
else:‖if self.grandparent:‖1
if self.grandparent:‖self.grandparent.rotate_left()‖1
self.grandparent.rotate_left()‖self.parent.color = 0‖1
self.parent.color = 0‖if self.parent.left:‖1
if self.parent.left:‖self.parent.left.color = 1‖1
self.parent.left.color = 1‖else:‖1
else:‖self.parent.color = 0‖1
self.parent.color = 0‖if uncle and self.grandparent:‖1
if uncle and self.grandparent:‖uncle.color = 0‖1
uncle.color = 0‖self.grandparent.color = 1‖1
self.grandparent.color = 1‖self.grandparent._insert_repair()‖1
if self.label == label:‖if self.left and self.right:‖1
value = self.left.get_max()‖if value is not None:‖1
if value is not None:‖self.label = value‖1
self.label = value‖self.left.remove(value)‖1
self.left.remove(value)‖else:‖1
child = self.left or self.right‖if self.color == 1:‖1
if self.parent:‖if self.is_left():‖1
if self.is_left():‖self.parent.left = None‖2
self.parent.left = None‖else:‖2
else:‖self.parent.right = None‖2
return RedBlackTree(None)‖else:‖1
else:‖self._remove_repair()‖1
self._remove_repair()‖if self.is_left():‖1
self.parent.right = None‖self.parent = None‖1
self.parent = None‖else:‖1
self.label = child.label‖self.left = child.left‖1
self.left = child.left‖self.right = child.right‖1
self.right = child.right‖if self.left:‖1
self.left.parent = self‖if self.right:‖1
self.right.parent = self‖elif self.label is not None and self.label > label:‖1
elif self.label is not None and self.label > label:‖if self.left:‖2
if self.left:‖self.left.remove(label)‖1
self.left.remove(label)‖elif self.right:‖1
elif self.right:‖self.right.remove(label)‖1
self.right.remove(label)‖return self.parent or self‖1
if (‖self.parent is None‖1
self.parent is None‖or self.sibling is None‖1
or self.sibling is None‖or self.parent.sibling is None‖1
or self.parent.sibling is None‖or self.grandparent is None‖1
or self.grandparent is None‖):‖1
):‖return‖1
return‖if color(self.sibling) == 1:‖1
if color(self.sibling) == 1:‖self.sibling.color = 0‖1
self.sibling.color = 0‖self.parent.color = 1‖1
self.parent.color = 1‖if self.is_left():‖1
if self.is_left():‖self.parent.rotate_left()‖1
self.parent.rotate_left()‖else:‖1
else:‖self.parent.rotate_right()‖1
self.parent.rotate_right()‖if (‖1
if (‖color(self.parent) == 0‖1
color(self.parent) == 0‖and color(self.sibling) == 0‖1
and color(self.sibling) == 0‖and color(self.sibling.left) == 0‖2
and color(self.sibling.left) == 0‖and color(self.sibling.right) == 0‖2
and color(self.sibling.right) == 0‖):‖2
):‖self.sibling.color = 1‖2
self.sibling.color = 1‖self.parent._remove_repair()‖1
self.parent._remove_repair()‖return‖1
return‖if (‖2
if (‖color(self.parent) == 1‖1
color(self.parent) == 1‖and color(self.sibling) == 0‖1
self.sibling.color = 1‖self.parent.color = 0‖1
self.parent.color = 0‖return‖1
if (‖self.is_left()‖2
self.is_left()‖and color(self.sibling) == 0‖2
and color(self.sibling) == 0‖and color(self.sibling.right) == 0‖1
and color(self.sibling.right) == 0‖and color(self.sibling.left) == 1‖1
and color(self.sibling.left) == 1‖):‖2
):‖self.sibling.rotate_right()‖1
self.sibling.rotate_right()‖self.sibling.color = 0‖1
self.sibling.color = 0‖if self.sibling.right:‖1
if self.sibling.right:‖self.sibling.right.color = 1‖1
self.sibling.right.color = 1‖if (‖1
if (‖self.is_right()‖2
self.is_right()‖and color(self.sibling) == 0‖2
and color(self.sibling) == 0‖and color(self.sibling.right) == 1‖2
and color(self.sibling.right) == 1‖and color(self.sibling.left) == 0‖1
and color(self.sibling.left) == 0‖):‖1
):‖self.sibling.rotate_left()‖1
self.sibling.rotate_left()‖self.sibling.color = 0‖1
self.sibling.color = 0‖if self.sibling.left:‖1
if self.sibling.left:‖self.sibling.left.color = 1‖1
self.sibling.left.color = 1‖if (‖1
and color(self.sibling.right) == 1‖):‖1
):‖self.parent.rotate_left()‖1
self.parent.rotate_left()‖self.grandparent.color = self.parent.color‖1
self.grandparent.color = self.parent.color‖self.parent.color = 0‖2
self.parent.color = 0‖self.parent.sibling.color = 0‖2
self.parent.sibling.color = 0‖if (‖1
and color(self.sibling) == 0‖and color(self.sibling.left) == 1‖1
):‖self.parent.rotate_right()‖1
self.parent.rotate_right()‖self.grandparent.color = self.parent.color‖1
"print(""Property 2"")"‖return False‖1
if not self.check_coloring():‖"print(""Property 4"")"‖1
"print(""Property 4"")"‖return False‖1
if self.black_height() is None:‖"print(""Property 5"")"‖1
"print(""Property 5"")"‖return False‖1
if self.color == 1 and 1 in (color(self.left), color(self.right)):‖return False‖1
return False‖if self.left and not self.left.check_coloring():‖1
if self.left and not self.left.check_coloring():‖return False‖1
return False‖return not (self.right and not self.right.check_coloring())‖1
return 1‖left = RedBlackTree.black_height(self.left)‖1
left = RedBlackTree.black_height(self.left)‖right = RedBlackTree.black_height(self.right)‖1
right = RedBlackTree.black_height(self.right)‖if left is None or right is None:‖1
return None‖if left != right:‖1
return self‖elif self.label is not None and label > self.label:‖1
elif self.label is not None and label > self.label:‖if self.right is None:‖1
if self.right is None:‖return None‖1
return None‖else:‖7
else:‖return self.right.search(label)‖1
return self.right.search(label)‖elif self.left is None:‖1
elif self.left is None:‖return None‖1
else:‖return self.left.search(label)‖1
if self.label == label:‖return self.label‖2
return self.label‖elif self.label is not None and self.label > label:‖1
if self.left:‖return self.left.floor(label)‖1
return self.left.floor(label)‖else:‖1
else:‖if self.right:‖1
if self.right:‖attempt = self.right.floor(label)‖1
attempt = self.right.floor(label)‖if attempt is not None:‖1
if attempt is not None:‖return attempt‖2
return attempt‖return self.label‖2
return self.label‖elif self.label is not None and self.label < label:‖1
elif self.label is not None and self.label < label:‖if self.right:‖1
if self.right:‖return self.right.ceil(label)‖1
return self.right.ceil(label)‖else:‖1
else:‖if self.left:‖1
if self.left:‖attempt = self.left.ceil(label)‖1
attempt = self.left.ceil(label)‖if attempt is not None:‖1
return self.right.get_max()‖else:‖1
else:‖return self.label‖2
return self.left.get_min()‖else:‖1
@property‖def grandparent(self) -> RedBlackTree | None:‖1
if self.parent is None:‖return None‖2
else:‖return self.parent.parent‖1
@property‖def sibling(self) -> RedBlackTree | None:‖1
return None‖elif self.parent.left is self:‖1
elif self.parent.left is self:‖return self.parent.right‖1
return self.parent.right‖else:‖1
else:‖return self.parent.left‖1
if self.parent is None:‖return False‖2
return False‖return self.parent.left is self‖1
return False‖return self.parent.right is self‖1
def __bool__(self) -> bool:‖return True‖1
ln = 1‖if self.left:‖1
if self.left:‖ln += len(self.left)‖1
ln += len(self.left)‖if self.right:‖1
if self.right:‖ln += len(self.right)‖1
ln += len(self.right)‖return ln‖1
def preorder_traverse(self) -> Iterator[int | None]:‖yield self.label‖1
yield self.label‖if self.left:‖1
if self.left:‖yield from self.left.preorder_traverse()‖1
yield from self.left.preorder_traverse()‖if self.right:‖1
if self.right:‖yield from self.right.preorder_traverse()‖1
def inorder_traverse(self) -> Iterator[int | None]:‖if self.left:‖1
if self.left:‖yield from self.left.inorder_traverse()‖1
yield from self.left.inorder_traverse()‖yield self.label‖1
yield self.label‖if self.right:‖1
if self.right:‖yield from self.right.inorder_traverse()‖1
def postorder_traverse(self) -> Iterator[int | None]:‖if self.left:‖1
if self.left:‖yield from self.left.postorder_traverse()‖1
yield from self.left.postorder_traverse()‖if self.right:‖1
if self.right:‖yield from self.right.postorder_traverse()‖1
yield from self.right.postorder_traverse()‖yield self.label‖1
if self.left is None and self.right is None:‖"return f""'{self.label} {(self.color and 'red') or 'blk'}'"""‖1
"return f""'{self.label} {(self.color and 'red') or 'blk'}'"""‖return pformat(‖1
return pformat(‖{‖1
{‖"f""{self.label} {(self.color and 'red') or 'blk'}"": ("‖1
"f""{self.label} {(self.color and 'red') or 'blk'}"": ("‖self.left,‖1
self.left,‖self.right,‖1
self.right,‖)‖1
)‖},‖1
},‖indent=1,‖1
indent=1,‖)‖1
if not isinstance(other, RedBlackTree):‖return NotImplemented‖1
return NotImplemented‖if self.label == other.label:‖1
if self.label == other.label:‖return self.left == other.left and self.right == other.right‖1
return self.left == other.left and self.right == other.right‖else:‖1
return 0‖else:‖2
else:‖return node.color‖1
tree = RedBlackTree(0)‖tree.left = RedBlackTree(-10, parent=tree)‖1
tree.left = RedBlackTree(-10, parent=tree)‖tree.right = RedBlackTree(10, parent=tree)‖1
tree.right = RedBlackTree(10, parent=tree)‖tree.left.left = RedBlackTree(-20, parent=tree.left)‖1
tree.left.left = RedBlackTree(-20, parent=tree.left)‖tree.left.right = RedBlackTree(-5, parent=tree.left)‖1
tree.left.right = RedBlackTree(-5, parent=tree.left)‖tree.right.left = RedBlackTree(5, parent=tree.right)‖1
tree.right.left = RedBlackTree(5, parent=tree.right)‖tree.right.right = RedBlackTree(20, parent=tree.right)‖1
left_rot = RedBlackTree(10)‖left_rot.left = RedBlackTree(0, parent=left_rot)‖1
left_rot.left = RedBlackTree(0, parent=left_rot)‖left_rot.left.left = RedBlackTree(-10, parent=left_rot.left)‖1
left_rot.left.left = RedBlackTree(-10, parent=left_rot.left)‖left_rot.left.right = RedBlackTree(5, parent=left_rot.left)‖1
left_rot.left.right = RedBlackTree(5, parent=left_rot.left)‖left_rot.left.left.left = RedBlackTree(-20, parent=left_rot.left.left)‖1
left_rot.left.left.left = RedBlackTree(-20, parent=left_rot.left.left)‖left_rot.left.left.right = RedBlackTree(-5, parent=left_rot.left.left)‖1
left_rot.left.left.right = RedBlackTree(-5, parent=left_rot.left.left)‖left_rot.right = RedBlackTree(20, parent=left_rot)‖1
left_rot.right = RedBlackTree(20, parent=left_rot)‖tree = tree.rotate_left()‖1
tree = tree.rotate_left()‖if tree != left_rot:‖1
if tree != left_rot:‖return False‖1
return False‖tree = tree.rotate_right()‖1
tree = tree.rotate_right()‖tree = tree.rotate_right()‖1
right_rot = RedBlackTree(-10)‖right_rot.left = RedBlackTree(-20, parent=right_rot)‖1
right_rot.left = RedBlackTree(-20, parent=right_rot)‖right_rot.right = RedBlackTree(0, parent=right_rot)‖1
right_rot.right = RedBlackTree(0, parent=right_rot)‖right_rot.right.left = RedBlackTree(-5, parent=right_rot.right)‖1
right_rot.right.left = RedBlackTree(-5, parent=right_rot.right)‖right_rot.right.right = RedBlackTree(10, parent=right_rot.right)‖1
right_rot.right.right = RedBlackTree(10, parent=right_rot.right)‖right_rot.right.right.left = RedBlackTree(5, parent=right_rot.right.right)‖1
right_rot.right.right.left = RedBlackTree(5, parent=right_rot.right.right)‖right_rot.right.right.right = RedBlackTree(20, parent=right_rot.right.right)‖1
right_rot.right.right.right = RedBlackTree(20, parent=right_rot.right.right)‖return tree == right_rot‖1
tree = RedBlackTree(-1)‖for i in range(300000):‖1
for i in range(300000):‖tree = tree.insert(i)‖1
tree = tree.insert(i)‖return True‖1
tree = RedBlackTree(0)‖tree.insert(8)‖2
tree.insert(8)‖tree.insert(-8)‖2
tree.insert(-8)‖tree.insert(4)‖2
tree.insert(4)‖tree.insert(12)‖2
tree.insert(12)‖tree.insert(10)‖2
tree.insert(10)‖tree.insert(11)‖2
tree.insert(11)‖ans = RedBlackTree(0, 0)‖1
ans = RedBlackTree(0, 0)‖ans.left = RedBlackTree(-8, 0, ans)‖1
ans.left = RedBlackTree(-8, 0, ans)‖ans.right = RedBlackTree(8, 1, ans)‖1
ans.right = RedBlackTree(8, 1, ans)‖ans.right.left = RedBlackTree(4, 0, ans.right)‖1
ans.right.left = RedBlackTree(4, 0, ans.right)‖ans.right.right = RedBlackTree(11, 0, ans.right)‖1
ans.right.right = RedBlackTree(11, 0, ans.right)‖ans.right.right.left = RedBlackTree(10, 1, ans.right.right)‖1
ans.right.right.left = RedBlackTree(10, 1, ans.right.right)‖ans.right.right.right = RedBlackTree(12, 1, ans.right.right)‖1
ans.right.right.right = RedBlackTree(12, 1, ans.right.right)‖return tree == ans‖1
tree.insert(11)‖if any(i in tree for i in (5, -6, -10, 13)):‖1
tree = RedBlackTree(0)‖tree = tree.insert(-12)‖1
tree = tree.insert(-12)‖tree = tree.insert(8)‖1
tree = tree.insert(8)‖tree = tree.insert(-8)‖1
tree = tree.insert(-8)‖tree = tree.insert(15)‖1
tree = tree.insert(15)‖tree = tree.insert(4)‖1
tree = tree.insert(4)‖tree = tree.insert(12)‖1
tree = tree.insert(12)‖tree = tree.insert(10)‖1
tree = tree.insert(10)‖tree = tree.insert(9)‖1
tree = tree.insert(9)‖tree = tree.insert(11)‖1
tree = tree.insert(11)‖tree = tree.remove(15)‖1
tree = tree.remove(15)‖tree = tree.remove(-12)‖1
tree = tree.remove(-12)‖tree = tree.remove(9)‖1
tree = tree.remove(9)‖if not tree.check_color_properties():‖1
if not tree.check_color_properties():‖return False‖1
return False‖return list(tree.inorder_traverse()) == [-8, 0, 4, 8, 10, 11, 12]‖1
tree = RedBlackTree(0)‖tree.insert(-16)‖2
tree.insert(-16)‖tree.insert(16)‖2
tree.insert(16)‖tree.insert(8)‖3
tree.insert(8)‖tree.insert(24)‖3
tree.insert(24)‖tree.insert(20)‖3
tree.insert(20)‖tree.insert(22)‖3
tree.insert(22)‖tuples = [(-20, None, -16), (-10, -16, 0), (8, 8, 8), (50, 24, None)]‖1
tuples = [(-20, None, -16), (-10, -16, 0), (8, 8, 8), (50, 24, None)]‖for val, floor, ceil in tuples:‖1
for val, floor, ceil in tuples:‖if tree.floor(val) != floor or tree.ceil(val) != ceil:‖1
if tree.floor(val) != floor or tree.ceil(val) != ceil:‖return False‖1
tree.insert(22)‖return not (tree.get_max() != 22 or tree.get_min() != -16)‖1
tree = RedBlackTree(0)‖tree = tree.insert(-16)‖1
tree = tree.insert(-16)‖tree.insert(16)‖1
tree.insert(22)‖if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:‖1
if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:‖return False‖2
return False‖if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:‖2
if list(tree.preorder_traverse()) != [0, -16, 16, 8, 22, 20, 24]:‖return False‖2
return False‖return list(tree.postorder_traverse()) == [-16, 8, 20, 24, 22, 16, 0]‖2
tree = RedBlackTree(0)‖tree = tree.insert(-16).insert(16).insert(8).insert(24).insert(20).insert(22)‖1
tree = tree.insert(-16).insert(16).insert(8).insert(24).insert(20).insert(22)‖if list(tree.inorder_traverse()) != [-16, 0, 8, 16, 20, 22, 24]:‖1
def print_results(msg: str, passes: bool) -> None:‖"print(str(msg), ""works!"" if passes else ""doesn't work :("")"‖2
def pytests() -> None:‖assert test_rotations()‖1
assert test_rotations()‖assert test_insert()‖1
assert test_insert()‖assert test_insert_and_search()‖1
assert test_insert_and_search()‖assert test_insert_delete()‖1
assert test_insert_delete()‖assert test_floor_ceil()‖1
assert test_floor_ceil()‖assert test_tree_traversal()‖1
assert test_tree_traversal()‖assert test_tree_chaining()‖1
"print_results(""Rotating right and left"", test_rotations())"‖"print_results(""Inserting"", test_insert())"‖1
"print_results(""Inserting"", test_insert())"‖"print_results(""Searching"", test_insert_and_search())"‖1
"print_results(""Searching"", test_insert_and_search())"‖"print_results(""Deleting"", test_insert_delete())"‖1
"print_results(""Deleting"", test_insert_delete())"‖"print_results(""Floor and ceil"", test_floor_ceil())"‖1
"print_results(""Floor and ceil"", test_floor_ceil())"‖"print_results(""Tree traversal"", test_tree_traversal())"‖1
"print_results(""Tree traversal"", test_tree_traversal())"‖"print_results(""Tree traversal"", test_tree_chaining())"‖1
"print_results(""Tree traversal"", test_tree_chaining())"‖"print(""Testing tree balancing..."")"‖1
"print(""Testing tree balancing..."")"‖"print(""This should only be a few seconds."")"‖1
"print(""This should only be a few seconds."")"‖test_insertion_speed()‖1
test_insertion_speed()‖"print(""Done!"")"‖1
self,‖size_table: int,‖1
size_table: int,‖charge_factor: int | None = None,‖1
charge_factor: int | None = None,‖lim_charge: float | None = None,‖1
lim_charge: float | None = None,‖) -> None:‖1
) -> None:‖self.size_table = size_table‖1
self.size_table = size_table‖self.values = [None] * self.size_table‖1
self.values = [None] * self.size_table‖self.lim_charge = 0.75 if lim_charge is None else lim_charge‖1
self.lim_charge = 0.75 if lim_charge is None else lim_charge‖self.charge_factor = 1 if charge_factor is None else charge_factor‖1
self.charge_factor = 1 if charge_factor is None else charge_factor‖self.__aux_list: list = []‖1
self.__aux_list: list = []‖self._keys: dict = {}‖1
def balanced_factor(self):‖return sum(1 for slot in self.values if slot is not None) / (‖1
return sum(1 for slot in self.values if slot is not None) / (‖self.size_table * self.charge_factor‖1
self.size_table * self.charge_factor‖)‖1
def _step_by_step(self, step_ord):‖"print(f""step {step_ord}"")"‖1
"print(f""step {step_ord}"")"‖print(list(range(len(self.values))))‖1
print(list(range(len(self.values))))‖print(self.values)‖1
i = 1‖self.__aux_list = values‖1
self.__aux_list = values‖for value in values:‖1
for value in values:‖self.insert_data(value)‖1
self.insert_data(value)‖self._step_by_step(i)‖1
self._step_by_step(i)‖i += 1‖1
self.values[key] = data‖self._keys[key] = data‖1
@abstractmethod‖def _collision_resolution(self, key, data=None):‖1
while self.values[new_key] is not None and self.values[new_key] != key:‖if self.values.count(None) > 0:‖1
if self.values.count(None) > 0:‖new_key = self.hash_function(new_key + 1)‖1
new_key = self.hash_function(new_key + 1)‖else:‖1
else:‖new_key = None‖1
new_key = None‖break‖1
def rehashing(self):‖survivor_values = [value for value in self.values if value is not None]‖1
survivor_values = [value for value in self.values if value is not None]‖self.size_table = next_prime(self.size_table, factor=2)‖1
self.size_table = next_prime(self.size_table, factor=2)‖self._keys.clear()‖1
self._keys.clear()‖self.values = [None] * self.size_table‖1
self.values = [None] * self.size_table‖for value in survivor_values:‖1
for value in survivor_values:‖self.insert_data(value)‖1
if self.values[key] is None:‖self._set_value(key, data)‖1
elif self.values[key] == data:‖pass‖1
else:‖collision_resolution = self._collision_resolution(key, data)‖1
collision_resolution = self._collision_resolution(key, data)‖if collision_resolution is not None:‖1
if collision_resolution is not None:‖self._set_value(collision_resolution, data)‖1
self._set_value(collision_resolution, data)‖else:‖1
else:‖self.rehashing()‖1
self.rehashing()‖self.insert_data(data)‖1
self.size = size‖self.arr = [0] * size‖1
self.arr = [0] * size‖self.tree = [0] * size‖1
@staticmethod‖def get_next(index: int) -> int:‖1
@staticmethod‖def get_prev(index: int) -> int:‖1
self.arr[index] = value‖while index < self.size:‖1
while index < self.size:‖current_left_border = self.get_prev(index) + 1‖1
current_left_border = self.get_prev(index) + 1‖if current_left_border == index:‖1
if current_left_border == index:‖self.tree[index] = value‖1
self.tree[index] = value‖else:‖1
else:‖self.tree[index] = max(value, current_left_border, index)‖1
self.tree[index] = max(value, current_left_border, index)‖index = self.get_next(index)‖1
right -= 1‖result = 0‖1
result = 0‖while left <= right:‖1
while left <= right:‖current_left = self.get_prev(right)‖1
current_left = self.get_prev(right)‖if left <= current_left:‖1
if left <= current_left:‖result = max(result, self.tree[right])‖1
result = max(result, self.tree[right])‖right = current_left‖1
right = current_left‖else:‖1
else:‖result = max(result, self.arr[right])‖1
result = max(result, self.arr[right])‖right -= 1‖1
right -= 1‖return result‖1
from .hash_table import HashTable‖from .number_theory.prime_numbers import is_prime, next_prime‖1
def __init__(self, *args, **kwargs):‖super().__init__(*args, **kwargs)‖3
def __hash_function_2(self, value, data):‖next_prime_gt = (‖1
next_prime_gt = (‖next_prime(value % self.size_table)‖1
next_prime(value % self.size_table)‖if not is_prime(value % self.size_table)‖1
if not is_prime(value % self.size_table)‖else value % self.size_table‖1
else value % self.size_table‖)‖1
)‖return next_prime_gt - (data % next_prime_gt)‖1
def __hash_double_function(self, key, data, increment):‖return (increment * self.__hash_function_2(key, data)) % self.size_table‖1
i = 1‖new_key = self.hash_function(data)‖1
while self.values[new_key] is not None and self.values[new_key] != key:‖new_key = (‖1
new_key = (‖self.__hash_double_function(key, data, i)‖1
self.__hash_double_function(key, data, i)‖if self.balanced_factor() >= self.lim_charge‖1
if self.balanced_factor() >= self.lim_charge‖else None‖1
else None‖)‖2
)‖if new_key is None:‖1
if new_key is None:‖break‖2
else:‖i += 1‖4
root.left = Node(2)‖root.right = Node(2)‖2
root.right = Node(2)‖root.left.left = Node(3)‖2
root.left.left = Node(3)‖root.left.right = Node(4)‖2
root.left.right = Node(4)‖root.right.left = Node(4)‖1
root.right.left = Node(4)‖root.right.right = Node(3)‖1
root.right.right = Node(3)‖return root‖1
root.left.right = Node(4)‖root.right.left = Node(3)‖1
root.right.left = Node(3)‖root.right.right = Node(4)‖1
root.right.right = Node(4)‖return root‖1
if tree:‖return is_mirror(tree.left, tree.right)‖1
return is_mirror(tree.left, tree.right)‖return True‖1
return True‖if left is None or right is None:‖1
return False‖if left.data == right.data:‖1
return is_mirror(left.left, right.right) and is_mirror(left.right, right.left)‖return False‖1
from abc import abstractmethod‖from collections.abc import Iterable‖1
from collections.abc import Iterable‖from typing import Generic, Protocol, TypeVar‖1
class Comparable(Protocol):‖@abstractmethod‖1
@abstractmethod‖def __lt__(self: T, other: T) -> bool:‖1
def __lt__(self: T, other: T) -> bool:‖pass‖1
@abstractmethod‖def __gt__(self: T, other: T) -> bool:‖1
def __gt__(self: T, other: T) -> bool:‖pass‖1
@abstractmethod‖def __eq__(self: T, other: object) -> bool:‖1
def __eq__(self: T, other: object) -> bool:‖pass‖1
def __init__(self) -> None:‖self.h: list[T] = []‖1
self.h: list[T] = []‖self.heap_size: int = 0‖1
def __repr__(self) -> str:‖return str(self.h)‖1
if child_idx > 0:‖return (child_idx - 1) // 2‖1
return (child_idx - 1) // 2‖return None‖1
left_child_index = 2 * parent_idx + 1‖if left_child_index < self.heap_size:‖1
if left_child_index < self.heap_size:‖return left_child_index‖1
return left_child_index‖return None‖1
right_child_index = 2 * parent_idx + 2‖if right_child_index < self.heap_size:‖1
if right_child_index < self.heap_size:‖return right_child_index‖1
return right_child_index‖return None‖1
if index < self.heap_size:‖violation: int = index‖1
violation: int = index‖left_child = self.left_child_idx(index)‖1
left_child = self.left_child_idx(index)‖right_child = self.right_child_idx(index)‖1
if left_child is not None and self.h[left_child] > self.h[violation]:‖violation = left_child‖1
violation = left_child‖if right_child is not None and self.h[right_child] > self.h[violation]:‖1
if right_child is not None and self.h[right_child] > self.h[violation]:‖violation = right_child‖1
self.h = list(collection)‖self.heap_size = len(self.h)‖1
self.heap_size = len(self.h)‖if self.heap_size > 1:‖1
for i in range(self.heap_size // 2 - 1, -1, -1):‖self.max_heapify(i)‖1
if self.heap_size >= 2:‖me = self.h[0]‖1
me = self.h[0]‖self.h[0] = self.h.pop(-1)‖1
self.h[0] = self.h.pop(-1)‖self.heap_size -= 1‖1
self.heap_size -= 1‖self.max_heapify(0)‖2
self.max_heapify(0)‖return me‖1
return me‖elif self.heap_size == 1:‖1
elif self.heap_size == 1:‖self.heap_size -= 1‖1
self.heap_size -= 1‖return self.h.pop(-1)‖1
return self.h.pop(-1)‖else:‖1
else:‖"raise Exception(""Empty heap"")"‖1
self.h.append(value)‖idx = (self.heap_size - 1) // 2‖1
idx = (self.heap_size - 1) // 2‖self.heap_size += 1‖1
self.heap_size += 1‖while idx >= 0:‖1
while idx >= 0:‖self.max_heapify(idx)‖1
self.max_heapify(idx)‖idx = (idx - 1) // 2‖1
def heap_sort(self) -> None:‖size = self.heap_size‖1
size = self.heap_size‖for j in range(size - 1, 0, -1):‖1
for j in range(size - 1, 0, -1):‖self.h[0], self.h[j] = self.h[j], self.h[0]‖1
self.h[0], self.h[j] = self.h[j], self.h[0]‖self.heap_size -= 1‖1
self.max_heapify(0)‖self.heap_size = size‖1
for unsorted in [‖[0],‖1
[0],‖[2],‖1
[2],‖[3, 5],‖1
[3, 5],‖[5, 3],‖1
[5, 3],‖[5, 5],‖1
[5, 5],‖[0, 0, 0, 0],‖1
[0, 0, 0, 0],‖[1, 1, 1, 1],‖1
[1, 1, 1, 1],‖[2, 2, 3, 5],‖1
[2, 2, 3, 5],‖[0, 2, 2, 3, 5],‖1
[0, 2, 2, 3, 5],‖[2, 5, 3, 0, 2, 3, 0, 3],‖1
[2, 5, 3, 0, 2, 3, 0, 3],‖[6, 1, 2, 7, 9, 3, 4, 5, 10, 8],‖1
[6, 1, 2, 7, 9, 3, 4, 5, 10, 8],‖[103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5],‖1
[103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5],‖[-45, -2, -5],‖1
[-45, -2, -5],‖]:‖1
]:‖"print(f""unsorted array: {unsorted}"")"‖1
heap: Heap[int] = Heap()‖heap.build_max_heap(unsorted)‖1
heap.build_max_heap(unsorted)‖"print(f""after build heap: {heap}"")"‖1
"print(f""max value: {heap.extract_max()}"")"‖"print(f""after max value removed: {heap}"")"‖1
heap.insert(100)‖"print(f""after new value 100 inserted: {heap}"")"‖1
heap.heap_sort()‖"print(f""heap-sorted array: {heap}\n"")"‖1
class Bloom:‖def __init__(self, size: int = 8) -> None:‖1
def __init__(self, size: int = 8) -> None:‖self.bitarray = 0b0‖1
self.bitarray = 0b0‖self.size = size‖1
def add(self, value: str) -> None:‖h = self.hash_(value)‖1
h = self.hash_(value)‖self.bitarray |= h‖1
def exists(self, value: str) -> bool:‖h = self.hash_(value)‖1
h = self.hash_(value)‖return (h & self.bitarray) == h‖1
def __contains__(self, other: str) -> bool:‖return self.exists(other)‖1
def format_bin(self, bitarray: int) -> str:‖res = bin(bitarray)[2:]‖1
res = bin(bitarray)[2:]‖return res.zfill(self.size)‖1
@property‖def bitstring(self) -> str:‖1
def bitstring(self) -> str:‖return self.format_bin(self.bitarray)‖1
def hash_(self, value: str) -> int:‖res = 0b0‖1
res = 0b0‖for func in HASH_FUNCTIONS:‖1
for func in HASH_FUNCTIONS:‖position = (‖1
position = (‖"int.from_bytes(func(value.encode()).digest(), ""little"") % self.size"‖1
"int.from_bytes(func(value.encode()).digest(), ""little"") % self.size"‖)‖1
)‖res |= 2**position‖1
res |= 2**position‖return res‖1
def format_hash(self, value: str) -> str:‖return self.format_bin(self.hash_(value))‖1
@property‖def estimated_error_rate(self) -> float:‖1
def estimated_error_rate(self) -> float:‖"n_ones = bin(self.bitarray).count(""1"")"‖1
"n_ones = bin(self.bitarray).count(""1"")"‖return (n_ones / self.size) ** len(HASH_FUNCTIONS)‖1
i = 1‖new_key = self.hash_function(key + i * i)‖1
while self.values[new_key] is not None and self.values[new_key] != key:‖i += 1‖1
i += 1‖new_key = (‖1
new_key = (‖self.hash_function(key + i * i)‖1
self.hash_function(key + i * i)‖if not self.balanced_factor() >= self.lim_charge‖1
if not self.balanced_factor() >= self.lim_charge‖else None‖1
class HashTableWithLinkedList(HashTable):‖def __init__(self, *args, **kwargs):‖1
def _set_value(self, key, data):‖self.values[key] = deque([]) if self.values[key] is None else self.values[key]‖1
self.values[key] = deque([]) if self.values[key] is None else self.values[key]‖self.values[key].appendleft(data)‖1
self.values[key].appendleft(data)‖self._keys[key] = self.values[key]‖1
def balanced_factor(self):‖return (‖1
return (‖sum(self.charge_factor - len(slot) for slot in self.values)‖1
sum(self.charge_factor - len(slot) for slot in self.values)‖/ self.size_table‖1
/ self.size_table‖* self.charge_factor‖1
* self.charge_factor‖)‖1
def _collision_resolution(self, key, data=None):‖if not (‖1
if not (‖len(self.values[key]) == self.charge_factor and self.values.count(None) == 0‖1
len(self.values[key]) == self.charge_factor and self.values.count(None) == 0‖):‖1
):‖return key‖1
return key‖return super()._collision_resolution(key, data)‖1
class DisjointSet:‖def __init__(self, set_counts: list) -> None:‖1
self.set_counts = set_counts‖self.max_set = max(set_counts)‖1
self.max_set = max(set_counts)‖num_sets = len(set_counts)‖1
num_sets = len(set_counts)‖self.ranks = [1] * num_sets‖1
self.ranks = [1] * num_sets‖self.parents = list(range(num_sets))‖1
src_parent = self.get_parent(src)‖dst_parent = self.get_parent(dst)‖1
if src_parent == dst_parent:‖return False‖1
if self.ranks[dst_parent] >= self.ranks[src_parent]:‖self.set_counts[dst_parent] += self.set_counts[src_parent]‖1
self.set_counts[dst_parent] += self.set_counts[src_parent]‖self.set_counts[src_parent] = 0‖1
self.set_counts[src_parent] = 0‖self.parents[src_parent] = dst_parent‖1
self.parents[src_parent] = dst_parent‖if self.ranks[dst_parent] == self.ranks[src_parent]:‖1
if self.ranks[dst_parent] == self.ranks[src_parent]:‖self.ranks[dst_parent] += 1‖1
self.ranks[dst_parent] += 1‖joined_set_size = self.set_counts[dst_parent]‖1
joined_set_size = self.set_counts[dst_parent]‖else:‖1
else:‖self.set_counts[src_parent] += self.set_counts[dst_parent]‖1
self.set_counts[src_parent] += self.set_counts[dst_parent]‖self.set_counts[dst_parent] = 0‖1
self.set_counts[dst_parent] = 0‖self.parents[dst_parent] = src_parent‖1
self.parents[dst_parent] = src_parent‖joined_set_size = self.set_counts[src_parent]‖1
self.max_set = max(self.max_set, joined_set_size)‖return True‖1
if self.parents[disj_set] == disj_set:‖return disj_set‖1
return disj_set‖self.parents[disj_set] = self.get_parent(self.parents[disj_set])‖1
self.parents[disj_set] = self.get_parent(self.parents[disj_set])‖return self.parents[disj_set]‖1
class Node:‖def __init__(self, name, val):‖1
def __init__(self, name, val):‖self.name = name‖1
self.name = name‖self.val = val‖1
def __str__(self):‖"return f""{self.__class__.__name__}({self.name}, {self.val})"""‖1
def __lt__(self, other):‖return self.val < other.val‖1
def __init__(self, array):‖self.idx_of_element = {}‖1
self.idx_of_element = {}‖self.heap_dict = {}‖1
self.heap_dict = {}‖self.heap = self.build_heap(array)‖1
def __getitem__(self, key):‖return self.get_value(key)‖1
def get_parent_idx(self, idx):‖return (idx - 1) // 2‖1
def get_left_child_idx(self, idx):‖return idx * 2 + 1‖1
def get_right_child_idx(self, idx):‖return idx * 2 + 2‖1
def get_value(self, key):‖return self.heap_dict[key]‖1
def build_heap(self, array):‖last_idx = len(array) - 1‖1
last_idx = len(array) - 1‖start_from = self.get_parent_idx(last_idx)‖1
for idx, i in enumerate(array):‖self.idx_of_element[i] = idx‖1
self.idx_of_element[i] = idx‖self.heap_dict[i.name] = i.val‖1
for i in range(start_from, -1, -1):‖self.sift_down(i, array)‖1
self.sift_down(i, array)‖return array‖1
def sift_down(self, idx, array):‖while True:‖1
while True:‖left = self.get_left_child_idx(idx)‖1
left = self.get_left_child_idx(idx)‖right = self.get_right_child_idx(idx)‖1
smallest = idx‖if left < len(array) and array[left] < array[idx]:‖1
if left < len(array) and array[left] < array[idx]:‖smallest = left‖1
smallest = left‖if right < len(array) and array[right] < array[smallest]:‖1
if right < len(array) and array[right] < array[smallest]:‖smallest = right‖1
if smallest != idx:‖array[idx], array[smallest] = array[smallest], array[idx]‖1
array[idx], array[smallest] = array[smallest], array[idx]‖(‖1
(‖self.idx_of_element[array[idx]],‖1
self.idx_of_element[array[idx]],‖self.idx_of_element[array[smallest]],‖1
self.idx_of_element[array[smallest]],‖) = (‖1
) = (‖self.idx_of_element[array[smallest]],‖1
self.idx_of_element[array[smallest]],‖self.idx_of_element[array[idx]],‖1
self.idx_of_element[array[idx]],‖)‖1
)‖idx = smallest‖1
idx = smallest‖else:‖1
def sift_up(self, idx):‖p = self.get_parent_idx(idx)‖1
p = self.get_parent_idx(idx)‖while p >= 0 and self.heap[p] > self.heap[idx]:‖1
while p >= 0 and self.heap[p] > self.heap[idx]:‖self.heap[p], self.heap[idx] = self.heap[idx], self.heap[p]‖1
self.heap[p], self.heap[idx] = self.heap[idx], self.heap[p]‖self.idx_of_element[self.heap[p]], self.idx_of_element[self.heap[idx]] = (‖1
self.idx_of_element[self.heap[p]], self.idx_of_element[self.heap[idx]] = (‖self.idx_of_element[self.heap[idx]],‖1
self.idx_of_element[self.heap[idx]],‖self.idx_of_element[self.heap[p]],‖1
self.idx_of_element[self.heap[p]],‖)‖1
)‖idx = p‖1
idx = p‖p = self.get_parent_idx(idx)‖1
def peek(self):‖return self.heap[0]‖1
def remove(self):‖self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]‖1
self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]‖self.idx_of_element[self.heap[0]], self.idx_of_element[self.heap[-1]] = (‖1
self.idx_of_element[self.heap[0]], self.idx_of_element[self.heap[-1]] = (‖self.idx_of_element[self.heap[-1]],‖1
self.idx_of_element[self.heap[-1]],‖self.idx_of_element[self.heap[0]],‖1
self.idx_of_element[self.heap[0]],‖)‖1
x = self.heap.pop()‖del self.idx_of_element[x]‖1
del self.idx_of_element[x]‖self.sift_down(0, self.heap)‖1
self.sift_down(0, self.heap)‖return x‖1
def insert(self, node):‖self.heap.append(node)‖1
self.heap.append(node)‖self.idx_of_element[node] = len(self.heap) - 1‖1
self.idx_of_element[node] = len(self.heap) - 1‖self.heap_dict[node.name] = node.val‖1
self.heap_dict[node.name] = node.val‖self.sift_up(len(self.heap) - 1)‖1
def is_empty(self):‖return len(self.heap) == 0‖1
def decrease_key(self, node, new_value):‖assert self.heap[self.idx_of_element[node]].val > new_value, (‖1
assert self.heap[self.idx_of_element[node]].val > new_value, (‖"""newValue must be less that current value"""‖1
"""newValue must be less that current value"""‖)‖1
)‖node.val = new_value‖1
node.val = new_value‖self.heap_dict[node.name] = new_value‖1
self.heap_dict[node.name] = new_value‖self.sift_up(self.idx_of_element[node])‖1
"r = Node(""R"", -1)"‖"b = Node(""B"", 6)"‖1
"b = Node(""B"", 6)"‖"a = Node(""A"", 3)"‖1
"a = Node(""A"", 3)"‖"x = Node(""X"", 1)"‖1
"x = Node(""X"", 1)"‖"e = Node(""E"", 4)"‖1
"print(""Min Heap - before decrease key"")"‖for i in my_min_heap.heap:‖1
for i in my_min_heap.heap:‖print(i)‖2
"print(""Min Heap - After decrease key of node [B -> -17]"")"‖my_min_heap.decrease_key(b, -17)‖1
from dataclasses import dataclass‖from typing import Any‖4
class Node:‖data: Any‖2
data: Any‖next_node: Node | None = None‖3
@dataclass‖class CircularLinkedList:‖1
class CircularLinkedList:‖head: Node | None = None‖1
head: Node | None = None‖tail: Node | None = None‖1
node = self.head‖while node:‖10
while node:‖yield node.data‖9
yield node.data‖node = node.next_node‖8
node = node.next_node‖if node == self.head:‖1
if node == self.head:‖break‖1
if index < 0 or index > len(self):‖"raise IndexError(""list index out of range."")"‖1
"raise IndexError(""list index out of range."")"‖new_node: Node = Node(data)‖1
new_node: Node = Node(data)‖if self.head is None:‖1
if self.head is None:‖new_node.next_node = new_node‖1
new_node.next_node = new_node‖self.tail = self.head = new_node‖1
self.tail = self.head = new_node‖elif index == 0:‖1
elif index == 0:‖new_node.next_node = self.head‖2
new_node.next_node = self.head‖assert self.tail is not None‖1
assert self.tail is not None‖self.head = self.tail.next_node = new_node‖1
self.head = self.tail.next_node = new_node‖else:‖1
else:‖temp: Node | None = self.head‖2
temp: Node | None = self.head‖for _ in range(index - 1):‖2
for _ in range(index - 1):‖assert temp is not None‖2
assert temp is not None‖temp = temp.next_node‖2
temp = temp.next_node‖assert temp is not None‖2
assert temp is not None‖new_node.next_node = temp.next_node‖1
new_node.next_node = temp.next_node‖temp.next_node = new_node‖2
temp.next_node = new_node‖if index == len(self) - 1:‖1
if index == len(self) - 1:‖self.tail = new_node‖1
if not 0 <= index < len(self):‖"raise IndexError(""list index out of range."")"‖1
assert self.head is not None‖assert self.tail is not None‖1
assert self.tail is not None‖delete_node: Node = self.head‖1
delete_node: Node = self.head‖if self.head == self.tail:‖1
if self.head == self.tail:‖self.head = self.tail = None‖1
self.head = self.tail = None‖elif index == 0:‖2
elif index == 0:‖assert self.tail.next_node is not None‖1
assert self.tail.next_node is not None‖self.tail.next_node = self.tail.next_node.next_node‖1
self.tail.next_node = self.tail.next_node.next_node‖self.head = self.head.next_node‖1
self.head = self.head.next_node‖else:‖2
assert temp is not None‖assert temp.next_node is not None‖1
assert temp.next_node is not None‖delete_node = temp.next_node‖1
delete_node = temp.next_node‖temp.next_node = temp.next_node.next_node‖2
temp.next_node = temp.next_node.next_node‖if index == len(self) - 1:‖1
if index == len(self) - 1:‖self.tail = temp‖1
self.tail = temp‖return delete_node.data‖1
circular_linked_list = CircularLinkedList()‖assert len(circular_linked_list) == 0‖1
assert len(circular_linked_list) == 0‖assert circular_linked_list.is_empty() is True‖1
assert circular_linked_list.is_empty() is True‖"assert str(circular_linked_list) == """""‖1
try:‖circular_linked_list.delete_front()‖1
circular_linked_list.delete_front()‖raise AssertionError‖1
raise AssertionError‖except IndexError:‖8
except IndexError:‖assert True‖8
try:‖circular_linked_list.delete_tail()‖1
circular_linked_list.delete_tail()‖raise AssertionError‖1
try:‖circular_linked_list.delete_nth(-1)‖1
circular_linked_list.delete_nth(-1)‖raise AssertionError‖1
try:‖circular_linked_list.delete_nth(0)‖1
circular_linked_list.delete_nth(0)‖raise AssertionError‖1
assert circular_linked_list.is_empty() is True‖for i in range(5):‖1
for i in range(5):‖assert len(circular_linked_list) == i‖1
assert len(circular_linked_list) == i‖circular_linked_list.insert_nth(i, i + 1)‖1
circular_linked_list.insert_nth(i, i + 1)‖"assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 6))"‖1
circular_linked_list.insert_tail(6)‖"assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 7))"‖1
"assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 7))"‖circular_linked_list.insert_head(0)‖1
circular_linked_list.insert_head(0)‖"assert str(circular_linked_list) == ""->"".join(str(i) for i in range(7))"‖1
assert circular_linked_list.delete_front() == 0‖assert circular_linked_list.delete_tail() == 6‖1
assert circular_linked_list.delete_tail() == 6‖"assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 6))"‖1
"assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 6))"‖assert circular_linked_list.delete_nth(2) == 3‖1
circular_linked_list.insert_nth(2, 3)‖"assert str(circular_linked_list) == ""->"".join(str(i) for i in range(1, 6))"‖1
if not points:‖return None‖1
k = len(points[0])‖axis = depth % k‖1
points.sort(key=lambda point: point[axis])‖median_idx = len(points) // 2‖1
left_points = points[:median_idx]‖right_points = points[median_idx + 1 :]‖1
return KDNode(‖point=points[median_idx],‖1
point=points[median_idx],‖left=build_kdtree(left_points, depth + 1),‖1
left=build_kdtree(left_points, depth + 1),‖right=build_kdtree(right_points, depth + 1),‖1
right=build_kdtree(right_points, depth + 1),‖)‖1
def __init__(self, val):‖self.val = val‖1
self.left_tree_size = 0‖self.left = None‖1
self.left = None‖self.right = None‖2
self.right = None‖self.parent = None‖1
if self.val < other.val:‖other.left = self.right‖1
other.left = self.right‖other.parent = None‖1
other.parent = None‖if self.right:‖1
if self.right:‖self.right.parent = other‖1
self.right.parent = other‖self.right = other‖1
self.right = other‖self.left_tree_size = self.left_tree_size * 2 + 1‖1
self.left_tree_size = self.left_tree_size * 2 + 1‖return self‖1
return self‖else:‖1
else:‖self.left = other.right‖1
self.left = other.right‖self.parent = None‖1
self.parent = None‖if other.right:‖1
if other.right:‖other.right.parent = self‖1
other.right.parent = self‖other.right = self‖1
other.right = self‖other.left_tree_size = other.left_tree_size * 2 + 1‖1
other.left_tree_size = other.left_tree_size * 2 + 1‖return other‖1
def __init__(self, bottom_root=None, min_node=None, heap_size=0):‖self.size = heap_size‖1
self.size = heap_size‖self.bottom_root = bottom_root‖1
self.bottom_root = bottom_root‖self.min_node = min_node‖1
if other.size == 0:‖return None‖1
return None‖if self.size == 0:‖1
if self.size == 0:‖self.size = other.size‖1
self.size = other.size‖self.bottom_root = other.bottom_root‖1
self.bottom_root = other.bottom_root‖self.min_node = other.min_node‖1
self.min_node = other.min_node‖return None‖1
if self.min_node.val > other.min_node.val:‖self.min_node = other.min_node‖1
combined_roots_list = []‖i, j = self.bottom_root, other.bottom_root‖1
i, j = self.bottom_root, other.bottom_root‖while i or j:‖1
while i or j:‖if i and ((not j) or i.left_tree_size < j.left_tree_size):‖1
if i and ((not j) or i.left_tree_size < j.left_tree_size):‖combined_roots_list.append((i, True))‖1
combined_roots_list.append((i, True))‖i = i.parent‖1
i = i.parent‖else:‖1
else:‖combined_roots_list.append((j, False))‖1
combined_roots_list.append((j, False))‖j = j.parent‖1
for i in range(len(combined_roots_list) - 1):‖if combined_roots_list[i][1] != combined_roots_list[i + 1][1]:‖1
if combined_roots_list[i][1] != combined_roots_list[i + 1][1]:‖combined_roots_list[i][0].parent = combined_roots_list[i + 1][0]‖1
combined_roots_list[i][0].parent = combined_roots_list[i + 1][0]‖combined_roots_list[i + 1][0].left = combined_roots_list[i][0]‖1
i = combined_roots_list[0][0]‖while i.parent:‖1
while i.parent:‖if (‖1
if (‖(i.left_tree_size == i.parent.left_tree_size) and (not i.parent.parent)‖1
(i.left_tree_size == i.parent.left_tree_size) and (not i.parent.parent)‖) or (‖1
) or (‖i.left_tree_size == i.parent.left_tree_size‖1
i.left_tree_size == i.parent.left_tree_size‖and i.left_tree_size != i.parent.parent.left_tree_size‖1
and i.left_tree_size != i.parent.parent.left_tree_size‖):‖1
previous_node = i.left‖next_node = i.parent.parent‖1
i.left = previous_node‖i.parent = next_node‖1
i.parent = next_node‖if previous_node:‖1
if previous_node:‖previous_node.parent = i‖1
previous_node.parent = i‖if next_node:‖1
if next_node:‖next_node.left = i‖1
next_node.left = i‖else:‖1
else:‖i = i.parent‖1
while i.left:‖i = i.left‖1
i = i.left‖self.bottom_root = i‖1
other.size = self.size‖other.bottom_root = self.bottom_root‖1
other.bottom_root = self.bottom_root‖other.min_node = self.min_node‖1
if self.size == 0:‖self.bottom_root = Node(val)‖1
self.bottom_root = Node(val)‖self.size = 1‖1
self.size = 1‖self.min_node = self.bottom_root‖1
self.min_node = self.bottom_root‖else:‖1
if val < self.min_node.val:‖self.min_node = new_node‖1
self.bottom_root.left = new_node‖new_node.parent = self.bottom_root‖1
new_node.parent = self.bottom_root‖self.bottom_root = new_node‖1
while (‖self.bottom_root.parent‖1
self.bottom_root.parent‖and self.bottom_root.left_tree_size‖1
and self.bottom_root.left_tree_size‖== self.bottom_root.parent.left_tree_size‖1
== self.bottom_root.parent.left_tree_size‖):‖1
self.bottom_root.parent = next_node‖self.bottom_root.left = None‖1
self.bottom_root.left = None‖if next_node:‖1
if next_node:‖next_node.left = self.bottom_root‖1
def is_empty(self):‖return self.size == 0‖1
self.bottom_root = self.bottom_root.parent‖self.bottom_root.left = None‖1
self.min_node = self.bottom_root‖i = self.bottom_root.parent‖1
i = self.bottom_root.parent‖while i:‖1
while i:‖if i.val < self.min_node.val:‖2
if i.val < self.min_node.val:‖self.min_node = i‖2
self.min_node = i‖i = i.parent‖2
i = i.parent‖return min_value‖1
bottom_of_new = self.min_node.right‖bottom_of_new.parent = None‖1
bottom_of_new.parent = None‖min_of_new = bottom_of_new‖1
min_of_new = bottom_of_new‖size_of_new = 1‖1
while bottom_of_new.left:‖size_of_new = size_of_new * 2 + 1‖1
size_of_new = size_of_new * 2 + 1‖bottom_of_new = bottom_of_new.left‖1
bottom_of_new = bottom_of_new.left‖if bottom_of_new.val < min_of_new.val:‖1
if bottom_of_new.val < min_of_new.val:‖min_of_new = bottom_of_new‖1
if (not self.min_node.left) and (not self.min_node.parent):‖self.size = size_of_new‖1
self.size = size_of_new‖self.bottom_root = bottom_of_new‖1
self.bottom_root = bottom_of_new‖self.min_node = min_of_new‖1
new_heap = BinomialHeap(‖bottom_root=bottom_of_new, min_node=min_of_new, heap_size=size_of_new‖1
bottom_root=bottom_of_new, min_node=min_of_new, heap_size=size_of_new‖)‖1
previous_node = self.min_node.left‖next_node = self.min_node.parent‖1
self.min_node = previous_node or next_node‖self.bottom_root = next_node‖1
if previous_node:‖previous_node.parent = next_node‖1
self.bottom_root = previous_node‖self.min_node = previous_node‖1
self.min_node = previous_node‖while self.bottom_root.left:‖1
while self.bottom_root.left:‖self.bottom_root = self.bottom_root.left‖1
self.bottom_root = self.bottom_root.left‖if self.bottom_root.val < self.min_node.val:‖1
if self.bottom_root.val < self.min_node.val:‖self.min_node = self.bottom_root‖1
self.min_node = self.bottom_root‖if next_node:‖1
if next_node:‖next_node.left = previous_node‖1
i = next_node‖while i:‖1
top_root = self.bottom_root‖while top_root.parent:‖1
while top_root.parent:‖top_root = top_root.parent‖1
heap_pre_order = []‖self.__traversal(top_root, heap_pre_order)‖1
self.__traversal(top_root, heap_pre_order)‖return heap_pre_order‖1
if curr_node:‖preorder.append((curr_node.val, level))‖1
preorder.append((curr_node.val, level))‖self.__traversal(curr_node.left, preorder, level + 1)‖1
self.__traversal(curr_node.left, preorder, level + 1)‖self.__traversal(curr_node.right, preorder, level + 1)‖1
self.__traversal(curr_node.right, preorder, level + 1)‖else:‖1
else:‖"preorder.append((""#"", level))"‖1
if self.is_empty():‖"return """""‖2
"return """""‖preorder_heap = self.pre_order()‖1
def _get(k):‖return getitem, k‖1
def _set(k, v):‖return setitem, k, v‖1
def _del(k):‖return delitem, k‖1
def _run_operation(obj, fun, *args):‖try:‖1
try:‖return fun(obj, *args), None‖1
return fun(obj, *args), None‖except Exception as e:‖1
except Exception as e:‖return None, e‖1
_add_items = (‖"_set(""key_a"", ""val_a""),"‖1
"_set(""key_a"", ""val_a""),"‖"_set(""key_b"", ""val_b""),"‖2
"_set(""key_b"", ""val_b""),"‖)‖1
_overwrite_items = [‖"_set(""key_a"", ""val_a""),"‖1
"_set(""key_a"", ""val_a""),"‖"_set(""key_a"", ""val_b""),"‖1
"_set(""key_a"", ""val_b""),"‖]‖2
_delete_items = [‖"_set(""key_a"", ""val_a""),"‖1
"_set(""key_b"", ""val_b""),"‖"_del(""key_a""),"‖1
"_del(""key_a""),"‖"_del(""key_b""),"‖1
"_del(""key_b""),"‖"_set(""key_a"", ""val_a""),"‖1
"_set(""key_a"", ""val_a""),"‖"_del(""key_a""),"‖2
"_del(""key_a""),"‖]‖1
_access_absent_items = [‖"_get(""key_a""),"‖1
"_get(""key_a""),"‖"_del(""key_a""),"‖1
"_del(""key_a""),"‖"_set(""key_a"", ""val_a""),"‖1
"_del(""key_a""),"‖"_del(""key_a""),"‖1
"_del(""key_a""),"‖"_get(""key_a""),"‖1
"_get(""key_a""),"‖]‖1
_add_with_resize_up = [‖*[_set(x, x) for x in range(5)],‖1
*[_set(x, x) for x in range(5)],‖]‖1
_add_with_resize_down = [‖*[_set(x, x) for x in range(5)],‖1
*[_set(x, x) for x in range(5)],‖*[_del(x) for x in range(5)],‖1
*[_del(x) for x in range(5)],‖"_set(""key_a"", ""val_b""),"‖1
@pytest.mark.parametrize(‖"""operations"","‖1
"""operations"","‖[‖1
[‖"pytest.param(_add_items, id=""add items""),"‖1
"pytest.param(_add_items, id=""add items""),"‖"pytest.param(_overwrite_items, id=""overwrite items""),"‖1
"pytest.param(_overwrite_items, id=""overwrite items""),"‖"pytest.param(_delete_items, id=""delete items""),"‖1
"pytest.param(_delete_items, id=""delete items""),"‖"pytest.param(_access_absent_items, id=""access absent items""),"‖1
"pytest.param(_access_absent_items, id=""access absent items""),"‖"pytest.param(_add_with_resize_up, id=""add with resize up""),"‖1
"pytest.param(_add_with_resize_up, id=""add with resize up""),"‖"pytest.param(_add_with_resize_down, id=""add with resize down""),"‖1
"pytest.param(_add_with_resize_down, id=""add with resize down""),"‖],‖1
],‖)‖3
)‖def test_hash_map_is_the_same_as_dict(operations):‖1
def test_hash_map_is_the_same_as_dict(operations):‖my = HashMap(initial_block_size=4)‖1
my = HashMap(initial_block_size=4)‖py = {}‖1
py = {}‖for _, (fun, *args) in enumerate(operations):‖1
for _, (fun, *args) in enumerate(operations):‖my_res, my_exc = _run_operation(my, fun, *args)‖1
my_res, my_exc = _run_operation(my, fun, *args)‖py_res, py_exc = _run_operation(py, fun, *args)‖1
py_res, py_exc = _run_operation(py, fun, *args)‖assert my_res == py_res‖1
assert my_res == py_res‖assert str(my_exc) == str(py_exc)‖1
assert str(my_exc) == str(py_exc)‖assert set(py) == set(my)‖1
assert set(py) == set(my)‖assert len(py) == len(my)‖1
assert len(py) == len(my)‖assert set(my.items()) == set(py.items())‖1
def test_no_new_methods_was_added_to_api():‖def is_public(name: str) -> bool:‖1
def is_public(name: str) -> bool:‖"return not name.startswith(""_"")"‖1
dict_public_names = {name for name in dir({}) if is_public(name)}‖hash_public_names = {name for name in dir(HashMap()) if is_public(name)}‖1
class Node:‖def __init__(self, data: int) -> None:‖2
self.data = data‖self.rank: int‖1
self.rank: int‖self.parent: Node‖1
x.rank = 0‖x.parent = x‖1
x, y = find_set(x), find_set(y)‖if x == y:‖1
if x == y:‖return‖1
elif x.rank > y.rank:‖y.parent = x‖1
y.parent = x‖else:‖1
else:‖x.parent = y‖1
x.parent = y‖if x.rank == y.rank:‖1
if x.rank == y.rank:‖y.rank += 1‖1
if x != x.parent:‖x.parent = find_set(x.parent)‖1
x.parent = find_set(x.parent)‖return x.parent‖1
sets = ({0, 1, 2}, {3, 4, 5})‖for s in sets:‖1
for s in sets:‖if node.data in s:‖1
if node.data in s:‖return s‖1
return s‖"msg = f""{node.data} is not in {sets}"""‖1
"msg = f""{node.data} is not in {sets}"""‖raise ValueError(msg)‖1
vertex = [Node(i) for i in range(6)]‖for v in vertex:‖1
for v in vertex:‖make_set(v)‖1
union_set(vertex[0], vertex[1])‖union_set(vertex[1], vertex[2])‖1
union_set(vertex[1], vertex[2])‖union_set(vertex[3], vertex[4])‖1
union_set(vertex[3], vertex[4])‖union_set(vertex[3], vertex[5])‖1
for node0 in vertex:‖for node1 in vertex:‖1
for node1 in vertex:‖if find_python_set(node0).isdisjoint(find_python_set(node1)):‖1
if find_python_set(node0).isdisjoint(find_python_set(node1)):‖assert find_set(node0) != find_set(node1)‖1
assert find_set(node0) != find_set(node1)‖else:‖1
else:‖assert find_set(node0) == find_set(node1)‖1
"if __name__ == ""__main__"":"‖test_disjoint_set()‖1
self,‖point: list[float],‖1
point: list[float],‖left: KDNode | None = None,‖1
left: KDNode | None = None,‖right: KDNode | None = None,‖1
right: KDNode | None = None,‖) -> None:‖1
self.point = point‖self.left = left‖1
import random‖from collections.abc import Iterable‖2
from collections.abc import Iterable‖from typing import Any, Generic, TypeVar‖1
def __init__(self, value: T) -> None:‖self._value: T = value‖2
self._value: T = value‖self.left: RandomizedHeapNode[T] | None = None‖1
self.left: RandomizedHeapNode[T] | None = None‖self.right: RandomizedHeapNode[T] | None = None‖1
@property‖def value(self) -> T:‖2
@staticmethod‖def merge(‖2
def merge(‖root1: RandomizedHeapNode[T] | None, root2: RandomizedHeapNode[T] | None‖1
root1: RandomizedHeapNode[T] | None, root2: RandomizedHeapNode[T] | None‖) -> RandomizedHeapNode[T] | None:‖1
if not root1:‖return root2‖2
if not root2:‖return root1‖2
if root1.value > root2.value:‖root1, root2 = root2, root1‖2
if random.choice([True, False]):‖root1.left, root1.right = root1.right, root1.left‖1
if data:‖for item in data:‖2
for item in data:‖self.insert(item)‖2
if self._root is None:‖return None‖1
if not self._root:‖"raise IndexError(""Can't get top element for the empty heap."")"‖2
"raise IndexError(""Can't get top element for the empty heap."")"‖return self._root.value‖2
result = []‖while self:‖1
while self:‖result.append(self.pop())‖2
from data_structures.kd_tree.build_kdtree import build_kdtree‖from data_structures.kd_tree.example.hypercube_points import hypercube_points‖2
from data_structures.kd_tree.example.hypercube_points import hypercube_points‖from data_structures.kd_tree.nearest_neighbour_search import nearest_neighbour_search‖1
num_points: int = 5000‖cube_size: float = 10.0‖1
cube_size: float = 10.0‖num_dimensions: int = 10‖1
points: np.ndarray = hypercube_points(num_points, cube_size, num_dimensions)‖hypercube_kdtree = build_kdtree(points.tolist())‖1
rng = np.random.default_rng()‖query_point: list[float] = rng.random(num_dimensions).tolist()‖1
nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(‖hypercube_kdtree, query_point‖1
hypercube_kdtree, query_point‖)‖1
"print(f""Query point: {query_point}"")"‖"print(f""Nearest point: {nearest_point}"")"‖1
"print(f""Nearest point: {nearest_point}"")"‖"print(f""Distance: {nearest_dist:.4f}"")"‖1
"print(f""Distance: {nearest_dist:.4f}"")"‖"print(f""Nodes visited: {nodes_visited}"")"‖1
def __init__(self):‖self.__heap = [0]‖1
self.__heap = [0]‖self.__size = 0‖1
temporary = self.__heap[i]‖while i // 2 > 0:‖1
while i // 2 > 0:‖if self.__heap[i] > self.__heap[i // 2]:‖1
if self.__heap[i] > self.__heap[i // 2]:‖self.__heap[i] = self.__heap[i // 2]‖1
self.__heap[i] = self.__heap[i // 2]‖self.__heap[i // 2] = temporary‖1
self.__heap[i // 2] = temporary‖i //= 2‖1
self.__heap.append(value)‖self.__size += 1‖1
self.__size += 1‖self.__swap_up(self.__size)‖1
while self.__size >= 2 * i:‖if 2 * i + 1 > self.__size:‖1
if 2 * i + 1 > self.__size:‖bigger_child = 2 * i‖1
bigger_child = 2 * i‖elif self.__heap[2 * i] > self.__heap[2 * i + 1]:‖1
elif self.__heap[2 * i] > self.__heap[2 * i + 1]:‖bigger_child = 2 * i‖1
bigger_child = 2 * i‖else:‖1
else:‖bigger_child = 2 * i + 1‖1
bigger_child = 2 * i + 1‖temporary = self.__heap[i]‖1
temporary = self.__heap[i]‖if self.__heap[i] < self.__heap[bigger_child]:‖1
if self.__heap[i] < self.__heap[bigger_child]:‖self.__heap[i] = self.__heap[bigger_child]‖1
self.__heap[i] = self.__heap[bigger_child]‖self.__heap[bigger_child] = temporary‖1
self.__heap[bigger_child] = temporary‖i = bigger_child‖1
max_value = self.__heap[1]‖self.__heap[1] = self.__heap[self.__size]‖1
self.__heap[1] = self.__heap[self.__size]‖self.__size -= 1‖1
self.__size -= 1‖self.__heap.pop()‖1
self.__heap.pop()‖self.__swap_down(1)‖1
self.__swap_down(1)‖return max_value‖1
@property‖def get_list(self):‖1
def get_list(self):‖return self.__heap[1:]‖1
binary_heap = BinaryHeap()‖binary_heap.insert(6)‖1
binary_heap.insert(6)‖binary_heap.insert(10)‖1
binary_heap.insert(10)‖binary_heap.insert(15)‖1
binary_heap.insert(15)‖binary_heap.insert(12)‖1
print(binary_heap.pop())‖print(binary_heap.pop())‖1
print(binary_heap.get_list)‖print(len(binary_heap))‖1
assert isinstance(number, int) and (number >= 0), (‖"""'number' must been an int and positive"""‖2
"""'number' must been an int and positive"""‖)‖2
return True‖elif number < 2 or not number % 2:‖1
odd_numbers = range(3, int(math.sqrt(number) + 1), 2)‖return not any(not number % i for i in odd_numbers)‖1
def next_prime(value, factor=1, **kwargs):‖value = factor * value‖1
value = factor * value‖first_value_val = value‖1
while not is_prime(value):‖"value += 1 if not (""desc"" in kwargs and kwargs[""desc""] is True) else -1"‖1
if value == first_value_val:‖return next_prime(value + 1, **kwargs)‖1
return next_prime(value + 1, **kwargs)‖return value‖1
left = int(2 * i + 1)‖return left if 0 < left < self.size else None‖1
right = int(2 * i + 2)‖return right if 0 < right < self.size else None‖1
self.pos_map[self.arr[i][0]], self.pos_map[self.arr[j][0]] = (‖self.pos_map[self.arr[j][0]],‖1
self.pos_map[self.arr[j][0]],‖self.pos_map[self.arr[i][0]],‖1
self.pos_map[self.arr[i][0]],‖)‖1
left = self._left(i)‖right = self._right(i)‖1
right = self._right(i)‖valid_parent = i‖1
if left is not None and not self._cmp(left, valid_parent):‖valid_parent = left‖1
valid_parent = left‖if right is not None and not self._cmp(right, valid_parent):‖1
if right is not None and not self._cmp(right, valid_parent):‖valid_parent = right‖1
parent = self._parent(index)‖while parent is not None and not self._cmp(index, parent):‖1
while parent is not None and not self._cmp(index, parent):‖self._swap(index, parent)‖1
self._swap(index, parent)‖index, parent = parent, self._parent(parent)‖1
valid_parent = self._get_valid_parent(index)‖while valid_parent != index:‖1
while valid_parent != index:‖self._swap(index, valid_parent)‖1
self._swap(index, valid_parent)‖index, valid_parent = valid_parent, self._get_valid_parent(valid_parent)‖1
if item not in self.pos_map:‖return‖2
return‖index = self.pos_map[item]‖2
index = self.pos_map[item]‖self.arr[index] = [item, self.key(item_value)]‖1
self._heapify_up(index)‖self._heapify_down(index)‖2
index = self.pos_map[item]‖del self.pos_map[item]‖1
del self.pos_map[item]‖self.arr[index] = self.arr[self.size - 1]‖1
self.arr[index] = self.arr[self.size - 1]‖self.pos_map[self.arr[self.size - 1][0]] = index‖1
self.pos_map[self.arr[self.size - 1][0]] = index‖self.size -= 1‖1
if self.size > index:‖self._heapify_up(index)‖1
arr_len = len(self.arr)‖if arr_len == self.size:‖1
if arr_len == self.size:‖self.arr.append([item, self.key(item_value)])‖1
self.arr.append([item, self.key(item_value)])‖else:‖1
else:‖self.arr[self.size] = [item, self.key(item_value)]‖1
self.arr[self.size] = [item, self.key(item_value)]‖self.pos_map[item] = self.size‖1
self.pos_map[item] = self.size‖self.size += 1‖1
self.size += 1‖self._heapify_up(self.size - 1)‖1
top_item_tuple = self.get_top()‖if top_item_tuple:‖1
if top_item_tuple:‖self.delete_item(top_item_tuple[0])‖1
self.delete_item(top_item_tuple[0])‖return top_item_tuple‖1
def test_heap() -> None:‖pass‖1
import numpy as np‖import pytest‖4
from data_structures.kd_tree.example.hypercube_points import hypercube_points‖from data_structures.kd_tree.kd_node import KDNode‖1
from data_structures.kd_tree.kd_node import KDNode‖from data_structures.kd_tree.nearest_neighbour_search import nearest_neighbour_search‖1
@pytest.mark.parametrize(‖"(""num_points"", ""cube_size"", ""num_dimensions"", ""depth"", ""expected_result""),"‖1
"(""num_points"", ""cube_size"", ""num_dimensions"", ""depth"", ""expected_result""),"‖[‖1
[‖(0, 10.0, 2, 0, None),‖1
(0, 10.0, 2, 0, None),‖(10, 10.0, 2, 2, KDNode),‖1
(10, 10.0, 2, 2, KDNode),‖(10, 10.0, 3, -2, KDNode),‖1
(10, 10.0, 3, -2, KDNode),‖],‖1
)‖def test_build_kdtree(num_points, cube_size, num_dimensions, depth, expected_result):‖1
points = (‖hypercube_points(num_points, cube_size, num_dimensions).tolist()‖1
hypercube_points(num_points, cube_size, num_dimensions).tolist()‖if num_points > 0‖1
if num_points > 0‖else []‖1
else []‖)‖1
"assert kdtree is None, f""Expected None for empty points list, got {kdtree}"""‖else:‖1
assert len(kdtree.point) == num_dimensions, (‖"f""Expected point dimension {num_dimensions}, got {len(kdtree.point)}"""‖1
"f""Expected point dimension {num_dimensions}, got {len(kdtree.point)}"""‖)‖1
assert isinstance(kdtree, KDNode), (‖"f""Expected KDNode instance, got {type(kdtree)}"""‖1
"f""Expected KDNode instance, got {type(kdtree)}"""‖)‖1
num_points = 10‖cube_size = 10.0‖1
cube_size = 10.0‖num_dimensions = 2‖1
num_dimensions = 2‖points = hypercube_points(num_points, cube_size, num_dimensions)‖1
points = hypercube_points(num_points, cube_size, num_dimensions)‖kdtree = build_kdtree(points.tolist())‖1
rng = np.random.default_rng()‖query_point = rng.random(num_dimensions).tolist()‖1
nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(‖kdtree, query_point‖1
kdtree, query_point‖)‖1
empty_kdtree = build_kdtree([])‖query_point = [0.0] * 2‖1
nearest_point, nearest_dist, nodes_visited = nearest_neighbour_search(‖empty_kdtree, query_point‖1
empty_kdtree, query_point‖)‖1
assert nearest_point is None‖"assert nearest_dist == float(""inf"")"‖1
"assert nearest_dist == float(""inf"")"‖assert nodes_visited == 0‖1
"if __name__ == ""__main__"":"‖import pytest‖1
def nearest_neighbour_search(‖root: KDNode | None, query_point: list[float]‖1
root: KDNode | None, query_point: list[float]‖) -> tuple[list[float] | None, float, int]:‖1
nearest_point: list[float] | None = None‖"nearest_dist: float = float(""inf"")"‖1
"nearest_dist: float = float(""inf"")"‖nodes_visited: int = 0‖1
nonlocal nearest_point, nearest_dist, nodes_visited‖if node is None:‖1
current_point = node.point‖current_dist = sum(‖1
current_dist = sum(‖(query_coord - point_coord) ** 2‖1
(query_coord - point_coord) ** 2‖for query_coord, point_coord in zip(query_point, current_point)‖1
for query_coord, point_coord in zip(query_point, current_point)‖)‖1
if nearest_point is None or current_dist < nearest_dist:‖nearest_point = current_point‖1
nearest_point = current_point‖nearest_dist = current_dist‖1
k = len(query_point)‖axis = depth % k‖1
if query_point[axis] <= current_point[axis]:‖nearer_subtree = node.left‖1
nearer_subtree = node.left‖further_subtree = node.right‖1
further_subtree = node.right‖else:‖1
else:‖nearer_subtree = node.right‖1
nearer_subtree = node.right‖further_subtree = node.left‖1
if (query_point[axis] - current_point[axis]) ** 2 < nearest_dist:‖search(further_subtree, depth + 1)‖1
search(root, 0)‖return nearest_point, nearest_dist, nodes_visited‖1
class Node:‖def __init__(self, data):‖1
def __init__(self, data):‖self.data = data‖3
self.data = data‖self.previous = None‖1
self.previous = None‖self.next = None‖1
def __str__(self):‖"return f""{self.data}"""‖1
class DoublyLinkedList:‖def __init__(self):‖1
def __init__(self):‖self.head = None‖4
self.head = None‖self.tail = None‖2
def __iter__(self):‖node = self.head‖2
yield node.data‖node = node.next‖3
def __str__(self):‖"return ""->"".join([str(item) for item in self])"‖1
def __len__(self):‖return sum(1 for _ in self)‖1
def insert_at_head(self, data):‖self.insert_at_nth(0, data)‖1
def insert_at_tail(self, data):‖self.insert_at_nth(len(self), data)‖1
def insert_at_nth(self, index: int, data):‖length = len(self)‖1
if not 0 <= index <= length:‖"raise IndexError(""list index out of range"")"‖1
"raise IndexError(""list index out of range"")"‖new_node = Node(data)‖2
new_node = Node(data)‖if self.head is None:‖2
if self.head is None:‖self.head = self.tail = new_node‖1
self.head = self.tail = new_node‖elif index == 0:‖1
elif index == 0:‖self.head.previous = new_node‖1
self.head.previous = new_node‖new_node.next = self.head‖1
new_node.next = self.head‖self.head = new_node‖2
self.head = new_node‖elif index == length:‖1
elif index == length:‖self.tail.next = new_node‖1
self.tail.next = new_node‖new_node.previous = self.tail‖1
new_node.previous = self.tail‖self.tail = new_node‖1
self.tail = new_node‖else:‖1
else:‖temp = self.head‖4
temp = self.head‖for _ in range(index):‖2
for _ in range(index):‖temp = temp.next‖2
temp = temp.next‖temp.previous.next = new_node‖1
temp.previous.next = new_node‖new_node.previous = temp.previous‖1
new_node.previous = temp.previous‖new_node.next = temp‖1
new_node.next = temp‖temp.previous = new_node‖1
def delete_head(self):‖return self.delete_at_nth(0)‖1
def delete_tail(self):‖return self.delete_at_nth(len(self) - 1)‖1
def delete_at_nth(self, index: int):‖length = len(self)‖1
if not 0 <= index <= length - 1:‖"raise IndexError(""list index out of range"")"‖1
"raise IndexError(""list index out of range"")"‖delete_node = self.head‖1
delete_node = self.head‖if length == 1:‖1
if length == 1:‖self.head = self.tail = None‖1
elif index == 0:‖self.head = self.head.next‖1
self.head = self.head.next‖self.head.previous = None‖1
self.head.previous = None‖elif index == length - 1:‖1
elif index == length - 1:‖delete_node = self.tail‖1
delete_node = self.tail‖self.tail = self.tail.previous‖1
self.tail = self.tail.previous‖self.tail.next = None‖1
self.tail.next = None‖else:‖1
temp = temp.next‖delete_node = temp‖1
delete_node = temp‖temp.next.previous = temp.previous‖1
temp.next.previous = temp.previous‖temp.previous.next = temp.next‖1
temp.previous.next = temp.next‖return delete_node.data‖1
def delete(self, data) -> str:‖current = self.head‖1
while current.data != data:‖if current.next:‖1
if current.next:‖current = current.next‖1
current = current.next‖else:‖1
else:‖"raise ValueError(""No data matching given value"")"‖1
if current == self.head:‖self.delete_head()‖1
elif current == self.tail:‖self.delete_tail()‖1
else:‖current.previous.next = current.next‖1
current.previous.next = current.next‖current.next.previous = current.previous‖1
current.next.previous = current.previous‖return data‖1
def is_empty(self):‖return len(self) == 0‖1
def test_doubly_linked_list() -> None:‖linked_list = DoublyLinkedList()‖1
linked_list = DoublyLinkedList()‖assert linked_list.is_empty() is True‖1
assert linked_list.is_empty() is True‖"assert str(linked_list) == """""‖2
try:‖linked_list.delete_head()‖2
linked_list.delete_head()‖raise AssertionError‖2
try:‖linked_list.delete_tail()‖2
linked_list.delete_tail()‖raise AssertionError‖2
for i in range(10):‖assert len(linked_list) == i‖2
assert len(linked_list) == i‖linked_list.insert_at_nth(i, i + 1)‖1
linked_list.insert_at_nth(i, i + 1)‖"assert str(linked_list) == ""->"".join(str(i) for i in range(1, 11))"‖1
linked_list.insert_at_head(0)‖linked_list.insert_at_tail(11)‖1
linked_list.insert_at_tail(11)‖"assert str(linked_list) == ""->"".join(str(i) for i in range(12))"‖1
assert linked_list.delete_head() == 0‖assert linked_list.delete_at_nth(9) == 10‖1
assert linked_list.delete_at_nth(9) == 10‖assert linked_list.delete_tail() == 11‖1
assert linked_list.delete_tail() == 11‖assert len(linked_list) == 9‖2
assert len(linked_list) == 9‖"assert str(linked_list) == ""->"".join(str(i) for i in range(1, 10))"‖1
from collections.abc import Iterable, Iterator‖from typing import Any, Generic, TypeVar‖1
self._value: T = value‖self.left: SkewNode[T] | None = None‖1
self.left: SkewNode[T] | None = None‖self.right: SkewNode[T] | None = None‖1
def merge(‖root1: SkewNode[T] | None, root2: SkewNode[T] | None‖1
root1: SkewNode[T] | None, root2: SkewNode[T] | None‖) -> SkewNode[T] | None:‖1
result = root1‖temp = root1.right‖1
temp = root1.right‖result.right = root1.left‖1
result.right = root1.left‖result.left = SkewNode.merge(temp, root2)‖1
self._root: SkewNode[T] | None = None‖if data:‖1
result: list[Any] = []‖while self:‖1
for item in result:‖self.insert(item)‖1
result = self.top()‖self._root = (‖1
self._root = (‖SkewNode.merge(self._root.left, self._root.right) if self._root else None‖1
SkewNode.merge(self._root.left, self._root.right) if self._root else None‖)‖1
class _Node:‖"__slots__ = ""_data"", ""_next"", ""_prev"""‖1
def __init__(self, link_p, element, link_n):‖self._prev = link_p‖1
self._prev = link_p‖self._data = element‖1
self._data = element‖self._next = link_n‖1
def has_next_and_prev(self):‖return (‖1
return (‖"f"" Prev -> {self._prev is not None}, Next -> {self._next is not None}"""‖1
"f"" Prev -> {self._prev is not None}, Next -> {self._next is not None}"""‖)‖1
def __init__(self):‖self._header = self._Node(None, None, None)‖1
self._header = self._Node(None, None, None)‖self._trailer = self._Node(None, None, None)‖1
self._trailer = self._Node(None, None, None)‖self._header._next = self._trailer‖1
self._header._next = self._trailer‖self._trailer._prev = self._header‖1
self._trailer._prev = self._header‖self._size = 0‖1
def __len__(self):‖return self._size‖1
def is_empty(self):‖return self.__len__() == 0‖1
new_node = self._Node(predecessor, e, successor)‖predecessor._next = new_node‖1
predecessor._next = new_node‖successor._prev = new_node‖1
successor._prev = new_node‖self._size += 1‖1
self._size += 1‖return self‖1
def _delete(self, node):‖predecessor = node._prev‖1
predecessor = node._prev‖successor = node._next‖1
predecessor._next = successor‖successor._prev = predecessor‖1
successor._prev = predecessor‖self._size -= 1‖1
self._size -= 1‖temp = node._data‖1
temp = node._data‖node._prev = node._next = node._data = None‖1
node._prev = node._next = node._data = None‖del node‖1
del node‖return temp‖1
class LinkedDeque(_DoublyLinkedBase):‖def first(self):‖1
if self.is_empty():‖"raise Exception(""List is empty"")"‖2
"raise Exception(""List is empty"")"‖return self._header._next._data‖1
"raise Exception(""List is empty"")"‖return self._trailer._prev._data‖1
if self.is_empty():‖"raise IndexError(""remove_first from empty list"")"‖2
"raise IndexError(""remove_first from empty list"")"‖return self._delete(self._header._next)‖1
"raise IndexError(""remove_first from empty list"")"‖return self._delete(self._trailer._prev)‖1
from itertools import pairwise‖from random import random‖1
from random import random‖from typing import Generic, TypeVar‖1
"KT = TypeVar(""KT"")"‖"VT = TypeVar(""VT"")"‖1
class Node(Generic[KT, VT]):‖"def __init__(self, key: KT | str = ""root"", value: VT | None = None):"‖1
"def __init__(self, key: KT | str = ""root"", value: VT | None = None):"‖self.key = key‖1
self.key = key‖self.value = value‖1
self.value = value‖self.forward: list[Node[KT, VT]] = []‖1
@property‖def level(self) -> int:‖1
class SkipList(Generic[KT, VT]):‖def __init__(self, p: float = 0.5, max_level: int = 16):‖1
def __init__(self, p: float = 0.5, max_level: int = 16):‖self.head: Node[KT, VT] = Node[KT, VT]()‖1
self.head: Node[KT, VT] = Node[KT, VT]()‖self.level = 0‖1
self.level = 0‖self.p = p‖1
self.p = p‖self.max_level = max_level‖1
if len(items) == 0:‖"return f""SkipList(level={self.level})"""‖1
label_size = max((len(str(item)) for item in items), default=4)‖label_size = max(label_size, 4) + 4‖1
node = self.head‖lines = []‖1
forwards = node.forward.copy()‖"lines.append(f""[{node.key}]"".ljust(label_size, ""-"") + ""* "" * len(forwards))"‖1
"lines.append(f""[{node.key}]"".ljust(label_size, ""-"") + ""* "" * len(forwards))"‖"lines.append("" "" * label_size + ""| "" * len(forwards))"‖1
while len(node.forward) != 0:‖node = node.forward[0]‖1
lines.append(‖"f""[{node.key}]"".ljust(label_size, ""-"")"‖1
"f""[{node.key}]"".ljust(label_size, ""-"")"‖"+ "" "".join(str(n.key) if n.key == node.key else ""|"" for n in forwards)"‖1
"+ "" "".join(str(n.key) if n.key == node.key else ""|"" for n in forwards)"‖)‖1
)‖"lines.append("" "" * label_size + ""| "" * len(forwards))"‖1
"lines.append("" "" * label_size + ""| "" * len(forwards))"‖forwards[: node.level] = node.forward‖1
"lines.append(""None"".ljust(label_size) + ""* "" * len(forwards))"‖"return f""SkipList(level={self.level})\n"" + ""\n"".join(lines)"‖1
while len(node.forward) != 0:‖yield node.forward[0].key‖1
yield node.forward[0].key‖node = node.forward[0]‖1
level = 1‖while random() < self.p and level < self.max_level:‖1
while random() < self.p and level < self.max_level:‖level += 1‖1
while i < node.level and node.forward[i].key < key:‖node = node.forward[i]‖1
if len(node.forward) != 0 and node.forward[0].key == key:‖return node.forward[0], update_vector‖1
return node.forward[0], update_vector‖else:‖1
else:‖return None, update_vector‖1
if node is not None:‖for i, update_node in enumerate(update_vector):‖1
if update_node.level > i and update_node.forward[i].key == key:‖if node.level > i:‖1
if node.level > i:‖update_node.forward[i] = node.forward[i]‖1
update_node.forward[i] = node.forward[i]‖else:‖1
else:‖update_node.forward = update_node.forward[:i]‖1
node, update_vector = self._locate_node(key)‖if node is not None:‖1
if node is not None:‖node.value = value‖1
node.value = value‖else:‖1
else:‖level = self.random_level()‖1
for _ in range(self.level - 1, level):‖update_vector.append(self.head)‖1
update_vector.append(self.head)‖self.level = level‖1
if update_node.level > i:‖new_node.forward.append(update_node.forward[i])‖1
if update_node.level < i + 1:‖update_node.forward.append(new_node)‖1
update_node.forward.append(new_node)‖else:‖1
else:‖update_node.forward[i] = new_node‖1
if node is not None:‖return node.value‖1
def test_insert():‖skip_list = SkipList()‖1
skip_list = SkipList()‖"skip_list.insert(""Key1"", 3)"‖1
"skip_list.insert(""Key1"", 3)"‖"skip_list.insert(""Key2"", 12)"‖1
"skip_list.insert(""Key2"", 12)"‖"skip_list.insert(""Key3"", 41)"‖1
"skip_list.insert(""Key3"", 41)"‖"skip_list.insert(""Key4"", -19)"‖1
node = skip_list.head‖all_values = {}‖2
all_values = {}‖while node.level != 0:‖2
while node.level != 0:‖node = node.forward[0]‖2
node = node.forward[0]‖all_values[node.key] = node.value‖2
assert len(all_values) == 4‖"assert all_values[""Key1""] == 3"‖1
"assert all_values[""Key1""] == 3"‖"assert all_values[""Key2""] == 12"‖1
"assert all_values[""Key2""] == 12"‖"assert all_values[""Key3""] == 41"‖1
"assert all_values[""Key3""] == 41"‖"assert all_values[""Key4""] == -19"‖1
def test_insert_overrides_existing_value():‖skip_list = SkipList()‖1
skip_list = SkipList()‖"skip_list.insert(""Key1"", 10)"‖1
"skip_list.insert(""Key1"", 10)"‖"skip_list.insert(""Key1"", 12)"‖1
"skip_list.insert(""Key5"", 7)"‖"skip_list.insert(""Key7"", 10)"‖1
"skip_list.insert(""Key7"", 10)"‖"skip_list.insert(""Key10"", 5)"‖1
"skip_list.insert(""Key7"", 7)"‖"skip_list.insert(""Key5"", 5)"‖1
"skip_list.insert(""Key5"", 5)"‖"skip_list.insert(""Key10"", 10)"‖1
if len(all_values) != 4:‖print()‖1
print()‖assert len(all_values) == 4‖1
assert len(all_values) == 4‖"assert all_values[""Key1""] == 12"‖1
"assert all_values[""Key1""] == 12"‖"assert all_values[""Key7""] == 7"‖1
"assert all_values[""Key7""] == 7"‖"assert all_values[""Key5""] == 5"‖1
"assert all_values[""Key5""] == 5"‖"assert all_values[""Key10""] == 10"‖1
def test_searching_empty_list_returns_none():‖skip_list = SkipList()‖1
skip_list = SkipList()‖"assert skip_list.find(""Some key"") is None"‖1
def test_search():‖skip_list = SkipList()‖1
"skip_list.insert(""Key2"", 20)"‖"assert skip_list.find(""Key2"") == 20"‖1
"skip_list.insert(""Some Key"", 10)"‖"skip_list.insert(""Key2"", 8)"‖1
"skip_list.insert(""Key2"", 8)"‖"skip_list.insert(""V"", 13)"‖1
"assert skip_list.find(""Y"") is None"‖"assert skip_list.find(""Key2"") == 8"‖1
"assert skip_list.find(""Key2"") == 8"‖"assert skip_list.find(""Some Key"") == 10"‖1
"assert skip_list.find(""Some Key"") == 10"‖"assert skip_list.find(""V"") == 13"‖1
def test_deleting_item_from_empty_list_do_nothing():‖skip_list = SkipList()‖1
skip_list = SkipList()‖"skip_list.delete(""Some key"")"‖1
def test_deleted_items_are_not_founded_by_find_method():‖skip_list = SkipList()‖1
"skip_list.insert(""Key1"", 12)"‖"skip_list.insert(""V"", 13)"‖3
"skip_list.insert(""V"", 13)"‖"skip_list.insert(""X"", 14)"‖2
"skip_list.insert(""X"", 14)"‖"skip_list.insert(""Key2"", 15)"‖2
"skip_list.delete(""V"")"‖"skip_list.delete(""Key2"")"‖1
"assert skip_list.find(""V"") is None"‖"assert skip_list.find(""Key2"") is None"‖1
def test_delete_removes_only_given_key():‖skip_list = SkipList()‖1
"skip_list.delete(""V"")"‖"assert skip_list.find(""V"") is None"‖1
"assert skip_list.find(""V"") is None"‖"assert skip_list.find(""X"") == 14"‖1
"assert skip_list.find(""X"") == 14"‖"assert skip_list.find(""Key1"") == 12"‖1
"assert skip_list.find(""Key1"") == 12"‖"assert skip_list.find(""Key2"") == 15"‖2
"skip_list.delete(""X"")"‖"assert skip_list.find(""V"") is None"‖1
"assert skip_list.find(""V"") is None"‖"assert skip_list.find(""X"") is None"‖3
"assert skip_list.find(""X"") is None"‖"assert skip_list.find(""Key1"") == 12"‖1
"skip_list.delete(""Key1"")"‖"assert skip_list.find(""V"") is None"‖1
"assert skip_list.find(""X"") is None"‖"assert skip_list.find(""Key1"") is None"‖2
"assert skip_list.find(""Key1"") is None"‖"assert skip_list.find(""Key2"") == 15"‖1
"skip_list.delete(""Key2"")"‖"assert skip_list.find(""V"") is None"‖1
"assert skip_list.find(""Key1"") is None"‖"assert skip_list.find(""Key2"") is None"‖1
def test_delete_doesnt_leave_dead_nodes():‖skip_list = SkipList()‖1
"skip_list.insert(""V"", 13)"‖"skip_list.insert(""X"", 142)"‖1
"skip_list.insert(""X"", 142)"‖"skip_list.insert(""Key2"", 15)"‖1
def traverse_keys(node):‖yield node.key‖1
yield node.key‖for forward_node in node.forward:‖1
for forward_node in node.forward:‖yield from traverse_keys(forward_node)‖1
def test_iter_always_yields_sorted_values():‖def is_sorted(lst):‖1
def is_sorted(lst):‖return all(next_item >= item for item, next_item in pairwise(lst))‖1
skip_list = SkipList()‖for i in range(10):‖1
for i in range(10):‖skip_list.insert(i, i)‖1
skip_list.insert(i, i)‖assert is_sorted(list(skip_list))‖1
assert is_sorted(list(skip_list))‖skip_list.delete(5)‖1
skip_list.delete(5)‖skip_list.delete(8)‖1
skip_list.delete(8)‖skip_list.delete(2)‖1
skip_list.delete(2)‖assert is_sorted(list(skip_list))‖1
assert is_sorted(list(skip_list))‖skip_list.insert(-12, -12)‖1
skip_list.insert(-12, -12)‖skip_list.insert(77, 77)‖1
skip_list.insert(77, 77)‖assert is_sorted(list(skip_list))‖1
def pytests():‖for _ in range(100):‖1
test_insert()‖test_insert_overrides_existing_value()‖1
test_searching_empty_list_returns_none()‖test_search()‖1
test_deleting_item_from_empty_list_do_nothing()‖test_deleted_items_are_not_founded_by_find_method()‖1
test_deleted_items_are_not_founded_by_find_method()‖test_delete_removes_only_given_key()‖1
test_delete_removes_only_given_key()‖test_delete_doesnt_leave_dead_nodes()‖1
skip_list = SkipList()‖"skip_list.insert(2, ""2"")"‖1
"skip_list.insert(2, ""2"")"‖"skip_list.insert(4, ""4"")"‖1
"skip_list.insert(4, ""4"")"‖"skip_list.insert(6, ""4"")"‖1
"skip_list.insert(6, ""4"")"‖"skip_list.insert(4, ""5"")"‖1
"skip_list.insert(4, ""5"")"‖"skip_list.insert(8, ""4"")"‖1
"skip_list.insert(8, ""4"")"‖"skip_list.insert(9, ""4"")"‖1
class Node:‖def __init__(self, data: int, previous=None, next_node=None):‖1
def __init__(self, data: int, previous=None, next_node=None):‖self.data = data‖1
self.data = data‖self.previous = previous‖1
self.previous = previous‖self.next = next_node‖1
def __str__(self) -> str:‖"return f""{self.data}"""‖3
def get_data(self) -> int:‖return self.data‖1
def get_next(self):‖return self.next‖1
def get_previous(self):‖return self.previous‖1
class LinkedListIterator:‖def __init__(self, head):‖1
def __init__(self, head):‖self.current = head‖1
def __iter__(self):‖return self‖1
def __next__(self):‖if not self.current:‖1
if not self.current:‖raise StopIteration‖1
raise StopIteration‖else:‖1
else:‖value = self.current.get_data()‖1
value = self.current.get_data()‖self.current = self.current.get_next()‖1
self.current = self.current.get_next()‖return value‖1
class LinkedList:‖def __init__(self):‖3
def __str__(self):‖current = self.head‖1
current = self.head‖nodes = []‖1
nodes = []‖while current is not None:‖1
while current is not None:‖nodes.append(current.get_data())‖1
nodes.append(current.get_data())‖current = current.get_next()‖1
current = current.get_next()‖"return "" "".join(str(node) for node in nodes)"‖1
def __contains__(self, value: int):‖current = self.head‖1
current = self.head‖while current:‖1
while current:‖if current.get_data() == value:‖1
if current.get_data() == value:‖return True‖1
return True‖current = current.get_next()‖1
current = current.get_next()‖return False‖1
def __iter__(self):‖return LinkedListIterator(self.head)‖1
def get_head_data(self):‖if self.head:‖1
if self.head:‖return self.head.get_data()‖1
return self.head.get_data()‖return None‖1
def get_tail_data(self):‖if self.tail:‖1
if self.tail:‖return self.tail.get_data()‖1
return self.tail.get_data()‖return None‖1
def set_head(self, node: Node) -> None:‖if self.head is None:‖1
if self.head is None:‖self.head = node‖1
self.head = node‖self.tail = node‖1
self.tail = node‖else:‖1
else:‖self.insert_before_node(self.head, node)‖1
def set_tail(self, node: Node) -> None:‖if self.head is None:‖1
if self.head is None:‖self.set_head(node)‖2
self.set_head(node)‖else:‖2
else:‖self.insert_after_node(self.tail, node)‖1
def insert(self, value: int) -> None:‖node = Node(value)‖1
node = Node(value)‖if self.head is None:‖1
else:‖self.set_tail(node)‖1
def insert_before_node(self, node: Node, node_to_insert: Node) -> None:‖node_to_insert.next = node‖1
node_to_insert.next = node‖node_to_insert.previous = node.previous‖1
if node.get_previous() is None:‖self.head = node_to_insert‖1
self.head = node_to_insert‖else:‖1
else:‖node.previous.next = node_to_insert‖1
def insert_after_node(self, node: Node, node_to_insert: Node) -> None:‖node_to_insert.previous = node‖1
node_to_insert.previous = node‖node_to_insert.next = node.next‖1
if node.get_next() is None:‖self.tail = node_to_insert‖1
self.tail = node_to_insert‖else:‖1
else:‖node.next.previous = node_to_insert‖1
def insert_at_position(self, position: int, value: int) -> None:‖current_position = 1‖1
current_position = 1‖new_node = Node(value)‖1
new_node = Node(value)‖node = self.head‖1
while node:‖if current_position == position:‖1
if current_position == position:‖self.insert_before_node(node, new_node)‖1
self.insert_before_node(node, new_node)‖return‖1
return‖current_position += 1‖1
current_position += 1‖node = node.next‖1
node = node.next‖self.insert_after_node(self.tail, new_node)‖1
def get_node(self, item: int) -> Node:‖node = self.head‖1
while node:‖if node.get_data() == item:‖1
if node.get_data() == item:‖return node‖1
return node‖node = node.get_next()‖1
node = node.get_next()‖"raise Exception(""Node not found"")"‖1
def delete_value(self, value):‖if (node := self.get_node(value)) is not None:‖1
if (node := self.get_node(value)) is not None:‖if node == self.head:‖1
if node == self.head:‖self.head = self.head.get_next()‖1
if node == self.tail:‖self.tail = self.tail.get_previous()‖1
@staticmethod‖def remove_node_pointers(node: Node) -> None:‖1
def remove_node_pointers(node: Node) -> None:‖if node.get_next():‖1
if node.get_next():‖node.next.previous = node.previous‖1
if node.get_previous():‖node.previous.next = node.next‖1
node.next = None‖node.previous = None‖1
def is_empty(self):‖return self.head is None‖1
def create_linked_list() -> None:‖pass‖1
data: Any‖next_node: Self | None = None‖1
@dataclass‖class LinkedList:‖2
def __iter__(self) -> Iterator:‖visited = []‖1
visited = []‖node = self.head‖1
if node in visited:‖return‖1
return‖visited.append(node)‖1
visited.append(node)‖yield node.data‖1
def add_node(self, data: Any) -> None:‖new_node = Node(data)‖1
if self.head is None:‖self.head = new_node‖2
self.head = new_node‖return‖1
current_node = self.head‖while current_node.next_node is not None:‖1
while current_node.next_node is not None:‖current_node = current_node.next_node‖1
def detect_cycle(self) -> bool:‖if self.head is None:‖1
if self.head is None:‖return False‖1
slow_pointer: Node | None = self.head‖fast_pointer: Node | None = self.head‖1
while fast_pointer is not None and fast_pointer.next_node is not None:‖slow_pointer = slow_pointer.next_node if slow_pointer else None‖1
slow_pointer = slow_pointer.next_node if slow_pointer else None‖fast_pointer = fast_pointer.next_node.next_node‖1
fast_pointer = fast_pointer.next_node.next_node‖if slow_pointer == fast_pointer:‖1
if slow_pointer == fast_pointer:‖return True‖1
linked_list = LinkedList()‖linked_list.add_node(1)‖1
linked_list.add_node(1)‖linked_list.add_node(2)‖1
linked_list.add_node(2)‖linked_list.add_node(3)‖1
linked_list.add_node(3)‖linked_list.add_node(4)‖1
if (‖linked_list.head‖1
linked_list.head‖and linked_list.head.next_node‖1
and linked_list.head.next_node‖and linked_list.head.next_node.next_node‖1
and linked_list.head.next_node.next_node‖):‖1
):‖linked_list.head.next_node.next_node.next_node = linked_list.head.next_node‖1
has_cycle = linked_list.detect_cycle()‖print(has_cycle)‖1
class Queue:‖def __init__(self):‖1
def __init__(self):‖self.stack = []‖1
self.stack = []‖self.length = 0‖1
def __str__(self):‖"printed = ""<"" + str(self.stack)[1:-1] + "">"""‖1
"printed = ""<"" + str(self.stack)[1:-1] + "">"""‖return printed‖1
def size(self) -> int:‖return self.length‖1
data: int‖next_node: Node | None = None‖3
def __init__(self) -> None:‖self.head: Node | None = None‖2
self.head: Node | None = None‖self.tail: Node | None = None‖1
def __iter__(self) -> Iterator[int]:‖node = self.head‖3
def __repr__(self) -> str:‖"return "" -> "".join([str(data) for data in self])"‖1
def append(self, data: int) -> None:‖if self.tail:‖1
if self.tail:‖self.tail.next_node = self.tail = Node(data)‖1
self.tail.next_node = self.tail = Node(data)‖else:‖1
else:‖self.head = self.tail = Node(data)‖1
def extend(self, items: Iterable[int]) -> None:‖for item in items:‖1
for item in items:‖self.append(item)‖1
def make_linked_list(elements_list: Iterable[int]) -> LinkedList:‖if not elements_list:‖1
if not elements_list:‖"raise Exception(""The Elements List is empty"")"‖1
linked_list = LinkedList()‖linked_list.extend(elements_list)‖1
linked_list.extend(elements_list)‖return linked_list‖1
def in_reverse(linked_list: LinkedList) -> str:‖"return "" <- "".join(str(line) for line in reversed(tuple(linked_list)))"‖1
testmod()‖linked_list = make_linked_list((14, 52, 14, 12, 43))‖1
linked_list = make_linked_list((14, 52, 14, 12, 43))‖"print(f""Linked List:  {linked_list}"")"‖1
"print(f""Linked List:  {linked_list}"")"‖"print(f""Reverse List: {in_reverse(linked_list)}"")"‖1
def hypercube_points(‖num_points: int, hypercube_size: float, num_dimensions: int‖1
num_points: int, hypercube_size: float, num_dimensions: int‖) -> np.ndarray:‖1
rng = np.random.default_rng()‖shape = (num_points, num_dimensions)‖1
shape = (num_points, num_dimensions)‖return hypercube_size * rng.random(shape)‖1
self.data = data‖self.next = None‖2
def push(self, new_data: int) -> int:‖new_node = Node(new_data)‖1
new_node = Node(new_data)‖new_node.next = self.head‖1
self.head = new_node‖return self.head.data‖1
def middle_element(self) -> int | None:‖slow_pointer = self.head‖1
slow_pointer = self.head‖fast_pointer = self.head‖1
fast_pointer = self.head‖if self.head:‖1
if self.head:‖while fast_pointer and fast_pointer.next:‖1
while fast_pointer and fast_pointer.next:‖fast_pointer = fast_pointer.next.next‖1
fast_pointer = fast_pointer.next.next‖slow_pointer = slow_pointer.next‖1
slow_pointer = slow_pointer.next‖return slow_pointer.data‖1
return slow_pointer.data‖else:‖1
else:‖"print(""No element found."")"‖1
"print(""No element found."")"‖return None‖1
"if __name__ == ""__main__"":"‖link = LinkedList()‖1
link = LinkedList()‖for _ in range(int(input().strip())):‖1
for _ in range(int(input().strip())):‖data = int(input().strip())‖1
data = int(input().strip())‖link.push(data)‖1
link.push(data)‖print(link.middle_element())‖1
class LinkedList:‖def __init__(self, ints: Iterable[int]) -> None:‖1
def __init__(self, ints: Iterable[int]) -> None:‖self.head: Node | None = None‖2
self.head: Node | None = None‖for i in ints:‖1
for i in ints:‖self.append(i)‖1
def __str__(self) -> str:‖"return "" -> "".join([str(node) for node in self])"‖2
def append(self, data: int) -> None:‖if not self.head:‖1
if not self.head:‖self.head = Node(data)‖1
self.head = Node(data)‖return‖1
return‖node = self.head‖1
node = self.head‖while node.next_node:‖1
while node.next_node:‖node = node.next_node‖1
node = node.next_node‖node.next_node = Node(data)‖1
def reverse_k_nodes(self, group_size: int) -> None:‖if self.head is None or self.head.next_node is None:‖1
if self.head is None or self.head.next_node is None:‖return‖1
length = len(self)‖dummy_head = Node(0)‖1
dummy_head = Node(0)‖dummy_head.next_node = self.head‖1
dummy_head.next_node = self.head‖previous_node = dummy_head‖1
while length >= group_size:‖current_node = previous_node.next_node‖1
current_node = previous_node.next_node‖assert current_node‖1
assert current_node‖next_node = current_node.next_node‖1
next_node = current_node.next_node‖for _ in range(1, group_size):‖1
for _ in range(1, group_size):‖assert next_node, current_node‖1
assert next_node, current_node‖current_node.next_node = next_node.next_node‖1
current_node.next_node = next_node.next_node‖assert previous_node‖1
assert previous_node‖next_node.next_node = previous_node.next_node‖1
next_node.next_node = previous_node.next_node‖previous_node.next_node = next_node‖1
previous_node.next_node = next_node‖next_node = current_node.next_node‖1
next_node = current_node.next_node‖previous_node = current_node‖1
previous_node = current_node‖length -= group_size‖1
length -= group_size‖self.head = dummy_head.next_node‖1
doctest.testmod()‖ll = LinkedList([1, 2, 3, 4, 5])‖1
ll = LinkedList([1, 2, 3, 4, 5])‖"print(f""Original Linked List: {ll}"")"‖1
"print(f""Original Linked List: {ll}"")"‖k = 2‖1
k = 2‖ll.reverse_k_nodes(k)‖1
ll.reverse_k_nodes(k)‖"print(f""After reversing groups of size {k}: {ll}"")"‖1
test_data_odd = (3, 9, -11, 0, 7, 5, 1, -1)‖test_data_even = (4, 6, 2, 0, 8, 10, 3, -2)‖1
data: int‖next_node: Node | None‖1
class SortedLinkedList:‖def __init__(self, ints: Iterable[int]) -> None:‖1
self.head: Node | None = None‖for i in sorted(ints, reverse=True):‖1
for i in sorted(ints, reverse=True):‖self.head = Node(i, self.head)‖1
def merge_lists(‖sll_one: SortedLinkedList, sll_two: SortedLinkedList‖1
sll_one: SortedLinkedList, sll_two: SortedLinkedList‖) -> SortedLinkedList:‖1
) -> SortedLinkedList:‖return SortedLinkedList(list(sll_one) + list(sll_two))‖1
doctest.testmod()‖SSL = SortedLinkedList‖1
SSL = SortedLinkedList‖print(merge_lists(SSL(test_data_odd), SSL(test_data_even)))‖1
class LinkedList:‖head: Node | None = None‖1
def __iter__(self) -> Iterator:‖node = self.head‖1
def push(self, new_data: Any) -> None:‖new_node = Node(new_data)‖1
new_node = Node(new_data)‖new_node.next_node = self.head‖1
new_node.next_node = self.head‖self.head = new_node‖2
def swap_nodes(self, node_data_1: Any, node_data_2: Any) -> None:‖if node_data_1 == node_data_2:‖1
if node_data_1 == node_data_2:‖return‖1
node_1 = self.head‖while node_1 and node_1.data != node_data_1:‖1
while node_1 and node_1.data != node_data_1:‖node_1 = node_1.next_node‖1
node_1 = node_1.next_node‖node_2 = self.head‖1
node_2 = self.head‖while node_2 and node_2.data != node_data_2:‖1
while node_2 and node_2.data != node_data_2:‖node_2 = node_2.next_node‖1
node_2 = node_2.next_node‖if node_1 is None or node_2 is None:‖1
if node_1 is None or node_2 is None:‖return‖1
testmod()‖linked_list = LinkedList()‖1
linked_list = LinkedList()‖for i in range(5, 0, -1):‖1
for i in range(5, 0, -1):‖linked_list.push(i)‖1
"print(f""Original Linked List: {list(linked_list)}"")"‖linked_list.swap_nodes(1, 4)‖1
linked_list.swap_nodes(1, 4)‖"print(f""Modified Linked List: {list(linked_list)}"")"‖1
"print(f""Modified Linked List: {list(linked_list)}"")"‖"print(""After swapping the nodes whose data is 1 and 4."")"‖1
@dataclass‖class ListNode:‖1
class ListNode:‖val: int = 0‖1
val: int = 0‖next_node: ListNode | None = None‖1
def is_palindrome(head: ListNode | None) -> bool:‖if not head:‖1
if not head:‖return True‖1
fast: ListNode | None = head.next_node‖slow: ListNode | None = head‖1
slow: ListNode | None = head‖while fast and fast.next_node:‖1
while fast and fast.next_node:‖fast = fast.next_node.next_node‖2
fast = fast.next_node.next_node‖slow = slow.next_node if slow else None‖2
slow = slow.next_node if slow else None‖if slow:‖1
second = slow.next_node‖slow.next_node = None‖1
node: ListNode | None = None‖while second:‖1
while second:‖nxt = second.next_node‖1
nxt = second.next_node‖second.next_node = node‖1
second.next_node = node‖node = second‖1
node = second‖second = nxt‖1
while node and head:‖if node.val != head.val:‖1
if node.val != head.val:‖return False‖1
return False‖node = node.next_node‖1
node = node.next_node‖head = head.next_node‖1
head = head.next_node‖return True‖1
def is_palindrome_stack(head: ListNode | None) -> bool:‖if not head or not head.next_node:‖1
if not head or not head.next_node:‖return True‖2
slow: ListNode | None = head‖fast: ListNode | None = head‖1
fast: ListNode | None = head‖while fast and fast.next_node:‖1
if slow:‖stack = [slow.val]‖1
while slow.next_node:‖slow = slow.next_node‖1
slow = slow.next_node‖stack.append(slow.val)‖1
cur: ListNode | None = head‖while stack and cur:‖1
while stack and cur:‖if stack.pop() != cur.val:‖1
if stack.pop() != cur.val:‖return False‖1
return False‖cur = cur.next_node‖1
def is_palindrome_dict(head: ListNode | None) -> bool:‖if not head or not head.next_node:‖1
return True‖d: dict[int, list[int]] = {}‖1
d: dict[int, list[int]] = {}‖pos = 0‖1
pos = 0‖while head:‖1
while head:‖if head.val in d:‖1
if head.val in d:‖d[head.val].append(pos)‖1
d[head.val].append(pos)‖else:‖1
else:‖d[head.val] = [pos]‖1
d[head.val] = [pos]‖head = head.next_node‖1
head = head.next_node‖pos += 1‖1
pos += 1‖checksum = pos - 1‖1
checksum = pos - 1‖middle = 0‖1
middle = 0‖for v in d.values():‖1
for v in d.values():‖if len(v) % 2 != 0:‖1
if len(v) % 2 != 0:‖middle += 1‖1
middle += 1‖else:‖1
else:‖for step, i in enumerate(range(len(v))):‖1
for step, i in enumerate(range(len(v))):‖if v[i] + v[len(v) - 1 - step] != checksum:‖1
if v[i] + v[len(v) - 1 - step] != checksum:‖return False‖1
return False‖if middle > 1:‖1
if middle > 1:‖return False‖1
def print_linked_list(head: Node | None) -> None:‖if head is None:‖1
if head is None:‖return‖1
return‖while head.next_node is not None:‖1
while head.next_node is not None:‖"print(head.data, end=""->"")"‖1
"print(head.data, end=""->"")"‖head = head.next_node‖1
head = head.next_node‖print(head.data)‖1
def insert_node(head: Node | None, data: int) -> Node:‖new_node = Node(data)‖1
if head is None:‖return new_node‖1
temp_node = head‖while temp_node.next_node:‖1
while temp_node.next_node:‖temp_node = temp_node.next_node‖2
temp_node.next_node = new_node‖return head‖1
if not head:‖"raise ValueError(""The linked list is empty."")"‖1
if head.next_node is None:‖return head‖1
length = 1‖temp_node = head‖1
temp_node = head‖while temp_node.next_node is not None:‖1
while temp_node.next_node is not None:‖length += 1‖1
length += 1‖temp_node = temp_node.next_node‖1
if places == 0:‖return head‖1
temp_node = head‖for _ in range(new_head_index - 1):‖1
for _ in range(new_head_index - 1):‖assert temp_node.next_node‖1
assert temp_node.next_node‖temp_node = temp_node.next_node‖1
assert temp_node.next_node‖new_head = temp_node.next_node‖1
new_head = temp_node.next_node‖temp_node.next_node = None‖1
temp_node.next_node = None‖temp_node = new_head‖1
temp_node = new_head‖while temp_node.next_node:‖1
temp_node = temp_node.next_node‖temp_node.next_node = head‖1
assert new_head‖return new_head‖1
doctest.testmod()‖head = insert_node(None, 5)‖1
head = insert_node(None, 5)‖head = insert_node(head, 1)‖1
head = insert_node(head, 1)‖head = insert_node(head, 2)‖1
head = insert_node(head, 2)‖head = insert_node(head, 4)‖1
head = insert_node(head, 4)‖head = insert_node(head, 3)‖1
"print(""Original list: "", end="""")"‖print_linked_list(head)‖1
places = 3‖new_head = rotate_to_the_right(head, places)‖1
"print(f""After {places} iterations: "", end="""")"‖print_linked_list(new_head)‖1
class Node:‖def __init__(self, data=None):‖1
def __init__(self, data=None):‖self.data = data‖1
def __repr__(self):‖"string_rep = """""‖1
"string_rep = """""‖temp = self‖1
temp = self‖while temp:‖1
while temp:‖"string_rep += f""<{temp.data}> ---> """‖1
"string_rep += f""<{temp.data}> ---> """‖temp = temp.next‖1
temp = temp.next‖"string_rep += ""<END>"""‖1
"string_rep += ""<END>"""‖return string_rep‖1
def make_linked_list(elements_list):‖pass‖1
from collections.abc import Iterable‖from typing import Generic, TypeVar‖2
class QueueByTwoStacks(Generic[_T]):‖def __init__(self, iterable: Iterable[_T] | None = None) -> None:‖1
def __init__(self, iterable: Iterable[_T] | None = None) -> None:‖self._stack1: list[_T] = list(iterable or [])‖1
self._stack1: list[_T] = list(iterable or [])‖self._stack2: list[_T] = []‖1
def __repr__(self) -> str:‖"return f""Queue({tuple(self._stack2[::-1] + self._stack1)})"""‖1
stack1_pop = self._stack1.pop‖stack2_append = self._stack2.append‖1
if not self._stack2:‖while self._stack1:‖1
while self._stack1:‖stack2_append(stack1_pop())‖1
if not self._stack2:‖"raise IndexError(""Queue is empty"")"‖1
"raise IndexError(""Queue is empty"")"‖return self._stack2.pop()‖1
class ContainsLoopError(Exception):‖pass‖1
class Node:‖def __init__(self, data: Any) -> None:‖2
def __init__(self, data: Any) -> None:‖self.data: Any = data‖2
self.data: Any = data‖self.next_node: Node | None = None‖1
def __iter__(self):‖node = self‖1
node = self‖visited = set()‖1
visited = set()‖while node:‖1
while node:‖if node in visited:‖1
if node in visited:‖raise ContainsLoopError‖1
raise ContainsLoopError‖visited.add(node)‖1
visited.add(node)‖yield node.data‖1
@property‖def has_loop(self) -> bool:‖1
def has_loop(self) -> bool:‖try:‖1
try:‖list(self)‖1
list(self)‖return False‖1
return False‖except ContainsLoopError:‖1
except ContainsLoopError:‖return True‖1
"if __name__ == ""__main__"":"‖root_node = Node(1)‖1
root_node = Node(1)‖root_node.next_node = Node(2)‖1
root_node.next_node = Node(2)‖root_node.next_node.next_node = Node(3)‖1
root_node.next_node.next_node = Node(3)‖root_node.next_node.next_node.next_node = Node(4)‖1
root_node.next_node.next_node.next_node = Node(4)‖print(root_node.has_loop)‖1
print(root_node.has_loop)‖root_node.next_node.next_node.next_node = root_node.next_node‖1
root_node.next_node.next_node.next_node = root_node.next_node‖print(root_node.has_loop)‖1
root_node = Node(5)‖root_node.next_node = Node(6)‖1
root_node.next_node = Node(6)‖root_node.next_node.next_node = Node(5)‖1
root_node.next_node.next_node = Node(5)‖root_node.next_node.next_node.next_node = Node(6)‖1
root_node.next_node.next_node.next_node = Node(6)‖print(root_node.has_loop)‖1
root_node = Node(1)‖print(root_node.has_loop)‖1
class Node:‖def __init__(self, item: Any, next: Any) -> None:‖1
def __init__(self, item: Any, next: Any) -> None:‖self.item = item‖1
self.item = item‖self.next = next‖1
class LinkedList:‖def __init__(self) -> None:‖1
self.head: Node | None = None‖self.size = 0‖1
if position < 0:‖"raise ValueError(""Position must be non-negative"")"‖1
if position == 0 or self.head is None:‖new_node = Node(item, self.head)‖1
new_node = Node(item, self.head)‖self.head = new_node‖1
self.head = new_node‖else:‖2
else:‖current = self.head‖1
current = self.head‖for _ in range(position - 1):‖1
for _ in range(position - 1):‖current = current.next‖1
current = current.next‖if current is None:‖1
if current is None:‖"raise ValueError(""Out of bounds"")"‖1
"raise ValueError(""Out of bounds"")"‖new_node = Node(item, current.next)‖1
new_node = Node(item, current.next)‖current.next = new_node‖1
current.next = new_node‖self.size += 1‖1
if self.head is None:‖return None‖2
else:‖item = self.head.item‖1
item = self.head.item‖self.head = self.head.next‖1
self.head = self.head.next‖self.size -= 1‖1
self.size -= 1‖return item‖1
def is_empty(self) -> bool:‖return self.head is None‖3
"return """""‖else:‖1
else:‖iterate = self.head‖1
iterate = self.head‖"item_str = """""‖1
"item_str = """""‖item_list: list[str] = []‖1
item_list: list[str] = []‖while iterate:‖1
while iterate:‖item_list.append(str(iterate.item))‖1
item_list.append(str(iterate.item))‖iterate = iterate.next‖1
from collections.abc import Iterable‖from dataclasses import dataclass‖1
@dataclass‖class _Node:‖1
val: Any = None‖next_node: Deque._Node | None = None‖1
next_node: Deque._Node | None = None‖prev_node: Deque._Node | None = None‖1
def __init__(self, cur: Deque._Node | None) -> None:‖self._cur = cur‖1
def __iter__(self) -> Deque._Iterator:‖return self‖1
def __next__(self) -> Any:‖if self._cur is None:‖1
raise StopIteration‖val = self._cur.val‖1
val = self._cur.val‖self._cur = self._cur.next_node‖1
def __init__(self, iterable: Iterable[Any] | None = None) -> None:‖self._front: Any = None‖1
self._front: Any = None‖self._back: Any = None‖1
self._back: Any = None‖self._len: int = 0‖1
for val in iterable:‖self.append(val)‖2
def append(self, val: Any) -> None:‖node = self._Node(val, None, None)‖1
node = self._Node(val, None, None)‖if self.is_empty():‖2
self._front = self._back = node‖self._len = 1‖2
self._len = 1‖else:‖2
self._back.next_node = node‖node.prev_node = self._back‖1
node.prev_node = self._back‖self._back = node‖1
def appendleft(self, val: Any) -> None:‖node = self._Node(val, None, None)‖1
node.next_node = self._front‖self._front.prev_node = node‖1
self._front.prev_node = node‖self._front = node‖1
def extend(self, iterable: Iterable[Any]) -> None:‖for val in iterable:‖1
def extendleft(self, iterable: Iterable[Any]) -> None:‖for val in iterable:‖1
for val in iterable:‖self.appendleft(val)‖1
if self._front == self._back:‖self._front = None‖2
self._front = None‖self._back = None‖2
self._back = None‖else:‖2
else:‖self._back = self._back.prev_node‖1
else:‖self._front = self._front.next_node‖1
self._front = self._front.next_node‖self._front.prev_node = None‖1
def is_empty(self) -> bool:‖return self._front is None‖1
def __len__(self) -> int:‖return self._len‖1
if not isinstance(other, Deque):‖return NotImplemented‖1
me = self._front‖oth = other._front‖1
if len(self) != len(other):‖return False‖2
if me.val != oth.val:‖return False‖1
return False‖me = me.next_node‖1
me = me.next_node‖oth = oth.next_node‖1
def __iter__(self) -> Deque._Iterator:‖return Deque._Iterator(self._front)‖1
def __repr__(self) -> str:‖values_list = []‖1
values_list = []‖aux = self._front‖1
aux = self._front‖while aux is not None:‖1
values_list.append(aux.val)‖aux = aux.next_node‖1
doctest.testmod()‖dq = Deque([3])‖1
dq = Deque([3])‖dq.pop()‖1
class QueueByList(Generic[_T]):‖def __init__(self, iterable: Iterable[_T] | None = None) -> None:‖1
def __init__(self, iterable: Iterable[_T] | None = None) -> None:‖self.entries: list[_T] = list(iterable or [])‖1
if not self.entries:‖"raise IndexError(""Queue is empty"")"‖1
"raise IndexError(""Queue is empty"")"‖return self.entries.pop(0)‖1
put = self.entries.append‖get = self.entries.pop‖1
for _ in range(rotation):‖put(get(0))‖1
from .balanced_parentheses import balanced_parentheses‖from .stack import Stack‖1
PRECEDENCES: dict[str, int] = {‖"""+"": 1,"‖1
"""+"": 1,"‖"""-"": 1,"‖2
"""-"": 1,"‖"""*"": 2,"‖1
"""*"": 2,"‖"""/"": 2,"‖2
"""/"": 2,"‖"""^"": 3,"‖1
"""^"": 3,"‖}‖1
}‖"ASSOCIATIVITIES: dict[str, Literal[""LR"", ""RL""]] = {"‖1
"ASSOCIATIVITIES: dict[str, Literal[""LR"", ""RL""]] = {"‖"""+"": ""LR"","‖1
"""+"": ""LR"","‖"""-"": ""LR"","‖1
"""-"": ""LR"","‖"""*"": ""LR"","‖1
"""*"": ""LR"","‖"""/"": ""LR"","‖1
"""/"": ""LR"","‖"""^"": ""RL"","‖1
"""^"": ""RL"","‖}‖1
def precedence(char: str) -> int:‖return PRECEDENCES.get(char, -1)‖1
"def associativity(char: str) -> Literal[""LR"", ""RL""]:"‖return ASSOCIATIVITIES[char]‖1
def infix_to_postfix(expression_str: str) -> str:‖if not balanced_parentheses(expression_str):‖1
if not balanced_parentheses(expression_str):‖"raise ValueError(""Mismatched parentheses"")"‖1
"raise ValueError(""Mismatched parentheses"")"‖stack: Stack[str] = Stack()‖1
stack: Stack[str] = Stack()‖postfix = []‖1
postfix = []‖for char in expression_str:‖1
for char in expression_str:‖if char.isalpha() or char.isdigit():‖1
if char.isalpha() or char.isdigit():‖postfix.append(char)‖1
postfix.append(char)‖"elif char == ""("":"‖1
"elif char == ""("":"‖stack.push(char)‖1
stack.push(char)‖"elif char == "")"":"‖1
"elif char == "")"":"‖"while not stack.is_empty() and stack.peek() != ""("":"‖1
"while not stack.is_empty() and stack.peek() != ""("":"‖postfix.append(stack.pop())‖1
postfix.append(stack.pop())‖stack.pop()‖1
stack.pop()‖else:‖1
else:‖while True:‖1
while True:‖if stack.is_empty():‖1
if stack.is_empty():‖stack.push(char)‖1
stack.push(char)‖break‖3
char_precedence = precedence(char)‖tos_precedence = precedence(stack.peek())‖1
if char_precedence > tos_precedence:‖stack.push(char)‖1
break‖if char_precedence < tos_precedence:‖1
if char_precedence < tos_precedence:‖postfix.append(stack.pop())‖1
postfix.append(stack.pop())‖continue‖1
"if associativity(char) == ""RL"":"‖stack.push(char)‖1
break‖postfix.append(stack.pop())‖1
while not stack.is_empty():‖postfix.append(stack.pop())‖1
postfix.append(stack.pop())‖"return "" "".join(postfix)"‖1
testmod()‖"expression = ""a+b*(c^d-e)^(f+g*h)-i"""‖1
"print(""Infix to Postfix Notation demonstration:\n"")"‖"print(""Infix notation: "" + expression)"‖1
"print(""Infix notation: "" + expression)"‖"print(""Postfix notation: "" + infix_to_postfix(expression))"‖1
def __init__(self, initial_capacity: int = 6) -> None:‖self.front: Node | None = None‖1
self.front: Node | None = None‖self.rear: Node | None = None‖2
self.rear: Node | None = None‖self.create_linked_list(initial_capacity)‖1
def create_linked_list(self, initial_capacity: int) -> None:‖current_node = Node()‖1
current_node = Node()‖self.front = current_node‖1
self.front = current_node‖self.rear = current_node‖1
self.rear = current_node‖previous_node = current_node‖1
previous_node = current_node‖for _ in range(1, initial_capacity):‖1
for _ in range(1, initial_capacity):‖current_node = Node()‖1
current_node = Node()‖previous_node.next = current_node‖1
previous_node.next = current_node‖current_node.prev = previous_node‖1
current_node.prev = previous_node‖previous_node = current_node‖1
previous_node = current_node‖previous_node.next = self.front‖1
previous_node.next = self.front‖self.front.prev = previous_node‖1
return (‖self.front == self.rear‖1
self.front == self.rear‖and self.front is not None‖1
and self.front is not None‖and self.front.data is None‖1
and self.front.data is None‖)‖1
def first(self) -> Any | None:‖self.check_can_perform_operation()‖1
self.check_can_perform_operation()‖return self.front.data if self.front else None‖1
def enqueue(self, data: Any) -> None:‖if self.rear is None:‖1
if self.rear is None:‖return‖1
self.check_is_full()‖if not self.is_empty():‖1
if not self.is_empty():‖self.rear = self.rear.next‖1
self.rear = self.rear.next‖if self.rear:‖1
if self.rear:‖self.rear.data = data‖1
def dequeue(self) -> Any:‖self.check_can_perform_operation()‖1
self.check_can_perform_operation()‖if self.rear is None or self.front is None:‖1
if self.rear is None or self.front is None:‖return None‖1
return None‖if self.front == self.rear:‖1
if self.front == self.rear:‖data = self.front.data‖1
data = self.front.data‖self.front.data = None‖1
self.front.data = None‖return data‖1
old_front = self.front‖self.front = old_front.next‖1
self.front = old_front.next‖data = old_front.data‖1
data = old_front.data‖old_front.data = None‖1
old_front.data = None‖return data‖1
def check_can_perform_operation(self) -> None:‖if self.is_empty():‖1
if self.is_empty():‖"raise Exception(""Empty Queue"")"‖1
def check_is_full(self) -> None:‖if self.rear and self.rear.next == self.front:‖1
if self.rear and self.rear.next == self.front:‖"raise Exception(""Full Queue"")"‖1
class Node:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self.data: Any | None = None‖1
self.data: Any | None = None‖self.next: Node | None = None‖1
self.next: Node | None = None‖self.prev: Node | None = None‖1
def dijkstras_two_stack_algorithm(equation: str) -> int:‖"operators = {""*"": op.mul, ""/"": op.truediv, ""+"": op.add, ""-"": op.sub}"‖1
operand_stack: Stack[int] = Stack()‖operator_stack: Stack[str] = Stack()‖1
for i in equation:‖if i.isdigit():‖1
operand_stack.push(int(i))‖elif i in operators:‖1
operator_stack.push(i)‖"elif i == "")"":"‖1
opr = operator_stack.peek()‖operator_stack.pop()‖1
operator_stack.pop()‖num1 = operand_stack.peek()‖1
num1 = operand_stack.peek()‖operand_stack.pop()‖1
operand_stack.pop()‖num2 = operand_stack.peek()‖1
num2 = operand_stack.peek()‖operand_stack.pop()‖1
total = operators[opr](num2, num1)‖operand_stack.push(total)‖1
"if __name__ == ""__main__"":"‖"equation = ""(5 + ((4 * 2) * (2 + 3)))"""‖1
from collections.abc import Iterator‖from typing import Any‖1
self.data: Any = data‖self.next: Node | None = None‖1
def __init__(self) -> None:‖self.front: Node | None = None‖1
def __iter__(self) -> Iterator[Any]:‖node = self.front‖1
node = self.front‖while node:‖1
def __len__(self) -> int:‖return len(tuple(iter(self)))‖2
def __str__(self) -> str:‖"return "" <- "".join(str(item) for item in self)"‖1
def is_empty(self) -> bool:‖return len(self) == 0‖1
def put(self, item: Any) -> None:‖node = Node(item)‖1
node = Node(item)‖if self.is_empty():‖1
if self.is_empty():‖self.front = self.rear = node‖1
self.front = self.rear = node‖else:‖1
else:‖assert isinstance(self.rear, Node)‖1
assert isinstance(self.rear, Node)‖self.rear.next = node‖1
self.rear.next = node‖self.rear = node‖1
def get(self) -> Any:‖if self.is_empty():‖1
if self.is_empty():‖"raise IndexError(""dequeue from empty queue"")"‖1
"raise IndexError(""dequeue from empty queue"")"‖assert isinstance(self.front, Node)‖1
assert isinstance(self.front, Node)‖node = self.front‖1
node = self.front‖self.front = self.front.next‖1
self.front = self.front.next‖if self.front is None:‖1
if self.front is None:‖self.rear = None‖1
self.rear = None‖return node.data‖1
def clear(self) -> None:‖self.front = self.rear = None‖1
while stack:‖num = stack.pop()‖1
num = stack.pop()‖if num > max_number:‖1
if num > max_number:‖continue‖1
yield num‖if (num % 10) != 9:‖1
if (num % 10) != 9:‖stack.append(num + 1)‖1
testmod()‖"print(f""Numbers from 1 to 25 in lexical order: {list(lexical_order(26))}"")"‖1
class OverFlowError(Exception):‖pass‖1
class UnderFlowError(Exception):‖pass‖1
def __init__(self):‖self.queues = [‖1
self.queues = [‖[],‖1
[],‖[],‖2
[],‖]‖1
def enqueue(self, priority: int, data: int) -> None:‖try:‖1
try:‖if len(self.queues[priority]) >= 100:‖1
if len(self.queues[priority]) >= 100:‖"raise OverflowError(""Maximum queue size is 100"")"‖1
"raise OverflowError(""Maximum queue size is 100"")"‖self.queues[priority].append(data)‖1
self.queues[priority].append(data)‖except IndexError:‖1
except IndexError:‖"raise ValueError(""Valid priorities are 0, 1, and 2"")"‖1
def dequeue(self) -> int:‖for queue in self.queues:‖1
for queue in self.queues:‖if queue:‖1
if queue:‖return queue.pop(0)‖1
return queue.pop(0)‖"raise UnderFlowError(""All queues are empty"")"‖1
def __str__(self) -> str:‖"return ""\n"".join(f""Priority {i}: {q}"" for i, q in enumerate(self.queues))"‖1
def __init__(self):‖self.queue = []‖1
def enqueue(self, data: int) -> None:‖if len(self.queue) == 100:‖1
if len(self.queue) == 100:‖"raise OverFlowError(""Maximum queue size is 100"")"‖1
"raise OverFlowError(""Maximum queue size is 100"")"‖self.queue.append(data)‖1
def dequeue(self) -> int:‖if not self.queue:‖1
if not self.queue:‖"raise UnderFlowError(""The queue is empty"")"‖1
"raise UnderFlowError(""The queue is empty"")"‖else:‖1
else:‖data = min(self.queue)‖1
data = min(self.queue)‖self.queue.remove(data)‖1
self.queue.remove(data)‖return data‖1
def __str__(self) -> str:‖return str(self.queue)‖1
def fixed_priority_queue():‖fpq = FixedPriorityQueue()‖1
fpq = FixedPriorityQueue()‖fpq.enqueue(0, 10)‖1
fpq.enqueue(0, 10)‖fpq.enqueue(1, 70)‖1
fpq.enqueue(1, 70)‖fpq.enqueue(0, 100)‖1
fpq.enqueue(0, 100)‖fpq.enqueue(2, 1)‖1
fpq.enqueue(2, 1)‖fpq.enqueue(2, 5)‖1
fpq.enqueue(2, 5)‖fpq.enqueue(1, 7)‖1
fpq.enqueue(1, 7)‖fpq.enqueue(2, 4)‖1
fpq.enqueue(2, 4)‖fpq.enqueue(1, 64)‖1
fpq.enqueue(1, 64)‖fpq.enqueue(0, 128)‖1
fpq.enqueue(0, 128)‖print(fpq)‖1
print(fpq)‖print(fpq.dequeue())‖2
print(fpq.dequeue())‖print(fpq.dequeue())‖8
print(fpq.dequeue())‖print(fpq)‖1
def element_priority_queue():‖epq = ElementPriorityQueue()‖1
epq = ElementPriorityQueue()‖epq.enqueue(10)‖1
epq.enqueue(10)‖epq.enqueue(70)‖1
epq.enqueue(70)‖epq.enqueue(100)‖1
epq.enqueue(100)‖epq.enqueue(1)‖1
epq.enqueue(1)‖epq.enqueue(5)‖1
epq.enqueue(5)‖epq.enqueue(7)‖1
epq.enqueue(7)‖epq.enqueue(4)‖1
epq.enqueue(4)‖epq.enqueue(64)‖1
epq.enqueue(64)‖epq.enqueue(128)‖1
epq.enqueue(128)‖print(epq)‖1
print(epq)‖print(epq.dequeue())‖2
print(epq.dequeue())‖print(epq.dequeue())‖8
print(epq.dequeue())‖print(epq)‖1
"if __name__ == ""__main__"":"‖fixed_priority_queue()‖1
fixed_priority_queue()‖element_priority_queue()‖1
def __repr__(self) -> str:‖"return f""Node({self.data})"""‖1
def __iter__(self) -> Iterator[Any]:‖node = self.head‖1
def __repr__(self) -> str:‖"return "" -> "".join([str(item) for item in self])"‖1
def __getitem__(self, index: int) -> Any:‖if not 0 <= index < len(self):‖1
if not 0 <= index < len(self):‖"raise ValueError(""list index out of range."")"‖2
"raise ValueError(""list index out of range."")"‖for i, node in enumerate(self):‖1
for i, node in enumerate(self):‖if i == index:‖1
if i == index:‖return node‖1
return node‖return None‖1
def __setitem__(self, index: int, data: Any) -> None:‖if not 0 <= index < len(self):‖1
"raise ValueError(""list index out of range."")"‖current = self.head‖1
current = self.head‖for _ in range(index):‖1
for _ in range(index):‖current = current.next_node‖1
current = current.next_node‖current.data = data‖1
def insert_tail(self, data: Any) -> None:‖self.insert_nth(len(self), data)‖1
def insert_head(self, data: Any) -> None:‖self.insert_nth(0, data)‖1
def insert_nth(self, index: int, data: Any) -> None:‖if not 0 <= index <= len(self):‖1
if not 0 <= index <= len(self):‖"raise IndexError(""list index out of range"")"‖1
self.head = new_node‖elif index == 0:‖1
temp = self.head‖for _ in range(index - 1):‖2
for _ in range(index - 1):‖temp = temp.next_node‖2
temp = temp.next_node‖new_node.next_node = temp.next_node‖1
def print_list(self) -> None:‖print(self)‖1
def delete_head(self) -> Any:‖return self.delete_nth(0)‖1
def delete_tail(self) -> Any:‖return self.delete_nth(len(self) - 1)‖1
def delete_nth(self, index: int = 0) -> Any:‖if not 0 <= index <= len(self) - 1:‖1
if not 0 <= index <= len(self) - 1:‖"raise IndexError(""List index out of range."")"‖1
"raise IndexError(""List index out of range."")"‖delete_node = self.head‖1
delete_node = self.head‖if index == 0:‖1
if index == 0:‖self.head = self.head.next_node‖1
temp = temp.next_node‖delete_node = temp.next_node‖1
temp.next_node = temp.next_node.next_node‖return delete_node.data‖1
def reverse(self) -> None:‖prev = None‖1
prev = None‖current = self.head‖1
def test_singly_linked_list() -> None:‖linked_list = LinkedList()‖1
linked_list = LinkedList()‖assert linked_list.is_empty() is True‖1
assert len(linked_list) == i‖linked_list.insert_nth(i, i + 1)‖1
linked_list.insert_nth(i, i + 1)‖"assert str(linked_list) == "" -> "".join(str(i) for i in range(1, 11))"‖1
linked_list.insert_head(0)‖linked_list.insert_tail(11)‖1
linked_list.insert_tail(11)‖"assert str(linked_list) == "" -> "".join(str(i) for i in range(12))"‖1
assert linked_list.delete_head() == 0‖assert linked_list.delete_nth(9) == 10‖1
assert linked_list.delete_nth(9) == 10‖assert linked_list.delete_tail() == 11‖1
assert len(linked_list) == 9‖"assert str(linked_list) == "" -> "".join(str(i) for i in range(1, 10))"‖1
for i in range(9):‖linked_list[i] = -i‖1
linked_list[i] = -i‖assert all(linked_list[i] == -i for i in range(9)) is True‖1
linked_list.reverse()‖"assert str(linked_list) == "" -> "".join(str(i) for i in range(-8, 1))"‖1
def test_singly_linked_list_2() -> None:‖test_input = [‖1
test_input = [‖-9,‖1
-9,‖100,‖1
100,‖Node(77345112),‖1
Node(77345112),‖"""dlrow olleH"","‖1
"""dlrow olleH"","‖7,‖1
7,‖5555,‖1
5555,‖0,‖1
0,‖-192.55555,‖1
-192.55555,‖"""Hello, world!"","‖1
"""Hello, world!"","‖77.9,‖1
77.9,‖Node(10),‖1
Node(10),‖None,‖1
None,‖None,‖1
None,‖12.20,‖1
12.20,‖]‖1
]‖linked_list = LinkedList()‖1
for i in test_input:‖linked_list.insert_tail(i)‖1
assert linked_list.is_empty() is False‖assert (‖1
assert (‖str(linked_list)‖4
str(linked_list)‖"== ""-9 -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> """‖1
"== ""-9 -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> """‖"""0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2"""‖1
"""0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2"""‖)‖1
result = linked_list.delete_head()‖assert result == -9‖1
assert result == -9‖assert (‖1
assert (‖"str(linked_list) == ""100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> """‖3
"str(linked_list) == ""100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> """‖"""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2"""‖1
"""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None -> 12.2"""‖)‖1
result = linked_list.delete_tail()‖assert result == 12.2‖1
assert result == 12.2‖assert (‖1
"str(linked_list) == ""100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> """‖"""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None"""‖1
"""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None"""‖)‖1
result = linked_list.delete_nth(10)‖assert result is None‖1
assert result is None‖assert (‖1
"str(linked_list) == ""100 -> Node(77345112) -> dlrow olleH -> 7 -> 5555 -> 0 -> """‖"""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None"""‖1
"""-192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None"""‖)‖1
"linked_list.insert_head(Node(""Hello again, world!""))"‖assert (‖1
str(linked_list)‖"== ""Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> """‖1
"== ""Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> """‖"""7 -> 5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None"""‖1
"""7 -> 5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None"""‖)‖1
linked_list.insert_tail(None)‖assert (‖1
str(linked_list)‖"== ""Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> """‖1
"== ""Node(Hello again, world!) -> 100 -> Node(77345112) -> dlrow olleH -> 7 -> """‖"""5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None"""‖1
"""5555 -> 0 -> -192.55555 -> Hello, world! -> 77.9 -> Node(10) -> None -> None"""‖)‖1
linked_list.reverse()‖assert (‖1
str(linked_list)‖"== ""None -> None -> Node(10) -> 77.9 -> Hello, world! -> -192.55555 -> 0 -> """‖1
"== ""None -> None -> Node(10) -> 77.9 -> Hello, world! -> -192.55555 -> 0 -> """‖"""5555 -> 7 -> dlrow olleH -> Node(77345112) -> 100 -> Node(Hello again, world!)"""‖1
"""5555 -> 7 -> dlrow olleH -> Node(77345112) -> 100 -> Node(Hello again, world!)"""‖)‖1
def main():‖from doctest import testmod‖1
linked_list = LinkedList()‖"linked_list.insert_head(input(""Inserting 1st at head "").strip())"‖1
"linked_list.insert_head(input(""Inserting 1st at head "").strip())"‖"linked_list.insert_head(input(""Inserting 2nd at head "").strip())"‖1
"linked_list.insert_head(input(""Inserting 2nd at head "").strip())"‖"print(""\nPrint list:"")"‖1
"print(""\nPrint list:"")"‖linked_list.print_list()‖4
linked_list.print_list()‖"linked_list.insert_tail(input(""\nInserting 1st at tail "").strip())"‖1
"linked_list.insert_tail(input(""\nInserting 1st at tail "").strip())"‖"linked_list.insert_tail(input(""Inserting 2nd at tail "").strip())"‖1
"linked_list.insert_tail(input(""Inserting 2nd at tail "").strip())"‖"print(""\nPrint list:"")"‖1
linked_list.print_list()‖"print(""\nDelete head"")"‖1
"print(""\nDelete head"")"‖linked_list.delete_head()‖1
linked_list.delete_head()‖"print(""Delete tail"")"‖1
"print(""Delete tail"")"‖linked_list.delete_tail()‖1
linked_list.delete_tail()‖"print(""\nPrint list:"")"‖1
linked_list.print_list()‖"print(""\nReverse linked list"")"‖1
"print(""\nReverse linked list"")"‖linked_list.reverse()‖1
linked_list.reverse()‖"print(""\nPrint list:"")"‖1
linked_list.print_list()‖"print(""\nString representation of linked list:"")"‖1
"print(""\nString representation of linked list:"")"‖print(linked_list)‖1
print(linked_list)‖"print(""\nReading/changing Node data using indexing:"")"‖1
"print(""\nReading/changing Node data using indexing:"")"‖"print(f""Element at Position 1: {linked_list[1]}"")"‖1
"print(f""Element at Position 1: {linked_list[1]}"")"‖"linked_list[1] = input(""Enter New Value: "").strip()"‖1
"linked_list[1] = input(""Enter New Value: "").strip()"‖"print(""New list:"")"‖1
"print(""New list:"")"‖print(linked_list)‖1
print(linked_list)‖"print(f""length of linked_list is : {len(linked_list)}"")"‖1
arr = [-10, -5, 0, 5, 5.1, 11, 13, 21, 3, 4, -21, -10, -5, -1, 0]‖expect = [-5, 0, 5, 5.1, 11, 13, 21, -1, 4, -1, -10, -5, -1, 0, -1]‖1
result = []‖arr_size = len(arr)‖1
for i in range(arr_size):‖next_element: float = -1‖1
next_element: float = -1‖for j in range(i + 1, arr_size):‖1
for j in range(i + 1, arr_size):‖if arr[i] < arr[j]:‖1
if arr[i] < arr[j]:‖next_element = arr[j]‖1
next_element = arr[j]‖break‖1
break‖result.append(next_element)‖1
result.append(next_element)‖return result‖1
def next_greatest_element_fast(arr: list[float]) -> list[float]:‖result = []‖1
result = []‖for i, outer in enumerate(arr):‖1
for i, outer in enumerate(arr):‖next_item: float = -1‖1
next_item: float = -1‖for inner in arr[i + 1 :]:‖1
for inner in arr[i + 1 :]:‖if outer < inner:‖1
if outer < inner:‖next_item = inner‖1
next_item = inner‖break‖1
break‖result.append(next_item)‖1
result.append(next_item)‖return result‖1
def next_greatest_element(arr: list[float]) -> list[float]:‖arr_size = len(arr)‖1
arr_size = len(arr)‖stack: list[float] = []‖1
stack: list[float] = []‖result: list[float] = [-1] * arr_size‖1
for index in reversed(range(arr_size)):‖if stack:‖1
if stack:‖while stack[-1] <= arr[index]:‖1
while stack[-1] <= arr[index]:‖stack.pop()‖1
stack.pop()‖if not stack:‖1
if not stack:‖break‖1
break‖if stack:‖1
if stack:‖result[index] = stack[-1]‖1
result[index] = stack[-1]‖stack.append(arr[index])‖1
stack.append(arr[index])‖return result‖1
from doctest import testmod‖from timeit import timeit‖2
testmod()‖print(next_greatest_element_slow(arr))‖1
print(next_greatest_element_slow(arr))‖print(next_greatest_element_fast(arr))‖1
print(next_greatest_element_fast(arr))‖print(next_greatest_element(arr))‖1
setup = (‖"""from __main__ import arr, next_greatest_element_slow, """‖1
"""from __main__ import arr, next_greatest_element_slow, """‖"""next_greatest_element_fast, next_greatest_element"""‖1
"""next_greatest_element_fast, next_greatest_element"""‖)‖1
)‖print(‖17
print(‖"""next_greatest_element_slow():"","‖1
"""next_greatest_element_slow():"","‖"timeit(""next_greatest_element_slow(arr)"", setup=setup),"‖1
"timeit(""next_greatest_element_slow(arr)"", setup=setup),"‖)‖1
print(‖"""next_greatest_element_fast():"","‖1
"""next_greatest_element_fast():"","‖"timeit(""next_greatest_element_fast(arr)"", setup=setup),"‖1
"timeit(""next_greatest_element_fast(arr)"", setup=setup),"‖)‖1
print(‖"""     next_greatest_element():"","‖1
"""     next_greatest_element():"","‖"timeit(""next_greatest_element(arr)"", setup=setup),"‖1
"timeit(""next_greatest_element(arr)"", setup=setup),"‖)‖1
def balanced_parentheses(parentheses: str) -> bool:‖stack: Stack[str] = Stack()‖1
stack: Stack[str] = Stack()‖"bracket_pairs = {""("": "")"", ""["": ""]"", ""{"": ""}""}"‖1
"bracket_pairs = {""("": "")"", ""["": ""]"", ""{"": ""}""}"‖for bracket in parentheses:‖1
for bracket in parentheses:‖if bracket in bracket_pairs:‖1
if bracket in bracket_pairs:‖stack.push(bracket)‖1
stack.push(bracket)‖"elif bracket in ("")"", ""]"", ""}"") and ("‖1
"elif bracket in ("")"", ""]"", ""}"") and ("‖stack.is_empty() or bracket_pairs[stack.pop()] != bracket‖1
stack.is_empty() or bracket_pairs[stack.pop()] != bracket‖):‖1
):‖return False‖5
return False‖return stack.is_empty()‖1
"examples = [""((()))"", ""((())"", ""(()))""]"‖"print(""Balanced parentheses demonstration:\n"")"‖1
"print(""Balanced parentheses demonstration:\n"")"‖for example in examples:‖1
for example in examples:‖"not_str = """" if balanced_parentheses(example) else ""not """‖1
"not_str = """" if balanced_parentheses(example) else ""not """‖"print(f""{example} is {not_str}balanced"")"‖1
def infix_2_postfix(infix: str) -> str:‖stack = []‖1
stack = []‖post_fix = []‖1
post_fix = []‖priority = {‖1
priority = {‖"""^"": 3,"‖1
"""^"": 3,"‖"""*"": 2,"‖1
"""/"": 2,"‖"""%"": 2,"‖1
"""%"": 2,"‖"""+"": 1,"‖1
"""-"": 1,"‖}‖1
}‖print_width = max(len(infix), 7)‖1
print(‖"""Symbol"".center(8),"‖1
"""Symbol"".center(8),"‖"""Stack"".center(print_width),"‖1
"""Stack"".center(print_width),"‖"""Postfix"".center(print_width),"‖1
"""Postfix"".center(print_width),"‖"sep="" | "","‖1
"sep="" | "","‖)‖9
)‖"print(""-"" * (print_width * 3 + 7))"‖1
for x in infix:‖if x.isalpha() or x.isdigit():‖1
if x.isalpha() or x.isdigit():‖post_fix.append(x)‖1
post_fix.append(x)‖"elif x == ""("":"‖1
"elif x == ""("":"‖stack.append(x)‖1
stack.append(x)‖"elif x == "")"":"‖1
"elif x == "")"":"‖if len(stack) == 0:‖1
if len(stack) == 0:‖"raise IndexError(""list index out of range"")"‖1
"while stack[-1] != ""("":"‖post_fix.append(stack.pop())‖1
post_fix.append(stack.pop())‖stack.pop()‖1
stack.pop()‖elif len(stack) == 0:‖1
elif len(stack) == 0:‖stack.append(x)‖1
stack.append(x)‖else:‖1
else:‖"while stack and stack[-1] != ""("" and priority[x] <= priority[stack[-1]]:"‖1
"while stack and stack[-1] != ""("" and priority[x] <= priority[stack[-1]]:"‖post_fix.append(stack.pop())‖1
post_fix.append(stack.pop())‖stack.append(x)‖1
print(‖x.center(8),‖1
x.center(8),‖"("""".join(stack)).ljust(print_width),"‖1
"("""".join(stack)).ljust(print_width),"‖"("""".join(post_fix)).ljust(print_width),"‖2
"("""".join(post_fix)).ljust(print_width),"‖"sep="" | "","‖2
while len(stack) > 0:‖"if stack[-1] == ""("":"‖1
"if stack[-1] == ""("":"‖"raise ValueError(""invalid expression"")"‖1
post_fix.append(stack.pop())‖print(‖1
print(‖""" "".center(8),"‖1
""" "".center(8),"‖"("""".join(stack)).ljust(print_width),"‖1
def infix_2_prefix(infix: str) -> str:‖reversed_infix = list(infix[::-1])‖1
for i in range(len(reversed_infix)):‖"if reversed_infix[i] == ""("":"‖1
"if reversed_infix[i] == ""("":"‖"reversed_infix[i] = "")"""‖1
"reversed_infix[i] = "")"""‖"elif reversed_infix[i] == "")"":"‖1
"elif reversed_infix[i] == "")"":"‖"reversed_infix[i] = ""("""‖1
"Infix = input(""\nEnter an Infix Equation = "")"‖"Infix = """".join(Infix.split())"‖1
"Infix = """".join(Infix.split())"‖"print(""\n\t"", Infix, ""(Infix) -> "", infix_2_prefix(Infix), ""(Prefix)"")"‖1
calc = {‖"""+"": lambda x, y: x + y,"‖1
"""+"": lambda x, y: x + y,"‖"""-"": lambda x, y: x - y,"‖1
"""-"": lambda x, y: x - y,"‖"""*"": lambda x, y: x * y,"‖1
"""*"": lambda x, y: x * y,"‖"""/"": lambda x, y: x / y,"‖1
"""/"": lambda x, y: x / y,"‖}‖1
def is_operand(c):‖return c.isdigit()‖1
def evaluate(expression):‖stack = []‖1
if is_operand(c):‖stack.append(int(c))‖1
o1 = stack.pop()‖o2 = stack.pop()‖1
o2 = stack.pop()‖stack.append(calc[c](o1, o2))‖1
"if __name__ == ""__main__"":"‖"test_expression = ""+ 9 * 2 6"""‖1
"test_expression = ""+ 9 * 2 6"""‖print(evaluate(test_expression))‖1
"test_expression = ""/ * 10 2 + 4 1 """‖print(evaluate(test_expression))‖1
def __init__(self, n: int):‖self.n = n‖1
self.n = n‖self.array = [None] * self.n‖1
self.array = [None] * self.n‖self.front = 0‖1
self.front = 0‖self.rear = 0‖1
self.rear = 0‖self.size = 0‖1
def __len__(self) -> int:‖return self.size‖1
def is_empty(self) -> bool:‖return self.size == 0‖1
def first(self):‖return False if self.is_empty() else self.array[self.front]‖1
def enqueue(self, data):‖if self.size >= self.n:‖1
if self.size >= self.n:‖"raise Exception(""QUEUE IS FULL"")"‖1
self.array[self.rear] = data‖self.rear = (self.rear + 1) % self.n‖1
self.rear = (self.rear + 1) % self.n‖self.size += 1‖1
self.size += 1‖return self‖1
def dequeue(self):‖if self.size == 0:‖1
if self.size == 0:‖"raise Exception(""UNDERFLOW"")"‖1
temp = self.array[self.front]‖self.array[self.front] = None‖1
self.array[self.front] = None‖self.front = (self.front + 1) % self.n‖1
self.front = (self.front + 1) % self.n‖self.size -= 1‖1
self.size -= 1‖return temp‖1
class Node(Generic[T]):‖def __init__(self, data: T):‖2
def __init__(self, data: T):‖self.data = data‖2
self.data = data‖self.next: Node[T] | None = None‖2
self.next: Node[T] | None = None‖self.prev: Node[T] | None = None‖1
def __init__(self) -> None:‖self.head: Node[T] | None = None‖1
def push(self, data: T) -> None:‖if self.head is None:‖1
if self.head is None:‖self.head = Node(data)‖1
self.head = Node(data)‖else:‖1
else:‖new_node = Node(data)‖1
new_node = Node(data)‖self.head.prev = new_node‖1
self.head.prev = new_node‖new_node.next = self.head‖1
new_node.next = self.head‖new_node.prev = None‖1
new_node.prev = None‖self.head = new_node‖1
def pop(self) -> T | None:‖if self.head is None:‖1
else:‖assert self.head is not None‖1
assert self.head is not None‖temp = self.head.data‖1
temp = self.head.data‖self.head = self.head.next‖1
self.head = self.head.next‖if self.head is not None:‖1
if self.head is not None:‖self.head.prev = None‖1
self.head.prev = None‖return temp‖1
def top(self) -> T | None:‖return self.head.data if self.head is not None else None‖1
def __len__(self) -> int:‖temp = self.head‖1
temp = self.head‖count = 0‖1
count = 0‖while temp is not None:‖1
while temp is not None:‖count += 1‖1
count += 1‖temp = temp.next‖1
temp = temp.next‖return count‖1
def print_stack(self) -> None:‖"print(""stack elements are:"")"‖1
"print(""stack elements are:"")"‖temp = self.head‖1
temp = self.head‖while temp is not None:‖1
while temp is not None:‖"print(temp.data, end=""->"")"‖1
"print(temp.data, end=""->"")"‖temp = temp.next‖1
"print(""Stack operations using Doubly LinkedList"")"‖stack.push(4)‖1
from collections import deque‖from dataclasses import dataclass, field‖1
@dataclass‖class StackWithQueues:‖1
main_queue: deque[int] = field(default_factory=deque)‖temp_queue: deque[int] = field(default_factory=deque)‖1
def push(self, item: int) -> None:‖self.temp_queue.append(item)‖1
self.temp_queue.append(item)‖while self.main_queue:‖1
while self.main_queue:‖self.temp_queue.append(self.main_queue.popleft())‖1
self.temp_queue.append(self.main_queue.popleft())‖self.main_queue, self.temp_queue = self.temp_queue, self.main_queue‖1
def pop(self) -> int:‖return self.main_queue.popleft()‖1
def peek(self) -> int | None:‖return self.main_queue[0] if self.main_queue else None‖1
stack: StackWithQueues | None = StackWithQueues()‖while stack:‖1
while stack:‖"print(""\nChoose operation:"")"‖1
"print(""\nChoose operation:"")"‖"print(""1. Push"")"‖1
"print(""1. Push"")"‖"print(""2. Pop"")"‖1
"print(""2. Pop"")"‖"print(""3. Peek"")"‖1
"print(""3. Peek"")"‖"print(""4. Quit"")"‖1
"if choice == ""1"":"‖"element = int(input(""Enter an integer to push: "").strip())"‖1
"element = int(input(""Enter an integer to push: "").strip())"‖stack.push(element)‖1
stack.push(element)‖"print(f""{element} pushed onto the stack."")"‖1
"print(f""{element} pushed onto the stack."")"‖"elif choice == ""2"":"‖1
"elif choice == ""2"":"‖popped_element = stack.pop()‖1
popped_element = stack.pop()‖if popped_element is not None:‖1
if popped_element is not None:‖"print(f""Popped element: {popped_element}"")"‖1
"print(f""Popped element: {popped_element}"")"‖else:‖1
else:‖"print(""Stack is empty."")"‖2
"print(""Stack is empty."")"‖"elif choice == ""3"":"‖1
"elif choice == ""3"":"‖peeked_element = stack.peek()‖1
peeked_element = stack.peek()‖if peeked_element is not None:‖1
if peeked_element is not None:‖"print(f""Top element: {peeked_element}"")"‖1
"print(f""Top element: {peeked_element}"")"‖else:‖1
"print(""Stack is empty."")"‖"elif choice == ""4"":"‖1
"elif choice == ""4"":"‖del stack‖1
del stack‖stack = None‖1
stack = None‖else:‖1
else:‖"print(""Invalid choice. Please try again."")"‖1
def calculation_span(price, s):‖n = len(price)‖1
st = []‖st.append(0)‖1
while len(st) > 0 and price[st[0]] <= price[i]:‖st.pop()‖1
def print_array(arr, n):‖for i in range(n):‖1
for i in range(n):‖"print(arr[i], end="" "")"‖1
price = [10, 4, 5, 90, 120, 80]‖S = [0 for i in range(len(price) + 1)]‖1
class StackOverflowError(BaseException):‖pass‖1
class StackUnderflowError(BaseException):‖pass‖1
def __init__(self, limit: int = 10):‖self.stack: list[T] = []‖1
self.stack: list[T] = []‖self.limit = limit‖1
def __bool__(self) -> bool:‖return bool(self.stack)‖1
def __str__(self) -> str:‖return str(self.stack)‖1
def push(self, data: T) -> None:‖if len(self.stack) >= self.limit:‖1
if len(self.stack) >= self.limit:‖raise StackOverflowError‖1
raise StackOverflowError‖self.stack.append(data)‖1
def pop(self) -> T:‖if not self.stack:‖1
if not self.stack:‖raise StackUnderflowError‖2
raise StackUnderflowError‖return self.stack.pop()‖1
def peek(self) -> T:‖if not self.stack:‖1
raise StackUnderflowError‖return self.stack[-1]‖1
def is_empty(self) -> bool:‖return not bool(self.stack)‖1
def is_full(self) -> bool:‖return self.size() == self.limit‖1
def size(self) -> int:‖return len(self.stack)‖1
def __contains__(self, item: T) -> bool:‖return item in self.stack‖1
def test_stack() -> None:‖stack: Stack[int] = Stack(10)‖1
stack: Stack[int] = Stack(10)‖assert bool(stack) is False‖1
assert bool(stack) is False‖assert stack.is_empty() is True‖1
assert stack.is_empty() is True‖assert stack.is_full() is False‖1
assert stack.is_full() is False‖"assert str(stack) == ""[]"""‖1
try:‖_ = stack.pop()‖1
_ = stack.pop()‖raise AssertionError‖1
raise AssertionError‖except StackUnderflowError:‖2
except StackUnderflowError:‖assert True‖2
try:‖_ = stack.peek()‖1
_ = stack.peek()‖raise AssertionError‖1
for i in range(10):‖assert stack.size() == i‖1
assert stack.size() == i‖stack.push(i)‖1
assert bool(stack)‖assert not stack.is_empty()‖1
assert not stack.is_empty()‖assert stack.is_full()‖1
assert stack.is_full()‖assert str(stack) == str(list(range(10)))‖1
assert str(stack) == str(list(range(10)))‖assert stack.pop() == 9‖1
assert stack.pop() == 9‖assert stack.peek() == 8‖1
stack.push(100)‖assert str(stack) == str([0, 1, 2, 3, 4, 5, 6, 7, 8, 100])‖1
try:‖stack.push(200)‖1
stack.push(200)‖raise AssertionError‖1
raise AssertionError‖except StackOverflowError:‖1
except StackOverflowError:‖assert True‖1
assert not stack.is_empty()‖assert stack.size() == 10‖1
assert 5 in stack‖assert 55 not in stack‖1
"if __name__ == ""__main__"":"‖test_stack()‖1
class SuffixTreeNode:‖def __init__(‖1
self,‖children: dict[str, SuffixTreeNode] | None = None,‖1
children: dict[str, SuffixTreeNode] | None = None,‖is_end_of_string: bool = False,‖1
is_end_of_string: bool = False,‖start: int | None = None,‖1
start: int | None = None,‖end: int | None = None,‖1
end: int | None = None,‖suffix_link: SuffixTreeNode | None = None,‖1
suffix_link: SuffixTreeNode | None = None,‖) -> None:‖1
) -> None:‖self.children = children or {}‖1
self.children = children or {}‖self.is_end_of_string = is_end_of_string‖1
self.is_end_of_string = is_end_of_string‖self.start = start‖1
self.end = end‖self.suffix_link = suffix_link‖1
OPERATORS = {‖"""^"": lambda p, q: p**q,"‖1
"""^"": lambda p, q: p**q,"‖"""*"": lambda p, q: p * q,"‖1
"""*"": lambda p, q: p * q,"‖"""/"": lambda p, q: p / q,"‖1
"""/"": lambda p, q: p / q,"‖"""+"": lambda p, q: p + q,"‖1
"""+"": lambda p, q: p + q,"‖"""-"": lambda p, q: p - q,"‖1
"""-"": lambda p, q: p - q,"‖}‖1
def parse_token(token: str | float) -> float | str:‖if token in OPERATORS:‖1
if token in OPERATORS:‖return token‖1
return token‖try:‖1
try:‖return float(token)‖1
return float(token)‖except ValueError:‖1
except ValueError:‖"msg = f""{token} is neither a number nor a valid operator"""‖1
"msg = f""{token} is neither a number nor a valid operator"""‖raise ValueError(msg)‖1
def evaluate(post_fix: list[str], verbose: bool = False) -> float:‖if not post_fix:‖1
if not post_fix:‖return 0‖1
valid_expression = [parse_token(token) for token in post_fix]‖if verbose:‖1
"print(""Symbol"".center(8), ""Action"".center(12), ""Stack"", sep="" | "")"‖"print(""-"" * (30 + len(post_fix)))"‖1
"print(""-"" * (30 + len(post_fix)))"‖stack = []‖1
stack = []‖for x in valid_expression:‖1
for x in valid_expression:‖if x not in OPERATORS:‖1
if x not in OPERATORS:‖stack.append(x)‖1
stack.append(x)‖if verbose:‖1
print(‖"f""{x}"".rjust(8),"‖2
"f""{x}"".rjust(8),"‖"f""push({x})"".ljust(12),"‖1
"f""push({x})"".ljust(12),"‖stack,‖1
stack,‖"sep="" | "","‖6
)‖continue‖2
if x in UNARY_OP_SYMBOLS and len(stack) < 2:‖b = stack.pop()‖1
b = stack.pop()‖"if x == ""-"":"‖1
"if x == ""-"":"‖b *= -1‖1
b *= -1‖stack.append(b)‖1
stack.append(b)‖if verbose:‖1
print(‖""""".rjust(8),"‖3
""""".rjust(8),"‖"f""pop({b})"".ljust(12),"‖2
"f""pop({b})"".ljust(12),"‖stack,‖2
print(‖str(x).rjust(8),‖1
str(x).rjust(8),‖"f""push({x}{b})"".ljust(12),"‖1
"f""push({x}{b})"".ljust(12),"‖stack,‖1
continue‖b = stack.pop()‖1
b = stack.pop()‖if verbose:‖1
a = stack.pop()‖if verbose:‖1
""""".rjust(8),"‖"f""pop({a})"".ljust(12),"‖1
"f""pop({a})"".ljust(12),"‖stack,‖1
stack.append(OPERATORS[x](a, b))‖if verbose:‖1
"f""{x}"".rjust(8),"‖"f""push({a}{x}{b})"".ljust(12),"‖1
"f""push({a}{x}{b})"".ljust(12),"‖stack,‖1
if len(stack) != 1:‖"raise ArithmeticError(""Input is not a valid postfix expression"")"‖1
"raise ArithmeticError(""Input is not a valid postfix expression"")"‖return float(stack[0])‖1
while True:‖"expression = input(""Enter a Postfix Expression (space separated): "").split("" "")"‖1
"expression = input(""Enter a Postfix Expression (space separated): "").split("" "")"‖"prompt = ""Do you want to see stack contents while evaluating? [y/N]: """‖1
"prompt = ""Do you want to see stack contents while evaluating? [y/N]: """‖"verbose = input(prompt).strip().lower() == ""y"""‖1
"verbose = input(prompt).strip().lower() == ""y"""‖output = evaluate(expression, verbose)‖1
output = evaluate(expression, verbose)‖"print(""Result = "", output)"‖1
"print(""Result = "", output)"‖"prompt = ""Do you want to enter another expression? [y/N]: """‖1
"prompt = ""Do you want to enter another expression? [y/N]: """‖"if input(prompt).strip().lower() != ""y"":"‖1
"if input(prompt).strip().lower() != ""y"":"‖break‖1
class RadixNode:‖"def __init__(self, prefix: str = """", is_leaf: bool = False) -> None:"‖1
def match(self, word: str) -> tuple[str, str, str]:‖x = 0‖1
x = 0‖for q, w in zip(self.prefix, word):‖1
for q, w in zip(self.prefix, word):‖if q != w:‖1
if q != w:‖break‖1
def insert_many(self, words: list[str]) -> None:‖for word in words:‖2
for word in words:‖self.insert(word)‖2
if self.prefix == word and not self.is_leaf:‖self.is_leaf = True‖1
elif word[0] not in self.nodes:‖self.nodes[word[0]] = RadixNode(prefix=word, is_leaf=True)‖1
else:‖incoming_node = self.nodes[word[0]]‖1
incoming_node = self.nodes[word[0]]‖matching_string, remaining_prefix, remaining_word = incoming_node.match(‖1
matching_string, remaining_prefix, remaining_word = incoming_node.match(‖word‖3
word‖)‖3
"if remaining_prefix == """":"‖self.nodes[matching_string[0]].insert(remaining_word)‖1
else:‖incoming_node.prefix = remaining_prefix‖1
aux_node = self.nodes[matching_string[0]]‖self.nodes[matching_string[0]] = RadixNode(matching_string, False)‖1
self.nodes[matching_string[0]] = RadixNode(matching_string, False)‖self.nodes[matching_string[0]].nodes[remaining_prefix[0]] = aux_node‖1
"if remaining_word == """":"‖self.nodes[matching_string[0]].is_leaf = True‖1
self.nodes[matching_string[0]].is_leaf = True‖else:‖1
else:‖self.nodes[matching_string[0]].insert(remaining_word)‖1
def find(self, word: str) -> bool:‖incoming_node = self.nodes.get(word[0], None)‖1
incoming_node = self.nodes.get(word[0], None)‖if not incoming_node:‖2
if not incoming_node:‖return False‖2
else:‖matching_string, remaining_prefix, remaining_word = incoming_node.match(‖2
"if remaining_prefix != """":"‖return False‖2
"elif remaining_word == """":"‖return incoming_node.is_leaf‖1
else:‖return incoming_node.find(remaining_word)‖1
def delete(self, word: str) -> bool:‖incoming_node = self.nodes.get(word[0], None)‖1
"elif remaining_word != """":"‖return incoming_node.delete(remaining_word)‖1
elif not incoming_node.is_leaf:‖return False‖1
if len(incoming_node.nodes) == 0:‖del self.nodes[word[0]]‖1
if len(self.nodes) == 1 and not self.is_leaf:‖merging_node = next(iter(self.nodes.values()))‖1
merging_node = next(iter(self.nodes.values()))‖self.is_leaf = merging_node.is_leaf‖1
self.is_leaf = merging_node.is_leaf‖self.prefix += merging_node.prefix‖1
self.prefix += merging_node.prefix‖self.nodes = merging_node.nodes‖1
elif len(incoming_node.nodes) > 1:‖incoming_node.is_leaf = False‖1
else:‖merging_node = next(iter(incoming_node.nodes.values()))‖1
merging_node = next(iter(incoming_node.nodes.values()))‖incoming_node.is_leaf = merging_node.is_leaf‖1
incoming_node.is_leaf = merging_node.is_leaf‖incoming_node.prefix += merging_node.prefix‖1
incoming_node.prefix += merging_node.prefix‖incoming_node.nodes = merging_node.nodes‖1
def print_tree(self, height: int = 0) -> None:‖"if self.prefix != """":"‖1
"if self.prefix != """":"‖"print(""-"" * height, self.prefix, ""  (leaf)"" if self.is_leaf else """")"‖1
for value in self.nodes.values():‖value.print_tree(height + 1)‖1
def test_trie() -> bool:‖"words = ""banana bananas bandana band apple all beast"".split()"‖2
"words = ""banana bananas bandana band apple all beast"".split()"‖root = RadixNode()‖1
root = RadixNode()‖root.insert_many(words)‖1
assert all(root.find(word) for word in words)‖"assert not root.find(""bandanas"")"‖1
"assert not root.find(""bandanas"")"‖"assert not root.find(""apps"")"‖2
"assert not root.find(""apps"")"‖"root.delete(""all"")"‖1
"root.delete(""all"")"‖"assert not root.find(""all"")"‖2
"assert not root.find(""all"")"‖"root.delete(""banana"")"‖2
"root.delete(""banana"")"‖"assert not root.find(""banana"")"‖2
"assert not root.find(""banana"")"‖"assert root.find(""bananas"")"‖2
def pytests() -> None:‖assert test_trie()‖2
def main() -> None:‖root = RadixNode()‖1
root = RadixNode()‖"words = ""banana bananas bandanas bandana band apple all beast"".split()"‖1
"words = ""banana bananas bandanas bandana band apple all beast"".split()"‖root.insert_many(words)‖1
"print(""Words:"", words)"‖"print(""Tree:"")"‖1
"print(""Tree:"")"‖root.print_tree()‖1
import numpy as np‖from cv2 import COLOR_BGR2GRAY, cvtColor, imread‖1
from cv2 import COLOR_BGR2GRAY, cvtColor, imread‖from numpy import array, uint8‖1
from numpy import array, uint8‖from PIL import Image‖1
from digital_image_processing import change_contrast as cc‖from digital_image_processing import convert_to_negative as cn‖1
from digital_image_processing import convert_to_negative as cn‖from digital_image_processing import sepia as sp‖1
from digital_image_processing import sepia as sp‖from digital_image_processing.dithering import burkes as bs‖1
from digital_image_processing.dithering import burkes as bs‖from digital_image_processing.edge_detection import canny‖1
from digital_image_processing.edge_detection import canny‖from digital_image_processing.filters import convolve as conv‖1
from digital_image_processing.filters import convolve as conv‖from digital_image_processing.filters import gaussian_filter as gg‖1
from digital_image_processing.filters import gaussian_filter as gg‖from digital_image_processing.filters import local_binary_pattern as lbp‖1
from digital_image_processing.filters import local_binary_pattern as lbp‖from digital_image_processing.filters import median_filter as med‖1
from digital_image_processing.filters import median_filter as med‖from digital_image_processing.filters import sobel_filter as sob‖1
from digital_image_processing.filters import sobel_filter as sob‖from digital_image_processing.resize import resize as rs‖1
"img = imread(r""digital_image_processing/image_data/lena_small.jpg"")"‖gray = cvtColor(img, COLOR_BGR2GRAY)‖1
def test_convert_to_negative():‖negative_img = cn.convert_to_negative(img)‖1
def test_change_contrast():‖"with Image.open(""digital_image_processing/image_data/lena_small.jpg"") as img:"‖1
assert str(cc.change_contrast(img, 110)).startswith(‖"""<PIL.Image.Image image mode=RGB size=100x100 at"""‖1
"""<PIL.Image.Image image mode=RGB size=100x100 at"""‖)‖1
def test_gen_gaussian_kernel():‖resp = canny.gen_gaussian_kernel(9, sigma=1.4)‖1
def test_canny():‖"canny_img = imread(""digital_image_processing/image_data/lena_small.jpg"", 0)"‖1
assert canny_img.all()‖canny_array = canny.canny(canny_img)‖1
def test_gen_gaussian_kernel_filter():‖assert gg.gaussian_filter(gray, 5, sigma=0.9).all()‖1
laplace = array([[0.25, 0.5, 0.25], [0.5, -3, 0.5], [0.25, 0.5, 0.25]])‖res = conv.img_convolve(gray, laplace).astype(uint8)‖1
res = conv.img_convolve(gray, laplace).astype(uint8)‖assert res.any()‖1
def test_median_filter():‖assert med.median_filter(gray, 3).any()‖1
def test_sobel_filter():‖grad, theta = sob.sobel_filter(gray)‖1
grad, theta = sob.sobel_filter(gray)‖assert grad.any()‖1
assert grad.any()‖assert theta.any()‖1
def test_sepia():‖sepia = sp.make_sepia(img, 20)‖1
sepia = sp.make_sepia(img, 20)‖assert sepia.all()‖1
"def test_burkes(file_path: str = ""digital_image_processing/image_data/lena_small.jpg""):"‖burkes = bs.Burkes(imread(file_path, 1), 120)‖1
burkes = bs.Burkes(imread(file_path, 1), 120)‖burkes.process()‖1
burkes.process()‖assert burkes.output_img.any()‖1
def test_nearest_neighbour(‖"file_path: str = ""digital_image_processing/image_data/lena_small.jpg"","‖1
"file_path: str = ""digital_image_processing/image_data/lena_small.jpg"","‖):‖1
):‖nn = rs.NearestNeighbour(imread(file_path, 1), 400, 200)‖1
nn = rs.NearestNeighbour(imread(file_path, 1), 400, 200)‖nn.process()‖1
nn.process()‖assert nn.output.any()‖1
"file_name = ""lena_small.jpg"" if getenv(""CI"") else ""lena.jpg"""‖"file_path = f""digital_image_processing/image_data/{file_name}"""‖1
x_coordinate = 0‖y_coordinate = 0‖1
y_coordinate = 0‖center = image[x_coordinate][y_coordinate]‖1
neighbors_pixels = lbp.get_neighbors_pixel(‖image, x_coordinate, y_coordinate, center‖1
image, x_coordinate, y_coordinate, center‖)‖1
for i in range(image.shape[0]):‖for j in range(image.shape[1]):‖2
for j in range(image.shape[1]):‖lbp_image[i][j] = lbp.local_binary_value(image, i, j)‖1
def main() -> None:‖"text = ""monkey banana"""‖1
"text = ""monkey banana"""‖suffix_tree = SuffixTree(text)‖1
"patterns = [""ana"", ""ban"", ""na"", ""xyz"", ""mon""]"‖for pattern in patterns:‖1
for pattern in patterns:‖found = suffix_tree.search(pattern)‖1
found = suffix_tree.search(pattern)‖"print(f""Pattern '{pattern}' found: {found}"")"‖1
class SuffixTree:‖def __init__(self, text: str) -> None:‖1
def __init__(self, text: str) -> None:‖self.text: str = text‖1
self.text: str = text‖self.root: SuffixTreeNode = SuffixTreeNode()‖1
self.root: SuffixTreeNode = SuffixTreeNode()‖self.build_suffix_tree()‖1
def build_suffix_tree(self) -> None:‖text = self.text‖1
text = self.text‖n = len(text)‖1
n = len(text)‖for i in range(n):‖1
for i in range(n):‖suffix = text[i:]‖1
suffix = text[i:]‖self._add_suffix(suffix, i)‖1
def _add_suffix(self, suffix: str, index: int) -> None:‖node = self.root‖1
node = self.root‖for char in suffix:‖1
for char in suffix:‖if char not in node.children:‖1
if char not in node.children:‖node.children[char] = SuffixTreeNode()‖1
node.children[char] = SuffixTreeNode()‖node = node.children[char]‖1
node = node.children[char]‖node.is_end_of_string = True‖1
node.is_end_of_string = True‖node.start = index‖1
node.start = index‖node.end = index + len(suffix) - 1‖1
def search(self, pattern: str) -> bool:‖node = self.root‖1
node = self.root‖for char in pattern:‖1
for char in pattern:‖if char not in node.children:‖1
if char not in node.children:‖return False‖1
return False‖node = node.children[char]‖1
node = node.children[char]‖return True‖1
from collections.abc import Iterator‖from typing import Generic, TypeVar‖1
def __init__(self) -> None:‖self.top: Node[T] | None = None‖1
def __iter__(self) -> Iterator[T]:‖node = self.top‖1
node = self.top‖while node:‖1
def __str__(self) -> str:‖"return ""->"".join([str(item) for item in self])"‖1
def is_empty(self) -> bool:‖return self.top is None‖1
def push(self, item: T) -> None:‖node = Node(item)‖1
node = Node(item)‖if not self.is_empty():‖1
if not self.is_empty():‖node.next = self.top‖1
node.next = self.top‖self.top = node‖1
def pop(self) -> T:‖if self.is_empty():‖1
if self.is_empty():‖"raise IndexError(""pop from empty stack"")"‖1
"raise IndexError(""pop from empty stack"")"‖assert isinstance(self.top, Node)‖1
assert isinstance(self.top, Node)‖pop_node = self.top‖1
pop_node = self.top‖self.top = self.top.next‖1
self.top = self.top.next‖return pop_node.data‖1
def peek(self) -> T:‖if self.is_empty():‖1
if self.is_empty():‖"raise IndexError(""peek from empty stack"")"‖1
assert self.top is not None‖return self.top.data‖1
def clear(self) -> None:‖self.top = None‖1
def __init__(self, red=None, green=None, blue=None, red_edge=None, nir=None):‖self.set_matricies(red=red, green=green, blue=blue, red_edge=red_edge, nir=nir)‖1
def set_matricies(self, red=None, green=None, blue=None, red_edge=None, nir=None):‖if red is not None:‖1
if red is not None:‖self.red = red‖1
self.red = red‖if green is not None:‖1
if green is not None:‖self.green = green‖1
self.green = green‖if blue is not None:‖1
if blue is not None:‖self.blue = blue‖1
self.blue = blue‖if red_edge is not None:‖1
if red_edge is not None:‖self.redEdge = red_edge‖1
self.redEdge = red_edge‖if nir is not None:‖1
if nir is not None:‖self.nir = nir‖1
self.nir = nir‖return True‖1
def calculation(‖"self, index="""", red=None, green=None, blue=None, red_edge=None, nir=None"‖1
"self, index="""", red=None, green=None, blue=None, red_edge=None, nir=None"‖):‖1
):‖self.set_matricies(red=red, green=green, blue=blue, red_edge=red_edge, nir=nir)‖1
self.set_matricies(red=red, green=green, blue=blue, red_edge=red_edge, nir=nir)‖funcs = {‖1
funcs = {‖"""ARVI2"": self.arv12,"‖1
"""ARVI2"": self.arv12,"‖"""CCCI"": self.ccci,"‖1
"""CCCI"": self.ccci,"‖"""CVI"": self.cvi,"‖1
"""CVI"": self.cvi,"‖"""GLI"": self.gli,"‖1
"""GLI"": self.gli,"‖"""NDVI"": self.ndvi,"‖1
"""NDVI"": self.ndvi,"‖"""BNDVI"": self.bndvi,"‖1
"""BNDVI"": self.bndvi,"‖"""redEdgeNDVI"": self.red_edge_ndvi,"‖1
"""redEdgeNDVI"": self.red_edge_ndvi,"‖"""GNDVI"": self.gndvi,"‖1
"""GNDVI"": self.gndvi,"‖"""GBNDVI"": self.gbndvi,"‖1
"""GBNDVI"": self.gbndvi,"‖"""GRNDVI"": self.grndvi,"‖1
"""GRNDVI"": self.grndvi,"‖"""RBNDVI"": self.rbndvi,"‖1
"""RBNDVI"": self.rbndvi,"‖"""PNDVI"": self.pndvi,"‖1
"""PNDVI"": self.pndvi,"‖"""ATSAVI"": self.atsavi,"‖1
"""ATSAVI"": self.atsavi,"‖"""BWDRVI"": self.bwdrvi,"‖1
"""BWDRVI"": self.bwdrvi,"‖"""CIgreen"": self.ci_green,"‖1
"""CIgreen"": self.ci_green,"‖"""CIrededge"": self.ci_rededge,"‖1
"""CIrededge"": self.ci_rededge,"‖"""CI"": self.ci,"‖1
"""CI"": self.ci,"‖"""CTVI"": self.ctvi,"‖1
"""CTVI"": self.ctvi,"‖"""GDVI"": self.gdvi,"‖1
"""GDVI"": self.gdvi,"‖"""EVI"": self.evi,"‖1
"""EVI"": self.evi,"‖"""GEMI"": self.gemi,"‖1
"""GEMI"": self.gemi,"‖"""GOSAVI"": self.gosavi,"‖1
"""GOSAVI"": self.gosavi,"‖"""GSAVI"": self.gsavi,"‖1
"""GSAVI"": self.gsavi,"‖"""Hue"": self.hue,"‖1
"""Hue"": self.hue,"‖"""IVI"": self.ivi,"‖1
"""IVI"": self.ivi,"‖"""IPVI"": self.ipvi,"‖1
"""IPVI"": self.ipvi,"‖"""I"": self.i,"‖1
"""I"": self.i,"‖"""RVI"": self.rvi,"‖1
"""RVI"": self.rvi,"‖"""MRVI"": self.mrvi,"‖1
"""MRVI"": self.mrvi,"‖"""MSAVI"": self.m_savi,"‖1
"""MSAVI"": self.m_savi,"‖"""NormG"": self.norm_g,"‖1
"""NormG"": self.norm_g,"‖"""NormNIR"": self.norm_nir,"‖1
"""NormNIR"": self.norm_nir,"‖"""NormR"": self.norm_r,"‖1
"""NormR"": self.norm_r,"‖"""NGRDI"": self.ngrdi,"‖1
"""NGRDI"": self.ngrdi,"‖"""RI"": self.ri,"‖1
"""RI"": self.ri,"‖"""S"": self.s,"‖1
"""S"": self.s,"‖"""IF"": self._if,"‖1
"""IF"": self._if,"‖"""DVI"": self.dvi,"‖1
"""DVI"": self.dvi,"‖"""TVI"": self.tvi,"‖1
"""TVI"": self.tvi,"‖"""NDRE"": self.ndre,"‖1
"""NDRE"": self.ndre,"‖}‖1
try:‖return funcs[index]()‖1
return funcs[index]()‖except KeyError:‖1
except KeyError:‖"print(""Index not in the list!"")"‖1
"print(""Index not in the list!"")"‖return False‖1
def arv12(self):‖return -0.18 + (1.17 * ((self.nir - self.red) / (self.nir + self.red)))‖1
def ccci(self):‖return ((self.nir - self.redEdge) / (self.nir + self.redEdge)) / (‖1
return ((self.nir - self.redEdge) / (self.nir + self.redEdge)) / (‖(self.nir - self.red) / (self.nir + self.red)‖1
(self.nir - self.red) / (self.nir + self.red)‖)‖1
def cvi(self):‖return self.nir * (self.red / (self.green**2))‖1
def gli(self):‖return (2 * self.green - self.red - self.blue) / (‖1
return (2 * self.green - self.red - self.blue) / (‖2 * self.green + self.red + self.blue‖1
2 * self.green + self.red + self.blue‖)‖1
def ndvi(self):‖return (self.nir - self.red) / (self.nir + self.red)‖1
def bndvi(self):‖return (self.nir - self.blue) / (self.nir + self.blue)‖1
def red_edge_ndvi(self):‖return (self.redEdge - self.red) / (self.redEdge + self.red)‖1
def gndvi(self):‖return (self.nir - self.green) / (self.nir + self.green)‖1
def gbndvi(self):‖return (self.nir - (self.green + self.blue)) / (‖1
return (self.nir - (self.green + self.blue)) / (‖self.nir + (self.green + self.blue)‖1
self.nir + (self.green + self.blue)‖)‖1
def grndvi(self):‖return (self.nir - (self.green + self.red)) / (‖1
return (self.nir - (self.green + self.red)) / (‖self.nir + (self.green + self.red)‖1
self.nir + (self.green + self.red)‖)‖1
def rbndvi(self):‖return (self.nir - (self.blue + self.red)) / (self.nir + (self.blue + self.red))‖1
def pndvi(self):‖return (self.nir - (self.green + self.red + self.blue)) / (‖1
return (self.nir - (self.green + self.red + self.blue)) / (‖self.nir + (self.green + self.red + self.blue)‖1
self.nir + (self.green + self.red + self.blue)‖)‖1
def atsavi(self, x=0.08, a=1.22, b=0.03):‖return a * (‖1
return a * (‖(self.nir - a * self.red - b)‖1
(self.nir - a * self.red - b)‖/ (a * self.nir + self.red - a * b + x * (1 + a**2))‖1
/ (a * self.nir + self.red - a * b + x * (1 + a**2))‖)‖1
def bwdrvi(self):‖return (0.1 * self.nir - self.blue) / (0.1 * self.nir + self.blue)‖1
def ci_green(self):‖return (self.nir / self.green) - 1‖1
def ci_rededge(self):‖return (self.nir / self.redEdge) - 1‖1
def ci(self):‖return (self.red - self.blue) / self.red‖1
def ctvi(self):‖ndvi = self.ndvi()‖1
ndvi = self.ndvi()‖return ((ndvi + 0.5) / (abs(ndvi + 0.5))) * (abs(ndvi + 0.5) ** (1 / 2))‖1
def gdvi(self):‖return self.nir - self.green‖1
def evi(self):‖return 2.5 * (‖1
return 2.5 * (‖(self.nir - self.red) / (self.nir + 6 * self.red - 7.5 * self.blue + 1)‖1
(self.nir - self.red) / (self.nir + 6 * self.red - 7.5 * self.blue + 1)‖)‖1
def gemi(self):‖n = (2 * (self.nir**2 - self.red**2) + 1.5 * self.nir + 0.5 * self.red) / (‖1
n = (2 * (self.nir**2 - self.red**2) + 1.5 * self.nir + 0.5 * self.red) / (‖self.nir + self.red + 0.5‖1
self.nir + self.red + 0.5‖)‖1
)‖return n * (1 - 0.25 * n) - (self.red - 0.125) / (1 - self.red)‖1
def gosavi(self, y=0.16):‖return (self.nir - self.green) / (self.nir + self.green + y)‖1
def gsavi(self, n=0.5):‖return ((self.nir - self.green) / (self.nir + self.green + n)) * (1 + n)‖1
def hue(self):‖return np.arctan(‖1
return np.arctan(‖((2 * self.red - self.green - self.blue) / 30.5) * (self.green - self.blue)‖1
((2 * self.red - self.green - self.blue) / 30.5) * (self.green - self.blue)‖)‖1
def ivi(self, a=None, b=None):‖return (self.nir - b) / (a * self.red)‖1
def ipvi(self):‖return (self.nir / ((self.nir + self.red) / 2)) * (self.ndvi() + 1)‖1
def i(self):‖return (self.red + self.green + self.blue) / 30.5‖1
def rvi(self):‖return self.nir / self.red‖1
def mrvi(self):‖return (self.rvi() - 1) / (self.rvi() + 1)‖1
def m_savi(self):‖return (‖1
return (‖(2 * self.nir + 1)‖1
(2 * self.nir + 1)‖- ((2 * self.nir + 1) ** 2 - 8 * (self.nir - self.red)) ** (1 / 2)‖1
- ((2 * self.nir + 1) ** 2 - 8 * (self.nir - self.red)) ** (1 / 2)‖) / 2‖1
def norm_g(self):‖return self.green / (self.nir + self.red + self.green)‖1
def norm_nir(self):‖return self.nir / (self.nir + self.red + self.green)‖1
def norm_r(self):‖return self.red / (self.nir + self.red + self.green)‖1
def ngrdi(self):‖return (self.green - self.red) / (self.green + self.red)‖1
def ri(self):‖return (self.red - self.green) / (self.red + self.green)‖1
def s(self):‖max_value = np.max([np.max(self.red), np.max(self.green), np.max(self.blue)])‖1
max_value = np.max([np.max(self.red), np.max(self.green), np.max(self.blue)])‖min_value = np.min([np.min(self.red), np.min(self.green), np.min(self.blue)])‖1
min_value = np.min([np.min(self.red), np.min(self.green), np.min(self.blue)])‖return (max_value - min_value) / max_value‖1
def _if(self):‖return (2 * self.red - self.green - self.blue) / (self.green - self.blue)‖1
def dvi(self):‖return self.nir / self.red‖1
def tvi(self):‖return (self.ndvi() + 0.5) ** (1 / 2)‖1
def ndre(self):‖return (self.nir - self.redEdge) / (self.nir + self.redEdge)‖1
class TestSuffixTree(unittest.TestCase):‖def setUp(self) -> None:‖1
def setUp(self) -> None:‖"self.text = ""banana"""‖1
"self.text = ""banana"""‖self.suffix_tree = SuffixTree(self.text)‖1
def test_search_existing_patterns(self) -> None:‖"patterns = [""ana"", ""ban"", ""na""]"‖1
"patterns = [""ana"", ""ban"", ""na""]"‖for pattern in patterns:‖1
for pattern in patterns:‖with self.subTest(pattern=pattern):‖2
with self.subTest(pattern=pattern):‖assert self.suffix_tree.search(pattern), (‖1
assert self.suffix_tree.search(pattern), (‖"f""Pattern '{pattern}' should be found."""‖1
"f""Pattern '{pattern}' should be found."""‖)‖1
def test_search_non_existing_patterns(self) -> None:‖"patterns = [""xyz"", ""apple"", ""cat""]"‖1
"patterns = [""xyz"", ""apple"", ""cat""]"‖for pattern in patterns:‖1
with self.subTest(pattern=pattern):‖assert not self.suffix_tree.search(pattern), (‖1
assert not self.suffix_tree.search(pattern), (‖"f""Pattern '{pattern}' should not be found."""‖1
"f""Pattern '{pattern}' should not be found."""‖)‖1
def test_search_empty_pattern(self) -> None:‖"assert self.suffix_tree.search(""""), ""An empty pattern should be found."""‖1
def test_search_full_text(self) -> None:‖assert self.suffix_tree.search(self.text), (‖1
assert self.suffix_tree.search(self.text), (‖"""The full text should be found in the suffix tree."""‖1
"""The full text should be found in the suffix tree."""‖)‖1
def test_search_substrings(self) -> None:‖"substrings = [""ban"", ""ana"", ""a"", ""na""]"‖1
"substrings = [""ban"", ""ana"", ""a"", ""na""]"‖for substring in substrings:‖1
for substring in substrings:‖with self.subTest(substring=substring):‖1
with self.subTest(substring=substring):‖assert self.suffix_tree.search(substring), (‖1
assert self.suffix_tree.search(substring), (‖"f""Substring '{substring}' should be found."""‖1
"f""Substring '{substring}' should be found."""‖)‖1
"if __name__ == ""__main__"":"‖unittest.main()‖7
def change_contrast(img: Image, level: int) -> Image:‖factor = (259 * (level + 255)) / (255 * (259 - level))‖1
def contrast(c: int) -> int:‖return int(128 + factor * (c - 128))‖1
cont_img = change_contrast(img, 170)‖"cont_img.save(""image_data/lena_high_contrast.png"", format=""png"")"‖1
class TrieNode:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self.nodes: dict[str, TrieNode] = {}‖1
self.nodes: dict[str, TrieNode] = {}‖self.is_leaf = False‖1
def insert(self, word: str) -> None:‖curr = self‖1
curr = self‖for char in word:‖2
for char in word:‖if char not in curr.nodes:‖2
if char not in curr.nodes:‖curr.nodes[char] = TrieNode()‖1
curr.nodes[char] = TrieNode()‖curr = curr.nodes[char]‖1
curr = curr.nodes[char]‖curr.is_leaf = True‖1
def find(self, word: str) -> bool:‖curr = self‖1
if char not in curr.nodes:‖return False‖1
return False‖curr = curr.nodes[char]‖1
curr = curr.nodes[char]‖return curr.is_leaf‖1
def _delete(curr: TrieNode, word: str, index: int) -> bool:‖if index == len(word):‖1
if not curr.is_leaf:‖return False‖1
return False‖curr.is_leaf = False‖1
curr.is_leaf = False‖return len(curr.nodes) == 0‖1
return len(curr.nodes) == 0‖char = word[index]‖1
char = word[index]‖char_node = curr.nodes.get(char)‖1
if not char_node:‖return False‖1
delete_curr = _delete(char_node, word, index + 1)‖if delete_curr:‖1
if delete_curr:‖del curr.nodes[char]‖1
del curr.nodes[char]‖return len(curr.nodes) == 0‖1
return len(curr.nodes) == 0‖return delete_curr‖1
def print_words(node: TrieNode, word: str) -> None:‖if node.is_leaf:‖1
if node.is_leaf:‖"print(word, end="" "")"‖1
for key, value in node.nodes.items():‖print_words(value, word + key)‖1
"words = ""banana bananas bandana band apple all beast"".split()"‖root = TrieNode()‖1
root = TrieNode()‖root.insert_many(words)‖1
assert all(root.find(word) for word in words)‖"assert root.find(""banana"")"‖1
"assert root.find(""banana"")"‖"assert not root.find(""bandanas"")"‖1
"assert not root.find(""apps"")"‖"assert root.find(""apple"")"‖1
"assert root.find(""apple"")"‖"assert root.find(""all"")"‖1
"assert root.find(""all"")"‖"root.delete(""all"")"‖1
"assert root.find(""bananas"")"‖return True‖1
def main() -> None:‖"print_results(""Testing trie functionality"", test_trie())"‖1
def make_sepia(img, factor: int):‖pixel_h, pixel_v = img.shape[0], img.shape[1]‖1
def to_grayscale(blue, green, red):‖return 0.2126 * red + 0.587 * green + 0.114 * blue‖1
def normalize(value):‖return min(value, 255)‖1
for i in range(pixel_h):‖for j in range(pixel_v):‖2
for j in range(pixel_v):‖greyscale = int(to_grayscale(*img[i][j]))‖1
greyscale = int(to_grayscale(*img[i][j]))‖img[i][j] = [‖1
img[i][j] = [‖normalize(greyscale),‖1
normalize(greyscale),‖normalize(greyscale + factor),‖1
normalize(greyscale + factor),‖normalize(greyscale + 2 * factor),‖1
normalize(greyscale + 2 * factor),‖]‖1
images = {‖"percentage: imread(""image_data/lena.jpg"", 1) for percentage in (10, 20, 30, 40)"‖1
"percentage: imread(""image_data/lena.jpg"", 1) for percentage in (10, 20, 30, 40)"‖}‖1
for percentage, img in images.items():‖make_sepia(img, percentage)‖1
for percentage, img in images.items():‖"imshow(f""Original image with sepia (factor: {percentage})"", img)"‖1
waitKey(0)‖destroyAllWindows()‖4
from digital_image_processing.filters.convolve import img_convolve‖from digital_image_processing.filters.sobel_filter import sobel_filter‖1
def gen_gaussian_kernel(k_size, sigma):‖center = k_size // 2‖2
center = k_size // 2‖x, y = np.mgrid[0 - center : k_size - center, 0 - center : k_size - center]‖1
x, y = np.mgrid[0 - center : k_size - center, 0 - center : k_size - center]‖g = (‖1
g = (‖1‖1
1‖/ (2 * np.pi * sigma)‖1
/ (2 * np.pi * sigma)‖* np.exp(-(np.square(x) + np.square(y)) / (2 * np.square(sigma)))‖1
* np.exp(-(np.square(x) + np.square(y)) / (2 * np.square(sigma)))‖)‖1
)‖return g‖1
def suppress_non_maximum(image_shape, gradient_direction, sobel_grad):‖destination = np.zeros(image_shape)‖1
for row in range(1, image_shape[0] - 1):‖for col in range(1, image_shape[1] - 1):‖2
for col in range(1, image_shape[1] - 1):‖direction = gradient_direction[row, col]‖1
if (‖0 <= direction < PI / 8‖1
0 <= direction < PI / 8‖or 15 * PI / 8 <= direction <= 2 * PI‖1
or 15 * PI / 8 <= direction <= 2 * PI‖or 7 * PI / 8 <= direction <= 9 * PI / 8‖1
or 7 * PI / 8 <= direction <= 9 * PI / 8‖):‖1
):‖w = sobel_grad[row, col - 1]‖1
w = sobel_grad[row, col - 1]‖e = sobel_grad[row, col + 1]‖1
e = sobel_grad[row, col + 1]‖if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:‖1
if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:‖destination[row, col] = sobel_grad[row, col]‖1
elif (‖PI / 8 <= direction < 3 * PI / 8‖1
PI / 8 <= direction < 3 * PI / 8‖or 9 * PI / 8 <= direction < 11 * PI / 8‖1
or 9 * PI / 8 <= direction < 11 * PI / 8‖):‖1
):‖sw = sobel_grad[row + 1, col - 1]‖1
sw = sobel_grad[row + 1, col - 1]‖ne = sobel_grad[row - 1, col + 1]‖1
ne = sobel_grad[row - 1, col + 1]‖if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:‖1
if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:‖destination[row, col] = sobel_grad[row, col]‖1
elif (‖3 * PI / 8 <= direction < 5 * PI / 8‖1
3 * PI / 8 <= direction < 5 * PI / 8‖or 11 * PI / 8 <= direction < 13 * PI / 8‖1
or 11 * PI / 8 <= direction < 13 * PI / 8‖):‖1
):‖n = sobel_grad[row - 1, col]‖1
n = sobel_grad[row - 1, col]‖s = sobel_grad[row + 1, col]‖1
s = sobel_grad[row + 1, col]‖if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:‖1
if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:‖destination[row, col] = sobel_grad[row, col]‖1
elif (‖5 * PI / 8 <= direction < 7 * PI / 8‖1
5 * PI / 8 <= direction < 7 * PI / 8‖or 13 * PI / 8 <= direction < 15 * PI / 8‖1
or 13 * PI / 8 <= direction < 15 * PI / 8‖):‖1
):‖nw = sobel_grad[row - 1, col - 1]‖1
nw = sobel_grad[row - 1, col - 1]‖se = sobel_grad[row + 1, col + 1]‖1
se = sobel_grad[row + 1, col + 1]‖if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:‖1
if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:‖destination[row, col] = sobel_grad[row, col]‖1
def detect_high_low_threshold(‖image_shape, destination, threshold_low, threshold_high, weak, strong‖1
image_shape, destination, threshold_low, threshold_high, weak, strong‖):‖1
):‖for row in range(1, image_shape[0] - 1):‖1
for col in range(1, image_shape[1] - 1):‖if destination[row, col] >= threshold_high:‖1
if destination[row, col] >= threshold_high:‖destination[row, col] = strong‖1
destination[row, col] = strong‖elif destination[row, col] <= threshold_low:‖1
elif destination[row, col] <= threshold_low:‖destination[row, col] = 0‖1
destination[row, col] = 0‖else:‖1
else:‖destination[row, col] = weak‖1
def track_edge(image_shape, destination, weak, strong):‖for row in range(1, image_shape[0]):‖1
for row in range(1, image_shape[0]):‖for col in range(1, image_shape[1]):‖1
for col in range(1, image_shape[1]):‖if destination[row, col] == weak:‖1
if destination[row, col] == weak:‖if 255 in (‖1
if 255 in (‖destination[row, col + 1],‖1
destination[row, col + 1],‖destination[row, col - 1],‖1
destination[row, col - 1],‖destination[row - 1, col],‖1
destination[row - 1, col],‖destination[row + 1, col],‖1
destination[row + 1, col],‖destination[row - 1, col - 1],‖1
destination[row - 1, col - 1],‖destination[row + 1, col - 1],‖1
destination[row + 1, col - 1],‖destination[row - 1, col + 1],‖1
destination[row - 1, col + 1],‖destination[row + 1, col + 1],‖1
destination[row + 1, col + 1],‖):‖1
):‖destination[row, col] = strong‖1
destination[row, col] = strong‖else:‖1
else:‖destination[row, col] = 0‖1
sobel_grad, sobel_theta = sobel_filter(gaussian_out)‖gradient_direction = PI + np.rad2deg(sobel_theta)‖1
detect_high_low_threshold(‖image.shape, destination, threshold_low, threshold_high, weak, strong‖1
image.shape, destination, threshold_low, threshold_high, weak, strong‖)‖1
canny_destination = canny(lena)‖"cv2.imshow(""canny"", canny_destination)"‖1
"cv2.imshow(""canny"", canny_destination)"‖cv2.waitKey(0)‖1
def brightness(c: int) -> float:‖return 128 + level + (c - 128)‖1
if not -255.0 <= level <= 255.0:‖"raise ValueError(""level must be between -255.0 (black) and 255.0 (white)"")"‖1
"raise ValueError(""level must be between -255.0 (black) and 255.0 (white)"")"‖return img.point(brightness)‖1
brigt_img = change_brightness(img, 100)‖"brigt_img.save(""image_data/lena_brightness.png"", format=""png"")"‖1
for j in range(pixel_v):‖img[i][j] = [255, 255, 255] - img[i][j]‖1
"imshow(""negative of original image"", img)"‖waitKey(0)‖1
sigma = math.sqrt(variance)‖cons = 1 / (sigma * math.sqrt(2 * math.pi))‖1
cons = 1 / (sigma * math.sqrt(2 * math.pi))‖return cons * np.exp(-((img / sigma) ** 2) * 0.5)‖1
def get_slice(img: np.ndarray, x: int, y: int, kernel_size: int) -> np.ndarray:‖half = kernel_size // 2‖1
half = kernel_size // 2‖return img[x - half : x + half + 1, y - half : y + half + 1]‖1
arr = np.zeros((kernel_size, kernel_size))‖for i in range(kernel_size):‖1
for i in range(kernel_size):‖for j in range(kernel_size):‖1
for j in range(kernel_size):‖arr[i, j] = math.sqrt(‖1
arr[i, j] = math.sqrt(‖abs(i - kernel_size // 2) ** 2 + abs(j - kernel_size // 2) ** 2‖1
abs(i - kernel_size // 2) ** 2 + abs(j - kernel_size // 2) ** 2‖)‖1
)‖return vec_gaussian(arr, spatial_variance)‖1
def bilateral_filter(‖img: np.ndarray,‖1
img: np.ndarray,‖spatial_variance: float,‖1
spatial_variance: float,‖intensity_variance: float,‖1
intensity_variance: float,‖kernel_size: int,‖1
kernel_size: int,‖) -> np.ndarray:‖1
) -> np.ndarray:‖img2 = np.zeros(img.shape)‖1
img2 = np.zeros(img.shape)‖gauss_ker = get_gauss_kernel(kernel_size, spatial_variance)‖1
gauss_ker = get_gauss_kernel(kernel_size, spatial_variance)‖size_x, size_y = img.shape‖1
size_x, size_y = img.shape‖for i in range(kernel_size // 2, size_x - kernel_size // 2):‖1
for i in range(kernel_size // 2, size_x - kernel_size // 2):‖for j in range(kernel_size // 2, size_y - kernel_size // 2):‖1
for j in range(kernel_size // 2, size_y - kernel_size // 2):‖img_s = get_slice(img, i, j, kernel_size)‖1
img_s = get_slice(img, i, j, kernel_size)‖img_i = img_s - img_s[kernel_size // 2, kernel_size // 2]‖1
img_i = img_s - img_s[kernel_size // 2, kernel_size // 2]‖img_ig = vec_gaussian(img_i, intensity_variance)‖1
img_ig = vec_gaussian(img_i, intensity_variance)‖weights = np.multiply(gauss_ker, img_ig)‖1
weights = np.multiply(gauss_ker, img_ig)‖vals = np.multiply(img_s, weights)‖1
vals = np.multiply(img_s, weights)‖val = np.sum(vals) / np.sum(weights)‖1
val = np.sum(vals) / np.sum(weights)‖img2[i, j] = val‖1
img2[i, j] = val‖return img2‖1
def parse_args(args: list) -> tuple:‖"filename = args[1] if args[1:] else ""../image_data/lena.jpg"""‖1
"filename = args[1] if args[1:] else ""../image_data/lena.jpg"""‖spatial_variance = float(args[2]) if args[2:] else 1.0‖1
spatial_variance = float(args[2]) if args[2:] else 1.0‖intensity_variance = float(args[3]) if args[3:] else 1.0‖1
intensity_variance = float(args[3]) if args[3:] else 1.0‖if args[4:]:‖1
if args[4:]:‖kernel_size = int(args[4])‖1
kernel_size = int(args[4])‖kernel_size = kernel_size + abs(kernel_size % 2 - 1)‖1
kernel_size = kernel_size + abs(kernel_size % 2 - 1)‖else:‖1
else:‖kernel_size = 5‖1
kernel_size = 5‖return filename, spatial_variance, intensity_variance, kernel_size‖1
"if __name__ == ""__main__"":"‖filename, spatial_variance, intensity_variance, kernel_size = parse_args(sys.argv)‖1
filename, spatial_variance, intensity_variance, kernel_size = parse_args(sys.argv)‖img = cv2.imread(filename, 0)‖1
img = cv2.imread(filename, 0)‖"cv2.imshow(""input image"", img)"‖1
out = img / 255‖"out = out.astype(""float32"")"‖1
"out = out.astype(""float32"")"‖out = bilateral_filter(out, spatial_variance, intensity_variance, kernel_size)‖1
out = bilateral_filter(out, spatial_variance, intensity_variance, kernel_size)‖out = out * 255‖1
out = out * 255‖out = np.uint8(out)‖1
out = np.uint8(out)‖"cv2.imshow(""output image"", out)"‖1
"cv2.imshow(""output image"", out)"‖cv2.waitKey(0)‖1
cv2.waitKey(0)‖cv2.destroyAllWindows()‖2
from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey‖from numpy import dot, exp, mgrid, pi, ravel, square, uint8, zeros‖1
center = k_size // 2‖x, y = mgrid[0 - center : k_size - center, 0 - center : k_size - center]‖1
x, y = mgrid[0 - center : k_size - center, 0 - center : k_size - center]‖g = 1 / (2 * pi * sigma) * exp(-(square(x) + square(y)) / (2 * square(sigma)))‖1
g = 1 / (2 * pi * sigma) * exp(-(square(x) + square(y)) / (2 * square(sigma)))‖return g‖1
def gaussian_filter(image, k_size, sigma):‖height, width = image.shape[0], image.shape[1]‖1
dst_height = height - k_size + 1‖dst_width = width - k_size + 1‖1
image_array = zeros((dst_height * dst_width, k_size * k_size))‖for row, (i, j) in enumerate(product(range(dst_height), range(dst_width))):‖1
for row, (i, j) in enumerate(product(range(dst_height), range(dst_width))):‖window = ravel(image[i : i + k_size, j : j + k_size])‖1
window = ravel(image[i : i + k_size, j : j + k_size])‖image_array[row, :] = window‖1
gaussian_kernel = gen_gaussian_kernel(k_size, sigma)‖filter_array = ravel(gaussian_kernel)‖1
gaussian3x3 = gaussian_filter(gray, 3, sigma=1)‖gaussian5x5 = gaussian_filter(gray, 5, sigma=0.8)‖1
"imshow(""gaussian filter with 3x3 mask"", gaussian3x3)"‖"imshow(""gaussian filter with 5x5 mask"", gaussian5x5)"‖1
"imshow(""gaussian filter with 5x5 mask"", gaussian5x5)"‖waitKey()‖1
def get_neighbors_pixel(‖image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int‖1
image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int‖) -> int:‖1
try:‖return int(image[x_coordinate][y_coordinate] >= center)‖1
return int(image[x_coordinate][y_coordinate] >= center)‖except (IndexError, TypeError):‖1
except (IndexError, TypeError):‖return 0‖1
def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:‖center = image[x_coordinate][y_coordinate]‖1
center = image[x_coordinate][y_coordinate]‖powers = [1, 2, 4, 8, 16, 32, 64, 128]‖1
if center is None:‖return 0‖1
binary_values = [‖get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),‖1
get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),‖get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),‖1
get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),‖get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),‖1
get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),‖get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),‖1
get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),‖get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),‖1
get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),‖get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),‖1
get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),‖get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),‖1
get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),‖get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),‖1
get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),‖]‖1
return sum(‖binary_value * power for binary_value, power in zip(binary_values, powers)‖1
binary_value * power for binary_value, power in zip(binary_values, powers)‖)‖1
image = cv2.imread(‖"""digital_image_processing/image_data/lena.jpg"", cv2.IMREAD_GRAYSCALE"‖1
"""digital_image_processing/image_data/lena.jpg"", cv2.IMREAD_GRAYSCALE"‖)‖1
for j in range(image.shape[1]):‖lbp_image[i][j] = local_binary_value(image, i, j)‖1
"cv2.imshow(""local binary pattern"", lbp_image)"‖cv2.waitKey(0)‖1
import numpy as np‖from cv2 import (‖1
from cv2 import (‖BORDER_DEFAULT,‖1
BORDER_DEFAULT,‖COLOR_BGR2GRAY,‖1
COLOR_BGR2GRAY,‖CV_64F,‖1
CV_64F,‖cvtColor,‖1
cvtColor,‖filter2D,‖1
filter2D,‖imread,‖1
imread,‖imshow,‖1
imshow,‖waitKey,‖1
waitKey,‖)‖1
def my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:‖kernels = {‖1
kernels = {‖1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),‖1
1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),‖3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),‖1
3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),‖5: np.array(‖1
5: np.array(‖[‖1
[‖[0, 0, -1, 0, 0],‖1
[0, 0, -1, 0, 0],‖[0, -1, -2, -1, 0],‖1
[0, -1, -2, -1, 0],‖[-1, -2, 16, -2, -1],‖1
[-1, -2, 16, -2, -1],‖[0, -1, -2, -1, 0],‖1
[0, -1, -2, -1, 0],‖[0, 0, -1, 0, 0],‖1
[0, 0, -1, 0, 0],‖]‖1
]‖),‖2
),‖7: np.array(‖1
7: np.array(‖[‖1
[‖[0, 0, 0, -1, 0, 0, 0],‖1
[0, 0, 0, -1, 0, 0, 0],‖[0, 0, -2, -3, -2, 0, 0],‖1
[0, 0, -2, -3, -2, 0, 0],‖[0, -2, -7, -10, -7, -2, 0],‖1
[0, -2, -7, -10, -7, -2, 0],‖[-1, -3, -10, 68, -10, -3, -1],‖1
[-1, -3, -10, 68, -10, -3, -1],‖[0, -2, -7, -10, -7, -2, 0],‖1
[0, -2, -7, -10, -7, -2, 0],‖[0, 0, -2, -3, -2, 0, 0],‖1
[0, 0, -2, -3, -2, 0, 0],‖[0, 0, 0, -1, 0, 0, 0],‖1
[0, 0, 0, -1, 0, 0, 0],‖]‖1
),‖}‖1
}‖if ksize not in kernels:‖1
if ksize not in kernels:‖"msg = f""ksize must be in {tuple(kernels)}"""‖1
"msg = f""ksize must be in {tuple(kernels)}"""‖raise ValueError(msg)‖1
return filter2D(‖src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)‖1
src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)‖)‖1
"imshow(""Original image"", img)"‖"imshow(""Detected edges using laplacian filter"", laplacian_image)"‖1
from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey‖from numpy import divide, int8, multiply, ravel, sort, zeros_like‖1
median_img = zeros_like(gray_img)‖for i in range(bd, gray_img.shape[0] - bd):‖1
for i in range(bd, gray_img.shape[0] - bd):‖for j in range(bd, gray_img.shape[1] - bd):‖1
median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]‖median_img[i, j] = median‖1
median_img[i, j] = median‖return median_img‖1
median3x3 = median_filter(gray, 3)‖median5x5 = median_filter(gray, 5)‖1
"imshow(""median filter with 3x3 mask"", median3x3)"‖"imshow(""median filter with 5x5 mask"", median5x5)"‖1
"imshow(""median filter with 5x5 mask"", median5x5)"‖waitKey(0)‖1
import copy‖import os‖1
class ConstantStretch:‖def __init__(self):‖1
def __init__(self):‖"self.img = """""‖1
"self.img = """""‖"self.original_image = """""‖1
"self.original_image = """""‖self.last_list = []‖1
self.last_list = []‖self.rem = 0‖1
self.rem = 0‖self.L = 256‖1
self.L = 256‖self.sk = 0‖1
self.sk = 0‖self.k = 0‖1
self.k = 0‖self.number_of_rows = 0‖1
self.number_of_rows = 0‖self.number_of_cols = 0‖1
def stretch(self, input_image):‖self.img = cv2.imread(input_image, 0)‖1
self.img = cv2.imread(input_image, 0)‖self.original_image = copy.deepcopy(self.img)‖1
self.original_image = copy.deepcopy(self.img)‖"x, _, _ = plt.hist(self.img.ravel(), 256, [0, 256], label=""x"")"‖1
"x, _, _ = plt.hist(self.img.ravel(), 256, [0, 256], label=""x"")"‖self.k = np.sum(x)‖1
self.k = np.sum(x)‖for i in range(len(x)):‖1
for i in range(len(x)):‖prk = x[i] / self.k‖1
prk = x[i] / self.k‖self.sk += prk‖1
self.sk += prk‖last = (self.L - 1) * self.sk‖1
last = (self.L - 1) * self.sk‖if self.rem != 0:‖1
if self.rem != 0:‖self.rem = int(last % last)‖1
self.rem = int(last % last)‖last = int(last + 1 if self.rem >= 0.5 else last)‖1
last = int(last + 1 if self.rem >= 0.5 else last)‖self.last_list.append(last)‖1
self.last_list.append(last)‖self.number_of_rows = int(np.ma.count(self.img) / self.img[1].size)‖1
self.number_of_rows = int(np.ma.count(self.img) / self.img[1].size)‖self.number_of_cols = self.img[1].size‖1
self.number_of_cols = self.img[1].size‖for i in range(self.number_of_cols):‖1
for i in range(self.number_of_cols):‖for j in range(self.number_of_rows):‖1
for j in range(self.number_of_rows):‖num = self.img[j][i]‖1
num = self.img[j][i]‖if num != self.last_list[num]:‖1
if num != self.last_list[num]:‖self.img[j][i] = self.last_list[num]‖1
self.img[j][i] = self.last_list[num]‖"cv2.imwrite(""output_data/output.jpg"", self.img)"‖1
def plot_histogram(self):‖plt.hist(self.img.ravel(), 256, [0, 256])‖1
def show_image(self):‖"cv2.imshow(""Output-Image"", self.img)"‖1
"cv2.imshow(""Output-Image"", self.img)"‖"cv2.imshow(""Input-Image"", self.original_image)"‖1
"cv2.imshow(""Input-Image"", self.original_image)"‖cv2.waitKey(5000)‖1
cv2.waitKey(5000)‖cv2.destroyAllWindows()‖1
"if __name__ == ""__main__"":"‖"file_path = os.path.join(os.path.basename(__file__), ""image_data/input.jpg"")"‖1
"file_path = os.path.join(os.path.basename(__file__), ""image_data/input.jpg"")"‖stretcher = ConstantStretch()‖1
stretcher = ConstantStretch()‖stretcher.stretch(file_path)‖1
stretcher.stretch(file_path)‖stretcher.plot_histogram()‖1
stretcher.plot_histogram()‖stretcher.show_image()‖1
import numpy as np‖from cv2 import destroyAllWindows, imread, imshow, waitKey‖2
def __init__(self, input_img, threshold: int):‖self.min_threshold = 0‖1
if not self.min_threshold < threshold < self.max_threshold:‖"msg = f""Factor value should be from 0 to {self.max_threshold}"""‖1
"msg = f""Factor value should be from 0 to {self.max_threshold}"""‖raise ValueError(msg)‖1
self.input_img = input_img‖self.threshold = threshold‖1
self.threshold = threshold‖self.width, self.height = self.input_img.shape[1], self.input_img.shape[0]‖1
self.error_table = [‖[0 for _ in range(self.height + 4)] for __ in range(self.width + 1)‖1
[0 for _ in range(self.height + 4)] for __ in range(self.width + 1)‖]‖1
]‖self.output_img = np.ones((self.width, self.height, 3), np.uint8) * 255‖1
@classmethod‖def get_greyscale(cls, blue: int, green: int, red: int) -> float:‖1
def get_greyscale(cls, blue: int, green: int, red: int) -> float:‖return 0.114 * blue + 0.587 * green + 0.299 * red‖1
def process(self) -> None:‖for y in range(self.height):‖1
for y in range(self.height):‖for x in range(self.width):‖1
for x in range(self.width):‖greyscale = int(self.get_greyscale(*self.input_img[y][x]))‖1
greyscale = int(self.get_greyscale(*self.input_img[y][x]))‖if self.threshold > greyscale + self.error_table[y][x]:‖1
if self.threshold > greyscale + self.error_table[y][x]:‖self.output_img[y][x] = (0, 0, 0)‖1
self.output_img[y][x] = (0, 0, 0)‖current_error = greyscale + self.error_table[y][x]‖1
current_error = greyscale + self.error_table[y][x]‖else:‖1
else:‖self.output_img[y][x] = (255, 255, 255)‖1
self.output_img[y][x] = (255, 255, 255)‖current_error = greyscale + self.error_table[y][x] - 255‖1
current_error = greyscale + self.error_table[y][x] - 255‖self.error_table[y][x + 1] += int(8 / 32 * current_error)‖1
self.error_table[y][x + 1] += int(8 / 32 * current_error)‖self.error_table[y][x + 2] += int(4 / 32 * current_error)‖1
self.error_table[y][x + 2] += int(4 / 32 * current_error)‖self.error_table[y + 1][x] += int(8 / 32 * current_error)‖1
self.error_table[y + 1][x] += int(8 / 32 * current_error)‖self.error_table[y + 1][x + 1] += int(4 / 32 * current_error)‖1
self.error_table[y + 1][x + 1] += int(4 / 32 * current_error)‖self.error_table[y + 1][x + 2] += int(2 / 32 * current_error)‖1
self.error_table[y + 1][x + 2] += int(2 / 32 * current_error)‖self.error_table[y + 1][x - 1] += int(4 / 32 * current_error)‖1
self.error_table[y + 1][x - 1] += int(4 / 32 * current_error)‖self.error_table[y + 1][x - 2] += int(2 / 32 * current_error)‖1
burkes_instances = [‖"Burkes(imread(""image_data/lena.jpg"", 1), threshold)"‖1
"Burkes(imread(""image_data/lena.jpg"", 1), threshold)"‖for threshold in (1, 126, 130, 140)‖1
for threshold in (1, 126, 130, 140)‖]‖1
for burkes in burkes_instances:‖burkes.process()‖1
for burkes in burkes_instances:‖imshow(‖1
imshow(‖"f""Original image with dithering threshold: {burkes.threshold}"","‖1
"f""Original image with dithering threshold: {burkes.threshold}"","‖burkes.output_img,‖1
burkes.output_img,‖)‖1
import numpy as np‖from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey‖1
def sobel_filter(image):‖kernel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])‖1
kernel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])‖kernel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])‖1
dst_x = np.abs(img_convolve(image, kernel_x))‖dst_y = np.abs(img_convolve(image, kernel_y))‖1
dst_x = dst_x * 255 / np.max(dst_x)‖dst_y = dst_y * 255 / np.max(dst_y)‖1
dst_xy = np.sqrt((np.square(dst_x)) + (np.square(dst_y)))‖dst_xy = dst_xy * 255 / np.max(dst_xy)‖1
dst_xy = dst_xy * 255 / np.max(dst_xy)‖dst = dst_xy.astype(np.uint8)‖1
theta = np.arctan2(dst_y, dst_x)‖return dst, theta‖1
"imshow(""sobel filter"", sobel_grad)"‖"imshow(""sobel theta"", sobel_theta)"‖1
"imshow(""sobel theta"", sobel_theta)"‖waitKey(0)‖1
def rgb_to_gray(rgb: np.ndarray) -> np.ndarray:‖r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]‖2
r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]‖return 0.2989 * r + 0.5870 * g + 0.1140 * b‖2
def gray_to_binary(gray: np.ndarray) -> np.ndarray:‖return (gray > 127) & (gray <= 255)‖2
def dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:‖output = np.zeros_like(image)‖1
output = np.zeros_like(image)‖image_padded = np.zeros(‖2
image_padded = np.zeros(‖(image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)‖2
(image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)‖)‖2
for x in range(image.shape[1]):‖for y in range(image.shape[0]):‖2
for y in range(image.shape[0]):‖summation = (‖2
summation = (‖kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]‖2
kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]‖).sum()‖2
).sum()‖output[y, x] = int(summation > 0)‖1
output[y, x] = int(summation > 0)‖return output‖1
"lena_path = Path(__file__).resolve().parent / ""image_data"" / ""lena.jpg"""‖lena = np.array(Image.open(lena_path))‖2
structuring_element = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])‖output = dilation(gray_to_binary(rgb_to_gray(lena)), structuring_element)‖1
"pil_img = Image.fromarray(output).convert(""RGB"")"‖"pil_img.save(""result_dilation.png"")"‖1
from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey‖from numpy import array, dot, pad, ravel, uint8, zeros‖1
def im2col(image, block_size):‖rows, cols = image.shape‖1
rows, cols = image.shape‖dst_height = cols - block_size[1] + 1‖1
dst_height = cols - block_size[1] + 1‖dst_width = rows - block_size[0] + 1‖1
dst_width = rows - block_size[0] + 1‖image_array = zeros((dst_height * dst_width, block_size[1] * block_size[0]))‖1
image_array = zeros((dst_height * dst_width, block_size[1] * block_size[0]))‖row = 0‖1
row = 0‖for i in range(dst_height):‖1
for i in range(dst_height):‖for j in range(dst_width):‖1
for j in range(dst_width):‖window = ravel(image[i : i + block_size[0], j : j + block_size[1]])‖1
window = ravel(image[i : i + block_size[0], j : j + block_size[1]])‖image_array[row, :] = window‖1
image_array[row, :] = window‖row += 1‖1
def img_convolve(image, filter_kernel):‖height, width = image.shape[0], image.shape[1]‖1
height, width = image.shape[0], image.shape[1]‖k_size = filter_kernel.shape[0]‖1
k_size = filter_kernel.shape[0]‖pad_size = k_size // 2‖1
dst = dot(image_array, kernel_array).reshape(height, width)‖return dst‖1
Laplace_kernel = array([[0, 1, 0], [1, -4, 1], [0, 1, 0]])‖out = img_convolve(gray, Laplace_kernel).astype(uint8)‖1
out = img_convolve(gray, Laplace_kernel).astype(uint8)‖"imshow(""Laplacian"", out)"‖1
"imshow(""Laplacian"", out)"‖waitKey(0)‖1
def __init__(self, img, dst_width: int, dst_height: int):‖if dst_width < 0 or dst_height < 0:‖1
if dst_width < 0 or dst_height < 0:‖"raise ValueError(""Destination width/height should be > 0"")"‖1
self.img = img‖self.src_w = img.shape[1]‖1
self.src_w = img.shape[1]‖self.src_h = img.shape[0]‖1
self.src_h = img.shape[0]‖self.dst_w = dst_width‖1
self.dst_w = dst_width‖self.dst_h = dst_height‖1
self.ratio_x = self.src_w / self.dst_w‖self.ratio_y = self.src_h / self.dst_h‖1
self.output = self.output_img = (‖np.ones((self.dst_h, self.dst_w, 3), np.uint8) * 255‖1
np.ones((self.dst_h, self.dst_w, 3), np.uint8) * 255‖)‖1
def process(self):‖for i in range(self.dst_h):‖1
for i in range(self.dst_h):‖for j in range(self.dst_w):‖1
for j in range(self.dst_w):‖self.output[i][j] = self.img[self.get_y(i)][self.get_x(j)]‖1
def get_x(self, x: int) -> int:‖return int(self.ratio_x * x)‖1
def get_y(self, y: int) -> int:‖return int(self.ratio_y * y)‖1
"if __name__ == ""__main__"":"‖dst_w, dst_h = 800, 600‖1
dst_w, dst_h = 800, 600‖"im = imread(""image_data/lena.jpg"", 1)"‖1
"im = imread(""image_data/lena.jpg"", 1)"‖n = NearestNeighbour(im, dst_w, dst_h)‖1
n = NearestNeighbour(im, dst_w, dst_h)‖n.process()‖1
imshow(‖"f""Image resized from: {im.shape[1]}x{im.shape[0]} to {dst_w}x{dst_h}"", n.output"‖1
"f""Image resized from: {im.shape[1]}x{im.shape[0]} to {dst_w}x{dst_h}"", n.output"‖)‖1
)‖waitKey(0)‖1
num_inversions = 0‖n = len(arr)‖1
for i in range(n - 1):‖for j in range(i + 1, n):‖2
for j in range(i + 1, n):‖if arr[i] > arr[j]:‖1
if arr[i] > arr[j]:‖num_inversions += 1‖1
def count_inversions_recursive(arr):‖if len(arr) <= 1:‖1
if len(arr) <= 1:‖return arr, 0‖1
return arr, 0‖mid = len(arr) // 2‖1
mid = len(arr) // 2‖p = arr[0:mid]‖1
p = arr[0:mid]‖q = arr[mid:]‖1
a, inversion_p = count_inversions_recursive(p)‖b, inversions_q = count_inversions_recursive(q)‖1
b, inversions_q = count_inversions_recursive(q)‖c, cross_inversions = _count_cross_inversions(a, b)‖1
num_inversions = inversion_p + inversions_q + cross_inversions‖return c, num_inversions‖1
r = []‖i = j = num_inversion = 0‖1
i = j = num_inversion = 0‖while i < len(p) and j < len(q):‖1
while i < len(p) and j < len(q):‖if p[i] > q[j]:‖1
num_inversion += len(p) - i‖r.append(q[j])‖1
r.append(q[j])‖j += 1‖1
j += 1‖else:‖1
else:‖r.append(p[i])‖1
r.append(p[i])‖i += 1‖1
if i < len(p):‖r.extend(p[i:])‖1
r.extend(p[i:])‖else:‖1
else:‖r.extend(q[j:])‖1
def main():‖arr_1 = [10, 2, 1, 5, 5, 2, 11]‖1
num_inversions_bf = count_inversions_bf(arr_1)‖_, num_inversions_recursive = count_inversions_recursive(arr_1)‖3
arr_1.sort()‖num_inversions_bf = count_inversions_bf(arr_1)‖1
assert num_inversions_bf == num_inversions_recursive == 0‖"print(""number of inversions = "", num_inversions_bf)"‖2
arr_1 = []‖num_inversions_bf = count_inversions_bf(arr_1)‖1
if len(arr) <= 1:‖return [tuple(arr)]‖2
def generate(k: int, arr: list):‖if k == 1:‖1
if k == 1:‖res.append(tuple(arr[:]))‖1
res.append(tuple(arr[:]))‖return‖1
for i in range(k - 1):‖if k % 2 == 0:‖1
if k % 2 == 0:‖arr[i], arr[k - 1] = arr[k - 1], arr[i]‖1
arr[i], arr[k - 1] = arr[k - 1], arr[i]‖else:‖1
else:‖arr[0], arr[k - 1] = arr[k - 1], arr[0]‖1
arr[0], arr[k - 1] = arr[k - 1], arr[0]‖generate(k - 1, arr)‖1
generate(len(arr), arr)‖return res‖2
"if __name__ == ""__main__"":"‖"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖15
"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖"arr = [int(item) for item in user_input.split("","")]"‖2
"arr = [int(item) for item in user_input.split("","")]"‖print(heaps(arr))‖2
if len(a) == 1:‖return a[0], a[0]‖1
return a[0], a[0]‖else:‖1
first = a[: len(a) // 2]‖second = a[len(a) // 2 :]‖1
small1, big1 = max_difference(first)‖small2, big2 = max_difference(second)‖1
min_first = min(first)‖max_second = max(second)‖1
if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:‖return small2, big2‖1
return small2, big2‖elif big1 - small1 > max_second - min_first:‖1
elif big1 - small1 > max_second - min_first:‖return small1, big1‖1
return small1, big1‖else:‖1
else:‖return min_first, max_second‖1
def merge(left_half: list, right_half: list) -> list:‖sorted_array = [None] * (len(right_half) + len(left_half))‖1
pointer1 = 0‖pointer2 = 0‖1
pointer2 = 0‖index = 0‖1
while pointer1 < len(left_half) and pointer2 < len(right_half):‖if left_half[pointer1] < right_half[pointer2]:‖1
if left_half[pointer1] < right_half[pointer2]:‖sorted_array[index] = left_half[pointer1]‖1
sorted_array[index] = left_half[pointer1]‖pointer1 += 1‖2
pointer1 += 1‖index += 1‖2
index += 1‖else:‖1
else:‖sorted_array[index] = right_half[pointer2]‖1
sorted_array[index] = right_half[pointer2]‖pointer2 += 1‖2
pointer2 += 1‖index += 1‖2
index += 1‖while pointer1 < len(left_half):‖1
while pointer1 < len(left_half):‖sorted_array[index] = left_half[pointer1]‖1
while pointer2 < len(right_half):‖sorted_array[index] = right_half[pointer2]‖1
def merge_sort(array: list) -> list:‖if len(array) <= 1:‖1
if len(array) <= 1:‖return array‖1
left_half = array[:middle]‖right_half = array[middle:]‖1
import numpy as np‖from cv2 import COLOR_BGR2GRAY, CV_8UC3, cvtColor, filter2D, imread, imshow, waitKey‖1
def gabor_filter_kernel(‖ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int‖1
ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int‖) -> np.ndarray:‖1
if (ksize % 2) == 0:‖ksize = ksize + 1‖1
ksize = ksize + 1‖gabor = np.zeros((ksize, ksize), dtype=np.float32)‖1
for y in range(ksize):‖for x in range(ksize):‖1
px = x - ksize // 2‖py = y - ksize // 2‖1
_theta = theta / 180 * np.pi‖cos_theta = np.cos(_theta)‖1
cos_theta = np.cos(_theta)‖sin_theta = np.sin(_theta)‖1
gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(‖2 * np.pi * _x / lambd + psi‖1
2 * np.pi * _x / lambd + psi‖)‖1
out = np.zeros(gray.shape[:2])‖for theta in [0, 30, 60, 90, 120, 150]:‖1
for theta in [0, 30, 60, 90, 120, 150]:‖kernel_10 = gabor_filter_kernel(10, 8, theta, 10, 0, 0)‖1
kernel_10 = gabor_filter_kernel(10, 8, theta, 10, 0, 0)‖out += filter2D(gray, CV_8UC3, kernel_10)‖1
out += filter2D(gray, CV_8UC3, kernel_10)‖out = out / out.max() * 255‖1
out = out / out.max() * 255‖out = out.astype(np.uint8)‖1
"imshow(""Original"", gray)"‖"imshow(""Gabor filter with 20x20 mask and 6 directions"", out)"‖1
def default_matrix_multiplication(a: list, b: list) -> list:‖if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:‖1
if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:‖"raise Exception(""Matrices are not 2x2"")"‖1
"raise Exception(""Matrices are not 2x2"")"‖new_matrix = [‖1
new_matrix = [‖[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],‖1
[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],‖[a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],‖1
[a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],‖]‖1
]‖return new_matrix‖1
def matrix_addition(matrix_a: list, matrix_b: list):‖return [‖1
return [‖[matrix_a[row][col] + matrix_b[row][col] for col in range(len(matrix_a[row]))]‖1
[matrix_a[row][col] + matrix_b[row][col] for col in range(len(matrix_a[row]))]‖for row in range(len(matrix_a))‖1
for row in range(len(matrix_a))‖]‖2
def matrix_subtraction(matrix_a: list, matrix_b: list):‖return [‖1
return [‖[matrix_a[row][col] - matrix_b[row][col] for col in range(len(matrix_a[row]))]‖1
[matrix_a[row][col] - matrix_b[row][col] for col in range(len(matrix_a[row]))]‖for row in range(len(matrix_a))‖1
def split_matrix(a: list) -> tuple[list, list, list, list]:‖if len(a) % 2 != 0 or len(a[0]) % 2 != 0:‖1
if len(a) % 2 != 0 or len(a[0]) % 2 != 0:‖"raise Exception(""Odd matrices are not supported!"")"‖1
matrix_length = len(a)‖mid = matrix_length // 2‖1
top_right = [[a[i][j] for j in range(mid, matrix_length)] for i in range(mid)]‖bot_right = [‖1
bot_right = [‖[a[i][j] for j in range(mid, matrix_length)] for i in range(mid, matrix_length)‖1
[a[i][j] for j in range(mid, matrix_length)] for i in range(mid, matrix_length)‖]‖1
top_left = [[a[i][j] for j in range(mid)] for i in range(mid)]‖bot_left = [[a[i][j] for j in range(mid)] for i in range(mid, matrix_length)]‖1
def matrix_dimensions(matrix: list) -> tuple[int, int]:‖return len(matrix), len(matrix[0])‖1
def print_matrix(matrix: list) -> None:‖"print(""\n"".join(str(line) for line in matrix))"‖1
def actual_strassen(matrix_a: list, matrix_b: list) -> list:‖if matrix_dimensions(matrix_a) == (2, 2):‖1
if matrix_dimensions(matrix_a) == (2, 2):‖return default_matrix_multiplication(matrix_a, matrix_b)‖1
a, b, c, d = split_matrix(matrix_a)‖e, f, g, h = split_matrix(matrix_b)‖1
t1 = actual_strassen(a, matrix_subtraction(f, h))‖t2 = actual_strassen(matrix_addition(a, b), h)‖1
t2 = actual_strassen(matrix_addition(a, b), h)‖t3 = actual_strassen(matrix_addition(c, d), e)‖1
t3 = actual_strassen(matrix_addition(c, d), e)‖t4 = actual_strassen(d, matrix_subtraction(g, e))‖1
t4 = actual_strassen(d, matrix_subtraction(g, e))‖t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))‖1
t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))‖t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))‖1
t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))‖t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))‖1
top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)‖top_right = matrix_addition(t1, t2)‖1
top_right = matrix_addition(t1, t2)‖bot_left = matrix_addition(t3, t4)‖1
bot_left = matrix_addition(t3, t4)‖bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)‖1
new_matrix = []‖for i in range(len(top_right)):‖1
for i in range(len(top_right)):‖new_matrix.append(top_left[i] + top_right[i])‖1
new_matrix.append(top_left[i] + top_right[i])‖for i in range(len(bot_right)):‖1
for i in range(len(bot_right)):‖new_matrix.append(bot_left[i] + bot_right[i])‖1
new_matrix.append(bot_left[i] + bot_right[i])‖return new_matrix‖1
def strassen(matrix1: list, matrix2: list) -> list:‖if matrix_dimensions(matrix1)[1] != matrix_dimensions(matrix2)[0]:‖1
if matrix_dimensions(matrix1)[1] != matrix_dimensions(matrix2)[0]:‖msg = (‖1
msg = (‖"""Unable to multiply these matrices, please check the dimensions.\n"""‖1
"""Unable to multiply these matrices, please check the dimensions.\n"""‖"f""Matrix A: {matrix1}\n"""‖1
"f""Matrix A: {matrix1}\n"""‖"f""Matrix B: {matrix2}"""‖1
"f""Matrix B: {matrix2}"""‖)‖1
)‖raise Exception(msg)‖1
raise Exception(msg)‖dimension1 = matrix_dimensions(matrix1)‖1
dimension1 = matrix_dimensions(matrix1)‖dimension2 = matrix_dimensions(matrix2)‖1
if dimension1[0] == dimension1[1] and dimension2[0] == dimension2[1]:‖return [matrix1, matrix2]‖1
maximum = max(*dimension1, *dimension2)‖maxim = int(math.pow(2, math.ceil(math.log2(maximum))))‖1
maxim = int(math.pow(2, math.ceil(math.log2(maximum))))‖new_matrix1 = matrix1‖1
new_matrix1 = matrix1‖new_matrix2 = matrix2‖1
for i in range(maxim):‖if i < dimension1[0]:‖2
if i < dimension1[0]:‖for _ in range(dimension1[1], maxim):‖1
for _ in range(dimension1[1], maxim):‖new_matrix1[i].append(0)‖1
new_matrix1[i].append(0)‖else:‖1
else:‖new_matrix1.append([0] * maxim)‖1
new_matrix1.append([0] * maxim)‖if i < dimension2[0]:‖1
if i < dimension2[0]:‖for _ in range(dimension2[1], maxim):‖1
for _ in range(dimension2[1], maxim):‖new_matrix2[i].append(0)‖1
new_matrix2[i].append(0)‖else:‖1
else:‖new_matrix2.append([0] * maxim)‖1
if i < dimension1[0]:‖for _ in range(dimension2[1], maxim):‖1
for _ in range(dimension2[1], maxim):‖final_matrix[i].pop()‖1
final_matrix[i].pop()‖else:‖1
else:‖final_matrix.pop()‖1
final_matrix.pop()‖return final_matrix‖1
"if __name__ == ""__main__"":"‖matrix1 = [‖1
matrix1 = [‖[2, 3, 4, 5],‖1
[2, 3, 4, 5],‖[6, 4, 3, 1],‖2
[6, 4, 3, 1],‖[2, 3, 6, 7],‖2
[2, 3, 6, 7],‖[3, 1, 2, 4],‖2
[3, 1, 2, 4],‖[2, 3, 4, 5],‖2
[2, 3, 4, 5],‖[6, 2, 3, 1],‖1
[6, 2, 3, 1],‖]‖1
]‖matrix2 = [[0, 2, 1, 1], [16, 2, 3, 3], [2, 2, 7, 7], [13, 11, 22, 4]]‖1
matrix2 = [[0, 2, 1, 1], [16, 2, 3, 3], [2, 2, 7, 7], [13, 11, 22, 4]]‖print(strassen(matrix1, matrix2))‖1
def euclidean_distance_sqr(point1, point2):‖return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2‖1
def column_based_sort(array, column=0):‖return sorted(array, key=lambda x: x[column])‖1
for i in range(points_counts - 1):‖for j in range(i + 1, points_counts):‖1
for j in range(i + 1, points_counts):‖current_dis = euclidean_distance_sqr(points[i], points[j])‖1
current_dis = euclidean_distance_sqr(points[i], points[j])‖min_dis = min(min_dis, current_dis)‖2
min_dis = min(min_dis, current_dis)‖return min_dis‖2
for i in range(min(6, points_counts - 1), points_counts):‖for j in range(max(0, i - 6), i):‖1
for j in range(max(0, i - 6), i):‖current_dis = euclidean_distance_sqr(points[i], points[j])‖1
if points_counts <= 3:‖return dis_between_closest_pair(points_sorted_on_x, points_counts)‖1
mid = points_counts // 2‖closest_in_left = closest_pair_of_points_sqr(‖1
closest_in_left = closest_pair_of_points_sqr(‖points_sorted_on_x, points_sorted_on_y[:mid], mid‖1
points_sorted_on_x, points_sorted_on_y[:mid], mid‖)‖1
)‖closest_in_right = closest_pair_of_points_sqr(‖1
closest_in_right = closest_pair_of_points_sqr(‖points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid‖1
points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid‖)‖1
)‖closest_pair_dis = min(closest_in_left, closest_in_right)‖1
cross_strip = []‖for point in points_sorted_on_x:‖1
for point in points_sorted_on_x:‖if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:‖1
if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:‖cross_strip.append(point)‖1
closest_in_strip = dis_between_closest_in_strip(‖cross_strip, len(cross_strip), closest_pair_dis‖1
cross_strip, len(cross_strip), closest_pair_dis‖)‖1
)‖return min(closest_pair_dis, closest_in_strip)‖1
def closest_pair_of_points(points, points_counts):‖points_sorted_on_x = column_based_sort(points, column=0)‖1
points_sorted_on_x = column_based_sort(points, column=0)‖points_sorted_on_y = column_based_sort(points, column=1)‖1
points_sorted_on_y = column_based_sort(points, column=1)‖return (‖1
return (‖closest_pair_of_points_sqr(‖1
closest_pair_of_points_sqr(‖points_sorted_on_x, points_sorted_on_y, points_counts‖1
points_sorted_on_x, points_sorted_on_y, points_counts‖)‖1
)‖) ** 0.5‖1
"if __name__ == ""__main__"":"‖points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]‖1
points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]‖"print(""Distance:"", closest_pair_of_points(points, len(points)))"‖1
def get_rotation(‖img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int‖1
img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int‖) -> np.ndarray:‖1
) -> np.ndarray:‖matrix = cv2.getAffineTransform(pt1, pt2)‖1
matrix = cv2.getAffineTransform(pt1, pt2)‖return cv2.warpAffine(img, matrix, (rows, cols))‖1
image = cv2.imread(‖"str(Path(__file__).resolve().parent.parent / ""image_data"" / ""lena.jpg"")"‖1
"str(Path(__file__).resolve().parent.parent / ""image_data"" / ""lena.jpg"")"‖)‖1
pts1 = np.array([[50, 50], [200, 50], [50, 200]], np.float32)‖pts2 = np.array([[10, 100], [200, 50], [100, 250]], np.float32)‖1
pts2 = np.array([[10, 100], [200, 50], [100, 250]], np.float32)‖pts3 = np.array([[50, 50], [150, 50], [120, 200]], np.float32)‖1
pts3 = np.array([[50, 50], [150, 50], [120, 200]], np.float32)‖pts4 = np.array([[10, 100], [80, 50], [180, 250]], np.float32)‖1
images = [‖gray_img,‖1
gray_img,‖get_rotation(gray_img, pts1, pts2, img_rows, img_cols),‖1
get_rotation(gray_img, pts1, pts2, img_rows, img_cols),‖get_rotation(gray_img, pts2, pts3, img_rows, img_cols),‖1
get_rotation(gray_img, pts2, pts3, img_rows, img_cols),‖get_rotation(gray_img, pts2, pts4, img_rows, img_cols),‖1
get_rotation(gray_img, pts2, pts4, img_rows, img_cols),‖]‖1
fig = plt.figure(1)‖"titles = [""Original"", ""Rotation 1"", ""Rotation 2"", ""Rotation 3""]"‖1
"titles = [""Original"", ""Rotation 1"", ""Rotation 2"", ""Rotation 3""]"‖for i, image in enumerate(images):‖1
for i, image in enumerate(images):‖"plt.subplot(2, 2, i + 1), plt.imshow(image, ""gray"")"‖1
"plt.subplot(2, 2, i + 1), plt.imshow(image, ""gray"")"‖plt.title(titles[i])‖1
plt.title(titles[i])‖"plt.axis(""off"")"‖1
"plt.axis(""off"")"‖plt.subplots_adjust(left=0.0, bottom=0.05, right=1.0, top=0.95)‖1
plt.subplots_adjust(left=0.0, bottom=0.05, right=1.0, top=0.95)‖plt.show()‖1
def erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:‖output = np.zeros_like(image)‖1
).sum()‖output[y, x] = int(summation == 5)‖1
output[y, x] = int(summation == 5)‖return output‖1
"pil_img = Image.fromarray(output).convert(""RGB"")"‖"pil_img.save(""result_erosion.png"")"‖1
def __init__(self, x, y):‖self.x, self.y = float(x), float(y)‖1
def __eq__(self, other):‖return self.x == other.x and self.y == other.y‖1
def __ne__(self, other):‖return not self == other‖1
def __gt__(self, other):‖if self.x > other.x:‖1
if self.x > other.x:‖return True‖2
return True‖elif self.x == other.x:‖3
elif self.x == other.x:‖return self.y > other.y‖1
return self.y > other.y‖return False‖1
def __lt__(self, other):‖return not self > other‖1
def __ge__(self, other):‖if self.x > other.x:‖1
elif self.x == other.x:‖return self.y >= other.y‖1
return self.y >= other.y‖return False‖1
def __le__(self, other):‖if self.x < other.x:‖1
if self.x < other.x:‖return True‖1
elif self.x == other.x:‖return self.y <= other.y‖1
return self.y <= other.y‖return False‖1
def __repr__(self):‖"return f""({self.x}, {self.y})"""‖1
def __hash__(self):‖return hash(self.x)‖1
def _construct_points(‖list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]],‖1
list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]],‖) -> list[Point]:‖1
points: list[Point] = []‖if list_of_tuples:‖1
if list_of_tuples:‖for p in list_of_tuples:‖1
for p in list_of_tuples:‖if isinstance(p, Point):‖1
if isinstance(p, Point):‖points.append(p)‖1
points.append(p)‖else:‖1
else:‖try:‖2
try:‖points.append(Point(p[0], p[1]))‖1
points.append(Point(p[0], p[1]))‖except (IndexError, TypeError):‖1
except (IndexError, TypeError):‖print(‖1
print(‖"f""Ignoring deformed point {p}. All points"""‖1
"f""Ignoring deformed point {p}. All points"""‖""" must have at least 2 coordinates."""‖1
""" must have at least 2 coordinates."""‖)‖1
)‖return points‖1
"if not hasattr(points, ""__iter__""):"‖"msg = f""Expecting an iterable object but got an non-iterable type {points}"""‖1
"msg = f""Expecting an iterable object but got an non-iterable type {points}"""‖raise ValueError(msg)‖1
if not points:‖"msg = f""Expecting a list of points but got {points}"""‖1
"msg = f""Expecting a list of points but got {points}"""‖raise ValueError(msg)‖1
det = (a.x * b.y + b.x * c.y + c.x * a.y) - (a.y * b.x + b.y * c.x + c.y * a.x)‖return det‖1
points = sorted(_validate_input(points))‖n = len(points)‖3
n = len(points)‖convex_set = set()‖1
for j in range(i + 1, n):‖points_left_of_ij = points_right_of_ij = False‖1
points_left_of_ij = points_right_of_ij = False‖ij_part_of_convex_hull = True‖1
ij_part_of_convex_hull = True‖for k in range(n):‖1
for k in range(n):‖if k not in {i, j}:‖1
if k not in {i, j}:‖det_k = _det(points[i], points[j], points[k])‖1
if det_k > 0:‖points_left_of_ij = True‖1
points_left_of_ij = True‖elif det_k < 0:‖1
elif det_k < 0:‖points_right_of_ij = True‖1
elif points[k] < points[i] or points[k] > points[j]:‖ij_part_of_convex_hull = False‖1
ij_part_of_convex_hull = False‖break‖2
if points_left_of_ij and points_right_of_ij:‖ij_part_of_convex_hull = False‖1
if ij_part_of_convex_hull:‖convex_set.update([points[i], points[j]])‖1
def convex_hull_recursive(points: list[Point]) -> list[Point]:‖points = sorted(_validate_input(points))‖1
left_most_point = points[0]‖right_most_point = points[n - 1]‖1
convex_set = {left_most_point, right_most_point}‖upper_hull = []‖1
upper_hull = []‖lower_hull = []‖1
for i in range(1, n - 1):‖det = _det(left_most_point, right_most_point, points[i])‖1
if det > 0:‖upper_hull.append(points[i])‖1
upper_hull.append(points[i])‖elif det < 0:‖1
elif det < 0:‖lower_hull.append(points[i])‖1
_construct_hull(upper_hull, left_most_point, right_most_point, convex_set)‖_construct_hull(lower_hull, right_most_point, left_most_point, convex_set)‖1
def _construct_hull(‖points: list[Point], left: Point, right: Point, convex_set: set[Point]‖1
points: list[Point], left: Point, right: Point, convex_set: set[Point]‖) -> None:‖1
) -> None:‖if points:‖1
if points:‖extreme_point = None‖1
extreme_point = None‖"extreme_point_distance = float(""-inf"")"‖1
"extreme_point_distance = float(""-inf"")"‖candidate_points = []‖1
for p in points:‖det = _det(left, right, p)‖1
if det > 0:‖candidate_points.append(p)‖1
if det > extreme_point_distance:‖extreme_point_distance = det‖1
extreme_point_distance = det‖extreme_point = p‖1
if extreme_point:‖_construct_hull(candidate_points, left, extreme_point, convex_set)‖1
_construct_hull(candidate_points, left, extreme_point, convex_set)‖convex_set.add(extreme_point)‖1
convex_set.add(extreme_point)‖_construct_hull(candidate_points, extreme_point, right, convex_set)‖1
def convex_hull_melkman(points: list[Point]) -> list[Point]:‖points = sorted(_validate_input(points))‖1
convex_hull = points[:2]‖for i in range(2, n):‖1
for i in range(2, n):‖det = _det(convex_hull[1], convex_hull[0], points[i])‖1
det = _det(convex_hull[1], convex_hull[0], points[i])‖if det > 0:‖1
if det > 0:‖convex_hull.insert(0, points[i])‖1
convex_hull.insert(0, points[i])‖break‖1
break‖elif det < 0:‖1
elif det < 0:‖convex_hull.append(points[i])‖1
convex_hull.append(points[i])‖break‖1
else:‖convex_hull[1] = points[i]‖1
convex_hull[1] = points[i]‖i += 1‖1
for j in range(i, n):‖if (‖1
if (‖_det(convex_hull[0], convex_hull[-1], points[j]) > 0‖1
_det(convex_hull[0], convex_hull[-1], points[j]) > 0‖and _det(convex_hull[-1], convex_hull[0], points[1]) < 0‖1
and _det(convex_hull[-1], convex_hull[0], points[1]) < 0‖):‖1
convex_hull.insert(0, points[j])‖convex_hull.append(points[j])‖1
convex_hull.append(points[j])‖while _det(convex_hull[0], convex_hull[1], convex_hull[2]) >= 0:‖1
while _det(convex_hull[0], convex_hull[1], convex_hull[2]) >= 0:‖del convex_hull[1]‖1
del convex_hull[1]‖while _det(convex_hull[-1], convex_hull[-2], convex_hull[-3]) <= 0:‖1
while _det(convex_hull[-1], convex_hull[-2], convex_hull[-3]) <= 0:‖del convex_hull[-2]‖1
def main():‖points = [‖1
points = [‖(0, 3),‖1
(0, 3),‖(2, 2),‖1
(2, 2),‖(1, 1),‖1
(1, 1),‖(2, 1),‖2
(2, 1),‖(3, 0),‖1
(3, 0),‖(0, 0),‖1
(0, 0),‖(3, 3),‖1
(3, 3),‖(2, -1),‖1
(2, -1),‖(2, -4),‖1
(2, -4),‖(1, -3),‖1
(1, -3),‖]‖1
results_recursive = convex_hull_recursive(points)‖assert results_bf == results_recursive‖1
results_melkman = convex_hull_melkman(points)‖assert results_bf == results_melkman‖1
def random_pivot(lst):‖return choice(lst)‖1
small = [e for e in lst if e < pivot]‖big = [e for e in lst if e > pivot]‖1
if len(small) == k - 1:‖return pivot‖1
elif len(small) < k - 1:‖return kth_number(big, k - len(small) - 1)‖1
else:‖return kth_number(small, k)‖1
import time‖from collections.abc import Sequence‖1
from collections.abc import Sequence‖from random import randint‖1
def max_subarray(‖arr: Sequence[float], low: int, high: int‖1
arr: Sequence[float], low: int, high: int‖) -> tuple[int | None, int | None, float]:‖1
) -> tuple[int | None, int | None, float]:‖if not arr:‖1
if not arr:‖return None, None, 0‖1
return None, None, 0‖if low == high:‖1
if low == high:‖return low, high, arr[low]‖1
mid = (low + high) // 2‖left_low, left_high, left_sum = max_subarray(arr, low, mid)‖1
left_low, left_high, left_sum = max_subarray(arr, low, mid)‖right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)‖1
right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)‖cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)‖1
cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)‖if left_sum >= right_sum and left_sum >= cross_sum:‖1
if left_sum >= right_sum and left_sum >= cross_sum:‖return left_low, left_high, left_sum‖1
return left_low, left_high, left_sum‖elif right_sum >= left_sum and right_sum >= cross_sum:‖1
elif right_sum >= left_sum and right_sum >= cross_sum:‖return right_low, right_high, right_sum‖1
return right_low, right_high, right_sum‖return cross_left, cross_right, cross_sum‖1
def max_cross_sum(‖arr: Sequence[float], low: int, mid: int, high: int‖1
arr: Sequence[float], low: int, mid: int, high: int‖) -> tuple[int, int, float]:‖1
) -> tuple[int, int, float]:‖"left_sum, max_left = float(""-inf""), -1"‖1
"left_sum, max_left = float(""-inf""), -1"‖"right_sum, max_right = float(""-inf""), -1"‖1
summ: int | float = 0‖for i in range(mid, low - 1, -1):‖1
for i in range(mid, low - 1, -1):‖summ += arr[i]‖1
summ += arr[i]‖if summ > left_sum:‖1
if summ > left_sum:‖left_sum = summ‖1
left_sum = summ‖max_left = i‖1
summ = 0‖for i in range(mid + 1, high + 1):‖1
for i in range(mid + 1, high + 1):‖summ += arr[i]‖1
summ += arr[i]‖if summ > right_sum:‖1
if summ > right_sum:‖right_sum = summ‖1
right_sum = summ‖max_right = i‖1
def time_max_subarray(input_size: int) -> float:‖arr = [randint(1, input_size) for _ in range(input_size)]‖1
arr = [randint(1, input_size) for _ in range(input_size)]‖start = time.time()‖1
start = time.time()‖max_subarray(arr, 0, input_size - 1)‖1
max_subarray(arr, 0, input_size - 1)‖end = time.time()‖1
end = time.time()‖return end - start‖1
def plot_runtimes() -> None:‖input_sizes = [10, 100, 1000, 10000, 50000, 100000, 200000, 300000, 400000, 500000]‖1
input_sizes = [10, 100, 1000, 10000, 50000, 100000, 200000, 300000, 400000, 500000]‖runtimes = [time_max_subarray(input_size) for input_size in input_sizes]‖1
runtimes = [time_max_subarray(input_size) for input_size in input_sizes]‖"print(""No of Inputs\t\tTime Taken"")"‖1
"print(""No of Inputs\t\tTime Taken"")"‖for input_size, runtime in zip(input_sizes, runtimes):‖1
for input_size, runtime in zip(input_sizes, runtimes):‖"print(input_size, ""\t\t"", runtime)"‖1
"print(input_size, ""\t\t"", runtime)"‖plt.plot(input_sizes, runtimes)‖1
plt.plot(input_sizes, runtimes)‖"plt.xlabel(""Number of Inputs"")"‖1
"plt.xlabel(""Number of Inputs"")"‖"plt.ylabel(""Time taken in seconds"")"‖1
"plt.ylabel(""Time taken in seconds"")"‖plt.show()‖1
@lru_cache‖def factorial(num: int) -> int:‖1
def factorial(num: int) -> int:‖if num < 0:‖1
if num < 0:‖"raise ValueError(""Number should not be negative."")"‖1
table: list[list[list[str]]] = []‖for _ in range(table_size):‖1
for _ in range(table_size):‖table.append([])‖1
if table[i] != []:‖for word in word_bank:‖1
if target[i : i + len(word)] == word:‖new_combinations: list[list[str]] = [‖1
new_combinations: list[list[str]] = [‖[word, *way] for way in table[i]‖1
[word, *way] for way in table[i]‖]‖1
for combination in table[len(target)]:‖combination.reverse()‖1
"if __name__ == ""__main__"":"‖"print(all_construct(""jwajalapa"", [""jwa"", ""j"", ""w"", ""a"", ""la"", ""lapa""]))"‖1
"print(all_construct(""jwajalapa"", [""jwa"", ""j"", ""w"", ""a"", ""la"", ""lapa""]))"‖"print(all_construct(""rajamati"", [""s"", ""raj"", ""amat"", ""raja"", ""ma"", ""i"", ""t""]))"‖1
"print(all_construct(""rajamati"", [""s"", ""raj"", ""amat"", ""raja"", ""ma"", ""i"", ""t""]))"‖print(‖1
print(‖all_construct(‖1
all_construct(‖"""hexagonosaurus"","‖1
"""hexagonosaurus"","‖"[""h"", ""ex"", ""hex"", ""ag"", ""ago"", ""ru"", ""auru"", ""rus"", ""go"", ""no"", ""o"", ""s""],"‖1
"[""h"", ""ex"", ""hex"", ""ag"", ""ago"", ""ru"", ""auru"", ""rus"", ""go"", ""no"", ""o"", ""s""],"‖)‖1
def actual_power(a: int, b: int):‖if b == 0:‖1
if b == 0:‖return 1‖1
return 1‖if (b % 2) == 0:‖1
if (b % 2) == 0:‖return actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))‖1
return actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))‖else:‖1
else:‖return a * actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))‖1
def power(a: int, b: int) -> float:‖if b < 0:‖1
if b < 0:‖return 1 / actual_power(a, b)‖1
return 1 / actual_power(a, b)‖return actual_power(a, b)‖1
"if __name__ == ""__main__"":"‖print(power(-2, -3))‖1
def generate(n: int, arr: list):‖c = [0] * n‖1
c = [0] * n‖res.append(tuple(arr))‖1
i = 0‖while i < n:‖1
while i < n:‖if c[i] < i:‖1
if c[i] < i:‖if i % 2 == 0:‖1
if i % 2 == 0:‖arr[0], arr[i] = arr[i], arr[0]‖1
arr[0], arr[i] = arr[i], arr[0]‖else:‖1
else:‖arr[c[i]], arr[i] = arr[i], arr[c[i]]‖1
arr[c[i]], arr[i] = arr[i], arr[c[i]]‖res.append(tuple(arr))‖1
res.append(tuple(arr))‖c[i] += 1‖1
c[i] += 1‖i = 0‖1
i = 0‖else:‖2
else:‖c[i] = 0‖1
c[i] = 0‖i += 1‖1
class AssignmentUsingBitmask:‖def __init__(self, task_performed, total):‖1
def __init__(self, task_performed, total):‖self.total_tasks = total‖1
self.dp = [‖[-1 for i in range(total + 1)] for j in range(2 ** len(task_performed))‖1
[-1 for i in range(total + 1)] for j in range(2 ** len(task_performed))‖]‖1
if mask == self.final_mask:‖return 1‖1
if task_no > self.total_tasks:‖return 0‖1
if self.dp[mask][task_no] != -1:‖return self.dp[mask][task_no]‖1
if task_no in self.task:‖for p in self.task[task_no]:‖1
if mask & (1 << p):‖continue‖1
for i in range(len(task_performed)):‖for j in task_performed[i]:‖1
for j in task_performed[i]:‖self.task[j].append(i)‖1
"if __name__ == ""__main__"":"‖total_tasks = 5‖1
task_performed = [[1, 3, 4], [1, 2, 5], [3, 4]]‖print(‖1
print(‖AssignmentUsingBitmask(task_performed, total_tasks).count_no_of_ways(‖1
AssignmentUsingBitmask(task_performed, total_tasks).count_no_of_ways(‖task_performed‖1
task_performed‖)‖1
if not isinstance(iterations, int):‖"raise ValueError(""iterations must be defined as integers"")"‖1
"raise ValueError(""iterations must be defined as integers"")"‖if not isinstance(number, int) or not number >= 1:‖1
if not isinstance(number, int) or not number >= 1:‖raise ValueError(‖1
raise ValueError(‖if not iterations >= 1:‖1
if not iterations >= 1:‖"raise ValueError(""Iterations must be done more than 0 times to play FizzBuzz"")"‖1
"out = """""‖while number <= iterations:‖1
while number <= iterations:‖if number % 3 == 0:‖1
if number % 3 == 0:‖"out += ""Fizz"""‖1
"out += ""Fizz"""‖if number % 5 == 0:‖1
if number % 5 == 0:‖"out += ""Buzz"""‖1
"out += ""Buzz"""‖if 0 not in (number % 3, number % 5):‖1
if 0 not in (number % 3, number % 5):‖out += str(number)‖1
number += 1‖"out += "" """‖1
"out += "" """‖return out‖1
"def catalan_numbers(upper_limit: int) -> ""list[int]"":"‖if upper_limit < 0:‖1
if upper_limit < 0:‖"raise ValueError(""Limit for the Catalan sequence must be ≥ 0"")"‖1
catalan_list[0] = 1‖if upper_limit > 0:‖1
if upper_limit > 0:‖catalan_list[1] = 1‖1
for i in range(2, upper_limit + 1):‖for j in range(i):‖1
for j in range(i):‖catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]‖1
"if __name__ == ""__main__"":"‖"print(""\n********* Catalan Numbers Using Dynamic Programming ************\n"")"‖1
"print(""\n********* Catalan Numbers Using Dynamic Programming ************\n"")"‖"print(""\n*** Enter -1 at any time to quit ***"")"‖1
"print(""\n*** Enter -1 at any time to quit ***"")"‖"print(""\nEnter the upper limit (≥ 0) for the Catalan number sequence: "", end="""")"‖1
"print(""\nEnter the upper limit (≥ 0) for the Catalan number sequence: "", end="""")"‖try:‖1
while True:‖N = int(input().strip())‖1
N = int(input().strip())‖if N < 0:‖1
if N < 0:‖"print(""\n********* Goodbye!! ************"")"‖1
"print(""\n********* Goodbye!! ************"")"‖break‖1
else:‖"print(f""The Catalan numbers from 0 through {N} are:"")"‖1
"print(f""The Catalan numbers from 0 through {N} are:"")"‖print(catalan_numbers(N))‖1
print(catalan_numbers(N))‖"print(""Try another upper limit for the sequence: "", end="""")"‖1
"print(""Try another upper limit for the sequence: "", end="""")"‖except (NameError, ValueError):‖1
except (NameError, ValueError):‖"print(""\n********* Invalid input, goodbye! ************\n"")"‖1
def count_of_possible_combinations(target: int) -> int:‖if target < 0:‖1
if target < 0:‖return 0‖2
return 0‖if target == 0:‖2
if target == 0:‖return 1‖2
return 1‖return sum(count_of_possible_combinations(target - item) for item in array)‖1
def count_of_possible_combinations_with_dp_array(‖target: int, dp_array: list[int]‖1
target: int, dp_array: list[int]‖) -> int:‖1
) -> int:‖if target < 0:‖1
return 1‖if dp_array[target] != -1:‖1
if dp_array[target] != -1:‖return dp_array[target]‖1
return dp_array[target]‖answer = sum(‖1
answer = sum(‖count_of_possible_combinations_with_dp_array(target - item, dp_array)‖1
count_of_possible_combinations_with_dp_array(target - item, dp_array)‖for item in array‖1
for item in array‖)‖1
)‖dp_array[target] = answer‖1
dp_array[target] = answer‖return answer‖1
dp_array = [-1] * (target + 1)‖return count_of_possible_combinations_with_dp_array(target, dp_array)‖1
dp_array = [0] * (target + 1)‖dp_array[0] = 1‖1
for i in range(1, target + 1):‖for j in range(n):‖1
for j in range(n):‖if i - array[j] >= 0:‖1
if i - array[j] >= 0:‖dp_array[i] += dp_array[i - array[j]]‖1
doctest.testmod()‖target = 5‖1
target = 5‖array = [1, 2, 5]‖1
array = [1, 2, 5]‖print(combination_sum_iv(array, target))‖1
def fibonacci(n: int) -> int:‖if n < 0:‖1
if n < 0:‖"raise ValueError(""Negative arguments are not supported"")"‖1
"raise ValueError(""Negative arguments are not supported"")"‖return _fib(n)[0]‖1
def _fib(n: int) -> tuple[int, int]:‖if n == 0:‖1
if n == 0:‖return (0, 1)‖1
a, b = _fib(n // 2)‖c = a * (b * 2 - a)‖1
c = a * (b * 2 - a)‖d = a * a + b * b‖1
d = a * a + b * b‖return (d, c + d) if n % 2 else (c, d)‖1
"if __name__ == ""__main__"":"‖n = int(sys.argv[1])‖1
n = int(sys.argv[1])‖"print(f""fibonacci({n}) is {fibonacci(n)}"")"‖1
if three[1] > three[0] and three[1] > three[2]:‖return three[1]‖1
elif three[0] < three[2]:‖if len(lst[:m]) == 2:‖1
if len(lst[:m]) == 2:‖m -= 1‖1
m -= 1‖return peak(lst[m:])‖1
else:‖if len(lst[:m]) == 2:‖1
if len(lst[:m]) == 2:‖m += 1‖1
m += 1‖return peak(lst[:m])‖1
def climb_stairs(number_of_steps: int) -> int:‖assert isinstance(number_of_steps, int) and number_of_steps > 0, (‖1
assert isinstance(number_of_steps, int) and number_of_steps > 0, (‖"f""number_of_steps needs to be positive integer, your input {number_of_steps}"""‖1
"f""number_of_steps needs to be positive integer, your input {number_of_steps}"""‖)‖1
)‖if number_of_steps == 1:‖1
if number_of_steps == 1:‖return 1‖1
return 1‖previous, current = 1, 1‖1
previous, current = 1, 1‖for _ in range(number_of_steps - 1):‖1
for _ in range(number_of_steps - 1):‖current, previous = current + previous, current‖1
current, previous = current + previous, current‖return current‖1
def abbr(a: str, b: str) -> bool:‖n = len(a)‖1
n = len(a)‖m = len(b)‖1
m = len(b)‖dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]‖1
dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]‖dp[0][0] = True‖1
dp[0][0] = True‖for i in range(n):‖1
for i in range(n):‖for j in range(m + 1):‖1
for j in range(m + 1):‖if dp[i][j]:‖1
if dp[i][j]:‖if j < m and a[i].upper() == b[j]:‖1
if j < m and a[i].upper() == b[j]:‖dp[i + 1][j + 1] = True‖1
dp[i + 1][j + 1] = True‖if a[i].islower():‖1
if a[i].islower():‖dp[i + 1][j] = True‖1
dp[i + 1][j] = True‖return dp[n][m]‖1
class Graph:‖def __init__(self, n=0):‖1
def __init__(self, n=0):‖self.n = n‖1
self.n = n‖self.w = [‖1
self.w = [‖[math.inf for j in range(n)] for i in range(n)‖1
[math.inf for j in range(n)] for i in range(n)‖]‖2
]‖self.dp = [‖1
self.dp = [‖[math.inf for j in range(n)] for i in range(n)‖1
def add_edge(self, u, v, w):‖self.dp[u][v] = w‖1
def floyd_warshall(self):‖for k in range(self.n):‖1
for k in range(self.n):‖for i in range(self.n):‖1
for i in range(self.n):‖for j in range(self.n):‖2
for j in range(self.n):‖self.dp[i][j] = min(self.dp[i][j], self.dp[i][k] + self.dp[k][j])‖1
def show_min(self, u, v):‖return self.dp[u][v]‖1
graph = Graph(5)‖graph.add_edge(0, 2, 9)‖1
graph.add_edge(0, 2, 9)‖graph.add_edge(0, 4, 10)‖1
graph.add_edge(0, 4, 10)‖graph.add_edge(1, 3, 5)‖1
graph.add_edge(1, 3, 5)‖graph.add_edge(2, 3, 7)‖1
graph.add_edge(2, 3, 7)‖graph.add_edge(3, 0, 10)‖1
graph.add_edge(3, 0, 10)‖graph.add_edge(3, 1, 2)‖1
graph.add_edge(3, 1, 2)‖graph.add_edge(3, 2, 1)‖1
graph.add_edge(3, 2, 1)‖graph.add_edge(3, 4, 6)‖1
graph.add_edge(3, 4, 6)‖graph.add_edge(4, 1, 3)‖1
graph.add_edge(4, 1, 3)‖graph.add_edge(4, 2, 4)‖1
graph.add_edge(4, 2, 4)‖graph.add_edge(4, 3, 9)‖1
graph.add_edge(4, 3, 9)‖graph.floyd_warshall()‖1
graph.floyd_warshall()‖print(‖1
print(‖graph.show_min(1, 4)‖1
graph.show_min(1, 4)‖)‖1
print(‖graph.show_min(0, 3)‖1
graph.show_min(0, 3)‖)‖1
class Fibonacci:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self.sequence = [0, 1]‖1
def get(self, index: int) -> list:‖if (difference := index - (len(self.sequence) - 2)) >= 1:‖1
if (difference := index - (len(self.sequence) - 2)) >= 1:‖for _ in range(difference):‖1
for _ in range(difference):‖self.sequence.append(self.sequence[-1] + self.sequence[-2])‖1
self.sequence.append(self.sequence[-1] + self.sequence[-2])‖return self.sequence[:index]‖1
def main() -> None:‖print(‖1
print(‖"""Fibonacci Series Using Dynamic Programming\n"","‖1
"""Fibonacci Series Using Dynamic Programming\n"","‖"""Enter the index of the Fibonacci number you want to calculate "","‖1
"""Enter the index of the Fibonacci number you want to calculate "","‖"""in the prompt below. (To exit enter exit or Ctrl-C)\n"","‖1
"""in the prompt below. (To exit enter exit or Ctrl-C)\n"","‖"sep="""","‖1
"sep="""","‖)‖1
)‖fibonacci = Fibonacci()‖1
while True:‖"prompt: str = input("">> "")"‖1
"prompt: str = input("">> "")"‖"if prompt in {""exit"", ""quit""}:"‖1
"if prompt in {""exit"", ""quit""}:"‖break‖1
try:‖index: int = int(prompt)‖1
index: int = int(prompt)‖except ValueError:‖1
except ValueError:‖"print(""Enter a number or 'exit'"")"‖1
"print(""Enter a number or 'exit'"")"‖continue‖1
def __init__(self):‖"self.word1 = """""‖1
"self.word1 = """""‖"self.word2 = """""‖1
"self.word2 = """""‖self.dp = []‖1
def __min_dist_top_down_dp(self, m: int, n: int) -> int:‖if m == -1:‖1
if m == -1:‖return n + 1‖1
return n + 1‖elif n == -1:‖1
elif n == -1:‖return m + 1‖1
return m + 1‖elif self.dp[m][n] > -1:‖1
elif self.dp[m][n] > -1:‖return self.dp[m][n]‖1
return self.dp[m][n]‖else:‖1
else:‖if self.word1[m] == self.word2[n]:‖1
if self.word1[m] == self.word2[n]:‖self.dp[m][n] = self.__min_dist_top_down_dp(m - 1, n - 1)‖1
self.dp[m][n] = self.__min_dist_top_down_dp(m - 1, n - 1)‖else:‖1
else:‖insert = self.__min_dist_top_down_dp(m, n - 1)‖1
insert = self.__min_dist_top_down_dp(m, n - 1)‖delete = self.__min_dist_top_down_dp(m - 1, n)‖1
delete = self.__min_dist_top_down_dp(m - 1, n)‖replace = self.__min_dist_top_down_dp(m - 1, n - 1)‖1
replace = self.__min_dist_top_down_dp(m - 1, n - 1)‖self.dp[m][n] = 1 + min(insert, delete, replace)‖1
def min_dist_top_down(self, word1: str, word2: str) -> int:‖self.word1 = word1‖1
self.word1 = word1‖self.word2 = word2‖2
self.word2 = word2‖self.dp = [[-1 for _ in range(len(word2))] for _ in range(len(word1))]‖1
def min_dist_bottom_up(self, word1: str, word2: str) -> int:‖self.word1 = word1‖1
self.word2 = word2‖m = len(word1)‖1
m = len(word1)‖n = len(word2)‖1
n = len(word2)‖self.dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]‖1
for i in range(m + 1):‖for j in range(n + 1):‖1
for j in range(n + 1):‖if i == 0:‖1
if i == 0:‖self.dp[i][j] = j‖1
self.dp[i][j] = j‖elif j == 0:‖1
elif j == 0:‖self.dp[i][j] = i‖1
self.dp[i][j] = i‖elif word1[i - 1] == word2[j - 1]:‖1
elif word1[i - 1] == word2[j - 1]:‖self.dp[i][j] = self.dp[i - 1][j - 1]‖1
self.dp[i][j] = self.dp[i - 1][j - 1]‖else:‖1
else:‖insert = self.dp[i][j - 1]‖1
insert = self.dp[i][j - 1]‖delete = self.dp[i - 1][j]‖1
delete = self.dp[i - 1][j]‖replace = self.dp[i - 1][j - 1]‖1
replace = self.dp[i - 1][j - 1]‖self.dp[i][j] = 1 + min(insert, delete, replace)‖1
self.dp[i][j] = 1 + min(insert, delete, replace)‖return self.dp[m][n]‖1
"if __name__ == ""__main__"":"‖solver = EditDistance()‖1
"print(""****************** Testing Edit Distance DP Algorithm ******************"")"‖print()‖1
"S1 = input(""Enter the first string: "").strip()"‖"S2 = input(""Enter the second string: "").strip()"‖1
print()‖"print(f""The minimum edit distance is: {solver.min_dist_top_down(S1, S2)}"")"‖1
"print(f""The minimum edit distance is: {solver.min_dist_top_down(S1, S2)}"")"‖"print(f""The minimum edit distance is: {solver.min_dist_bottom_up(S1, S2)}"")"‖1
"print(f""The minimum edit distance is: {solver.min_dist_bottom_up(S1, S2)}"")"‖print()‖1
print()‖"print(""*************** End of Testing Edit Distance DP Algorithm ***************"")"‖1
def partition(m: int) -> int:‖memo: list[list[int]] = [[0 for _ in range(m)] for _ in range(m + 1)]‖1
memo: list[list[int]] = [[0 for _ in range(m)] for _ in range(m + 1)]‖for i in range(m + 1):‖1
for i in range(m + 1):‖memo[i][0] = 1‖1
for n in range(m + 1):‖for k in range(1, m):‖1
for k in range(1, m):‖memo[n][k] += memo[n][k - 1]‖1
memo[n][k] += memo[n][k - 1]‖if n - k > 0:‖1
if n - k > 0:‖memo[n][k] += memo[n - k - 1][k]‖1
"if __name__ == ""__main__"":"‖import sys‖1
if len(sys.argv) == 1:‖try:‖1
try:‖"n = int(input(""Enter a number: "").strip())"‖1
"n = int(input(""Enter a number: "").strip())"‖print(partition(n))‖1
print(partition(n))‖except ValueError:‖2
except ValueError:‖"print(""Please enter a number."")"‖1
"print(""Please enter a number."")"‖else:‖1
try:‖n = int(sys.argv[1])‖1
n = int(sys.argv[1])‖print(partition(n))‖1
except ValueError:‖"print(""Please pass a number."")"‖1
def longest_subsequence(array: list[int]) -> list[int]:‖array_length = len(array)‖1
if array_length <= 1:‖return array‖1
pivot = array[0]‖is_found = False‖1
is_found = False‖i = 1‖1
i = 1‖longest_subseq: list[int] = []‖1
longest_subseq: list[int] = []‖while not is_found and i < array_length:‖1
while not is_found and i < array_length:‖if array[i] < pivot:‖1
if array[i] < pivot:‖is_found = True‖1
is_found = True‖temp_array = array[i:]‖1
temp_array = array[i:]‖temp_array = longest_subsequence(temp_array)‖1
temp_array = longest_subsequence(temp_array)‖if len(temp_array) > len(longest_subseq):‖1
if len(temp_array) > len(longest_subseq):‖longest_subseq = temp_array‖1
longest_subseq = temp_array‖else:‖1
temp_array = [element for element in array[1:] if element >= pivot]‖temp_array = [pivot, *longest_subsequence(temp_array)]‖1
temp_array = [pivot, *longest_subsequence(temp_array)]‖if len(temp_array) > len(longest_subseq):‖1
if len(temp_array) > len(longest_subseq):‖return temp_array‖1
return temp_array‖else:‖1
else:‖return longest_subseq‖1
import tensorflow as tf‖from numpy import array‖1
noofclusters = int(noofclusters)‖assert noofclusters < len(vectors)‖1
vector_indices = list(range(len(vectors)))‖shuffle(vector_indices)‖1
centroids = [‖tf.Variable(vectors[vector_indices[i]]) for i in range(noofclusters)‖1
tf.Variable(vectors[vector_indices[i]]) for i in range(noofclusters)‖]‖1
"centroid_value = tf.placeholder(""float64"", [dim])"‖cent_assigns = []‖1
cent_assigns = []‖for centroid in centroids:‖1
for centroid in centroids:‖cent_assigns.append(tf.assign(centroid, centroid_value))‖1
"assignment_value = tf.placeholder(""int32"")"‖cluster_assigns = []‖1
cluster_assigns = []‖for assignment in assignments:‖1
for assignment in assignments:‖cluster_assigns.append(tf.assign(assignment, assignment_value))‖1
"v1 = tf.placeholder(""float"", [dim])"‖"v2 = tf.placeholder(""float"", [dim])"‖1
"v2 = tf.placeholder(""float"", [dim])"‖euclid_dist = tf.sqrt(tf.reduce_sum(tf.pow(tf.sub(v1, v2), 2)))‖1
"centroid_distances = tf.placeholder(""float"", [noofclusters])"‖cluster_assignment = tf.argmin(centroid_distances, 0)‖1
noofiterations = 100‖for _ in range(noofiterations):‖1
for vector_n in range(len(vectors)):‖vect = vectors[vector_n]‖1
distances = [‖sess.run(euclid_dist, feed_dict={v1: vect, v2: sess.run(centroid)})‖1
sess.run(euclid_dist, feed_dict={v1: vect, v2: sess.run(centroid)})‖for centroid in centroids‖1
for centroid in centroids‖]‖1
assignment = sess.run(‖cluster_assignment, feed_dict={centroid_distances: distances}‖1
cluster_assignment, feed_dict={centroid_distances: distances}‖)‖1
sess.run(‖cluster_assigns[vector_n], feed_dict={assignment_value: assignment}‖1
cluster_assigns[vector_n], feed_dict={assignment_value: assignment}‖)‖1
assigned_vects = [‖vectors[i]‖1
vectors[i]‖for i in range(len(vectors))‖1
for i in range(len(vectors))‖if sess.run(assignments[i]) == cluster_n‖1
if sess.run(assignments[i]) == cluster_n‖]‖1
new_location = sess.run(‖mean_op, feed_dict={mean_input: array(assigned_vects)}‖1
mean_op, feed_dict={mean_input: array(assigned_vects)}‖)‖1
sess.run(‖cent_assigns[cluster_n], feed_dict={centroid_value: new_location}‖1
cent_assigns[cluster_n], feed_dict={centroid_value: new_location}‖)‖1
centroids = sess.run(centroids)‖assignments = sess.run(assignments)‖1
assignments = sess.run(assignments)‖return centroids, assignments‖1
def mf_knapsack(i, wt, val, j):‖global f‖1
global f‖if f[i][j] < 0:‖1
if f[i][j] < 0:‖if j < wt[i - 1]:‖1
if j < wt[i - 1]:‖val = mf_knapsack(i - 1, wt, val, j)‖1
val = mf_knapsack(i - 1, wt, val, j)‖else:‖1
else:‖val = max(‖1
val = max(‖mf_knapsack(i - 1, wt, val, j),‖1
mf_knapsack(i - 1, wt, val, j),‖mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],‖1
mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],‖)‖1
)‖f[i][j] = val‖1
f[i][j] = val‖return f[i][j]‖1
def knapsack(w, wt, val, n):‖dp = [[0] * (w + 1) for _ in range(n + 1)]‖1
for i in range(1, n + 1):‖for w_ in range(1, w + 1):‖1
for w_ in range(1, w + 1):‖if wt[i - 1] <= w_:‖1
if wt[i - 1] <= w_:‖dp[i][w_] = max(val[i - 1] + dp[i - 1][w_ - wt[i - 1]], dp[i - 1][w_])‖1
dp[i][w_] = max(val[i - 1] + dp[i - 1][w_ - wt[i - 1]], dp[i - 1][w_])‖else:‖1
else:‖dp[i][w_] = dp[i - 1][w_]‖1
def knapsack_with_example_solution(w: int, wt: list, val: list):‖if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):‖1
if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):‖raise ValueError(‖1
raise ValueError(‖"""Both the weights and values vectors must be either lists or tuples"""‖1
"""Both the weights and values vectors must be either lists or tuples"""‖)‖1
num_items = len(wt)‖if num_items != len(val):‖1
if num_items != len(val):‖msg = (‖1
msg = (‖"""The number of weights must be the same as the number of values.\n"""‖1
"""The number of weights must be the same as the number of values.\n"""‖"f""But got {num_items} weights and {len(val)} values"""‖1
"f""But got {num_items} weights and {len(val)} values"""‖)‖1
raise ValueError(msg)‖for i in range(num_items):‖1
for i in range(num_items):‖if not isinstance(wt[i], int):‖1
if not isinstance(wt[i], int):‖msg = (‖1
msg = (‖"""All weights must be integers but got weight of """‖1
"""All weights must be integers but got weight of """‖"f""type {type(wt[i])} at index {i}"""‖1
"f""type {type(wt[i])} at index {i}"""‖)‖1
optimal_val, dp_table = knapsack(w, wt, val, num_items)‖example_optional_set: set = set()‖1
example_optional_set: set = set()‖_construct_solution(dp_table, wt, num_items, w, example_optional_set)‖1
if i > 0 and j > 0:‖if dp[i - 1][j] == dp[i][j]:‖1
if dp[i - 1][j] == dp[i][j]:‖_construct_solution(dp, wt, i - 1, j, optimal_set)‖1
_construct_solution(dp, wt, i - 1, j, optimal_set)‖else:‖1
else:‖optimal_set.add(i)‖1
optimal_set.add(i)‖_construct_solution(dp, wt, i - 1, j - wt[i - 1], optimal_set)‖1
"if __name__ == ""__main__"":"‖val = [3, 2, 4, 4]‖1
val = [3, 2, 4, 4]‖wt = [4, 3, 2, 3]‖1
wt = [4, 3, 2, 3]‖n = 4‖1
n = 4‖w = 6‖1
w = 6‖f = [[0] * (w + 1)] + [[0] + [-1] * (w + 1) for _ in range(n + 1)]‖1
f = [[0] * (w + 1)] + [[0] + [-1] * (w + 1) for _ in range(n + 1)]‖optimal_solution, _ = knapsack(w, wt, val, n)‖1
optimal_solution, _ = knapsack(w, wt, val, n)‖print(optimal_solution)‖1
print(optimal_solution)‖print(mf_knapsack(n, wt, val, w))‖1
optimal_solution, optimal_subset = knapsack_with_example_solution(w, wt, val)‖assert optimal_solution == 8‖1
assert optimal_solution == 8‖assert optimal_subset == {3, 4}‖1
assert optimal_subset == {3, 4}‖"print(""optimal_value = "", optimal_solution)"‖1
"print(""optimal_value = "", optimal_solution)"‖"print(""An optimal subset corresponding to the optimal value"", optimal_subset)"‖1
memo = [1] * number_of_items‖hash_array = list(range(number_of_items))‖1
for i, item in enumerate(items):‖for prev_index in range(i):‖1
for prev_index in range(i):‖if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (‖1
if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (‖(1 + memo[prev_index]) > memo[i]‖1
(1 + memo[prev_index]) > memo[i]‖):‖1
):‖memo[i] = 1 + memo[prev_index]‖1
memo[i] = 1 + memo[prev_index]‖hash_array[i] = prev_index‖1
ans = -1‖last_index = -1‖1
for i, memo_item in enumerate(memo):‖if memo_item > ans:‖1
if memo_item > ans:‖ans = memo_item‖1
ans = memo_item‖last_index = i‖1
if last_index == -1:‖return []‖1
return []‖result = [items[last_index]]‖1
result = [items[last_index]]‖while hash_array[last_index] != last_index:‖1
while hash_array[last_index] != last_index:‖last_index = hash_array[last_index]‖1
last_index = hash_array[last_index]‖result.append(items[last_index])‖1
items = [1, 16, 7, 8, 4]‖print(‖1
print(‖"f""The longest divisible subset of {items} is {largest_divisible_subset(items)}."""‖1
"f""The longest divisible subset of {items} is {largest_divisible_subset(items)}."""‖)‖1
def dp_count(s, n):‖if n < 0:‖1
if n < 0:‖return 0‖1
for coin_val in s:‖for j in range(coin_val, n + 1):‖1
for j in range(coin_val, n + 1):‖table[j] += table[j - coin_val]‖1
assert x is not None‖assert y is not None‖1
m = len(x)‖n = len(y)‖1
for i in range(1, m + 1):‖for j in range(1, n + 1):‖3
for j in range(1, n + 1):‖match = 1 if x[i - 1] == y[j - 1] else 0‖1
"seq = """""‖i, j = m, n‖1
i, j = m, n‖while i > 0 and j > 0:‖1
while i > 0 and j > 0:‖match = 1 if x[i - 1] == y[j - 1] else 0‖1
if dp[i][j] == dp[i - 1][j - 1] + match:‖if match == 1:‖1
if match == 1:‖seq = x[i - 1] + seq‖1
seq = x[i - 1] + seq‖i -= 1‖1
i -= 1‖j -= 1‖2
j -= 1‖elif dp[i][j] == dp[i - 1][j]:‖1
elif dp[i][j] == dp[i - 1][j]:‖i -= 1‖1
i -= 1‖else:‖4
else:‖j -= 1‖1
"if __name__ == ""__main__"":"‖"a = ""AGGTAB"""‖1
"a = ""AGGTAB"""‖"b = ""GXTXAYB"""‖1
"b = ""GXTXAYB"""‖expected_ln = 4‖1
expected_ln = 4‖"expected_subseq = ""GTAB"""‖1
ln, subseq = longest_common_subsequence(a, b)‖"print(""len ="", ln, "", sub-sequence ="", subseq)"‖1
"print(""len ="", ln, "", sub-sequence ="", subseq)"‖import doctest‖1
def maximum_non_adjacent_sum(nums: list[int]) -> int:‖if not nums:‖1
if not nums:‖return 0‖1
return 0‖max_including = nums[0]‖1
max_including = nums[0]‖max_excluding = 0‖1
max_excluding = 0‖for num in nums[1:]:‖1
for num in nums[1:]:‖max_including, max_excluding = (‖1
max_including, max_excluding = (‖max_excluding + num,‖1
max_excluding + num,‖max(max_including, max_excluding),‖1
max(max_including, max_excluding),‖)‖1
)‖return max(max_excluding, max_including)‖1
assert isinstance(mask, int) and mask > 0, (‖"f""mask needs to be positive integer, your input {mask}"""‖1
"f""mask needs to be positive integer, your input {mask}"""‖)‖1
all_submasks = []‖submask = mask‖1
while submask:‖all_submasks.append(submask)‖1
all_submasks.append(submask)‖submask = (submask - 1) & mask‖1
def longest_palindromic_subsequence(input_string: str) -> int:‖n = len(input_string)‖1
n = len(input_string)‖rev = input_string[::-1]‖1
rev = input_string[::-1]‖m = len(rev)‖1
m = len(rev)‖dp = [[-1] * (m + 1) for i in range(n + 1)]‖1
dp = [[-1] * (m + 1) for i in range(n + 1)]‖for i in range(n + 1):‖1
for i in range(n + 1):‖dp[i][0] = 0‖1
dp[i][0] = 0‖for i in range(m + 1):‖1
for i in range(m + 1):‖dp[0][i] = 0‖1
for i in range(1, n + 1):‖for j in range(1, m + 1):‖1
if input_string[i - 1] == rev[j - 1]:‖dp[i][j] = 1 + dp[i - 1][j - 1]‖1
dp[i][j] = 1 + dp[i - 1][j - 1]‖else:‖1
else:‖dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])‖1
if not (isinstance(text1, str) and isinstance(text2, str)):‖"raise ValueError(""longest_common_substring() takes two strings for inputs"")"‖1
text1_length = len(text1)‖text2_length = len(text2)‖1
dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]‖ans_index = 0‖1
ans_index = 0‖ans_length = 0‖1
for i in range(1, text1_length + 1):‖for j in range(1, text2_length + 1):‖1
for j in range(1, text2_length + 1):‖if text1[i - 1] == text2[j - 1]:‖1
if text1[i - 1] == text2[j - 1]:‖dp[i][j] = 1 + dp[i - 1][j - 1]‖1
dp[i][j] = 1 + dp[i - 1][j - 1]‖if dp[i][j] > ans_length:‖1
if dp[i][j] > ans_length:‖ans_index = i‖1
ans_index = i‖ans_length = dp[i][j]‖1
from collections.abc import Iterator‖from contextlib import contextmanager‖1
from contextlib import contextmanager‖from functools import cache‖1
from functools import cache‖from sys import maxsize‖1
def matrix_chain_multiply(arr: list[int]) -> int:‖if len(arr) < 2:‖1
if len(arr) < 2:‖return 0‖1
n = len(arr)‖dp = [[maxsize for j in range(n)] for i in range(n)]‖1
for i in range(n - 1, 0, -1):‖for j in range(i, n):‖1
for j in range(i, n):‖if i == j:‖1
if i == j:‖dp[i][j] = 0‖1
dp[i][j] = 0‖continue‖1
continue‖for k in range(i, j):‖1
for k in range(i, j):‖dp[i][j] = min(‖1
dp[i][j] = min(‖dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]‖1
dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]‖)‖1
@cache‖def a(i: int, j: int) -> int:‖1
def a(i: int, j: int) -> int:‖return min(‖1
return min(‖(a(i, k) + dims[i] * dims[k] * dims[j] + a(k, j) for k in range(i + 1, j)),‖1
(a(i, k) + dims[i] * dims[k] * dims[j] + a(k, j) for k in range(i + 1, j)),‖default=0,‖1
default=0,‖)‖1
@contextmanager‖def elapsed_time(msg: str) -> Iterator:‖1
start = perf_counter_ns()‖yield‖1
yield‖"print(f""Finished: {msg} in {(perf_counter_ns() - start) / 10**9} seconds."")"‖1
doctest.testmod()‖"with elapsed_time(""matrix_chain_order""):"‖1
"with elapsed_time(""matrix_chain_order""):"‖"print(f""{matrix_chain_order(list(range(1, 251))) = }"")"‖2
"print(f""{matrix_chain_order(list(range(1, 251))) = }"")"‖"with elapsed_time(""matrix_chain_multiply""):"‖2
"with elapsed_time(""matrix_chain_multiply""):"‖"print(f""{matrix_chain_multiply(list(range(1, 251))) = }"")"‖2
"print(f""{matrix_chain_multiply(list(range(1, 251))) = }"")"‖"with elapsed_time(""matrix_chain_order""):"‖1
def max_product_subarray(numbers: list[int]) -> int:‖if not numbers:‖1
if not numbers:‖return 0‖2
if not isinstance(numbers, (list, tuple)) or not all(‖isinstance(number, int) for number in numbers‖2
isinstance(number, int) for number in numbers‖):‖2
):‖"raise ValueError(""numbers must be an iterable of integers"")"‖2
number = numbers[i]‖if number < 0:‖1
if number < 0:‖max_till_now, min_till_now = min_till_now, max_till_now‖1
max_till_now, min_till_now = min_till_now, max_till_now‖max_till_now = max(number, max_till_now * number)‖1
max_till_now = max(number, max_till_now * number)‖min_till_now = min(number, min_till_now * number)‖1
def matrix_chain_order(array):‖n = len(array)‖1
n = len(array)‖matrix = [[0 for x in range(n)] for x in range(n)]‖1
matrix = [[0 for x in range(n)] for x in range(n)]‖sol = [[0 for x in range(n)] for x in range(n)]‖1
for chain_length in range(2, n):‖for a in range(1, n - chain_length + 1):‖1
for a in range(1, n - chain_length + 1):‖b = a + chain_length - 1‖1
matrix[a][b] = sys.maxsize‖for c in range(a, b):‖1
for c in range(a, b):‖cost = (‖1
cost = (‖matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]‖1
matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]‖)‖1
)‖if cost < matrix[a][b]:‖1
if cost < matrix[a][b]:‖matrix[a][b] = cost‖1
matrix[a][b] = cost‖sol[a][b] = c‖1
sol[a][b] = c‖return matrix, sol‖1
def print_optiomal_solution(optimal_solution, i, j):‖if i == j:‖1
if i == j:‖"print(""A"" + str(i), end="" "")"‖1
"print(""A"" + str(i), end="" "")"‖else:‖1
else:‖"print(""("", end="" "")"‖1
"print(""("", end="" "")"‖print_optiomal_solution(optimal_solution, i, optimal_solution[i][j])‖1
print_optiomal_solution(optimal_solution, i, optimal_solution[i][j])‖print_optiomal_solution(optimal_solution, optimal_solution[i][j] + 1, j)‖1
print_optiomal_solution(optimal_solution, optimal_solution[i][j] + 1, j)‖"print("")"", end="" "")"‖1
def main():‖array = [30, 35, 15, 5, 10, 20, 25]‖1
array = [30, 35, 15, 5, 10, 20, 25]‖n = len(array)‖1
"print(""No. of Operation required: "" + str(matrix[1][n - 1]))"‖print_optiomal_solution(optimal_solution, 1, n - 1)‖1
def find_min(numbers: list[int]) -> int:‖n = len(numbers)‖1
n = len(numbers)‖s = sum(numbers)‖1
for i in range(n + 1):‖dp[i][0] = True‖1
for i in range(1, s + 1):‖dp[0][i] = False‖1
for i in range(1, n + 1):‖for j in range(1, s + 1):‖1
for j in range(1, s + 1):‖dp[i][j] = dp[i - 1][j]‖1
if numbers[i - 1] <= j:‖dp[i][j] = dp[i][j] or dp[i - 1][j - numbers[i - 1]]‖1
for j in range(int(s / 2), -1, -1):‖if dp[n][j] is True:‖1
if dp[n][j] is True:‖diff = s - 2 * j‖1
diff = s - 2 * j‖break‖1
for i in range(1, len(matrix[0])):‖matrix[0][i] += matrix[0][i - 1]‖1
for i in range(1, len(matrix)):‖matrix[i][0] += matrix[i - 1][0]‖1
for i in range(1, len(matrix)):‖for j in range(1, len(matrix[0])):‖1
for j in range(1, len(matrix[0])):‖matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])‖1
def max_subarray_sum(‖arr: Sequence[float], allow_empty_subarrays: bool = False‖1
arr: Sequence[float], allow_empty_subarrays: bool = False‖) -> float:‖1
) -> float:‖if not arr:‖1
if not arr:‖return 0‖1
"max_sum = 0 if allow_empty_subarrays else float(""-inf"")"‖curr_sum = 0.0‖1
curr_sum = 0.0‖for num in arr:‖1
for num in arr:‖curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)‖1
curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)‖max_sum = max(max_sum, curr_sum)‖1
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]‖"print(f""{max_subarray_sum(nums) = }"")"‖1
def longest_subsequence(array: list[int]) -> list[int]:‖n = len(array)‖1
longest_increasing_subsequence = []‖for i in range(n):‖1
for i in range(n):‖longest_increasing_subsequence.append([array[i]])‖1
for i in range(1, n):‖for prev in range(i):‖1
if array[prev] <= array[i] and len(‖longest_increasing_subsequence[prev]‖1
longest_increasing_subsequence[prev]‖) + 1 > len(longest_increasing_subsequence[i]):‖1
) + 1 > len(longest_increasing_subsequence[i]):‖longest_increasing_subsequence[i] = copy.copy(‖1
longest_increasing_subsequence[i] = copy.copy(‖longest_increasing_subsequence[prev]‖1
longest_increasing_subsequence[prev]‖)‖1
)‖longest_increasing_subsequence[i].append(array[i])‖1
result: list[int] = []‖for i in range(n):‖1
for i in range(n):‖if len(longest_increasing_subsequence[i]) > len(result):‖1
if len(longest_increasing_subsequence[i]) > len(result):‖result = longest_increasing_subsequence[i]‖1
def minimum_squares_to_represent_a_number(number: int) -> int:‖if number != int(number):‖1
if number != int(number):‖"raise ValueError(""the value of input must be a natural number"")"‖1
"raise ValueError(""the value of input must be a natural number"")"‖if number < 0:‖1
if number < 0:‖"raise ValueError(""the value of input must not be a negative number"")"‖1
"raise ValueError(""the value of input must not be a negative number"")"‖if number == 0:‖1
if number == 0:‖return 1‖1
return 1‖answers = [-1] * (number + 1)‖1
answers = [-1] * (number + 1)‖answers[0] = 0‖1
answers[0] = 0‖for i in range(1, number + 1):‖1
for i in range(1, number + 1):‖answer = sys.maxsize‖1
answer = sys.maxsize‖root = int(math.sqrt(i))‖1
root = int(math.sqrt(i))‖for j in range(1, root + 1):‖1
for j in range(1, root + 1):‖current_answer = 1 + answers[i - (j**2)]‖1
current_answer = 1 + answers[i - (j**2)]‖answer = min(answer, current_answer)‖1
answer = min(answer, current_answer)‖answers[i] = answer‖1
answers[i] = answer‖return answers[number]‖1
if number <= 0:‖"msg = f""n must be greater than 0. Got n = {number}"""‖1
"msg = f""n must be greater than 0. Got n = {number}"""‖raise ValueError(msg)‖1
table[1] = 0‖for i in range(1, number):‖1
for i in range(1, number):‖table[i + 1] = min(table[i + 1], table[i] + 1)‖1
if i * 2 <= number:‖table[i * 2] = min(table[i * 2], table[i] + 1)‖1
if i * 3 <= number:‖table[i * 3] = min(table[i * 3], table[i] + 1)‖1
table[i * 3] = min(table[i * 3], table[i] + 1)‖return table[number]‖1
def find_minimum_partitions(string: str) -> int:‖length = len(string)‖1
length = len(string)‖cut = [0] * length‖1
cut = [0] * length‖is_palindromic = [[False for i in range(length)] for j in range(length)]‖1
is_palindromic = [[False for i in range(length)] for j in range(length)]‖for i, c in enumerate(string):‖1
for i, c in enumerate(string):‖mincut = i‖1
mincut = i‖for j in range(i + 1):‖1
for j in range(i + 1):‖if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):‖1
if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):‖is_palindromic[j][i] = True‖1
is_palindromic[j][i] = True‖mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))‖1
mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))‖cut[i] = mincut‖1
cut[i] = mincut‖return cut[length - 1]‖1
"if __name__ == ""__main__"":"‖"s = input(""Enter the string: "").strip()"‖1
"s = input(""Enter the string: "").strip()"‖ans = find_minimum_partitions(s)‖1
ans = find_minimum_partitions(s)‖"print(f""Minimum number of partitions required for the '{s}' is {ans}"")"‖1
import sys‖from random import randint‖1
def __init__(self, key, freq):‖self.key = key‖1
self.key = key‖self.freq = freq‖1
def __str__(self):‖"return f""Node(key={self.key}, freq={self.freq})"""‖1
def print_binary_search_tree(root, key, i, j, parent, is_left):‖if i > j or i < 0 or j > len(root) - 1:‖1
if i > j or i < 0 or j > len(root) - 1:‖return‖1
node = root[i][j]‖if parent == -1:‖1
if parent == -1:‖"print(f""{key[node]} is the root of the binary search tree."")"‖1
"print(f""{key[node]} is the root of the binary search tree."")"‖elif is_left:‖1
elif is_left:‖"print(f""{key[node]} is the left child of key {parent}."")"‖1
"print(f""{key[node]} is the left child of key {parent}."")"‖else:‖1
else:‖"print(f""{key[node]} is the right child of key {parent}."")"‖1
print_binary_search_tree(root, key, i, node - 1, key[node], True)‖print_binary_search_tree(root, key, node + 1, j, key[node], False)‖1
keys = [nodes[i].key for i in range(n)]‖freqs = [nodes[i].freq for i in range(n)]‖1
for interval_length in range(2, n + 1):‖for i in range(n - interval_length + 1):‖1
for i in range(n - interval_length + 1):‖j = i + interval_length - 1‖1
dp[i][j] = sys.maxsize‖total[i][j] = total[i][j - 1] + freqs[j]‖1
for r in range(root[i][j - 1], root[i + 1][j] + 1):‖left = dp[i][r - 1] if r != i else 0‖1
left = dp[i][r - 1] if r != i else 0‖right = dp[r + 1][j] if r != j else 0‖1
right = dp[r + 1][j] if r != j else 0‖cost = left + total[i][j] + right‖1
if dp[i][j] > cost:‖dp[i][j] = cost‖1
dp[i][j] = cost‖root[i][j] = r‖1
"print(""Binary search tree nodes:"")"‖for node in nodes:‖1
for node in nodes:‖print(node)‖2
"print(f""\nThe cost of optimal BST for given tree nodes is {dp[0][n - 1]}."")"‖print_binary_search_tree(root, keys, 0, n - 1, -1, False)‖1
nodes = [Node(i, randint(1, 50)) for i in range(10, 0, -1)]‖find_optimal_binary_search_tree(nodes)‖1
def tribonacci(num: int) -> list[int]:‖dp = [0] * num‖1
dp = [0] * num‖dp[2] = 1‖1
for i in range(3, num):‖dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]‖1
def trapped_rainwater(heights: tuple[int, ...]) -> int:‖if not heights:‖1
if not heights:‖return 0‖1
return 0‖if any(h < 0 for h in heights):‖1
if any(h < 0 for h in heights):‖"raise ValueError(""No height can be negative"")"‖1
"raise ValueError(""No height can be negative"")"‖length = len(heights)‖1
left_max = [0] * length‖left_max[0] = heights[0]‖1
left_max[0] = heights[0]‖for i, height in enumerate(heights[1:], start=1):‖1
for i, height in enumerate(heights[1:], start=1):‖left_max[i] = max(height, left_max[i - 1])‖1
right_max = [0] * length‖right_max[-1] = heights[-1]‖1
right_max[-1] = heights[-1]‖for i in range(length - 2, -1, -1):‖1
for i in range(length - 2, -1, -1):‖right_max[i] = max(heights[i], right_max[i + 1])‖1
return sum(‖min(left, right) - height‖1
min(left, right) - height‖for left, right, height in zip(left_max, right_max, heights)‖1
for left, right, height in zip(left_max, right_max, heights)‖)‖1
doctest.testmod()‖"print(f""{trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1)) = }"")"‖1
"print(f""{trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1)) = }"")"‖"print(f""{trapped_rainwater((7, 1, 5, 3, 6, 4)) = }"")"‖1
def ceil_index(v, left, right, key):‖while right - left > 1:‖1
while right - left > 1:‖middle = (left + right) // 2‖1
middle = (left + right) // 2‖if v[middle] >= key:‖1
if v[middle] >= key:‖right = middle‖1
right = middle‖else:‖1
else:‖left = middle‖1
left = middle‖return right‖1
def longest_increasing_subsequence_length(v: list[int]) -> int:‖if len(v) == 0:‖1
if len(v) == 0:‖return 0‖1
tail = [0] * len(v)‖length = 1‖1
for i in range(1, len(v)):‖if v[i] < tail[0]:‖1
if v[i] < tail[0]:‖tail[0] = v[i]‖1
tail[0] = v[i]‖elif v[i] > tail[length - 1]:‖1
elif v[i] > tail[length - 1]:‖tail[length] = v[i]‖1
tail[length] = v[i]‖length += 1‖1
length += 1‖else:‖1
else:‖tail[ceil_index(tail, -1, length - 1, v[i])] = v[i]‖1
if not isinstance(days, list) or not all(isinstance(day, int) for day in days):‖"raise ValueError(""The parameter days should be a list of integers"")"‖1
if len(costs) != 3 or not all(isinstance(cost, int) for cost in costs):‖"raise ValueError(""The parameter costs should be a list of three integers"")"‖1
if len(days) == 0:‖return 0‖1
if min(days) <= 0:‖"raise ValueError(""All days elements should be greater than 0"")"‖1
if max(days) >= 366:‖"raise ValueError(""All days elements should be less than 366"")"‖1
@functools.cache‖def dynamic_programming(index: int) -> int:‖1
def dynamic_programming(index: int) -> int:‖if index > 365:‖1
if index > 365:‖return 0‖1
if index not in days_set:‖return dynamic_programming(index + 1)‖1
return min(‖costs[0] + dynamic_programming(index + 1),‖1
costs[0] + dynamic_programming(index + 1),‖costs[1] + dynamic_programming(index + 7),‖1
costs[1] + dynamic_programming(index + 7),‖costs[2] + dynamic_programming(index + 30),‖1
costs[2] + dynamic_programming(index + 30),‖)‖1
import cmath‖import math‖1
def apparent_power(‖voltage: float, current: float, voltage_angle: float, current_angle: float‖1
voltage: float, current: float, voltage_angle: float, current_angle: float‖) -> complex:‖1
voltage_angle_rad = math.radians(voltage_angle)‖current_angle_rad = math.radians(current_angle)‖1
voltage_rect = cmath.rect(voltage, voltage_angle_rad)‖current_rect = cmath.rect(current, current_angle_rad)‖1
def is_match(string: str, pattern: str) -> bool:‖"dp = [[False] * (len(pattern) + 1) for _ in string + ""1""]"‖1
"dp = [[False] * (len(pattern) + 1) for _ in string + ""1""]"‖dp[0][0] = True‖1
for j, char in enumerate(pattern, 1):‖"if char == ""*"":"‖1
"if char == ""*"":"‖dp[0][j] = dp[0][j - 1]‖1
for i, s_char in enumerate(string, 1):‖for j, p_char in enumerate(pattern, 1):‖1
for j, p_char in enumerate(pattern, 1):‖"if p_char in (s_char, ""?""):"‖1
"if p_char in (s_char, ""?""):"‖dp[i][j] = dp[i - 1][j - 1]‖1
dp[i][j] = dp[i - 1][j - 1]‖"elif pattern[j - 1] == ""*"":"‖2
"elif pattern[j - 1] == ""*"":"‖dp[i][j] = dp[i - 1][j] or dp[i][j - 1]‖1
dp[i][j] = dp[i - 1][j] or dp[i][j - 1]‖return dp[len(string)][len(pattern)]‖1
doctest.testmod()‖"print(f""{is_match('baaabab','*****ba*****ab') = }"")"‖1
def minimum_subarray_sum(target: int, numbers: list[int]) -> int:‖if not numbers:‖1
return 0‖if target == 0 and target in numbers:‖1
if target == 0 and target in numbers:‖return 0‖1
return 0‖if not isinstance(numbers, (list, tuple)) or not all(‖1
left = right = curr_sum = 0‖min_len = sys.maxsize‖1
while right < len(numbers):‖curr_sum += numbers[right]‖1
curr_sum += numbers[right]‖while curr_sum >= target and left <= right:‖1
while curr_sum >= target and left <= right:‖min_len = min(min_len, right - left + 1)‖1
min_len = min(min_len, right - left + 1)‖curr_sum -= numbers[left]‖1
curr_sum -= numbers[left]‖left += 1‖1
left += 1‖right += 1‖1
if not pattern:‖return not text‖1
if not text:‖"return pattern[-1] == ""*"" and recursive_match(text, pattern[:-2])"‖1
"if text[-1] == pattern[-1] or pattern[-1] == ""."":"‖return recursive_match(text[:-1], pattern[:-1])‖1
"if pattern[-1] == ""*"":"‖return recursive_match(text[:-1], pattern) or recursive_match(‖1
return recursive_match(text[:-1], pattern) or recursive_match(‖text, pattern[:-2]‖1
text, pattern[:-2]‖)‖1
m = len(text)‖n = len(pattern)‖1
n = len(pattern)‖dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]‖1
dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]‖dp[0][0] = True‖1
for j in range(1, n + 1):‖"dp[0][j] = pattern[j - 1] == ""*"" and dp[0][j - 2]"‖1
for j in range(1, n + 1):‖"if pattern[j - 1] in {""."", text[i - 1]}:"‖1
"if pattern[j - 1] in {""."", text[i - 1]}:"‖dp[i][j] = dp[i - 1][j - 1]‖1
"elif pattern[j - 1] == ""*"":"‖dp[i][j] = dp[i][j - 2]‖1
dp[i][j] = dp[i][j - 2]‖"if pattern[j - 2] in {""."", text[i - 1]}:"‖1
"if pattern[j - 2] in {""."", text[i - 1]}:"‖dp[i][j] |= dp[i - 1][j]‖1
dp[i][j] |= dp[i - 1][j]‖else:‖1
else:‖dp[i][j] = False‖1
def score_function(‖source_char: str,‖1
source_char: str,‖target_char: str,‖1
target_char: str,‖match: int = 1,‖1
match: int = 1,‖mismatch: int = -1,‖2
mismatch: int = -1,‖gap: int = -2,‖2
gap: int = -2,‖) -> int:‖1
) -> int:‖"if ""-"" in (source_char, target_char):"‖1
"if ""-"" in (source_char, target_char):"‖return gap‖1
return gap‖return match if source_char == target_char else mismatch‖1
def smith_waterman(‖query: str,‖1
query: str,‖subject: str,‖1
subject: str,‖match: int = 1,‖1
gap: int = -2,‖) -> list[list[int]]:‖1
query = query.upper()‖subject = subject.upper()‖2
m = len(query)‖n = len(subject)‖1
n = len(subject)‖score = [[0] * (n + 1) for _ in range(m + 1)]‖1
score = [[0] * (n + 1) for _ in range(m + 1)]‖"kwargs = {""match"": match, ""mismatch"": mismatch, ""gap"": gap}"‖1
match = score[i - 1][j - 1] + score_function(‖query[i - 1], subject[j - 1], **kwargs‖1
query[i - 1], subject[j - 1], **kwargs‖)‖1
)‖delete = score[i - 1][j] + gap‖1
delete = score[i - 1][j] + gap‖insert = score[i][j - 1] + gap‖1
"max_value = float(""-inf"")"‖i_max = j_max = 0‖1
i_max = j_max = 0‖for i, row in enumerate(score):‖1
for i, row in enumerate(score):‖for j, value in enumerate(row):‖1
for j, value in enumerate(row):‖if value > max_value:‖1
if value > max_value:‖max_value = value‖1
max_value = value‖i_max, j_max = i, j‖1
i = i_max‖j = j_max‖1
j = j_max‖"align1 = """""‖1
"align1 = """""‖"align2 = """""‖1
"align2 = """""‖"gap = score_function(""-"", ""-"")"‖1
if i == 0 or j == 0:‖"return """""‖1
"return """""‖while i > 0 and j > 0:‖1
while i > 0 and j > 0:‖if score[i][j] == score[i - 1][j - 1] + score_function(‖1
if score[i][j] == score[i - 1][j - 1] + score_function(‖query[i - 1], subject[j - 1]‖1
query[i - 1], subject[j - 1]‖):‖1
align1 = query[i - 1] + align1‖align2 = subject[j - 1] + align2‖1
align2 = subject[j - 1] + align2‖i -= 1‖1
j -= 1‖elif score[i][j] == score[i - 1][j] + gap:‖1
align1 = query[i - 1] + align1‖"align2 = f""-{align2}"""‖1
"align2 = f""-{align2}"""‖i -= 1‖1
"align1 = f""-{align1}"""‖align2 = subject[j - 1] + align2‖1
align2 = subject[j - 1] + align2‖j -= 1‖1
"if __name__ == ""__main__"":"‖"query = ""HEAGAWGHEE"""‖1
"query = ""HEAGAWGHEE"""‖"subject = ""PAWHEAE"""‖1
score = smith_waterman(query, subject, match=1, mismatch=-1, gap=-2)‖print(traceback(score, query, subject))‖1
_enforce_args(n, prices)‖if n == 0:‖1
if n == 0:‖return 0‖2
return 0‖"max_revue = float(""-inf"")"‖1
"max_revue = float(""-inf"")"‖for i in range(1, n + 1):‖1
for i in range(1, n + 1):‖max_revue = max(‖1
max_revue = max(‖max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)‖1
max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)‖)‖1
def top_down_cut_rod(n: int, prices: list):‖_enforce_args(n, prices)‖1
_enforce_args(n, prices)‖"max_rev = [float(""-inf"") for _ in range(n + 1)]"‖1
"max_rev = [float(""-inf"") for _ in range(n + 1)]"‖return _top_down_cut_rod_recursive(n, prices, max_rev)‖1
def _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):‖if max_rev[n] >= 0:‖1
if max_rev[n] >= 0:‖return max_rev[n]‖1
return max_rev[n]‖elif n == 0:‖1
elif n == 0:‖return 0‖1
else:‖"max_revenue = float(""-inf"")"‖1
"max_revenue = float(""-inf"")"‖for i in range(1, n + 1):‖1
for i in range(1, n + 1):‖max_revenue = max(‖1
max_revenue = max(‖max_revenue,‖1
max_revenue,‖prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),‖1
prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),‖)‖1
def bottom_up_cut_rod(n: int, prices: list):‖_enforce_args(n, prices)‖1
"max_rev = [float(""-inf"") for _ in range(n + 1)]"‖max_rev[0] = 0‖1
for i in range(1, n + 1):‖max_revenue_i = max_rev[i]‖1
max_revenue_i = max_rev[i]‖for j in range(1, i + 1):‖1
for j in range(1, i + 1):‖max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])‖1
def _enforce_args(n: int, prices: list):‖if n < 0:‖1
if n < 0:‖"msg = f""n must be greater than or equal to 0. Got n = {n}"""‖1
"msg = f""n must be greater than or equal to 0. Got n = {n}"""‖raise ValueError(msg)‖1
if n > len(prices):‖msg = (‖1
msg = (‖"""Each integral piece of rod must have a corresponding price. """‖1
"""Each integral piece of rod must have a corresponding price. """‖"f""Got n = {n} but length of prices = {len(prices)}"""‖1
"f""Got n = {n} but length of prices = {len(prices)}"""‖)‖1
def main():‖prices = [6, 10, 12, 15, 20, 23]‖1
prices = [6, 10, 12, 15, 20, 23]‖n = len(prices)‖1
max_rev_top_down = top_down_cut_rod(n, prices)‖max_rev_bottom_up = bottom_up_cut_rod(n, prices)‖1
max_rev_bottom_up = bottom_up_cut_rod(n, prices)‖max_rev_naive = naive_cut_rod_recursive(n, prices)‖1
assert expected_max_revenue == max_rev_top_down‖assert max_rev_top_down == max_rev_bottom_up‖1
assert max_rev_top_down == max_rev_bottom_up‖assert max_rev_bottom_up == max_rev_naive‖1
def viterbi(‖observations_space: list,‖1
observations_space: list,‖states_space: list,‖1
states_space: list,‖initial_probabilities: dict,‖1
initial_probabilities: dict,‖transition_probabilities: dict,‖1
transition_probabilities: dict,‖emission_probabilities: dict,‖1
emission_probabilities: dict,‖) -> list:‖1
) -> list:‖_validation(‖1
_validation(‖observations_space,‖1
observations_space,‖states_space,‖3
states_space,‖initial_probabilities,‖3
initial_probabilities,‖transition_probabilities,‖3
transition_probabilities,‖emission_probabilities,‖3
emission_probabilities,‖)‖2
probabilities: dict = {}‖pointers: dict = {}‖1
pointers: dict = {}‖for state in states_space:‖1
for state in states_space:‖observation = observations_space[0]‖1
observation = observations_space[0]‖probabilities[(state, observation)] = (‖1
probabilities[(state, observation)] = (‖initial_probabilities[state] * emission_probabilities[state][observation]‖1
initial_probabilities[state] * emission_probabilities[state][observation]‖)‖1
)‖pointers[(state, observation)] = None‖1
for o in range(1, len(observations_space)):‖observation = observations_space[o]‖1
observation = observations_space[o]‖prior_observation = observations_space[o - 1]‖1
prior_observation = observations_space[o - 1]‖for state in states_space:‖1
"arg_max = """""‖max_probability = -1‖2
max_probability = -1‖for k_state in states_space:‖2
for k_state in states_space:‖probability = (‖1
probability = (‖probabilities[(k_state, prior_observation)]‖1
probabilities[(k_state, prior_observation)]‖* transition_probabilities[k_state][state]‖1
* transition_probabilities[k_state][state]‖* emission_probabilities[state][observation]‖1
* emission_probabilities[state][observation]‖)‖2
)‖if probability > max_probability:‖1
if probability > max_probability:‖max_probability = probability‖2
max_probability = probability‖arg_max = k_state‖2
probabilities[(state, observation)] = (‖probabilities[(arg_max, prior_observation)]‖1
probabilities[(arg_max, prior_observation)]‖* transition_probabilities[arg_max][state]‖1
* transition_probabilities[arg_max][state]‖* emission_probabilities[state][observation]‖1
for k_state in states_space:‖probability = probabilities[(k_state, final_observation)]‖1
probability = probabilities[(k_state, final_observation)]‖if probability > max_probability:‖1
arg_max = k_state‖last_state = arg_max‖1
previous = last_state‖result = []‖1
result = []‖for o in range(len(observations_space) - 1, -1, -1):‖1
for o in range(len(observations_space) - 1, -1, -1):‖result.append(previous)‖1
result.append(previous)‖previous = pointers[previous, observations_space[o]]‖1
previous = pointers[previous, observations_space[o]]‖result.reverse()‖1
def _validation(‖observations_space: Any,‖1
observations_space: Any,‖states_space: Any,‖2
states_space: Any,‖initial_probabilities: Any,‖2
initial_probabilities: Any,‖transition_probabilities: Any,‖3
transition_probabilities: Any,‖emission_probabilities: Any,‖3
emission_probabilities: Any,‖) -> None:‖3
) -> None:‖_validate_not_empty(‖1
_validate_not_empty(‖observations_space,‖1
)‖_validate_lists(observations_space, states_space)‖1
_validate_lists(observations_space, states_space)‖_validate_dicts(‖1
_validate_dicts(‖initial_probabilities, transition_probabilities, emission_probabilities‖1
initial_probabilities, transition_probabilities, emission_probabilities‖)‖1
def _validate_not_empty(‖observations_space: Any,‖1
) -> None:‖if not all(‖1
if not all(‖[‖1
[‖observations_space,‖1
emission_probabilities,‖]‖1
]‖):‖1
):‖"raise ValueError(""There's an empty parameter"")"‖1
def _validate_lists(observations_space: Any, states_space: Any) -> None:‖"_validate_list(observations_space, ""observations_space"")"‖1
"_validate_list(observations_space, ""observations_space"")"‖"_validate_list(states_space, ""states_space"")"‖1
def _validate_list(_object: Any, var_name: str) -> None:‖if not isinstance(_object, list):‖1
if not isinstance(_object, list):‖"msg = f""{var_name} must be a list"""‖1
"msg = f""{var_name} must be a list"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖else:‖3
else:‖for x in _object:‖1
for x in _object:‖if not isinstance(x, str):‖1
if not isinstance(x, str):‖"msg = f""{var_name} must be a list of strings"""‖1
"msg = f""{var_name} must be a list of strings"""‖raise ValueError(msg)‖1
def _validate_dicts(‖initial_probabilities: Any,‖1
) -> None:‖"_validate_dict(initial_probabilities, ""initial_probabilities"", float)"‖1
"_validate_dict(initial_probabilities, ""initial_probabilities"", float)"‖"_validate_nested_dict(transition_probabilities, ""transition_probabilities"")"‖1
"_validate_nested_dict(transition_probabilities, ""transition_probabilities"")"‖"_validate_nested_dict(emission_probabilities, ""emission_probabilities"")"‖1
def _validate_nested_dict(_object: Any, var_name: str) -> None:‖_validate_dict(_object, var_name, dict)‖1
_validate_dict(_object, var_name, dict)‖for x in _object.values():‖1
for x in _object.values():‖_validate_dict(x, var_name, float, True)‖1
def _validate_dict(‖_object: Any, var_name: str, value_type: type, nested: bool = False‖1
_object: Any, var_name: str, value_type: type, nested: bool = False‖) -> None:‖1
) -> None:‖if not isinstance(_object, dict):‖1
if not isinstance(_object, dict):‖"msg = f""{var_name} must be a dict"""‖1
"msg = f""{var_name} must be a dict"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖if not all(isinstance(x, str) for x in _object):‖1
if not all(isinstance(x, str) for x in _object):‖"msg = f""{var_name} all keys must be strings"""‖1
"msg = f""{var_name} all keys must be strings"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖if not all(isinstance(x, value_type) for x in _object.values()):‖1
if not all(isinstance(x, value_type) for x in _object.values()):‖"nested_text = ""nested dictionary "" if nested else """""‖1
"nested_text = ""nested dictionary "" if nested else """""‖"msg = f""{var_name} {nested_text}all values must be {value_type.__name__}"""‖1
"msg = f""{var_name} {nested_text}all values must be {value_type.__name__}"""‖raise ValueError(msg)‖1
arr_len = len(arr)‖subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]‖1
for i in range(arr_len + 1):‖subset[i][0] = True‖1
for i in range(1, required_sum + 1):‖subset[0][i] = False‖1
for i in range(1, arr_len + 1):‖for j in range(1, required_sum + 1):‖1
for j in range(1, required_sum + 1):‖if arr[i - 1] > j:‖1
if arr[i - 1] > j:‖subset[i][j] = subset[i - 1][j]‖1
subset[i][j] = subset[i - 1][j]‖if arr[i - 1] <= j:‖1
if arr[i - 1] <= j:‖subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]‖1
def capacitor_parallel(capacitors: list[float]) -> float:‖sum_c = 0.0‖1
sum_c = 0.0‖for index, capacitor in enumerate(capacitors):‖1
for index, capacitor in enumerate(capacitors):‖if capacitor < 0:‖1
if capacitor < 0:‖"msg = f""Capacitor at index {index} has a negative value!"""‖1
"msg = f""Capacitor at index {index} has a negative value!"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖sum_c += capacitor‖1
sum_c += capacitor‖return sum_c‖1
first_sum = 0.0‖for index, capacitor in enumerate(capacitors):‖1
for index, capacitor in enumerate(capacitors):‖if capacitor <= 0:‖1
if capacitor <= 0:‖"msg = f""Capacitor at index {index} has a negative or zero value!"""‖1
"msg = f""Capacitor at index {index} has a negative or zero value!"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖first_sum += 1 / capacitor‖1
first_sum += 1 / capacitor‖return 1 / first_sum‖1
def builtin_voltage(‖donor_conc: float,‖1
donor_conc: float,‖acceptor_conc: float,‖1
acceptor_conc: float,‖intrinsic_conc: float,‖1
intrinsic_conc: float,‖) -> float:‖1
if donor_conc <= 0:‖"raise ValueError(""Donor concentration should be positive"")"‖1
"raise ValueError(""Donor concentration should be positive"")"‖elif acceptor_conc <= 0:‖1
elif acceptor_conc <= 0:‖"raise ValueError(""Acceptor concentration should be positive"")"‖1
"raise ValueError(""Acceptor concentration should be positive"")"‖elif intrinsic_conc <= 0:‖1
elif intrinsic_conc <= 0:‖"raise ValueError(""Intrinsic concentration should be positive"")"‖1
"raise ValueError(""Intrinsic concentration should be positive"")"‖elif donor_conc <= intrinsic_conc:‖1
elif donor_conc <= intrinsic_conc:‖raise ValueError(‖1
raise ValueError(‖"""Donor concentration should be greater than intrinsic concentration"""‖1
"""Donor concentration should be greater than intrinsic concentration"""‖)‖1
)‖elif acceptor_conc <= intrinsic_conc:‖1
elif acceptor_conc <= intrinsic_conc:‖raise ValueError(‖1
raise ValueError(‖"""Acceptor concentration should be greater than intrinsic concentration"""‖1
"""Acceptor concentration should be greater than intrinsic concentration"""‖)‖1
else:‖return (‖4
return (‖Boltzmann‖1
Boltzmann‖* T‖1
* T‖* log((donor_conc * acceptor_conc) / intrinsic_conc**2)‖1
* log((donor_conc * acceptor_conc) / intrinsic_conc**2)‖"/ physical_constants[""electron volt""][0]"‖1
"/ physical_constants[""electron volt""][0]"‖)‖1
def couloumbs_law(‖force: float, charge1: float, charge2: float, distance: float‖1
force: float, charge1: float, charge2: float, distance: float‖) -> dict[str, float]:‖1
if (force, charge1, charge2, distance).count(0) != 1:‖"raise ValueError(""One and only one argument must be 0"")"‖1
"raise ValueError(""One and only one argument must be 0"")"‖if distance < 0:‖1
if distance < 0:‖"raise ValueError(""Distance cannot be negative"")"‖1
"raise ValueError(""Distance cannot be negative"")"‖if force == 0:‖1
if force == 0:‖force = COULOMBS_CONSTANT * charge_product / (distance**2)‖1
force = COULOMBS_CONSTANT * charge_product / (distance**2)‖"return {""force"": force}"‖1
"return {""force"": force}"‖elif charge1 == 0:‖1
elif charge1 == 0:‖charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)‖1
charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)‖"return {""charge1"": charge1}"‖1
"return {""charge1"": charge1}"‖elif charge2 == 0:‖1
elif charge2 == 0:‖charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)‖1
charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)‖"return {""charge2"": charge2}"‖1
"return {""charge2"": charge2}"‖elif distance == 0:‖1
elif distance == 0:‖distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5‖1
distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5‖"return {""distance"": distance}"‖1
"return {""distance"": distance}"‖"raise ValueError(""Exactly one argument must be 0"")"‖1
def carrier_concentration(‖electron_conc: float,‖1
electron_conc: float,‖hole_conc: float,‖1
hole_conc: float,‖intrinsic_conc: float,‖1
intrinsic_conc: float,‖) -> tuple:‖1
) -> tuple:‖if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:‖1
if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:‖"raise ValueError(""You cannot supply more or less than 2 values"")"‖1
"raise ValueError(""You cannot supply more or less than 2 values"")"‖elif electron_conc < 0:‖1
elif electron_conc < 0:‖"raise ValueError(""Electron concentration cannot be negative in a semiconductor"")"‖1
"raise ValueError(""Electron concentration cannot be negative in a semiconductor"")"‖elif hole_conc < 0:‖1
elif hole_conc < 0:‖"raise ValueError(""Hole concentration cannot be negative in a semiconductor"")"‖1
"raise ValueError(""Hole concentration cannot be negative in a semiconductor"")"‖elif intrinsic_conc < 0:‖1
elif intrinsic_conc < 0:‖raise ValueError(‖1
raise ValueError(‖"""Intrinsic concentration cannot be negative in a semiconductor"""‖1
"""Intrinsic concentration cannot be negative in a semiconductor"""‖)‖1
)‖elif electron_conc == 0:‖2
elif electron_conc == 0:‖return (‖2
return (‖"""electron_conc"","‖2
"""electron_conc"","‖intrinsic_conc**2 / hole_conc,‖1
intrinsic_conc**2 / hole_conc,‖)‖1
)‖elif hole_conc == 0:‖1
elif hole_conc == 0:‖return (‖1
return (‖"""hole_conc"","‖1
"""hole_conc"","‖intrinsic_conc**2 / electron_conc,‖1
intrinsic_conc**2 / electron_conc,‖)‖1
)‖elif intrinsic_conc == 0:‖1
elif intrinsic_conc == 0:‖return (‖1
return (‖"""intrinsic_conc"","‖1
"""intrinsic_conc"","‖(electron_conc * hole_conc) ** 0.5,‖1
(electron_conc * hole_conc) ** 0.5,‖)‖1
else:‖return (-1, -1)‖1
def min_distance_up_bottom(word1: str, word2: str) -> int:‖len_word1 = len(word1)‖1
len_word1 = len(word1)‖len_word2 = len(word2)‖1
@functools.cache‖def min_distance(index1: int, index2: int) -> int:‖1
if index1 >= len_word1:‖return len_word2 - index2‖1
if index2 >= len_word2:‖return len_word1 - index1‖1
return len_word1 - index1‖diff = int(word1[index1] != word2[index2])‖1
diff = int(word1[index1] != word2[index2])‖return min(‖1
return min(‖1 + min_distance(index1 + 1, index2),‖1
1 + min_distance(index1 + 1, index2),‖1 + min_distance(index1, index2 + 1),‖1
1 + min_distance(index1, index2 + 1),‖diff + min_distance(index1 + 1, index2 + 1),‖1
diff + min_distance(index1 + 1, index2 + 1),‖)‖1
def real_power(apparent_power: float, power_factor: float) -> float:‖if (‖1
if (‖not isinstance(power_factor, (int, float))‖2
not isinstance(power_factor, (int, float))‖or power_factor < -1‖2
or power_factor < -1‖or power_factor > 1‖2
or power_factor > 1‖):‖2
):‖"raise ValueError(""power_factor must be a valid float value between -1 and 1."")"‖2
"raise ValueError(""power_factor must be a valid float value between -1 and 1."")"‖return apparent_power * power_factor‖1
def reactive_power(apparent_power: float, power_factor: float) -> float:‖if (‖1
"raise ValueError(""power_factor must be a valid float value between -1 and 1."")"‖return apparent_power * math.sqrt(1 - power_factor**2)‖1
def charging_inductor(‖source_voltage: float,‖1
source_voltage: float,‖resistance: float,‖2
resistance: float,‖inductance: float,‖1
inductance: float,‖time: float,‖1
time: float,‖) -> float:‖1
if source_voltage <= 0:‖"raise ValueError(""Source voltage must be positive."")"‖2
"raise ValueError(""Source voltage must be positive."")"‖if resistance <= 0:‖2
if resistance <= 0:‖"raise ValueError(""Resistance must be positive."")"‖2
"raise ValueError(""Resistance must be positive."")"‖if inductance <= 0:‖1
if inductance <= 0:‖"raise ValueError(""Inductance must be positive."")"‖1
"raise ValueError(""Inductance must be positive."")"‖return round(‖1
return round(‖source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3‖1
source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3‖)‖1
def subset_combinations(elements: list[int], n: int) -> list:‖r = len(elements)‖1
r = len(elements)‖if n > r:‖1
if n > r:‖return []‖1
for i in range(1, r + 1):‖for j in range(i, 0, -1):‖1
for j in range(i, 0, -1):‖for prev_combination in dp[j - 1]:‖1
for prev_combination in dp[j - 1]:‖dp[j].append((*prev_combination, elements[i - 1]))‖1
try:‖return sorted(dp[n])‖1
return sorted(dp[n])‖except TypeError:‖1
except TypeError:‖return dp[n]‖1
testmod()‖"print(f""{subset_combinations(elements=[10, 20, 30, 40], n=2) = }"")"‖1
def main():‖sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)‖1
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)‖host = socket.gethostname()‖1
host = socket.gethostname()‖port = 12312‖1
sock.connect((host, port))‖"sock.send(b""Hello server!"")"‖1
"with open(""Received_file"", ""wb"") as out_file:"‖"print(""File opened"")"‖1
"print(""File opened"")"‖"print(""Receiving data..."")"‖1
"print(""Receiving data..."")"‖while True:‖1
while True:‖data = sock.recv(1024)‖1
data = sock.recv(1024)‖if not data:‖1
if not data:‖break‖1
break‖out_file.write(data)‖1
"print(""Successfully received the file"")"‖sock.close()‖1
sock.close()‖"print(""Connection closed"")"‖1
def astable_frequency(‖resistance_1: float, resistance_2: float, capacitance: float‖1
resistance_1: float, resistance_2: float, capacitance: float‖) -> float:‖1
if resistance_1 <= 0 or resistance_2 <= 0 or capacitance <= 0:‖"raise ValueError(""All values must be positive"")"‖1
"raise ValueError(""All values must be positive"")"‖return (1.44 / ((resistance_1 + 2 * resistance_2) * capacitance)) * 10**6‖1
if resistance_1 <= 0 or resistance_2 <= 0:‖"raise ValueError(""All values must be positive"")"‖1
"raise ValueError(""All values must be positive"")"‖return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100‖1
first_sum = 0.00‖for index, resistor in enumerate(resistors):‖1
for index, resistor in enumerate(resistors):‖if resistor <= 0:‖1
if resistor <= 0:‖"msg = f""Resistor at index {index} has a negative or zero value!"""‖1
"msg = f""Resistor at index {index} has a negative or zero value!"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖first_sum += 1 / float(resistor)‖1
first_sum += 1 / float(resistor)‖return 1 / first_sum‖1
def resistor_series(resistors: list[float]) -> float:‖sum_r = 0.00‖1
sum_r = 0.00‖for index, resistor in enumerate(resistors):‖1
for index, resistor in enumerate(resistors):‖sum_r += resistor‖1
sum_r += resistor‖if resistor < 0:‖1
if resistor < 0:‖"msg = f""Resistor at index {index} has a negative value!"""‖1
"msg = f""Resistor at index {index} has a negative value!"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖return sum_r‖1
import functools‖from typing import Any‖1
if not isinstance(string, str) or len(string) == 0:‖"raise ValueError(""the string should be not empty string"")"‖1
if not isinstance(words, list) or not all(‖isinstance(item, str) and len(item) > 0 for item in words‖1
isinstance(item, str) and len(item) > 0 for item in words‖):‖1
):‖"raise ValueError(""the words should be a list of non-empty strings"")"‖1
trie: dict[str, Any] = {}‖"word_keeper_key = ""WORD_KEEPER"""‖1
for word in words:‖trie_node = trie‖1
trie_node = trie‖for c in word:‖1
for c in word:‖if c not in trie_node:‖1
if c not in trie_node:‖trie_node[c] = {}‖1
@functools.cache‖def is_breakable(index: int) -> bool:‖1
def is_breakable(index: int) -> bool:‖if index == len_string:‖1
if index == len_string:‖return True‖1
trie_node = trie‖for i in range(index, len_string):‖1
for i in range(index, len_string):‖trie_node = trie_node.get(string[i], None)‖1
if trie_node is None:‖return False‖1
if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):‖return True‖1
def electrical_impedance(‖resistance: float, reactance: float, impedance: float‖1
resistance: float, reactance: float, impedance: float‖) -> dict[str, float]:‖1
) -> dict[str, float]:‖if (resistance, reactance, impedance).count(0) != 1:‖1
if (resistance, reactance, impedance).count(0) != 1:‖"raise ValueError(""One and only one argument must be 0"")"‖1
"raise ValueError(""One and only one argument must be 0"")"‖if resistance == 0:‖1
if resistance == 0:‖"return {""resistance"": sqrt(pow(impedance, 2) - pow(reactance, 2))}"‖1
"return {""resistance"": sqrt(pow(impedance, 2) - pow(reactance, 2))}"‖elif reactance == 0:‖1
elif reactance == 0:‖"return {""reactance"": sqrt(pow(impedance, 2) - pow(resistance, 2))}"‖1
"return {""reactance"": sqrt(pow(impedance, 2) - pow(resistance, 2))}"‖elif impedance == 0:‖1
elif impedance == 0:‖"return {""impedance"": sqrt(pow(resistance, 2) + pow(reactance, 2))}"‖1
"return {""impedance"": sqrt(pow(resistance, 2) + pow(reactance, 2))}"‖else:‖1
else:‖"raise ValueError(""Exactly one argument must be 0"")"‖3
def charging_capacitor(‖source_voltage: float,‖1
resistance: float,‖capacitance: float,‖1
capacitance: float,‖time_sec: float,‖1
time_sec: float,‖) -> float:‖1
"raise ValueError(""Resistance must be positive."")"‖if capacitance <= 0:‖1
if capacitance <= 0:‖"raise ValueError(""Capacitance must be positive."")"‖1
"raise ValueError(""Capacitance must be positive."")"‖return round(source_voltage * (1 - exp(-time_sec / (resistance * capacitance))), 3)‖1
def ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:‖if (voltage, current, resistance).count(0) != 1:‖1
if (voltage, current, resistance).count(0) != 1:‖"raise ValueError(""One and only one argument must be 0"")"‖1
"raise ValueError(""One and only one argument must be 0"")"‖if resistance < 0:‖1
if resistance < 0:‖"raise ValueError(""Resistance cannot be negative"")"‖1
"raise ValueError(""Resistance cannot be negative"")"‖if voltage == 0:‖1
if voltage == 0:‖"return {""voltage"": float(current * resistance)}"‖1
"return {""voltage"": float(current * resistance)}"‖elif current == 0:‖1
elif current == 0:‖"return {""current"": voltage / resistance}"‖1
"return {""current"": voltage / resistance}"‖elif resistance == 0:‖1
elif resistance == 0:‖"return {""resistance"": voltage / current}"‖1
"return {""resistance"": voltage / current}"‖else:‖1
import doctest‖from collections import deque‖1
self.first_signal = [2, 1, 2, -1]‖self.second_signal = [1, 2, 3, 4]‖1
length_first_signal = len(self.first_signal)‖length_second_signal = len(self.second_signal)‖1
if length_first_signal < length_second_signal:‖self.first_signal += [0] * (max_length - length_first_signal)‖1
self.first_signal += [0] * (max_length - length_first_signal)‖elif length_first_signal > length_second_signal:‖1
elif length_first_signal > length_second_signal:‖self.second_signal += [0] * (max_length - length_second_signal)‖1
for i in range(max_length):‖rotated_signal = deque(self.second_signal)‖1
rotated_signal = deque(self.second_signal)‖rotated_signal.rotate(i)‖1
rotated_signal.rotate(i)‖for j, item in enumerate(rotated_signal):‖1
for j, item in enumerate(rotated_signal):‖matrix[i][j] += item‖1
"if __name__ == ""__main__"":"‖doctest.testmod()‖1
class Result(NamedTuple):‖name: str‖1
name: str‖value: float‖1
def electric_power(voltage: float, current: float, power: float) -> tuple:‖if (voltage, current, power).count(0) != 1:‖1
if (voltage, current, power).count(0) != 1:‖"raise ValueError(""Exactly one argument must be 0"")"‖1
"raise ValueError(""Exactly one argument must be 0"")"‖elif power < 0:‖1
elif power < 0:‖raise ValueError(‖1
raise ValueError(‖"""Power cannot be negative in any electrical/electronics system"""‖1
"""Power cannot be negative in any electrical/electronics system"""‖)‖1
)‖elif voltage == 0:‖1
elif voltage == 0:‖"return Result(""voltage"", power / current)"‖1
"return Result(""voltage"", power / current)"‖elif current == 0:‖1
elif current == 0:‖"return Result(""current"", power / voltage)"‖1
"return Result(""current"", power / voltage)"‖elif power == 0:‖1
elif power == 0:‖"return Result(""power"", float(round(abs(voltage * current), 2)))"‖1
"return Result(""power"", float(round(abs(voltage * current), 2)))"‖else:‖1
else:‖raise AssertionError‖1
def wheatstone_solver(‖resistance_1: float, resistance_2: float, resistance_3: float‖1
resistance_1: float, resistance_2: float, resistance_3: float‖) -> float:‖1
if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:‖"raise ValueError(""All resistance values must be positive"")"‖1
"raise ValueError(""All resistance values must be positive"")"‖else:‖1
else:‖return float((resistance_2 / resistance_1) * resistance_3)‖1
if inductance <= 0:‖"raise ValueError(""Inductance cannot be 0 or negative"")"‖1
elif capacitance <= 0:‖"raise ValueError(""Capacitance cannot be 0 or negative"")"‖1
return (‖"""Resonant frequency"","‖1
"""Resonant frequency"","‖float(1 / (2 * pi * (sqrt(inductance * capacitance)))),‖1
float(1 / (2 * pi * (sqrt(inductance * capacitance)))),‖)‖1
"@patch(""socket.socket"")"‖"@patch(""builtins.open"")"‖1
"@patch(""builtins.open"")"‖def test_send_file_running_as_expected(file, sock):‖1
conn = Mock()‖sock.return_value.accept.return_value = conn, Mock()‖1
sock.return_value.accept.return_value = conn, Mock()‖f = iter([1, None])‖1
f = iter([1, None])‖file.return_value.__enter__.return_value.read.side_effect = lambda _: next(f)‖1
sock.assert_called_once()‖sock.return_value.bind.assert_called_once()‖1
sock.return_value.bind.assert_called_once()‖sock.return_value.listen.assert_called_once()‖1
sock.return_value.listen.assert_called_once()‖sock.return_value.accept.assert_called_once()‖1
sock.return_value.accept.assert_called_once()‖conn.recv.assert_called_once()‖1
file.return_value.__enter__.assert_called_once()‖file.return_value.__enter__.return_value.read.assert_called()‖1
conn.send.assert_called_once()‖conn.close.assert_called_once()‖1
conn.close.assert_called_once()‖sock.return_value.shutdown.assert_called_once()‖1
sock.return_value.shutdown.assert_called_once()‖sock.return_value.close.assert_called_once()‖1
valid_colors: list = [‖"""Black"","‖1
"""Black"","‖"""Brown"","‖1
"""Brown"","‖"""Red"","‖1
"""Red"","‖"""Orange"","‖1
"""Orange"","‖"""Yellow"","‖1
"""Yellow"","‖"""Green"","‖1
"""Green"","‖"""Blue"","‖1
"""Blue"","‖"""Violet"","‖1
"""Violet"","‖"""Grey"","‖1
"""Grey"","‖"""White"","‖1
"""White"","‖"""Gold"","‖1
"""Gold"","‖"""Silver"","‖1
"""Silver"","‖]‖1
significant_figures_color_values: dict[str, int] = {‖"""Black"": 0,"‖1
"""Black"": 0,"‖"""Brown"": 1,"‖1
"""Brown"": 1,"‖"""Red"": 2,"‖2
"""Red"": 2,"‖"""Orange"": 3,"‖1
"""Orange"": 3,"‖"""Yellow"": 4,"‖1
"""Yellow"": 4,"‖"""Green"": 5,"‖1
"""Green"": 5,"‖"""Blue"": 6,"‖1
"""Blue"": 6,"‖"""Violet"": 7,"‖1
"""Violet"": 7,"‖"""Grey"": 8,"‖1
"""Grey"": 8,"‖"""White"": 9,"‖1
"""White"": 9,"‖}‖1
multiplier_color_values: dict[str, float] = {‖"""Black"": 10**0,"‖1
"""Black"": 10**0,"‖"""Brown"": 10**1,"‖1
"""Brown"": 10**1,"‖"""Red"": 10**2,"‖1
"""Red"": 10**2,"‖"""Orange"": 10**3,"‖1
"""Orange"": 10**3,"‖"""Yellow"": 10**4,"‖1
"""Yellow"": 10**4,"‖"""Green"": 10**5,"‖1
"""Green"": 10**5,"‖"""Blue"": 10**6,"‖1
"""Blue"": 10**6,"‖"""Violet"": 10**7,"‖1
"""Violet"": 10**7,"‖"""Grey"": 10**8,"‖1
"""Grey"": 10**8,"‖"""White"": 10**9,"‖1
"""White"": 10**9,"‖"""Gold"": 10**-1,"‖1
"""Gold"": 10**-1,"‖"""Silver"": 10**-2,"‖1
"""Silver"": 10**-2,"‖}‖1
tolerance_color_values: dict[str, float] = {‖"""Brown"": 1,"‖1
"""Red"": 2,"‖"""Orange"": 0.05,"‖1
"""Orange"": 0.05,"‖"""Yellow"": 0.02,"‖1
"""Yellow"": 0.02,"‖"""Green"": 0.5,"‖1
"""Green"": 0.5,"‖"""Blue"": 0.25,"‖1
"""Blue"": 0.25,"‖"""Violet"": 0.1,"‖1
"""Violet"": 0.1,"‖"""Grey"": 0.01,"‖1
"""Grey"": 0.01,"‖"""Gold"": 5,"‖1
"""Gold"": 5,"‖"""Silver"": 10,"‖1
"""Silver"": 10,"‖}‖1
temperature_coeffecient_color_values: dict[str, int] = {‖"""Black"": 250,"‖1
"""Black"": 250,"‖"""Brown"": 100,"‖1
"""Brown"": 100,"‖"""Red"": 50,"‖1
"""Red"": 50,"‖"""Orange"": 15,"‖1
"""Orange"": 15,"‖"""Yellow"": 25,"‖1
"""Yellow"": 25,"‖"""Green"": 20,"‖1
"""Green"": 20,"‖"""Blue"": 10,"‖1
"""Blue"": 10,"‖"""Violet"": 5,"‖1
"""Violet"": 5,"‖"""Grey"": 1,"‖1
"""Grey"": 1,"‖}‖1
band_types: dict[int, dict[str, int]] = {‖"3: {""significant"": 2, ""multiplier"": 1},"‖1
"3: {""significant"": 2, ""multiplier"": 1},"‖"4: {""significant"": 2, ""multiplier"": 1, ""tolerance"": 1},"‖1
"4: {""significant"": 2, ""multiplier"": 1, ""tolerance"": 1},"‖"5: {""significant"": 3, ""multiplier"": 1, ""tolerance"": 1},"‖1
"5: {""significant"": 3, ""multiplier"": 1, ""tolerance"": 1},"‖"6: {""significant"": 3, ""multiplier"": 1, ""tolerance"": 1, ""temp_coeffecient"": 1},"‖1
"6: {""significant"": 3, ""multiplier"": 1, ""tolerance"": 1, ""temp_coeffecient"": 1},"‖}‖1
def get_significant_digits(colors: list) -> str:‖"digit = """""‖1
"digit = """""‖for color in colors:‖1
for color in colors:‖if color not in significant_figures_color_values:‖1
if color not in significant_figures_color_values:‖"msg = f""{color} is not a valid color for significant figure bands"""‖1
"msg = f""{color} is not a valid color for significant figure bands"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖digit = digit + str(significant_figures_color_values[color])‖1
digit = digit + str(significant_figures_color_values[color])‖return str(digit)‖1
def get_multiplier(color: str) -> float:‖if color not in multiplier_color_values:‖1
if color not in multiplier_color_values:‖"msg = f""{color} is not a valid color for multiplier band"""‖1
"msg = f""{color} is not a valid color for multiplier band"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖return multiplier_color_values[color]‖1
def get_tolerance(color: str) -> float:‖if color not in tolerance_color_values:‖1
if color not in tolerance_color_values:‖"msg = f""{color} is not a valid color for tolerance band"""‖1
"msg = f""{color} is not a valid color for tolerance band"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖return tolerance_color_values[color]‖1
def get_temperature_coeffecient(color: str) -> int:‖if color not in temperature_coeffecient_color_values:‖1
if color not in temperature_coeffecient_color_values:‖"msg = f""{color} is not a valid color for temperature coeffecient band"""‖1
"msg = f""{color} is not a valid color for temperature coeffecient band"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖return temperature_coeffecient_color_values[color]‖1
def get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:‖if total_number_of_bands not in band_types:‖1
if total_number_of_bands not in band_types:‖"msg = f""{total_number_of_bands} is not a valid number of bands"""‖1
"msg = f""{total_number_of_bands} is not a valid number of bands"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖if type_of_band not in band_types[total_number_of_bands]:‖1
if type_of_band not in band_types[total_number_of_bands]:‖"msg = f""{type_of_band} is not valid for a {total_number_of_bands} band resistor"""‖1
"msg = f""{type_of_band} is not valid for a {total_number_of_bands} band resistor"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖return band_types[total_number_of_bands][type_of_band]‖1
def check_validity(number_of_bands: int, colors: list) -> bool:‖if number_of_bands >= 3 and number_of_bands <= 6:‖1
if number_of_bands >= 3 and number_of_bands <= 6:‖if number_of_bands == len(colors):‖1
if number_of_bands == len(colors):‖for color in colors:‖1
for color in colors:‖if color not in valid_colors:‖1
if color not in valid_colors:‖"msg = f""{color} is not a valid color"""‖1
"msg = f""{color} is not a valid color"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖return True‖1
else:‖"msg = f""Expecting {number_of_bands} colors, provided {len(colors)} colors"""‖1
"msg = f""Expecting {number_of_bands} colors, provided {len(colors)} colors"""‖raise ValueError(msg)‖1
else:‖"msg = ""Invalid number of bands. Resistor bands must be 3 to 6"""‖1
"msg = ""Invalid number of bands. Resistor bands must be 3 to 6"""‖raise ValueError(msg)‖1
def calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:‖is_valid = check_validity(number_of_bands, color_code_list)‖1
is_valid = check_validity(number_of_bands, color_code_list)‖if is_valid:‖1
if is_valid:‖number_of_significant_bands = get_band_type_count(‖1
number_of_significant_bands = get_band_type_count(‖"number_of_bands, ""significant"""‖1
"number_of_bands, ""significant"""‖)‖1
)‖significant_colors = color_code_list[:number_of_significant_bands]‖1
significant_colors = color_code_list[:number_of_significant_bands]‖significant_digits = int(get_significant_digits(significant_colors))‖1
significant_digits = int(get_significant_digits(significant_colors))‖multiplier_color = color_code_list[number_of_significant_bands]‖1
multiplier_color = color_code_list[number_of_significant_bands]‖multiplier = get_multiplier(multiplier_color)‖1
multiplier = get_multiplier(multiplier_color)‖if number_of_bands == 3:‖1
if number_of_bands == 3:‖tolerance_color = None‖1
tolerance_color = None‖else:‖1
else:‖tolerance_color = color_code_list[number_of_significant_bands + 1]‖1
tolerance_color = color_code_list[number_of_significant_bands + 1]‖tolerance = (‖1
tolerance = (‖20 if tolerance_color is None else get_tolerance(str(tolerance_color))‖1
20 if tolerance_color is None else get_tolerance(str(tolerance_color))‖)‖1
)‖if number_of_bands != 6:‖1
if number_of_bands != 6:‖temperature_coeffecient_color = None‖1
temperature_coeffecient_color = None‖else:‖1
else:‖temperature_coeffecient_color = color_code_list[‖1
temperature_coeffecient_color = color_code_list[‖number_of_significant_bands + 2‖1
number_of_significant_bands + 2‖]‖1
]‖temperature_coeffecient = (‖1
temperature_coeffecient = (‖0‖1
0‖if temperature_coeffecient_color is None‖1
if temperature_coeffecient_color is None‖else get_temperature_coeffecient(str(temperature_coeffecient_color))‖1
else get_temperature_coeffecient(str(temperature_coeffecient_color))‖)‖1
)‖resisitance = significant_digits * multiplier‖1
resisitance = significant_digits * multiplier‖if temperature_coeffecient == 0:‖1
if temperature_coeffecient == 0:‖"answer = f""{resisitance}Ω ±{tolerance}% """‖1
"answer = f""{resisitance}Ω ±{tolerance}% """‖else:‖1
else:‖"answer = f""{resisitance}Ω ±{tolerance}% {temperature_coeffecient} ppm/K"""‖1
"answer = f""{resisitance}Ω ±{tolerance}% {temperature_coeffecient} ppm/K"""‖"return {""resistance"": answer}"‖1
"return {""resistance"": answer}"‖else:‖1
else:‖"raise ValueError(""Input is invalid"")"‖1
def electric_conductivity(‖conductivity: float,‖1
conductivity: float,‖electron_conc: float,‖1
electron_conc: float,‖mobility: float,‖1
mobility: float,‖) -> tuple[str, float]:‖1
) -> tuple[str, float]:‖if (conductivity, electron_conc, mobility).count(0) != 1:‖1
if (conductivity, electron_conc, mobility).count(0) != 1:‖"raise ValueError(""You cannot supply more or less than 2 values"")"‖1
"raise ValueError(""You cannot supply more or less than 2 values"")"‖elif conductivity < 0:‖1
elif conductivity < 0:‖"raise ValueError(""Conductivity cannot be negative"")"‖1
"raise ValueError(""Conductivity cannot be negative"")"‖elif electron_conc < 0:‖1
elif electron_conc < 0:‖"raise ValueError(""Electron concentration cannot be negative"")"‖1
"raise ValueError(""Electron concentration cannot be negative"")"‖elif mobility < 0:‖1
elif mobility < 0:‖"raise ValueError(""mobility cannot be negative"")"‖1
"raise ValueError(""mobility cannot be negative"")"‖elif conductivity == 0:‖1
elif conductivity == 0:‖return (‖1
return (‖"""conductivity"","‖1
"""conductivity"","‖mobility * electron_conc * ELECTRON_CHARGE,‖1
mobility * electron_conc * ELECTRON_CHARGE,‖)‖1
"""electron_conc"","‖conductivity / (mobility * ELECTRON_CHARGE),‖1
conductivity / (mobility * ELECTRON_CHARGE),‖)‖1
return (‖"""mobility"","‖1
"""mobility"","‖conductivity / (electron_conc * ELECTRON_CHARGE),‖1
conductivity / (electron_conc * ELECTRON_CHARGE),‖)‖1
def simple_interest(‖principal: float, daily_interest_rate: float, days_between_payments: float‖1
principal: float, daily_interest_rate: float, days_between_payments: float‖) -> float:‖1
) -> float:‖if days_between_payments <= 0:‖1
if days_between_payments <= 0:‖"raise ValueError(""days_between_payments must be > 0"")"‖1
"raise ValueError(""days_between_payments must be > 0"")"‖if daily_interest_rate < 0:‖1
if daily_interest_rate < 0:‖"raise ValueError(""daily_interest_rate must be >= 0"")"‖1
"raise ValueError(""daily_interest_rate must be >= 0"")"‖if principal <= 0:‖1
if principal <= 0:‖"raise ValueError(""principal must be > 0"")"‖3
"raise ValueError(""principal must be > 0"")"‖return principal * daily_interest_rate * days_between_payments‖1
def compound_interest(‖principal: float,‖1
principal: float,‖nominal_annual_interest_rate_percentage: float,‖1
nominal_annual_interest_rate_percentage: float,‖number_of_compounding_periods: float,‖1
number_of_compounding_periods: float,‖) -> float:‖1
) -> float:‖if number_of_compounding_periods <= 0:‖1
if number_of_compounding_periods <= 0:‖"raise ValueError(""number_of_compounding_periods must be > 0"")"‖1
"raise ValueError(""number_of_compounding_periods must be > 0"")"‖if nominal_annual_interest_rate_percentage < 0:‖1
if nominal_annual_interest_rate_percentage < 0:‖"raise ValueError(""nominal_annual_interest_rate_percentage must be >= 0"")"‖1
"raise ValueError(""nominal_annual_interest_rate_percentage must be >= 0"")"‖if principal <= 0:‖1
return principal * (‖(1 + nominal_annual_interest_rate_percentage) ** number_of_compounding_periods‖1
(1 + nominal_annual_interest_rate_percentage) ** number_of_compounding_periods‖- 1‖1
- 1‖)‖1
def apr_interest(‖principal: float,‖1
principal: float,‖nominal_annual_percentage_rate: float,‖1
nominal_annual_percentage_rate: float,‖number_of_years: float,‖1
number_of_years: float,‖) -> float:‖1
) -> float:‖if number_of_years <= 0:‖1
if number_of_years <= 0:‖"raise ValueError(""number_of_years must be > 0"")"‖1
"raise ValueError(""number_of_years must be > 0"")"‖if nominal_annual_percentage_rate < 0:‖1
if nominal_annual_percentage_rate < 0:‖"raise ValueError(""nominal_annual_percentage_rate must be >= 0"")"‖1
"raise ValueError(""nominal_annual_percentage_rate must be >= 0"")"‖if principal <= 0:‖1
return compound_interest(‖principal, nominal_annual_percentage_rate / 365, number_of_years * 365‖1
principal, nominal_annual_percentage_rate / 365, number_of_years * 365‖)‖1
def ind_reactance(‖inductance: float, frequency: float, reactance: float‖1
inductance: float, frequency: float, reactance: float‖) -> dict[str, float]:‖1
if (inductance, frequency, reactance).count(0) != 1:‖"raise ValueError(""One and only one argument must be 0"")"‖1
"raise ValueError(""One and only one argument must be 0"")"‖if inductance < 0:‖1
if inductance < 0:‖"raise ValueError(""Inductance cannot be negative"")"‖1
"raise ValueError(""Inductance cannot be negative"")"‖if frequency < 0:‖1
if frequency < 0:‖"raise ValueError(""Frequency cannot be negative"")"‖1
"raise ValueError(""Frequency cannot be negative"")"‖if reactance < 0:‖1
if reactance < 0:‖"raise ValueError(""Inductive reactance cannot be negative"")"‖1
"raise ValueError(""Inductive reactance cannot be negative"")"‖if inductance == 0:‖1
if inductance == 0:‖"return {""inductance"": reactance / (2 * pi * frequency)}"‖1
"return {""inductance"": reactance / (2 * pi * frequency)}"‖elif frequency == 0:‖1
elif frequency == 0:‖"return {""frequency"": reactance / (2 * pi * inductance)}"‖1
"return {""frequency"": reactance / (2 * pi * inductance)}"‖elif reactance == 0:‖1
elif reactance == 0:‖"return {""reactance"": 2 * pi * frequency * inductance}"‖1
"return {""reactance"": 2 * pi * frequency * inductance}"‖else:‖1
def simple_moving_average(‖data: Sequence[float], window_size: int‖1
data: Sequence[float], window_size: int‖) -> list[float | None]:‖1
) -> list[float | None]:‖if window_size < 1:‖1
if window_size < 1:‖"raise ValueError(""Window size must be a positive integer"")"‖1
for i in range(len(data)):‖if i < window_size - 1:‖1
if i < window_size - 1:‖sma.append(None)‖1
sma.append(None)‖else:‖1
else:‖window = data[i - window_size + 1 : i + 1]‖1
window = data[i - window_size + 1 : i + 1]‖sma_value = sum(window) / window_size‖1
sma_value = sum(window) / window_size‖sma.append(sma_value)‖1
sma.append(sma_value)‖return sma‖1
"print(""Simple Moving Average (SMA) Values:"")"‖for i, value in enumerate(sma_values):‖1
for i, value in enumerate(sma_values):‖if value is not None:‖1
if value is not None:‖"print(f""Day {i + 1}: {value:.2f}"")"‖1
"print(f""Day {i + 1}: {value:.2f}"")"‖else:‖1
else:‖"print(f""Day {i + 1}: Not enough data for SMA"")"‖1
def get_distance(x: float, y: float, max_step: int) -> float:‖a = x‖1
a = x‖b = y‖1
b = y‖for step in range(max_step):‖1
for step in range(max_step):‖a_new = a * a - b * b + x‖1
a_new = a * a - b * b + x‖b = 2 * a * b + y‖1
b = 2 * a * b + y‖a = a_new‖1
if a * a + b * b > 4:‖break‖1
break‖return step / (max_step - 1)‖1
def get_black_and_white_rgb(distance: float) -> tuple:‖if distance == 1:‖1
if distance == 1:‖return (0, 0, 0)‖2
return (0, 0, 0)‖else:‖2
else:‖return (255, 255, 255)‖1
def get_color_coded_rgb(distance: float) -> tuple:‖if distance == 1:‖1
else:‖return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))‖1
def get_image(‖image_width: int = 800,‖1
image_width: int = 800,‖image_height: int = 600,‖1
image_height: int = 600,‖figure_center_x: float = -0.6,‖1
figure_center_x: float = -0.6,‖figure_center_y: float = 0,‖1
figure_center_y: float = 0,‖figure_width: float = 3.2,‖1
figure_width: float = 3.2,‖max_step: int = 50,‖1
max_step: int = 50,‖use_distance_color_coding: bool = True,‖1
use_distance_color_coding: bool = True,‖) -> Image.Image:‖1
) -> Image.Image:‖"img = Image.new(""RGB"", (image_width, image_height))"‖1
"img = Image.new(""RGB"", (image_width, image_height))"‖pixels = img.load()‖1
for image_x in range(image_width):‖for image_y in range(image_height):‖1
figure_height = figure_width / image_width * image_height‖figure_x = figure_center_x + (image_x / image_width - 0.5) * figure_width‖1
figure_x = figure_center_x + (image_x / image_width - 0.5) * figure_width‖figure_y = figure_center_y + (image_y / image_height - 0.5) * figure_height‖1
if use_distance_color_coding:‖pixels[image_x, image_y] = get_color_coded_rgb(distance)‖1
pixels[image_x, image_y] = get_color_coded_rgb(distance)‖else:‖1
else:‖pixels[image_x, image_y] = get_black_and_white_rgb(distance)‖1
def present_value(discount_rate: float, cash_flows: list[float]) -> float:‖if discount_rate < 0:‖1
if discount_rate < 0:‖"raise ValueError(""Discount rate cannot be negative"")"‖1
"raise ValueError(""Discount rate cannot be negative"")"‖if not cash_flows:‖1
if not cash_flows:‖"raise ValueError(""Cash flows list cannot be empty"")"‖1
"raise ValueError(""Cash flows list cannot be empty"")"‖present_value = sum(‖1
present_value = sum(‖cash_flow / ((1 + discount_rate) ** i) for i, cash_flow in enumerate(cash_flows)‖1
cash_flow / ((1 + discount_rate) ** i) for i, cash_flow in enumerate(cash_flows)‖)‖1
)‖return round(present_value, ndigits=2)‖1
VECTOR_1 = np.array([0, 0])‖VECTOR_2 = np.array([0.5, 0.8660254])‖1
VECTOR_2 = np.array([0.5, 0.8660254])‖VECTOR_3 = np.array([1, 0])‖1
VECTOR_3 = np.array([1, 0])‖INITIAL_VECTORS = [VECTOR_1, VECTOR_2, VECTOR_3, VECTOR_1]‖1
def iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:‖vectors = initial_vectors‖1
vectors = initial_vectors‖for _ in range(steps):‖1
for _ in range(steps):‖vectors = iteration_step(vectors)‖1
vectors = iteration_step(vectors)‖return vectors‖1
def iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:‖new_vectors = []‖1
new_vectors = []‖for i, start_vector in enumerate(vectors[:-1]):‖1
for i, start_vector in enumerate(vectors[:-1]):‖end_vector = vectors[i + 1]‖1
end_vector = vectors[i + 1]‖new_vectors.append(start_vector)‖1
new_vectors.append(start_vector)‖difference_vector = end_vector - start_vector‖1
difference_vector = end_vector - start_vector‖new_vectors.append(start_vector + difference_vector / 3)‖1
new_vectors.append(start_vector + difference_vector / 3)‖new_vectors.append(‖1
new_vectors.append(‖start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)‖1
start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)‖)‖1
)‖new_vectors.append(start_vector + difference_vector * 2 / 3)‖1
new_vectors.append(start_vector + difference_vector * 2 / 3)‖new_vectors.append(vectors[-1])‖1
new_vectors.append(vectors[-1])‖return new_vectors‖1
def rotate(vector: np.ndarray, angle_in_degrees: float) -> np.ndarray:‖theta = np.radians(angle_in_degrees)‖1
theta = np.radians(angle_in_degrees)‖c, s = np.cos(theta), np.sin(theta)‖1
c, s = np.cos(theta), np.sin(theta)‖rotation_matrix = np.array(((c, -s), (s, c)))‖1
rotation_matrix = np.array(((c, -s), (s, c)))‖return np.dot(rotation_matrix, vector)‖1
axes = plt.gca()‖"axes.set_aspect(""equal"")"‖1
x_coordinates, y_coordinates = zip(*vectors)‖plt.plot(x_coordinates, y_coordinates)‖1
plt.plot(x_coordinates, y_coordinates)‖plt.show()‖1
processed_vectors = iterate(INITIAL_VECTORS, 5)‖plot(processed_vectors)‖1
@dataclass‖class FuzzySet:‖1
name: str‖left_boundary: float‖1
left_boundary: float‖peak: float‖1
peak: float‖right_boundary: float‖1
def __str__(self) -> str:‖return (‖1
return (‖"f""{self.name}: [{self.left_boundary}, {self.peak}, {self.right_boundary}]"""‖1
"f""{self.name}: [{self.left_boundary}, {self.peak}, {self.right_boundary}]"""‖)‖1
def complement(self) -> FuzzySet:‖return FuzzySet(‖1
return FuzzySet(‖"f""¬{self.name}"","‖1
"f""¬{self.name}"","‖1 - self.right_boundary,‖1
1 - self.right_boundary,‖1 - self.left_boundary,‖1
1 - self.left_boundary,‖1 - self.peak,‖1
1 - self.peak,‖)‖1
def intersection(self, other) -> FuzzySet:‖return FuzzySet(‖1
return FuzzySet(‖"f""{self.name} ∩ {other.name}"","‖1
"f""{self.name} ∩ {other.name}"","‖max(self.left_boundary, other.left_boundary),‖1
max(self.left_boundary, other.left_boundary),‖min(self.right_boundary, other.right_boundary),‖1
min(self.right_boundary, other.right_boundary),‖(self.peak + other.peak) / 2,‖1
(self.peak + other.peak) / 2,‖)‖2
def membership(self, x: float) -> float:‖if x <= self.left_boundary or x >= self.right_boundary:‖1
if x <= self.left_boundary or x >= self.right_boundary:‖return 0.0‖1
return 0.0‖elif self.left_boundary < x <= self.peak:‖1
elif self.left_boundary < x <= self.peak:‖return (x - self.left_boundary) / (self.peak - self.left_boundary)‖1
return (x - self.left_boundary) / (self.peak - self.left_boundary)‖elif self.peak < x < self.right_boundary:‖1
elif self.peak < x < self.right_boundary:‖return (self.right_boundary - x) / (self.right_boundary - self.peak)‖1
return (self.right_boundary - x) / (self.right_boundary - self.peak)‖"msg = f""Invalid value {x} for fuzzy set {self}"""‖1
"msg = f""Invalid value {x} for fuzzy set {self}"""‖raise ValueError(msg)‖1
def union(self, other) -> FuzzySet:‖return FuzzySet(‖1
return FuzzySet(‖"f""{self.name} U {other.name}"","‖1
"f""{self.name} U {other.name}"","‖min(self.left_boundary, other.left_boundary),‖1
min(self.left_boundary, other.left_boundary),‖max(self.right_boundary, other.right_boundary),‖1
max(self.right_boundary, other.right_boundary),‖(self.peak + other.peak) / 2,‖1
def plot(self):‖x = np.linspace(0, 1, 1000)‖1
x = np.linspace(0, 1, 1000)‖y = [self.membership(xi) for xi in x]‖1
testmod()‖"a = FuzzySet(""A"", 0, 0.5, 1)"‖1
"a = FuzzySet(""A"", 0, 0.5, 1)"‖"b = FuzzySet(""B"", 0.2, 0.7, 1)"‖1
a.plot()‖b.plot()‖1
"plt.xlabel(""x"")"‖"plt.ylabel(""Membership"")"‖2
"plt.ylabel(""Membership"")"‖plt.legend()‖2
plt.legend()‖plt.show()‖4
union_ab = a.union(b)‖intersection_ab = a.intersection(b)‖1
intersection_ab = a.intersection(b)‖complement_a = a.complement()‖1
union_ab.plot()‖intersection_ab.plot()‖1
intersection_ab.plot()‖complement_a.plot()‖1
"def send_file(filename: str = ""mytext.txt"", testing: bool = False) -> None:"‖import socket‖1
port = 12312‖sock = socket.socket()‖1
sock = socket.socket()‖host = socket.gethostname()‖1
host = socket.gethostname()‖sock.bind((host, port))‖1
sock.bind((host, port))‖sock.listen(5)‖1
while True:‖conn, addr = sock.accept()‖1
conn, addr = sock.accept()‖"print(f""Got connection from {addr}"")"‖1
"print(f""Got connection from {addr}"")"‖data = conn.recv(1024)‖1
data = conn.recv(1024)‖"print(f""Server received: {data = }"")"‖1
"with open(filename, ""rb"") as in_file:"‖data = in_file.read(1024)‖1
data = in_file.read(1024)‖while data:‖1
while data:‖conn.send(data)‖1
conn.send(data)‖"print(f""Sent {data!r}"")"‖1
"print(f""Sent {data!r}"")"‖data = in_file.read(1024)‖1
"print(""Done sending"")"‖conn.close()‖1
conn.close()‖if testing:‖1
if testing:‖break‖1
sock.shutdown(1)‖sock.close()‖1
"if __name__ == ""__main__"":"‖send_file()‖1
def equated_monthly_installments(‖principal: float, rate_per_annum: float, years_to_repay: int‖1
principal: float, rate_per_annum: float, years_to_repay: int‖) -> float:‖1
) -> float:‖if principal <= 0:‖1
if principal <= 0:‖"raise Exception(""Principal borrowed must be > 0"")"‖1
"raise Exception(""Principal borrowed must be > 0"")"‖if rate_per_annum < 0:‖1
if rate_per_annum < 0:‖"raise Exception(""Rate of interest must be >= 0"")"‖1
"raise Exception(""Rate of interest must be >= 0"")"‖if years_to_repay <= 0 or not isinstance(years_to_repay, int):‖1
if years_to_repay <= 0 or not isinstance(years_to_repay, int):‖"raise Exception(""Years to repay must be an integer > 0"")"‖1
return (‖principal‖1
principal‖* rate_per_month‖1
* rate_per_month‖* (1 + rate_per_month) ** number_of_payments‖1
* (1 + rate_per_month) ** number_of_payments‖/ ((1 + rate_per_month) ** number_of_payments - 1)‖1
/ ((1 + rate_per_month) ** number_of_payments - 1)‖)‖1
def price_plus_tax(price: float, tax_rate: float) -> float:‖return price * (1 + tax_rate)‖1
"if __name__ == ""__main__"":"‖"print(f""{price_plus_tax(100, 0.25) = }"")"‖1
"print(f""{price_plus_tax(100, 0.25) = }"")"‖"print(f""{price_plus_tax(125.50, 0.05) = }"")"‖1
AXIS_A = 6378137.0‖AXIS_B = 6356752.314245‖2
AXIS_B = 6356752.314245‖EQUATORIAL_RADIUS = 6378137‖1
def lamberts_ellipsoidal_distance(‖lat1: float, lon1: float, lat2: float, lon2: float‖1
lat1: float, lon1: float, lat2: float, lon2: float‖) -> float:‖1
b_lat1 = atan((1 - flattening) * tan(radians(lat1)))‖b_lat2 = atan((1 - flattening) * tan(radians(lat2)))‖1
p_value = (b_lat1 + b_lat2) / 2‖q_value = (b_lat2 - b_lat1) / 2‖1
x_numerator = (sin(p_value) ** 2) * (cos(q_value) ** 2)‖x_demonimator = cos(sigma / 2) ** 2‖1
x_demonimator = cos(sigma / 2) ** 2‖x_value = (sigma - sin(sigma)) * (x_numerator / x_demonimator)‖1
y_numerator = (cos(p_value) ** 2) * (sin(q_value) ** 2)‖y_denominator = sin(sigma / 2) ** 2‖1
y_denominator = sin(sigma / 2) ** 2‖y_value = (sigma + sin(sigma)) * (y_numerator / y_denominator)‖1
import warnings‖from collections.abc import Callable‖1
from collections.abc import Callable‖from typing import Any‖1
c_cauliflower = 0.25 + 0.0j‖c_polynomial_1 = -0.4 + 0.6j‖1
c_polynomial_1 = -0.4 + 0.6j‖c_polynomial_2 = -0.1 + 0.651j‖1
c_polynomial_2 = -0.1 + 0.651j‖c_exponential = -2.0‖1
c_exponential = -2.0‖nb_iterations = 56‖1
nb_iterations = 56‖window_size = 2.0‖1
window_size = 2.0‖nb_pixels = 666‖1
def eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:‖return np.exp(z_values) + c_parameter‖1
def eval_quadratic_polynomial(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:‖return z_values * z_values + c_parameter‖1
def prepare_grid(window_size: float, nb_pixels: int) -> np.ndarray:‖x = np.linspace(-window_size, window_size, nb_pixels)‖1
x = np.linspace(-window_size, window_size, nb_pixels)‖x = x.reshape((nb_pixels, 1))‖1
x = x.reshape((nb_pixels, 1))‖y = np.linspace(-window_size, window_size, nb_pixels)‖1
y = np.linspace(-window_size, window_size, nb_pixels)‖y = y.reshape((1, nb_pixels))‖1
y = y.reshape((1, nb_pixels))‖return x + 1.0j * y‖1
def iterate_function(‖eval_function: Callable[[Any, np.ndarray], np.ndarray],‖1
eval_function: Callable[[Any, np.ndarray], np.ndarray],‖function_params: Any,‖1
function_params: Any,‖nb_iterations: int,‖1
nb_iterations: int,‖z_0: np.ndarray,‖1
z_0: np.ndarray,‖infinity: float | None = None,‖1
infinity: float | None = None,‖) -> np.ndarray:‖1
"z_n = z_0.astype(""complex64"")"‖for _ in range(nb_iterations):‖1
for _ in range(nb_iterations):‖z_n = eval_function(function_params, z_n)‖1
z_n = eval_function(function_params, z_n)‖if infinity is not None:‖1
if infinity is not None:‖np.nan_to_num(z_n, copy=False, nan=infinity)‖1
np.nan_to_num(z_n, copy=False, nan=infinity)‖z_n[abs(z_n) == np.inf] = infinity‖1
z_n[abs(z_n) == np.inf] = infinity‖return z_n‖1
def show_results(‖function_label: str,‖1
function_label: str,‖function_params: Any,‖1
function_params: Any,‖escape_radius: float,‖1
escape_radius: float,‖z_final: np.ndarray,‖1
z_final: np.ndarray,‖) -> None:‖1
abs_z_final = (abs(z_final)).transpose()‖abs_z_final[:, :] = abs_z_final[::-1, :]‖1
abs_z_final[:, :] = abs_z_final[::-1, :]‖plt.matshow(abs_z_final < escape_radius)‖1
plt.matshow(abs_z_final < escape_radius)‖"plt.title(f""Julia set of ${function_label}$, $c={function_params}$"")"‖1
"plt.title(f""Julia set of ${function_label}$, $c={function_params}$"")"‖plt.show()‖1
def ignore_overflow_warnings() -> None:‖warnings.filterwarnings(‖1
warnings.filterwarnings(‖"""ignore"", category=RuntimeWarning, message=""overflow encountered in multiply"""‖1
"""ignore"", category=RuntimeWarning, message=""overflow encountered in multiply"""‖)‖1
)‖warnings.filterwarnings(‖3
warnings.filterwarnings(‖"""ignore"","‖1
"""ignore"","‖category=RuntimeWarning,‖1
category=RuntimeWarning,‖"message=""invalid value encountered in multiply"","‖1
"message=""invalid value encountered in multiply"","‖)‖1
warnings.filterwarnings(‖"""ignore"", category=RuntimeWarning, message=""overflow encountered in absolute"""‖1
"""ignore"", category=RuntimeWarning, message=""overflow encountered in absolute"""‖)‖1
warnings.filterwarnings(‖"""ignore"", category=RuntimeWarning, message=""overflow encountered in exp"""‖1
"""ignore"", category=RuntimeWarning, message=""overflow encountered in exp"""‖)‖1
"if __name__ == ""__main__"":"‖z_0 = prepare_grid(window_size, nb_pixels)‖1
nb_iterations = 24‖escape_radius = 2 * abs(c_cauliflower) + 1‖1
escape_radius = 2 * abs(c_cauliflower) + 1‖z_final = iterate_function(‖1
z_final = iterate_function(‖eval_quadratic_polynomial,‖3
eval_quadratic_polynomial,‖c_cauliflower,‖1
c_cauliflower,‖nb_iterations,‖1
nb_iterations,‖z_0,‖3
z_0,‖infinity=1.1 * escape_radius,‖3
infinity=1.1 * escape_radius,‖)‖3
)‖"show_results(""z^2+c"", c_cauliflower, escape_radius, z_final)"‖1
nb_iterations = 64‖escape_radius = 2 * abs(c_polynomial_1) + 1‖1
escape_radius = 2 * abs(c_polynomial_1) + 1‖z_final = iterate_function(‖1
eval_quadratic_polynomial,‖c_polynomial_1,‖1
c_polynomial_1,‖nb_iterations,‖1
)‖"show_results(""z^2+c"", c_polynomial_1, escape_radius, z_final)"‖1
nb_iterations = 161‖escape_radius = 2 * abs(c_polynomial_2) + 1‖1
escape_radius = 2 * abs(c_polynomial_2) + 1‖z_final = iterate_function(‖1
eval_quadratic_polynomial,‖c_polynomial_2,‖1
c_polynomial_2,‖nb_iterations,‖1
)‖"show_results(""z^2+c"", c_polynomial_2, escape_radius, z_final)"‖1
nb_iterations = 12‖escape_radius = 10000.0‖1
escape_radius = 10000.0‖z_final = iterate_function(‖1
z_final = iterate_function(‖eval_exponential,‖1
eval_exponential,‖c_exponential,‖1
c_exponential,‖nb_iterations,‖1
nb_iterations,‖z_0 + 2,‖1
z_0 + 2,‖infinity=1.0e10,‖1
infinity=1.0e10,‖)‖1
)‖"show_results(""e^z+c"", c_exponential, escape_radius, z_final)"‖1
import sys‖import turtle‖1
def get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:‖return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2‖1
def triangle(‖vertex1: tuple[float, float],‖1
vertex1: tuple[float, float],‖vertex2: tuple[float, float],‖1
vertex2: tuple[float, float],‖vertex3: tuple[float, float],‖1
vertex3: tuple[float, float],‖depth: int,‖1
depth: int,‖) -> None:‖1
) -> None:‖my_pen.up()‖1
my_pen.up()‖my_pen.goto(vertex1[0], vertex1[1])‖1
my_pen.goto(vertex1[0], vertex1[1])‖my_pen.down()‖1
my_pen.down()‖my_pen.goto(vertex2[0], vertex2[1])‖1
my_pen.goto(vertex2[0], vertex2[1])‖my_pen.goto(vertex3[0], vertex3[1])‖1
my_pen.goto(vertex3[0], vertex3[1])‖my_pen.goto(vertex1[0], vertex1[1])‖1
if depth == 0:‖return‖1
triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)‖triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)‖1
triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)‖triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)‖1
if len(sys.argv) != 2:‖raise ValueError(‖1
raise ValueError(‖"""Correct format for using this script: """‖1
"""Correct format for using this script: """‖"""python fractals.py <int:depth_for_fractal>"""‖1
"""python fractals.py <int:depth_for_fractal>"""‖)‖1
)‖my_pen = turtle.Turtle()‖1
my_pen = turtle.Turtle()‖my_pen.ht()‖1
my_pen.ht()‖my_pen.speed(5)‖1
my_pen.speed(5)‖"my_pen.pencolor(""red"")"‖1
vertices = [(-175, -125), (0, 175), (175, -125)]‖triangle(vertices[0], vertices[1], vertices[2], int(sys.argv[1]))‖1
triangle(vertices[0], vertices[1], vertices[2], int(sys.argv[1]))‖turtle.Screen().exitonclick()‖1
def draw_cross(x: float, y: float, length: float):‖turtle.up()‖1
turtle.up()‖turtle.goto(x - length / 2, y - length / 6)‖1
turtle.goto(x - length / 2, y - length / 6)‖turtle.down()‖1
turtle.down()‖turtle.seth(0)‖1
turtle.seth(0)‖turtle.begin_fill()‖1
turtle.begin_fill()‖for _ in range(4):‖1
for _ in range(4):‖turtle.fd(length / 3)‖1
turtle.fd(length / 3)‖turtle.right(90)‖1
turtle.right(90)‖turtle.fd(length / 3)‖1
turtle.fd(length / 3)‖turtle.left(90)‖2
turtle.left(90)‖turtle.fd(length / 3)‖1
turtle.left(90)‖turtle.end_fill()‖1
def draw_fractal_recursive(x: float, y: float, length: float, depth: float):‖if depth == 0:‖1
if depth == 0:‖draw_cross(x, y, length)‖1
draw_cross(x, y, length)‖return‖1
draw_fractal_recursive(x, y, length / 3, depth - 1)‖draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)‖1
draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)‖draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)‖1
draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)‖draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)‖1
draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)‖draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)‖1
def set_color(rgb: str):‖turtle.color(rgb)‖1
"def draw_vicsek_fractal(x: float, y: float, length: float, depth: float, color=""blue""):"‖turtle.speed(0)‖1
turtle.speed(0)‖turtle.hideturtle()‖1
turtle.hideturtle()‖set_color(color)‖1
set_color(color)‖draw_fractal_recursive(x, y, length, depth)‖1
draw_fractal_recursive(x, y, length, depth)‖turtle.Screen().update()‖1
def main():‖draw_vicsek_fractal(0, 0, 800, 4)‖1
def exponential_moving_average(‖stock_prices: Iterator[float], window_size: int‖1
stock_prices: Iterator[float], window_size: int‖) -> Iterator[float]:‖1
if window_size <= 0:‖"raise ValueError(""window_size must be > 0"")"‖1
for i, stock_price in enumerate(stock_prices):‖if i <= window_size:‖1
moving_average = (moving_average + stock_price) * 0.5 if i else stock_price‖else:‖1
moving_average = (alpha * stock_price) + ((1 - alpha) * moving_average)‖yield moving_average‖1
stock_prices = [2.0, 5, 3, 8.2, 6, 9, 10]‖window_size = 3‖1
window_size = 3‖result = tuple(exponential_moving_average(iter(stock_prices), window_size))‖1
result = tuple(exponential_moving_average(iter(stock_prices), window_size))‖"print(f""{stock_prices = }"")"‖1
"print(f""{stock_prices = }"")"‖"print(f""{window_size = }"")"‖1
"print(f""{window_size = }"")"‖"print(f""{result = }"")"‖1
def __init__(self, list_of_points: list[tuple[float, float]]):‖self.list_of_points = list_of_points‖1
def basis_function(self, t: float) -> list[float]:‖"assert 0 <= t <= 1, ""Time t must be between 0 and 1."""‖1
"assert 0 <= t <= 1, ""Time t must be between 0 and 1."""‖output_values: list[float] = []‖1
output_values: list[float] = []‖for i in range(len(self.list_of_points)):‖1
output_values.append(‖comb(self.degree, i) * ((1 - t) ** (self.degree - i)) * (t**i)‖1
comb(self.degree, i) * ((1 - t) ** (self.degree - i)) * (t**i)‖)‖1
assert round(sum(output_values), 5) == 1‖return output_values‖1
basis_function = self.basis_function(t)‖x = 0.0‖1
x = 0.0‖y = 0.0‖1
y = 0.0‖for i in range(len(self.list_of_points)):‖1
x += basis_function[i] * self.list_of_points[i][0]‖y += basis_function[i] * self.list_of_points[i][1]‖1
y += basis_function[i] * self.list_of_points[i][1]‖return (x, y)‖1
def plot_curve(self, step_size: float = 0.01):‖from matplotlib import pyplot as plt‖1
to_plot_x: list[float] = []‖to_plot_y: list[float] = []‖1
t = 0.0‖while t <= 1:‖1
while t <= 1:‖value = self.bezier_curve_function(t)‖1
value = self.bezier_curve_function(t)‖to_plot_x.append(value[0])‖1
to_plot_x.append(value[0])‖to_plot_y.append(value[1])‖1
to_plot_y.append(value[1])‖t += step_size‖1
x = [i[0] for i in self.list_of_points]‖y = [i[1] for i in self.list_of_points]‖1
plt.plot(‖to_plot_x,‖1
to_plot_x,‖to_plot_y,‖1
to_plot_y,‖"color=""blue"","‖1
"color=""blue"","‖"label=""Curve of Degree "" + str(self.degree),"‖1
"label=""Curve of Degree "" + str(self.degree),"‖)‖1
)‖"plt.scatter(x, y, color=""red"", label=""Control Points"")"‖1
"plt.scatter(x, y, color=""red"", label=""Control Points"")"‖plt.legend()‖1
BezierCurve([(1, 2), (3, 5)]).plot_curve()‖BezierCurve([(0, 0), (5, 5), (5, 0)]).plot_curve()‖1
BezierCurve([(0, 0), (5, 5), (5, 0)]).plot_curve()‖BezierCurve([(0, 0), (5, 5), (5, 0), (2.5, -2.5)]).plot_curve()‖1
def evaluate(item: str, main_target: str) -> tuple[str, float]:‖score = len([g for position, g in enumerate(item) if g == main_target[position]])‖1
score = len([g for position, g in enumerate(item) if g == main_target[position]])‖return (item, float(score))‖1
def crossover(parent_1: str, parent_2: str) -> tuple[str, str]:‖random_slice = random.randint(0, len(parent_1) - 1)‖1
random_slice = random.randint(0, len(parent_1) - 1)‖child_1 = parent_1[:random_slice] + parent_2[random_slice:]‖1
child_1 = parent_1[:random_slice] + parent_2[random_slice:]‖child_2 = parent_2[:random_slice] + parent_1[random_slice:]‖1
child_2 = parent_2[:random_slice] + parent_1[random_slice:]‖return (child_1, child_2)‖1
def mutate(child: str, genes: list[str]) -> str:‖child_list = list(child)‖1
child_list = list(child)‖if random.uniform(0, 1) < MUTATION_PROBABILITY:‖1
if random.uniform(0, 1) < MUTATION_PROBABILITY:‖child_list[random.randint(0, len(child)) - 1] = random.choice(genes)‖1
child_list[random.randint(0, len(child)) - 1] = random.choice(genes)‖"return """".join(child_list)"‖1
def select(‖parent_1: tuple[str, float],‖1
parent_1: tuple[str, float],‖population_score: list[tuple[str, float]],‖1
population_score: list[tuple[str, float]],‖genes: list[str],‖1
genes: list[str],‖) -> list[str]:‖1
) -> list[str]:‖pop = []‖1
child_n = int(parent_1[1] * 100) + 1‖child_n = 10 if child_n >= 10 else child_n‖1
child_n = 10 if child_n >= 10 else child_n‖for _ in range(child_n):‖1
for _ in range(child_n):‖parent_2 = population_score[random.randint(0, N_SELECTED)][0]‖1
pop.append(mutate(child_1, genes))‖pop.append(mutate(child_2, genes))‖1
pop.append(mutate(child_2, genes))‖return pop‖1
if N_POPULATION < N_SELECTED:‖"msg = f""{N_POPULATION} must be bigger than {N_SELECTED}"""‖1
"msg = f""{N_POPULATION} must be bigger than {N_SELECTED}"""‖raise ValueError(msg)‖1
not_in_genes_list = sorted({c for c in target if c not in genes})‖if not_in_genes_list:‖1
if not_in_genes_list:‖"msg = f""{not_in_genes_list} is not in genes list, evolution cannot converge"""‖1
"msg = f""{not_in_genes_list} is not in genes list, evolution cannot converge"""‖raise ValueError(msg)‖1
population = []‖for _ in range(N_POPULATION):‖1
for _ in range(N_POPULATION):‖"population.append("""".join([random.choice(genes) for i in range(len(target))]))"‖1
while True:‖generation += 1‖1
generation += 1‖total_population += len(population)‖1
population_score = sorted(population_score, key=lambda x: x[1], reverse=True)‖if population_score[0][0] == target:‖1
if population_score[0][0] == target:‖return (generation, total_population, population_score[0][0])‖1
if debug and generation % 10 == 0:‖print(‖1
print(‖"f""\nGeneration: {generation}"""‖1
"f""\nGeneration: {generation}"""‖"f""\nTotal Population:{total_population}"""‖1
"f""\nTotal Population:{total_population}"""‖"f""\nBest score: {population_score[0][1]}"""‖1
"f""\nBest score: {population_score[0][1]}"""‖"f""\nBest string: {population_score[0][0]}"""‖1
"f""\nBest string: {population_score[0][0]}"""‖)‖1
population_best = population[: int(N_POPULATION / 3)]‖population.clear()‖1
population.clear()‖population.extend(population_best)‖1
population_score = [‖(item, score / len(target)) for item, score in population_score‖1
(item, score / len(target)) for item, score in population_score‖]‖1
for i in range(N_SELECTED):‖population.extend(select(population_score[int(i)], population_score, genes))‖1
if len(population) > N_POPULATION:‖break‖1
"if __name__ == ""__main__"":"‖target_str = (‖1
target_str = (‖"""This is a genetic algorithm to evaluate, combine, evolve, and mutate a string!"""‖1
"""This is a genetic algorithm to evaluate, combine, evolve, and mutate a string!"""‖)‖1
)‖genes_list = list(‖1
genes_list = list(‖""" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm"""‖1
""" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm"""‖"""nopqrstuvwxyz.,;!?+-*#@^'èéòà€ù=)(&%$£/\\"""‖1
"""nopqrstuvwxyz.,;!?+-*#@^'èéòà€ù=)(&%$£/\\"""‖)‖1
)‖generation, population, target = basic(target_str, genes_list)‖1
generation, population, target = basic(target_str, genes_list)‖print(‖1
print(‖"f""\nGeneration: {generation}\nTotal Population: {population}\nTarget: {target}"""‖1
"f""\nGeneration: {generation}\nTotal Population: {population}\nTarget: {target}"""‖)‖1
import time‖from math import sqrt‖1
grid = [‖[0, 0, 0, 0, 0, 0, 0],‖2
[0, 0, 0, 0, 0, 0, 0],‖[0, 1, 0, 0, 0, 0, 0],‖3
[0, 1, 0, 0, 0, 0, 0],‖[0, 0, 0, 0, 0, 0, 0],‖3
[0, 0, 0, 0, 0, 0, 0],‖[0, 0, 1, 0, 0, 0, 0],‖3
[0, 0, 1, 0, 0, 0, 0],‖[1, 0, 1, 0, 0, 0, 0],‖3
[1, 0, 1, 0, 0, 0, 0],‖[0, 0, 0, 0, 0, 0, 0],‖3
[0, 0, 0, 0, 0, 0, 0],‖[0, 0, 0, 0, 1, 0, 0],‖3
[0, 0, 0, 0, 1, 0, 0],‖]‖2
self,‖pos_x: int,‖2
pos_x: int,‖pos_y: int,‖2
pos_y: int,‖goal_x: int,‖2
goal_x: int,‖goal_y: int,‖2
goal_y: int,‖g_cost: int,‖1
g_cost: int,‖parent: Node | None,‖1
parent: Node | None,‖) -> None:‖1
) -> None:‖self.pos_x = pos_x‖1
self.pos_x = pos_x‖self.pos_y = pos_y‖3
self.pos_y = pos_y‖self.pos = (pos_y, pos_x)‖3
self.pos = (pos_y, pos_x)‖self.goal_x = goal_x‖3
self.goal_x = goal_x‖self.goal_y = goal_y‖3
self.goal_y = goal_y‖self.g_cost = g_cost‖2
self.g_cost = g_cost‖self.parent = parent‖2
self.parent = parent‖self.h_cost = self.calculate_heuristic()‖1
self.h_cost = self.calculate_heuristic()‖self.f_cost = self.g_cost + self.h_cost‖1
def calculate_heuristic(self) -> float:‖dy = self.pos_x - self.goal_x‖1
dy = self.pos_x - self.goal_x‖dx = self.pos_y - self.goal_y‖1
dx = self.pos_y - self.goal_y‖if HEURISTIC == 1:‖1
if HEURISTIC == 1:‖return abs(dx) + abs(dy)‖1
return abs(dx) + abs(dy)‖else:‖1
else:‖return sqrt(dy**2 + dx**2)‖1
def __lt__(self, other: Node) -> bool:‖return self.f_cost < other.f_cost‖1
def __init__(self, start: TPosition, goal: TPosition):‖self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)‖1
self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)‖self.target = Node(goal[1], goal[0], goal[1], goal[0], 99999, None)‖2
self.open_nodes = [self.start]‖self.closed_nodes: list[Node] = []‖2
def search(self) -> list[TPosition]:‖while self.open_nodes:‖1
self.open_nodes.sort()‖current_node = self.open_nodes.pop(0)‖2
if current_node.pos == self.target.pos:‖return self.retrace_path(current_node)‖1
self.closed_nodes.append(current_node)‖successors = self.get_successors(current_node)‖2
for child_node in successors:‖if child_node in self.closed_nodes:‖2
if child_node in self.closed_nodes:‖continue‖2
if child_node not in self.open_nodes:‖self.open_nodes.append(child_node)‖2
self.open_nodes.append(child_node)‖else:‖2
if child_node.g_cost < better_node.g_cost:‖self.open_nodes.append(child_node)‖1
else:‖self.open_nodes.append(better_node)‖1
def get_successors(self, parent: Node) -> list[Node]:‖successors = []‖2
successors = []‖for action in delta:‖2
for action in delta:‖pos_x = parent.pos_x + action[1]‖2
pos_x = parent.pos_x + action[1]‖pos_y = parent.pos_y + action[0]‖2
pos_y = parent.pos_y + action[0]‖if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):‖2
if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):‖continue‖2
if grid[pos_y][pos_x] != 0:‖continue‖2
successors.append(‖Node(‖1
Node(‖pos_x,‖2
pos_x,‖pos_y,‖2
pos_y,‖self.target.pos_y,‖1
self.target.pos_y,‖self.target.pos_x,‖1
self.target.pos_x,‖parent.g_cost + 1,‖1
parent.g_cost + 1,‖parent,‖2
parent,‖)‖2
)‖return successors‖2
def retrace_path(self, node: Node | None) -> list[TPosition]:‖current_node = node‖1
current_node = node‖path = []‖3
path = []‖while current_node is not None:‖3
while current_node is not None:‖path.append((current_node.pos_y, current_node.pos_x))‖3
path.append((current_node.pos_y, current_node.pos_x))‖current_node = current_node.parent‖3
current_node = current_node.parent‖path.reverse()‖3
path.reverse()‖return path‖3
def __init__(self, start: TPosition, goal: TPosition) -> None:‖self.fwd_astar = AStar(start, goal)‖1
self.fwd_astar = AStar(start, goal)‖self.bwd_astar = AStar(goal, start)‖1
self.bwd_astar = AStar(goal, start)‖self.reached = False‖1
def search(self) -> list[TPosition]:‖while self.fwd_astar.open_nodes or self.bwd_astar.open_nodes:‖1
while self.fwd_astar.open_nodes or self.bwd_astar.open_nodes:‖self.fwd_astar.open_nodes.sort()‖1
self.fwd_astar.open_nodes.sort()‖self.bwd_astar.open_nodes.sort()‖1
self.bwd_astar.open_nodes.sort()‖current_fwd_node = self.fwd_astar.open_nodes.pop(0)‖1
current_fwd_node = self.fwd_astar.open_nodes.pop(0)‖current_bwd_node = self.bwd_astar.open_nodes.pop(0)‖1
if current_bwd_node.pos == current_fwd_node.pos:‖return self.retrace_bidirectional_path(‖1
return self.retrace_bidirectional_path(‖current_fwd_node, current_bwd_node‖2
current_fwd_node, current_bwd_node‖)‖2
self.fwd_astar.closed_nodes.append(current_fwd_node)‖self.bwd_astar.closed_nodes.append(current_bwd_node)‖1
self.fwd_astar.target = current_bwd_node‖self.bwd_astar.target = current_fwd_node‖1
successors = {‖self.fwd_astar: self.fwd_astar.get_successors(current_fwd_node),‖1
self.fwd_astar: self.fwd_astar.get_successors(current_fwd_node),‖self.bwd_astar: self.bwd_astar.get_successors(current_bwd_node),‖1
self.bwd_astar: self.bwd_astar.get_successors(current_bwd_node),‖}‖1
for astar in [self.fwd_astar, self.bwd_astar]:‖for child_node in successors[astar]:‖1
for child_node in successors[astar]:‖if child_node in astar.closed_nodes:‖1
if child_node in astar.closed_nodes:‖continue‖1
if child_node not in astar.open_nodes:‖astar.open_nodes.append(child_node)‖1
astar.open_nodes.append(child_node)‖else:‖2
better_node = astar.open_nodes.pop(‖astar.open_nodes.index(child_node)‖1
astar.open_nodes.index(child_node)‖)‖1
if child_node.g_cost < better_node.g_cost:‖astar.open_nodes.append(child_node)‖1
else:‖astar.open_nodes.append(better_node)‖1
def retrace_bidirectional_path(‖self, fwd_node: Node, bwd_node: Node‖1
self, fwd_node: Node, bwd_node: Node‖) -> list[TPosition]:‖1
) -> list[TPosition]:‖fwd_path = self.fwd_astar.retrace_path(fwd_node)‖1
fwd_path = self.fwd_astar.retrace_path(fwd_node)‖bwd_path = self.bwd_astar.retrace_path(bwd_node)‖1
bwd_path = self.bwd_astar.retrace_path(bwd_node)‖bwd_path.pop()‖1
bwd_path.pop()‖bwd_path.reverse()‖2
bwd_path.reverse()‖path = fwd_path + bwd_path‖2
path = fwd_path + bwd_path‖return path‖2
init = (0, 0)‖goal = (len(grid) - 1, len(grid[0]) - 1)‖3
goal = (len(grid) - 1, len(grid[0]) - 1)‖for elem in grid:‖3
for elem in grid:‖print(elem)‖4
start_time = time.time()‖a_star = AStar(init, goal)‖1
a_star = AStar(init, goal)‖path = a_star.search()‖1
path = a_star.search()‖end_time = time.time() - start_time‖1
end_time = time.time() - start_time‖"print(f""AStar execution time = {end_time:f} seconds"")"‖1
bd_start_time = time.time()‖bidir_astar = BidirectionalAStar(init, goal)‖1
bidir_astar = BidirectionalAStar(init, goal)‖bd_end_time = time.time() - bd_start_time‖1
bd_end_time = time.time() - bd_start_time‖"print(f""BidirectionalAStar execution time = {bd_end_time:f} seconds"")"‖1
def butterfly_pattern(n: int) -> str:‖result = []‖1
for i in range(1, n):‖"left_stars = ""*"" * i"‖1
"left_stars = ""*"" * i"‖"spaces = "" "" * (2 * (n - i) - 1)"‖2
"spaces = "" "" * (2 * (n - i) - 1)"‖"right_stars = ""*"" * i"‖2
"right_stars = ""*"" * i"‖result.append(left_stars + spaces + right_stars)‖2
for i in range(n - 1, 0, -1):‖"left_stars = ""*"" * i"‖1
"if __name__ == ""__main__"":"‖"n = int(input(""Enter the size of the butterfly pattern: ""))"‖1
"n = int(input(""Enter the size of the butterfly pattern: ""))"‖print(butterfly_pattern(n))‖1
def print_distance(distance: list[float], src):‖"print(f""Vertex\tShortest Distance from vertex {src}"")"‖1
"print(f""Vertex\tShortest Distance from vertex {src}"")"‖for i, d in enumerate(distance):‖1
for i, d in enumerate(distance):‖"print(f""{i}\t\t{d}"")"‖1
def check_negative_cycle(‖graph: list[dict[str, int]], distance: list[float], edge_count: int‖1
graph: list[dict[str, int]], distance: list[float], edge_count: int‖):‖1
):‖for j in range(edge_count):‖1
for j in range(edge_count):‖"u, v, w = (graph[j][k] for k in [""src"", ""dst"", ""weight""])"‖2
"u, v, w = (graph[j][k] for k in [""src"", ""dst"", ""weight""])"‖"if distance[u] != float(""inf"") and distance[u] + w < distance[v]:"‖1
"if distance[u] != float(""inf"") and distance[u] + w < distance[v]:"‖return True‖1
return True‖return False‖1
def bellman_ford(‖graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int‖1
graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int‖) -> list[float]:‖1
) -> list[float]:‖"distance = [float(""inf"")] * vertex_count"‖1
"distance = [float(""inf"")] * vertex_count"‖distance[src] = 0.0‖1
for _ in range(vertex_count - 1):‖for j in range(edge_count):‖1
"if distance[u] != float(""inf"") and distance[u] + w < distance[v]:"‖distance[v] = distance[u] + w‖1
negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)‖if negative_cycle_exists:‖1
if negative_cycle_exists:‖"raise Exception(""Negative cycle found"")"‖1
"V = int(input(""Enter number of vertices: "").strip())"‖"E = int(input(""Enter number of edges: "").strip())"‖2
for i in range(E):‖"print(""Edge "", i + 1)"‖1
"print(""Edge "", i + 1)"‖src, dest, weight = (‖1
src, dest, weight = (‖int(x)‖1
int(x)‖"for x in input(""Enter source, destination, weight: "").strip().split("" "")"‖1
"for x in input(""Enter source, destination, weight: "").strip().split("" "")"‖)‖1
)‖"graph[i] = {""src"": src, ""dst"": dest, ""weight"": weight}"‖1
"source = int(input(""\nEnter shortest path source:"").strip())"‖shortest_distance = bellman_ford(graph, V, E, source)‖1
shortest_distance = bellman_ford(graph, V, E, source)‖print_distance(shortest_distance, 0)‖1
DIRECTIONS = [‖[-1, 0],‖1
[-1, 0],‖[0, -1],‖1
[0, -1],‖[1, 0],‖1
[1, 0],‖[0, 1],‖1
[0, 1],‖]‖1
def search(‖grid: list[list[int]],‖1
grid: list[list[int]],‖init: list[int],‖1
init: list[int],‖goal: list[int],‖1
goal: list[int],‖cost: int,‖1
cost: int,‖heuristic: list[list[int]],‖1
heuristic: list[list[int]],‖) -> tuple[list[list[int]], list[list[int]]]:‖1
) -> tuple[list[list[int]], list[list[int]]]:‖closed = [‖1
closed = [‖[0 for col in range(len(grid[0]))] for row in range(len(grid))‖1
[0 for col in range(len(grid[0]))] for row in range(len(grid))‖]‖2
]‖closed[init[0]][init[1]] = 1‖1
closed[init[0]][init[1]] = 1‖action = [‖1
action = [‖[0 for col in range(len(grid[0]))] for row in range(len(grid))‖1
x = init[0]‖y = init[1]‖1
y = init[1]‖g = 0‖1
g = 0‖f = g + heuristic[x][y]‖1
f = g + heuristic[x][y]‖cell = [[f, g, x, y]]‖1
found = False‖resign = False‖1
while not found and not resign:‖if len(cell) == 0:‖1
if len(cell) == 0:‖"raise ValueError(""Algorithm is unable to find solution"")"‖1
"raise ValueError(""Algorithm is unable to find solution"")"‖else:‖1
else:‖cell.sort()‖1
cell.sort()‖cell.reverse()‖1
cell.reverse()‖next_cell = cell.pop()‖1
next_cell = cell.pop()‖x = next_cell[2]‖1
x = next_cell[2]‖y = next_cell[3]‖1
y = next_cell[3]‖g = next_cell[1]‖1
if x == goal[0] and y == goal[1]:‖found = True‖1
found = True‖else:‖1
else:‖for i in range(len(DIRECTIONS)):‖1
for i in range(len(DIRECTIONS)):‖x2 = x + DIRECTIONS[i][0]‖1
x2 = x + DIRECTIONS[i][0]‖y2 = y + DIRECTIONS[i][1]‖1
y2 = y + DIRECTIONS[i][1]‖if (‖1
if (‖x2 >= 0‖1
x2 >= 0‖and x2 < len(grid)‖1
and x2 < len(grid)‖and y2 >= 0‖1
and y2 >= 0‖and y2 < len(grid[0])‖1
and y2 < len(grid[0])‖and closed[x2][y2] == 0‖1
and closed[x2][y2] == 0‖and grid[x2][y2] == 0‖1
and grid[x2][y2] == 0‖):‖1
):‖g2 = g + cost‖1
g2 = g + cost‖f2 = g2 + heuristic[x2][y2]‖1
f2 = g2 + heuristic[x2][y2]‖cell.append([f2, g2, x2, y2])‖1
cell.append([f2, g2, x2, y2])‖closed[x2][y2] = 1‖1
closed[x2][y2] = 1‖action[x2][y2] = i‖1
action[x2][y2] = i‖invpath = []‖1
invpath = []‖x = goal[0]‖1
x = goal[0]‖y = goal[1]‖1
y = goal[1]‖invpath.append([x, y])‖1
invpath.append([x, y])‖while x != init[0] or y != init[1]:‖1
while x != init[0] or y != init[1]:‖x2 = x - DIRECTIONS[action[x][y]][0]‖1
x2 = x - DIRECTIONS[action[x][y]][0]‖y2 = y - DIRECTIONS[action[x][y]][1]‖1
y2 = y - DIRECTIONS[action[x][y]][1]‖x = x2‖1
x = x2‖y = y2‖1
y = y2‖invpath.append([x, y])‖1
path = []‖for i in range(len(invpath)):‖1
for i in range(len(invpath)):‖path.append(invpath[len(invpath) - 1 - i])‖1
path.append(invpath[len(invpath) - 1 - i])‖return path, action‖1
"if __name__ == ""__main__"":"‖grid = [‖1
grid = [‖[0, 1, 0, 0, 0, 0],‖1
[0, 1, 0, 0, 0, 0],‖[0, 1, 0, 0, 0, 0],‖2
[0, 1, 0, 0, 0, 0],‖[0, 1, 0, 0, 1, 0],‖1
[0, 1, 0, 0, 1, 0],‖[0, 0, 0, 0, 1, 0],‖1
[0, 0, 0, 0, 1, 0],‖]‖1
goal = [len(grid) - 1, len(grid[0]) - 1]‖cost = 1‖1
heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]‖for i in range(len(grid)):‖1
for i in range(len(grid)):‖for j in range(len(grid[0])):‖1
for j in range(len(grid[0])):‖heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])‖1
heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])‖if grid[i][j] == 1:‖1
"print(""ACTION MAP"")"‖for i in range(len(action)):‖1
for i in range(len(action)):‖print(action[i])‖1
for i in range(len(path)):‖print(path[i])‖1
import math‖from dataclasses import dataclass, field‖1
from dataclasses import dataclass, field‖from types import NoneType‖1
from types import NoneType‖from typing import Self‖1
@dataclass‖class Angle:‖1
def __post_init__(self) -> None:‖if not isinstance(self.degrees, (int, float)) or not 0 <= self.degrees <= 360:‖1
if not isinstance(self.degrees, (int, float)) or not 0 <= self.degrees <= 360:‖"raise TypeError(""degrees must be a numeric value between 0 and 360."")"‖1
@dataclass‖class Side:‖1
length: float‖angle: Angle = field(default_factory=Angle)‖1
angle: Angle = field(default_factory=Angle)‖next_side: Side | None = None‖1
def __post_init__(self) -> None:‖if not isinstance(self.length, (int, float)) or self.length <= 0:‖1
if not isinstance(self.length, (int, float)) or self.length <= 0:‖"raise TypeError(""length must be a positive numeric value."")"‖1
"raise TypeError(""length must be a positive numeric value."")"‖if not isinstance(self.angle, Angle):‖1
if not isinstance(self.angle, Angle):‖"raise TypeError(""angle must be an Angle object."")"‖1
"raise TypeError(""angle must be an Angle object."")"‖if not isinstance(self.next_side, (Side, NoneType)):‖1
if not isinstance(self.next_side, (Side, NoneType)):‖"raise TypeError(""next_side must be a Side or None."")"‖1
@dataclass‖class Ellipse:‖1
major_radius: float‖minor_radius: float‖1
@property‖def area(self) -> float:‖1
def area(self) -> float:‖return math.pi * self.major_radius * self.minor_radius‖1
@property‖def perimeter(self) -> float:‖1
def perimeter(self) -> float:‖return math.pi * (self.major_radius + self.minor_radius)‖1
def __init__(self, radius: float) -> None:‖super().__init__(radius, radius)‖1
super().__init__(radius, radius)‖self.radius = radius‖1
def __repr__(self) -> str:‖"return f""Circle(radius={self.radius})"""‖1
@property‖def diameter(self) -> float:‖1
def diameter(self) -> float:‖return self.radius * 2‖1
def max_parts(self, num_cuts: float) -> float:‖if not isinstance(num_cuts, (int, float)) or num_cuts < 0:‖1
if not isinstance(num_cuts, (int, float)) or num_cuts < 0:‖"raise TypeError(""num_cuts must be a positive numeric value."")"‖1
"raise TypeError(""num_cuts must be a positive numeric value."")"‖return (num_cuts + 2 + num_cuts**2) * 0.5‖1
@dataclass‖class Polygon:‖1
def add_side(self, side: Side) -> Self:‖self.sides.append(side)‖1
self.sides.append(side)‖return self‖1
def get_side(self, index: int) -> Side:‖return self.sides[index]‖1
def set_side(self, index: int, side: Side) -> Self:‖self.sides[index] = side‖1
self.sides[index] = side‖return self‖1
def __init__(self, short_side_length: float, long_side_length: float) -> None:‖super().__init__()‖1
super().__init__()‖self.short_side_length = short_side_length‖1
self.short_side_length = short_side_length‖self.long_side_length = long_side_length‖1
self.long_side_length = long_side_length‖self.post_init()‖1
def post_init(self) -> None:‖self.short_side = Side(self.short_side_length)‖1
self.short_side = Side(self.short_side_length)‖self.long_side = Side(self.long_side_length)‖1
self.long_side = Side(self.long_side_length)‖super().add_side(self.short_side)‖1
super().add_side(self.short_side)‖super().add_side(self.long_side)‖1
def perimeter(self) -> float:‖return (self.short_side.length + self.long_side.length) * 2‖1
def area(self) -> float:‖return self.short_side.length * self.long_side.length‖1
@dataclass‖class Square(Rectangle):‖1
def __init__(self, side_length: float) -> None:‖super().__init__(side_length, side_length)‖1
def perimeter(self) -> float:‖return super().perimeter()‖1
def area(self) -> float:‖return super().area()‖1
"if __name__ == ""__main__"":"‖"__import__(""doctest"").testmod()"‖5
AXIS_B = 6356752.314245‖RADIUS = 6378137‖1
flattening = (AXIS_A - AXIS_B) / AXIS_A‖phi_1 = atan((1 - flattening) * tan(radians(lat1)))‖1
phi_1 = atan((1 - flattening) * tan(radians(lat1)))‖phi_2 = atan((1 - flattening) * tan(radians(lat2)))‖1
phi_2 = atan((1 - flattening) * tan(radians(lat2)))‖lambda_1 = radians(lon1)‖1
lambda_1 = radians(lon1)‖lambda_2 = radians(lon2)‖1
sin_sq_phi = sin((phi_2 - phi_1) / 2)‖sin_sq_lambda = sin((lambda_2 - lambda_1) / 2)‖1
sin_sq_phi *= sin_sq_phi‖sin_sq_lambda *= sin_sq_lambda‖1
sin_sq_lambda *= sin_sq_lambda‖h_value = sqrt(sin_sq_phi + (cos(phi_1) * cos(phi_2) * sin_sq_lambda))‖1
h_value = sqrt(sin_sq_phi + (cos(phi_1) * cos(phi_2) * sin_sq_lambda))‖return 2 * RADIUS * asin(h_value)‖1
def digital_differential_analyzer_line(‖p1: tuple[int, int], p2: tuple[int, int]‖1
p1: tuple[int, int], p2: tuple[int, int]‖) -> list[tuple[int, int]]:‖1
) -> list[tuple[int, int]]:‖x1, y1 = p1‖1
x1, y1 = p1‖x2, y2 = p2‖1
x2, y2 = p2‖dx = x2 - x1‖1
dx = x2 - x1‖dy = y2 - y1‖1
dy = y2 - y1‖steps = max(abs(dx), abs(dy))‖1
steps = max(abs(dx), abs(dy))‖x_increment = dx / float(steps)‖1
x_increment = dx / float(steps)‖y_increment = dy / float(steps)‖1
y_increment = dy / float(steps)‖coordinates = []‖1
coordinates = []‖x: float = x1‖1
x: float = x1‖y: float = y1‖1
y: float = y1‖for _ in range(steps):‖1
for _ in range(steps):‖x += x_increment‖1
x += x_increment‖y += y_increment‖1
y += y_increment‖coordinates.append((int(round(x)), int(round(y))))‖1
coordinates.append((int(round(x)), int(round(y))))‖return coordinates‖1
"x1 = int(input(""Enter the x-coordinate of the starting point: ""))"‖"y1 = int(input(""Enter the y-coordinate of the starting point: ""))"‖1
"y1 = int(input(""Enter the y-coordinate of the starting point: ""))"‖"x2 = int(input(""Enter the x-coordinate of the ending point: ""))"‖1
"x2 = int(input(""Enter the x-coordinate of the ending point: ""))"‖"y2 = int(input(""Enter the y-coordinate of the ending point: ""))"‖1
"y2 = int(input(""Enter the y-coordinate of the ending point: ""))"‖coordinates = digital_differential_analyzer_line((x1, y1), (x2, y2))‖1
coordinates = digital_differential_analyzer_line((x1, y1), (x2, y2))‖x_points, y_points = zip(*coordinates)‖1
x_points, y_points = zip(*coordinates)‖"plt.plot(x_points, y_points, marker=""o"")"‖1
"plt.plot(x_points, y_points, marker=""o"")"‖"plt.title(""Digital Differential Analyzer Line Drawing Algorithm"")"‖1
"plt.title(""Digital Differential Analyzer Line Drawing Algorithm"")"‖"plt.xlabel(""X-axis"")"‖1
"plt.xlabel(""X-axis"")"‖"plt.ylabel(""Y-axis"")"‖1
"plt.ylabel(""Y-axis"")"‖plt.grid()‖1
plt.grid()‖plt.show()‖1
class Node:‖def __init__(‖1
def __init__(‖self, pos_x: int, pos_y: int, goal_x: int, goal_y: int, parent: Node | None‖1
self, pos_x: int, pos_y: int, goal_x: int, goal_y: int, parent: Node | None‖):‖1
):‖self.pos_x = pos_x‖2
self.goal_y = goal_y‖self.parent = parent‖1
def __init__(self, start: tuple[int, int], goal: tuple[int, int]):‖self.start = Node(start[1], start[0], goal[1], goal[0], None)‖1
self.start = Node(start[1], start[0], goal[1], goal[0], None)‖self.target = Node(goal[1], goal[0], goal[1], goal[0], None)‖1
self.node_queue = [self.start]‖self.reached = False‖1
def search(self) -> Path | None:‖while self.node_queue:‖1
while self.node_queue:‖current_node = self.node_queue.pop(0)‖1
if current_node.pos == self.target.pos:‖self.reached = True‖2
self.reached = True‖return self.retrace_path(current_node)‖2
for node in successors:‖self.node_queue.append(node)‖1
if not self.reached:‖return [self.start.pos]‖2
return [self.start.pos]‖return None‖2
successors.append(‖Node(pos_x, pos_y, self.target.pos_y, self.target.pos_x, parent)‖1
Node(pos_x, pos_y, self.target.pos_y, self.target.pos_x, parent)‖)‖1
def retrace_path(self, node: Node | None) -> Path:‖current_node = node‖2
def __init__(self, start, goal):‖self.fwd_bfs = BreadthFirstSearch(start, goal)‖1
self.fwd_bfs = BreadthFirstSearch(start, goal)‖self.bwd_bfs = BreadthFirstSearch(goal, start)‖1
self.bwd_bfs = BreadthFirstSearch(goal, start)‖self.reached = False‖1
def search(self) -> Path | None:‖while self.fwd_bfs.node_queue or self.bwd_bfs.node_queue:‖1
while self.fwd_bfs.node_queue or self.bwd_bfs.node_queue:‖current_fwd_node = self.fwd_bfs.node_queue.pop(0)‖1
current_fwd_node = self.fwd_bfs.node_queue.pop(0)‖current_bwd_node = self.bwd_bfs.node_queue.pop(0)‖1
if current_bwd_node.pos == current_fwd_node.pos:‖self.reached = True‖1
self.reached = True‖return self.retrace_bidirectional_path(‖1
self.fwd_bfs.target = current_bwd_node‖self.bwd_bfs.target = current_fwd_node‖1
successors = {‖self.fwd_bfs: self.fwd_bfs.get_successors(current_fwd_node),‖1
self.fwd_bfs: self.fwd_bfs.get_successors(current_fwd_node),‖self.bwd_bfs: self.bwd_bfs.get_successors(current_bwd_node),‖1
self.bwd_bfs: self.bwd_bfs.get_successors(current_bwd_node),‖}‖1
for bfs in [self.fwd_bfs, self.bwd_bfs]:‖for node in successors[bfs]:‖1
for node in successors[bfs]:‖bfs.node_queue.append(node)‖1
if not self.reached:‖return [self.fwd_bfs.start.pos]‖1
return [self.fwd_bfs.start.pos]‖return None‖1
def retrace_bidirectional_path(self, fwd_node: Node, bwd_node: Node) -> Path:‖fwd_path = self.fwd_bfs.retrace_path(fwd_node)‖1
fwd_path = self.fwd_bfs.retrace_path(fwd_node)‖bwd_path = self.bwd_bfs.retrace_path(bwd_node)‖1
bwd_path = self.bwd_bfs.retrace_path(bwd_node)‖bwd_path.pop()‖1
doctest.testmod()‖init = (0, 0)‖1
start_bfs_time = time.time()‖bfs = BreadthFirstSearch(init, goal)‖1
bfs = BreadthFirstSearch(init, goal)‖path = bfs.search()‖1
path = bfs.search()‖bfs_time = time.time() - start_bfs_time‖1
start_bd_bfs_time = time.time()‖bd_bfs = BidirectionalBreadthFirstSearch(init, goal)‖1
bd_bfs = BidirectionalBreadthFirstSearch(init, goal)‖bd_path = bd_bfs.search()‖1
bd_path = bd_bfs.search()‖bd_bfs_time = time.time() - start_bd_bfs_time‖1
"__version__ = ""2020.9.26"""‖"__author__ = ""xcodz-dot, cclaus, dhruvmanila"""‖1
def convert_to_2d(‖x: float, y: float, z: float, scale: float, distance: float‖1
x: float, y: float, z: float, scale: float, distance: float‖) -> tuple[float, float]:‖1
) -> tuple[float, float]:‖if not all(isinstance(val, (float, int)) for val in locals().values()):‖1
if not all(isinstance(val, (float, int)) for val in locals().values()):‖"msg = f""Input values must either be float or int: {list(locals().values())}"""‖1
"msg = f""Input values must either be float or int: {list(locals().values())}"""‖raise TypeError(msg)‖1
raise TypeError(msg)‖projected_x = ((x * distance) / (z + distance)) * scale‖1
projected_x = ((x * distance) / (z + distance)) * scale‖projected_y = ((y * distance) / (z + distance)) * scale‖1
projected_y = ((y * distance) / (z + distance)) * scale‖return projected_x, projected_y‖1
def rotate(‖x: float, y: float, z: float, axis: str, angle: float‖1
x: float, y: float, z: float, axis: str, angle: float‖) -> tuple[float, float, float]:‖1
) -> tuple[float, float, float]:‖if not isinstance(axis, str):‖1
if not isinstance(axis, str):‖"raise TypeError(""Axis must be a str"")"‖1
"raise TypeError(""Axis must be a str"")"‖input_variables = locals()‖1
input_variables = locals()‖"del input_variables[""axis""]"‖1
"del input_variables[""axis""]"‖if not all(isinstance(val, (float, int)) for val in input_variables.values()):‖1
if not all(isinstance(val, (float, int)) for val in input_variables.values()):‖msg = (‖1
msg = (‖"""Input values except axis must either be float or int: """‖1
"""Input values except axis must either be float or int: """‖"f""{list(input_variables.values())}"""‖1
"f""{list(input_variables.values())}"""‖)‖1
raise TypeError(msg)‖angle = (angle % 360) / 450 * 180 / math.pi‖1
angle = (angle % 360) / 450 * 180 / math.pi‖"if axis == ""z"":"‖1
"if axis == ""z"":"‖new_x = x * math.cos(angle) - y * math.sin(angle)‖1
new_x = x * math.cos(angle) - y * math.sin(angle)‖new_y = y * math.cos(angle) + x * math.sin(angle)‖1
new_y = y * math.cos(angle) + x * math.sin(angle)‖new_z = z‖1
new_z = z‖"elif axis == ""x"":"‖1
"elif axis == ""x"":"‖new_y = y * math.cos(angle) - z * math.sin(angle)‖1
new_y = y * math.cos(angle) - z * math.sin(angle)‖new_z = z * math.cos(angle) + y * math.sin(angle)‖1
new_z = z * math.cos(angle) + y * math.sin(angle)‖new_x = x‖1
new_x = x‖"elif axis == ""y"":"‖1
"elif axis == ""y"":"‖new_x = x * math.cos(angle) - z * math.sin(angle)‖1
new_x = x * math.cos(angle) - z * math.sin(angle)‖new_z = z * math.cos(angle) + x * math.sin(angle)‖1
new_z = z * math.cos(angle) + x * math.sin(angle)‖new_y = y‖1
new_y = y‖else:‖1
else:‖"raise ValueError(""not a valid axis, choose one of 'x', 'y', 'z'"")"‖1
doctest.testmod()‖"print(f""{convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0) = }"")"‖1
"print(f""{convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0) = }"")"‖"print(f""{rotate(1.0, 2.0, 3.0, 'y', 90.0) = }"")"‖1
def compute_ap(graph):‖n = len(graph)‖1
n = len(graph)‖out_edge_count = 0‖1
out_edge_count = 0‖low = [0] * n‖1
low = [0] * n‖visited = [False] * n‖2
visited = [False] * n‖is_art = [False] * n‖1
def dfs(root, at, parent, out_edge_count):‖if parent == root:‖1
if parent == root:‖out_edge_count += 1‖1
out_edge_count += 1‖visited[at] = True‖1
visited[at] = True‖low[at] = at‖1
for to in graph[at]:‖if to == parent:‖2
if to == parent:‖pass‖2
pass‖elif not visited[to]:‖2
elif not visited[to]:‖out_edge_count = dfs(root, to, at, out_edge_count)‖1
out_edge_count = dfs(root, to, at, out_edge_count)‖low[at] = min(low[at], low[to])‖1
if at < low[to]:‖is_art[at] = True‖1
if at == low[to]:‖is_art[at] = True‖1
is_art[at] = True‖else:‖1
else:‖low[at] = min(low[at], to)‖1
low[at] = min(low[at], to)‖return out_edge_count‖1
for i in range(n):‖if not visited[i]:‖2
if not visited[i]:‖out_edge_count = 0‖1
out_edge_count = 0‖out_edge_count = dfs(i, i, -1, out_edge_count)‖1
out_edge_count = dfs(i, i, -1, out_edge_count)‖is_art[i] = out_edge_count > 1‖1
for x in range(len(is_art)):‖if is_art[x] is True:‖1
if is_art[x] is True:‖print(x)‖1
graph = {‖0: [1, 2],‖1
0: [1, 2],‖1: [0, 2],‖2
1: [0, 2],‖2: [0, 1, 3, 5],‖2
2: [0, 1, 3, 5],‖3: [2, 4],‖2
3: [2, 4],‖4: [3],‖2
4: [3],‖5: [2, 6, 8],‖2
5: [2, 6, 8],‖6: [5, 7],‖2
6: [5, 7],‖7: [6, 8],‖2
7: [6, 8],‖8: [5, 7],‖2
8: [5, 7],‖}‖1
}‖compute_ap(graph)‖1
graph = {‖"""A"": [""B"", ""C"", ""E""],"‖1
"""A"": [""B"", ""C"", ""E""],"‖"""B"": [""A"", ""D"", ""E""],"‖2
"""B"": [""A"", ""D"", ""E""],"‖"""C"": [""A"", ""F"", ""G""],"‖2
"""C"": [""A"", ""F"", ""G""],"‖"""D"": [""B""],"‖2
"""D"": [""B""],"‖"""E"": [""A"", ""B"", ""D""],"‖2
"""E"": [""A"", ""B"", ""D""],"‖"""F"": [""C""],"‖2
"""F"": [""C""],"‖"""G"": [""C""],"‖2
"""G"": [""C""],"‖}‖2
class Graph:‖def __init__(self, graph: dict[str, list[str]], source_vertex: str) -> None:‖1
def __init__(self, graph: dict[str, list[str]], source_vertex: str) -> None:‖self.graph = graph‖1
self.parent: dict[str, str | None] = {}‖self.source_vertex = source_vertex‖1
def breath_first_search(self) -> None:‖visited = {self.source_vertex}‖1
visited = {self.source_vertex}‖self.parent[self.source_vertex] = None‖1
self.parent[self.source_vertex] = None‖queue = [self.source_vertex]‖1
while queue:‖vertex = queue.pop(0)‖3
vertex = queue.pop(0)‖for adjacent_vertex in self.graph[vertex]:‖1
for adjacent_vertex in self.graph[vertex]:‖if adjacent_vertex not in visited:‖1
if adjacent_vertex not in visited:‖visited.add(adjacent_vertex)‖1
visited.add(adjacent_vertex)‖self.parent[adjacent_vertex] = vertex‖1
self.parent[adjacent_vertex] = vertex‖queue.append(adjacent_vertex)‖1
def shortest_path(self, target_vertex: str) -> str:‖if target_vertex == self.source_vertex:‖1
if target_vertex == self.source_vertex:‖return self.source_vertex‖1
target_vertex_parent = self.parent.get(target_vertex)‖if target_vertex_parent is None:‖1
if target_vertex_parent is None:‖msg = (‖1
msg = (‖"f""No path from vertex: {self.source_vertex} to vertex: {target_vertex}"""‖1
"f""No path from vertex: {self.source_vertex} to vertex: {target_vertex}"""‖)‖1
"if __name__ == ""__main__"":"‖"g = Graph(graph, ""G"")"‖1
"g = Graph(graph, ""G"")"‖g.breath_first_search()‖1
g.breath_first_search()‖"print(g.shortest_path(""D""))"‖1
"print(g.shortest_path(""D""))"‖"print(g.shortest_path(""G""))"‖1
"print(g.shortest_path(""G""))"‖"print(g.shortest_path(""Foo""))"‖1
def depth_first_search(node: int, color: int) -> bool:‖if visited[node] == -1:‖1
if visited[node] == -1:‖visited[node] = color‖1
visited[node] = color‖for neighbor in graph[node]:‖1
for neighbor in graph[node]:‖if not depth_first_search(neighbor, 1 - color):‖1
if not depth_first_search(neighbor, 1 - color):‖return False‖1
return False‖return visited[node] == color‖1
visited: defaultdict[int, int] = defaultdict(lambda: -1)‖for node in graph:‖2
for node in graph:‖if visited[node] == -1 and not depth_first_search(node, 0):‖1
if visited[node] == -1 and not depth_first_search(node, 0):‖return False‖1
def is_bipartite_bfs(graph: defaultdict[int, list[int]]) -> bool:‖visited: defaultdict[int, int] = defaultdict(lambda: -1)‖1
for node in graph:‖if visited[node] == -1:‖1
if visited[node] == -1:‖queue: deque[int] = deque()‖1
queue: deque[int] = deque()‖queue.append(node)‖1
queue.append(node)‖visited[node] = 0‖1
visited[node] = 0‖while queue:‖1
while queue:‖curr_node = queue.popleft()‖1
curr_node = queue.popleft()‖for neighbor in graph[curr_node]:‖1
for neighbor in graph[curr_node]:‖if visited[neighbor] == -1:‖1
if visited[neighbor] == -1:‖visited[neighbor] = 1 - visited[curr_node]‖1
visited[neighbor] = 1 - visited[curr_node]‖queue.append(neighbor)‖1
queue.append(neighbor)‖elif visited[neighbor] == visited[curr_node]:‖1
elif visited[neighbor] == visited[curr_node]:‖return False‖1
"if __name__ == ""__main"":"‖import doctest‖1
result = doctest.testmod()‖if result.failed:‖1
if result.failed:‖"print(f""{result.failed} test(s) failed."")"‖1
"print(f""{result.failed} test(s) failed."")"‖else:‖1
else:‖"print(""All tests passed!"")"‖1
from collections import deque‖from queue import Queue‖1
from queue import Queue‖from timeit import timeit‖1
G = {‖"""A"": [""B"", ""C""],"‖1
"""A"": [""B"", ""C""],"‖"""B"": [""A"", ""D"", ""E""],"‖1
"""B"": [""A"", ""D"", ""E""],"‖"""C"": [""A"", ""F""],"‖2
"""C"": [""A"", ""F""],"‖"""D"": [""B""],"‖1
"""D"": [""B""],"‖"""E"": [""B"", ""F""],"‖1
"""E"": [""B"", ""F""],"‖"""F"": [""C"", ""E""],"‖1
"""F"": [""C"", ""E""],"‖}‖1
def breadth_first_search(graph: dict, start: str) -> list[str]:‖explored = {start}‖1
explored = {start}‖result = [start]‖1
result = [start]‖queue: Queue = Queue()‖1
queue: Queue = Queue()‖queue.put(start)‖1
queue.put(start)‖while not queue.empty():‖1
while not queue.empty():‖v = queue.get()‖1
v = queue.get()‖for w in graph[v]:‖1
for w in graph[v]:‖if w not in explored:‖1
if w not in explored:‖explored.add(w)‖1
explored.add(w)‖result.append(w)‖1
result.append(w)‖queue.put(w)‖1
queue.put(w)‖return result‖1
def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:‖visited = {start}‖1
visited = {start}‖result = [start]‖1
result = [start]‖queue = deque([start])‖1
queue = deque([start])‖while queue:‖1
while queue:‖v = queue.popleft()‖1
v = queue.popleft()‖for child in graph[v]:‖1
for child in graph[v]:‖if child not in visited:‖1
if child not in visited:‖visited.add(child)‖1
visited.add(child)‖result.append(child)‖1
result.append(child)‖queue.append(child)‖1
queue.append(child)‖return result‖1
def benchmark_function(name: str) -> None:‖"setup = f""from __main__ import G, {name}"""‖1
"setup = f""from __main__ import G, {name}"""‖number = 10000‖1
number = 10000‖"res = timeit(f""{name}(G, 'A')"", setup=setup, number=number)"‖1
"res = timeit(f""{name}(G, 'A')"", setup=setup, number=number)"‖"print(f""{name:<35} finished {number} runs in {res:.5f} seconds"")"‖1
"benchmark_function(""breadth_first_search"")"‖"benchmark_function(""breadth_first_search_with_deque"")"‖1
class Graph:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self.vertices: dict[int, list[int]] = {}‖1
def print_graph(self) -> None:‖for i in self.vertices:‖1
for i in self.vertices:‖"print(i, "" : "", "" -> "".join([str(j) for j in self.vertices[i]]))"‖1
def add_edge(self, from_vertex: int, to_vertex: int) -> None:‖if from_vertex in self.vertices:‖1
if from_vertex in self.vertices:‖self.vertices[from_vertex].append(to_vertex)‖1
self.vertices[from_vertex].append(to_vertex)‖else:‖1
else:‖self.vertices[from_vertex] = [to_vertex]‖1
visited.add(start_vertex)‖queue.put(start_vertex)‖1
while not queue.empty():‖vertex = queue.get()‖1
for adjacent_vertex in self.vertices[vertex]:‖if adjacent_vertex not in visited:‖1
if adjacent_vertex not in visited:‖queue.put(adjacent_vertex)‖1
queue.put(adjacent_vertex)‖visited.add(adjacent_vertex)‖1
visited.add(adjacent_vertex)‖return visited‖1
g = Graph()‖g.add_edge(0, 1)‖2
g.add_edge(0, 1)‖g.add_edge(0, 2)‖2
g.add_edge(0, 2)‖g.add_edge(1, 2)‖2
g.add_edge(1, 2)‖g.add_edge(2, 0)‖2
g.add_edge(2, 0)‖g.add_edge(2, 3)‖2
g.add_edge(2, 3)‖g.add_edge(3, 3)‖2
def depth_first_search(graph: dict, start: str) -> set[str]:‖explored, stack = set(start), [start]‖1
while stack:‖v = stack.pop()‖1
v = stack.pop()‖explored.add(v)‖1
for adj in reversed(graph[v]):‖if adj not in explored:‖1
if adj not in explored:‖stack.append(adj)‖1
stack.append(adj)‖return explored‖1
G = {‖"""A"": [""B"", ""C"", ""D""],"‖1
"""A"": [""B"", ""C"", ""D""],"‖"""B"": [""A"", ""D"", ""E""],"‖1
"""C"": [""A"", ""F""],"‖"""D"": [""B"", ""D""],"‖1
"""D"": [""B"", ""D""],"‖"""E"": [""B"", ""F""],"‖1
"""E"": [""B"", ""F""],"‖"""F"": [""C"", ""E"", ""G""],"‖1
"""F"": [""C"", ""E"", ""G""],"‖"""G"": [""F""],"‖1
"""G"": [""F""],"‖}‖1
doctest.testmod()‖"print(depth_first_search(G, ""A""))"‖1
rec_stk: set[int] = set()‖return any(‖1
return any(‖node not in visited and depth_first_search(graph, node, visited, rec_stk)‖1
node not in visited and depth_first_search(graph, node, visited, rec_stk)‖for node in graph‖1
for node in graph‖)‖1
visited.add(vertex)‖rec_stk.add(vertex)‖1
for node in graph[vertex]:‖if node not in visited:‖1
if node not in visited:‖if depth_first_search(graph, node, visited, rec_stk):‖1
if depth_first_search(graph, node, visited, rec_stk):‖return True‖1
return True‖elif node in rec_stk:‖1
elif node in rec_stk:‖return True‖1
rec_stk.remove(vertex)‖return False‖1
demo_graph = {‖"""A"": [""B"", ""C"", ""E""],"‖1
if start == goal:‖return [start]‖1
node = path[-1]‖if node not in explored:‖1
if node not in explored:‖neighbours = graph[node]‖1
for neighbour in neighbours:‖new_path = list(path)‖1
new_path = list(path)‖new_path.append(neighbour)‖1
new_path.append(neighbour)‖queue.append(new_path)‖1
if neighbour == goal:‖return new_path‖1
def bfs_shortest_path_distance(graph: dict, start, target) -> int:‖if not graph or start not in graph or target not in graph:‖1
if not graph or start not in graph or target not in graph:‖return -1‖1
return -1‖if start == target:‖1
if start == target:‖return 0‖1
return 0‖queue = [start]‖1
queue = [start]‖visited = set(start)‖1
dist = {start: 0, target: -1}‖while queue:‖1
while queue:‖node = queue.pop(0)‖1
node = queue.pop(0)‖if node == target:‖1
if node == target:‖dist[target] = (‖1
dist[target] = (‖dist[node] if dist[target] == -1 else min(dist[target], dist[node])‖1
dist[node] if dist[target] == -1 else min(dist[target], dist[node])‖)‖1
)‖for adjacent in graph[node]:‖1
for adjacent in graph[node]:‖if adjacent not in visited:‖1
if adjacent not in visited:‖visited.add(adjacent)‖1
visited.add(adjacent)‖queue.append(adjacent)‖1
queue.append(adjacent)‖dist[adjacent] = dist[node] + 1‖1
dist[adjacent] = dist[node] + 1‖return dist[target]‖1
"if __name__ == ""__main__"":"‖"print(bfs_shortest_path(demo_graph, ""G"", ""D""))"‖1
"print(bfs_shortest_path(demo_graph, ""G"", ""D""))"‖"print(bfs_shortest_path_distance(demo_graph, ""G"", ""D""))"‖1
import copy‖import random‖1
cities = {‖0: [0, 0],‖1
0: [0, 0],‖1: [0, 5],‖1
1: [0, 5],‖2: [3, 8],‖1
2: [3, 8],‖3: [8, 10],‖1
3: [8, 10],‖4: [12, 8],‖1
4: [12, 8],‖5: [12, 4],‖1
5: [12, 4],‖6: [8, 0],‖1
6: [8, 0],‖7: [6, 2],‖1
7: [6, 2],‖}‖1
def main(‖cities: dict[int, list[int]],‖1
cities: dict[int, list[int]],‖ants_num: int,‖1
ants_num: int,‖iterations_num: int,‖1
iterations_num: int,‖pheromone_evaporation: float,‖1
pheromone_evaporation: float,‖alpha: float,‖1
alpha: float,‖beta: float,‖2
beta: float,‖q: float,‖1
q: float,‖) -> tuple[list[int], float]:‖1
cities_num = len(cities)‖pheromone = [[1.0] * cities_num] * cities_num‖1
best_path: list[int] = []‖"best_distance = float(""inf"")"‖1
"best_distance = float(""inf"")"‖for _ in range(iterations_num):‖1
for _ in range(iterations_num):‖ants_route = []‖1
ants_route = []‖for _ in range(ants_num):‖1
for _ in range(ants_num):‖unvisited_cities = copy.deepcopy(cities)‖1
unvisited_cities = copy.deepcopy(cities)‖current_city = {next(iter(cities.keys())): next(iter(cities.values()))}‖1
current_city = {next(iter(cities.keys())): next(iter(cities.values()))}‖del unvisited_cities[next(iter(current_city.keys()))]‖1
del unvisited_cities[next(iter(current_city.keys()))]‖ant_route = [next(iter(current_city.keys()))]‖1
ant_route = [next(iter(current_city.keys()))]‖while unvisited_cities:‖1
while unvisited_cities:‖current_city, unvisited_cities = city_select(‖1
current_city, unvisited_cities = city_select(‖pheromone, current_city, unvisited_cities, alpha, beta‖1
pheromone, current_city, unvisited_cities, alpha, beta‖)‖1
)‖ant_route.append(next(iter(current_city.keys())))‖1
ant_route.append(next(iter(current_city.keys())))‖ant_route.append(0)‖1
ant_route.append(0)‖ants_route.append(ant_route)‖1
pheromone, best_path, best_distance = pheromone_update(‖pheromone,‖1
pheromone,‖cities,‖1
cities,‖pheromone_evaporation,‖1
pheromone_evaporation,‖ants_route,‖1
ants_route,‖q,‖1
q,‖best_path,‖1
best_path,‖best_distance,‖1
best_distance,‖)‖1
)‖return best_path, best_distance‖1
def distance(city1: list[int], city2: list[int]) -> float:‖return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5‖1
def pheromone_update(‖pheromone: list[list[float]],‖1
pheromone: list[list[float]],‖cities: dict[int, list[int]],‖1
cities: dict[int, list[int]],‖pheromone_evaporation: float,‖1
pheromone_evaporation: float,‖ants_route: list[list[int]],‖1
ants_route: list[list[int]],‖q: float,‖1
q: float,‖best_path: list[int],‖1
best_path: list[int],‖best_distance: float,‖1
best_distance: float,‖) -> tuple[list[list[float]], list[int], float]:‖1
) -> tuple[list[list[float]], list[int], float]:‖for a in range(len(cities)):‖1
for a in range(len(cities)):‖for b in range(len(cities)):‖1
for b in range(len(cities)):‖pheromone[a][b] *= pheromone_evaporation‖1
pheromone[a][b] *= pheromone_evaporation‖for ant_route in ants_route:‖1
for ant_route in ants_route:‖total_distance = 0.0‖1
total_distance = 0.0‖for i in range(len(ant_route) - 1):‖1
for i in range(len(ant_route) - 1):‖total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])‖1
total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])‖delta_pheromone = q / total_distance‖1
delta_pheromone = q / total_distance‖for i in range(len(ant_route) - 1):‖1
for i in range(len(ant_route) - 1):‖pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone‖1
pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone‖pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][‖1
pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][‖ant_route[i + 1]‖1
ant_route[i + 1]‖]‖1
if total_distance < best_distance:‖best_path = ant_route‖1
best_path = ant_route‖best_distance = total_distance‖1
def city_select(‖pheromone: list[list[float]],‖1
pheromone: list[list[float]],‖current_city: dict[int, list[int]],‖1
current_city: dict[int, list[int]],‖unvisited_cities: dict[int, list[int]],‖1
unvisited_cities: dict[int, list[int]],‖alpha: float,‖1
beta: float,‖) -> tuple[dict[int, list[int]], dict[int, list[int]]]:‖1
) -> tuple[dict[int, list[int]], dict[int, list[int]]]:‖probabilities = []‖1
probabilities = []‖for city, value in unvisited_cities.items():‖1
for city, value in unvisited_cities.items():‖city_distance = distance(value, next(iter(current_city.values())))‖1
city_distance = distance(value, next(iter(current_city.values())))‖probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (‖1
probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (‖(1 / city_distance) ** beta‖1
(1 / city_distance) ** beta‖)‖1
)‖probabilities.append(probability)‖1
chosen_city_i = random.choices(‖list(unvisited_cities.keys()), weights=probabilities‖1
list(unvisited_cities.keys()), weights=probabilities‖)[0]‖1
)[0]‖chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}‖1
chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}‖del unvisited_cities[next(iter(chosen_city.keys()))]‖1
del unvisited_cities[next(iter(chosen_city.keys()))]‖return chosen_city, unvisited_cities‖1
"if __name__ == ""__main__"":"‖best_path, best_distance = main(‖1
best_path, best_distance = main(‖cities=cities,‖1
cities=cities,‖ants_num=10,‖1
ants_num=10,‖iterations_num=20,‖1
iterations_num=20,‖pheromone_evaporation=0.7,‖1
pheromone_evaporation=0.7,‖alpha=1.0,‖1
alpha=1.0,‖beta=5.0,‖1
beta=5.0,‖q=10,‖1
q=10,‖)‖1
"print(f""{best_path = }"")"‖"print(f""{best_distance = }"")"‖1
from queue import PriorityQueue‖from typing import Any‖1
def pass_and_relaxation(‖graph: dict,‖1
graph: dict,‖v: str,‖1
v: str,‖visited_forward: set,‖1
visited_forward: set,‖visited_backward: set,‖1
visited_backward: set,‖cst_fwd: dict,‖1
cst_fwd: dict,‖cst_bwd: dict,‖1
cst_bwd: dict,‖queue: PriorityQueue,‖1
queue: PriorityQueue,‖parent: dict,‖1
parent: dict,‖shortest_distance: float,‖1
shortest_distance: float,‖) -> float:‖1
) -> float:‖for nxt, d in graph[v]:‖1
for nxt, d in graph[v]:‖if nxt in visited_forward:‖1
if nxt in visited_forward:‖continue‖1
continue‖old_cost_f = cst_fwd.get(nxt, np.inf)‖1
old_cost_f = cst_fwd.get(nxt, np.inf)‖new_cost_f = cst_fwd[v] + d‖1
new_cost_f = cst_fwd[v] + d‖if new_cost_f < old_cost_f:‖1
if new_cost_f < old_cost_f:‖queue.put((new_cost_f, nxt))‖1
queue.put((new_cost_f, nxt))‖cst_fwd[nxt] = new_cost_f‖1
cst_fwd[nxt] = new_cost_f‖parent[nxt] = v‖1
parent[nxt] = v‖if (‖1
if (‖nxt in visited_backward‖1
nxt in visited_backward‖and cst_fwd[v] + d + cst_bwd[nxt] < shortest_distance‖1
and cst_fwd[v] + d + cst_bwd[nxt] < shortest_distance‖):‖1
):‖shortest_distance = cst_fwd[v] + d + cst_bwd[nxt]‖1
shortest_distance = cst_fwd[v] + d + cst_bwd[nxt]‖return shortest_distance‖1
def bidirectional_dij(‖source: str, destination: str, graph_forward: dict, graph_backward: dict‖1
source: str, destination: str, graph_forward: dict, graph_backward: dict‖) -> int:‖1
) -> int:‖shortest_path_distance = -1‖1
visited_forward = set()‖visited_backward = set()‖1
visited_backward = set()‖cst_fwd = {source: 0}‖1
cst_fwd = {source: 0}‖cst_bwd = {destination: 0}‖1
cst_bwd = {destination: 0}‖parent_forward = {source: None}‖1
parent_forward = {source: None}‖parent_backward = {destination: None}‖1
parent_backward = {destination: None}‖queue_forward: PriorityQueue[Any] = PriorityQueue()‖1
queue_forward: PriorityQueue[Any] = PriorityQueue()‖queue_backward: PriorityQueue[Any] = PriorityQueue()‖1
queue_forward.put((0, source))‖queue_backward.put((0, destination))‖1
if source == destination:‖return 0‖1
while not queue_forward.empty() and not queue_backward.empty():‖_, v_fwd = queue_forward.get()‖1
_, v_fwd = queue_forward.get()‖visited_forward.add(v_fwd)‖1
_, v_bwd = queue_backward.get()‖visited_backward.add(v_bwd)‖1
shortest_distance = pass_and_relaxation(‖graph_forward,‖1
graph_forward,‖v_fwd,‖1
v_fwd,‖visited_forward,‖1
visited_forward,‖visited_backward,‖1
visited_backward,‖cst_fwd,‖1
cst_fwd,‖cst_bwd,‖1
cst_bwd,‖queue_forward,‖1
queue_forward,‖parent_forward,‖1
parent_forward,‖shortest_distance,‖1
shortest_distance,‖)‖2
shortest_distance = pass_and_relaxation(‖graph_backward,‖1
graph_backward,‖v_bwd,‖1
v_bwd,‖visited_backward,‖1
visited_backward,‖visited_forward,‖1
visited_forward,‖cst_bwd,‖1
cst_bwd,‖cst_fwd,‖1
cst_fwd,‖queue_backward,‖1
queue_backward,‖parent_backward,‖1
parent_backward,‖shortest_distance,‖1
if cst_fwd[v_fwd] + cst_bwd[v_bwd] >= shortest_distance:‖break‖1
if shortest_distance != np.inf:‖shortest_path_distance = shortest_distance‖1
shortest_path_distance = shortest_distance‖return shortest_path_distance‖1
graph_fwd = {‖"""B"": [[""C"", 1]],"‖1
"""B"": [[""C"", 1]],"‖"""C"": [[""D"", 1]],"‖3
"""C"": [[""D"", 1]],"‖"""D"": [[""F"", 1]],"‖3
"""D"": [[""F"", 1]],"‖"""E"": [[""B"", 1], [""G"", 2]],"‖2
"""E"": [[""B"", 1], [""G"", 2]],"‖"""F"": [],"‖2
"""F"": [],"‖"""G"": [[""F"", 1]],"‖2
"""G"": [[""F"", 1]],"‖}‖2
}‖graph_bwd = {‖1
graph_bwd = {‖"""B"": [[""E"", 1]],"‖1
"""B"": [[""E"", 1]],"‖"""C"": [[""B"", 1]],"‖1
"""C"": [[""B"", 1]],"‖"""D"": [[""C"", 1]],"‖1
"""D"": [[""C"", 1]],"‖"""F"": [[""D"", 1], [""G"", 1]],"‖1
"""F"": [[""D"", 1], [""G"", 1]],"‖"""E"": [[None, np.inf]],"‖1
"""E"": [[None, np.inf]],"‖"""G"": [[""E"", 2]],"‖1
"""G"": [[""E"", 2]],"‖}‖1
class Graph:‖def __init__(self, num_of_nodes: int) -> None:‖1
self.m_num_of_nodes = num_of_nodes‖self.m_edges: list[list[int]] = []‖1
self.m_edges: list[list[int]] = []‖self.m_component: dict[int, int] = {}‖1
if self.m_component[u_node] == u_node:‖return u_node‖1
return u_node‖return self.find_component(self.m_component[u_node])‖1
if self.m_component[u_node] != u_node:‖for k in self.m_component:‖1
for k in self.m_component:‖self.m_component[k] = self.find_component(k)‖1
component_size = []‖mst_weight = 0‖1
for node in range(self.m_num_of_nodes):‖self.m_component.update({node: node})‖1
self.m_component.update({node: node})‖component_size.append(1)‖1
while num_of_components > 1:‖for edge in self.m_edges:‖1
for edge in self.m_edges:‖u, v, w = edge‖1
u_component = self.m_component[u]‖v_component = self.m_component[v]‖2
for component in (u_component, v_component):‖if (‖1
if (‖minimum_weight_edge[component] == -1‖1
minimum_weight_edge[component] == -1‖or minimum_weight_edge[component][2] > w‖1
or minimum_weight_edge[component][2] > w‖):‖1
):‖minimum_weight_edge[component] = [u, v, w]‖1
for edge in minimum_weight_edge:‖if isinstance(edge, list):‖1
if isinstance(edge, list):‖u, v, w = edge‖1
if u_component != v_component:‖mst_weight += w‖1
mst_weight += w‖self.union(component_size, u_component, v_component)‖1
self.union(component_size, u_component, v_component)‖"print(f""Added edge [{u} - {v}]\nAdded weight: {w}\n"")"‖1
"print(f""Added edge [{u} - {v}]\nAdded weight: {w}\n"")"‖num_of_components -= 1‖1
minimum_weight_edge = [-1] * self.m_num_of_nodes‖"print(f""The total weight of the minimal spanning tree is: {mst_weight}"")"‖1
def test_vector() -> None:‖pass‖2
def __init__(self):‖self.cur_size = 0‖1
self.cur_size = 0‖self.array = []‖1
self.array = []‖self.pos = {}‖1
def is_empty(self):‖return self.cur_size == 0‖1
def min_heapify(self, idx):‖lc = self.left(idx)‖1
lc = self.left(idx)‖rc = self.right(idx)‖1
rc = self.right(idx)‖if lc < self.cur_size and self.array(lc)[0] < self.array[idx][0]:‖1
if lc < self.cur_size and self.array(lc)[0] < self.array[idx][0]:‖smallest = lc‖1
smallest = lc‖else:‖1
else:‖smallest = idx‖1
smallest = idx‖if rc < self.cur_size and self.array(rc)[0] < self.array[smallest][0]:‖1
if rc < self.cur_size and self.array(rc)[0] < self.array[smallest][0]:‖smallest = rc‖1
smallest = rc‖if smallest != idx:‖1
if smallest != idx:‖self.swap(idx, smallest)‖1
self.swap(idx, smallest)‖self.min_heapify(smallest)‖1
def insert(self, tup):‖self.pos[tup[1]] = self.cur_size‖1
self.pos[tup[1]] = self.cur_size‖self.cur_size += 1‖1
self.cur_size += 1‖self.array.append((sys.maxsize, tup[1]))‖1
self.array.append((sys.maxsize, tup[1]))‖self.decrease_key((sys.maxsize, tup[1]), tup[0])‖1
def extract_min(self):‖min_node = self.array[0][1]‖1
min_node = self.array[0][1]‖self.array[0] = self.array[self.cur_size - 1]‖1
self.array[0] = self.array[self.cur_size - 1]‖self.cur_size -= 1‖1
self.cur_size -= 1‖self.min_heapify(1)‖1
self.min_heapify(1)‖del self.pos[min_node]‖1
del self.pos[min_node]‖return min_node‖1
def left(self, i):‖return 2 * i + 1‖1
def right(self, i):‖return 2 * i + 2‖1
def par(self, i):‖return math.floor(i / 2)‖1
def swap(self, i, j):‖self.pos[self.array[i][1]] = j‖1
self.pos[self.array[i][1]] = j‖self.pos[self.array[j][1]] = i‖1
self.pos[self.array[j][1]] = i‖temp = self.array[i]‖1
temp = self.array[i]‖self.array[i] = self.array[j]‖1
self.array[i] = self.array[j]‖self.array[j] = temp‖1
def decrease_key(self, tup, new_d):‖idx = self.pos[tup[1]]‖1
self.array[idx] = (new_d, tup[1])‖while idx > 0 and self.array[self.par(idx)][0] > self.array[idx][0]:‖1
while idx > 0 and self.array[self.par(idx)][0] > self.array[idx][0]:‖self.swap(idx, self.par(idx))‖1
self.swap(idx, self.par(idx))‖idx = self.par(idx)‖1
class Graph:‖def __init__(self, num):‖1
def __init__(self, num):‖self.adjList = {}‖1
self.adjList = {}‖self.num_nodes = num‖1
self.dist = [0] * self.num_nodes‖self.par = [-1] * self.num_nodes‖1
if u in self.adjList:‖self.adjList[u].append((v, w))‖1
self.adjList[u].append((v, w))‖else:‖1
else:‖self.adjList[u] = [(v, w)]‖1
if v in self.adjList:‖self.adjList[v].append((u, w))‖1
self.adjList[v].append((u, w))‖else:‖1
else:‖self.adjList[v] = [(u, w)]‖1
def show_graph(self):‖for u in self.adjList:‖1
for u in self.adjList:‖"print(u, ""->"", "" -> "".join(str(f""{v}({w})"") for v, w in self.adjList[u]))"‖1
self.dist[src] = 0‖q = PriorityQueue()‖1
q = PriorityQueue()‖q.insert((0, src))‖1
q.insert((0, src))‖for u in self.adjList:‖1
for u in self.adjList:‖if u != src:‖1
if u != src:‖self.dist[u] = sys.maxsize‖1
self.dist[u] = sys.maxsize‖self.par[u] = -1‖1
while not q.is_empty():‖u = q.extract_min()‖1
for v, w in self.adjList[u]:‖new_dist = self.dist[u] + w‖1
new_dist = self.dist[u] + w‖if self.dist[v] > new_dist:‖1
if self.dist[v] > new_dist:‖if self.dist[v] == sys.maxsize:‖1
if self.dist[v] == sys.maxsize:‖q.insert((new_dist, v))‖1
q.insert((new_dist, v))‖else:‖1
else:‖q.decrease_key((self.dist[v], v), new_dist)‖1
q.decrease_key((self.dist[v], v), new_dist)‖self.dist[v] = new_dist‖1
self.dist[v] = new_dist‖self.par[v] = u‖1
def show_distances(self, src):‖"print(f""Distance from node: {src}"")"‖1
"print(f""Distance from node: {src}"")"‖for u in range(self.num_nodes):‖1
for u in range(self.num_nodes):‖"print(f""Node {u} has distance: {self.dist[u]}"")"‖1
def show_path(self, src, dest):‖path = []‖1
path = []‖cost = 0‖1
cost = 0‖temp = dest‖1
while self.par[temp] != -1:‖path.append(temp)‖1
path.append(temp)‖if temp != src:‖1
if temp != src:‖for v, w in self.adjList[temp]:‖1
for v, w in self.adjList[temp]:‖if v == self.par[temp]:‖1
if v == self.par[temp]:‖cost += w‖1
cost += w‖break‖1
break‖temp = self.par[temp]‖1
temp = self.par[temp]‖path.append(src)‖1
path.append(src)‖path.reverse()‖1
"print(f""----Path to reach {dest} from {src}----"")"‖for u in path:‖1
for u in path:‖"print(f""{u}"", end="" "")"‖1
"print(f""{u}"", end="" "")"‖if u != dest:‖1
if u != dest:‖"print(""-> "", end="""")"‖1
testmod()‖graph = Graph(9)‖1
graph = Graph(9)‖graph.add_edge(0, 1, 4)‖1
graph.add_edge(0, 1, 4)‖graph.add_edge(0, 7, 8)‖1
graph.add_edge(0, 7, 8)‖graph.add_edge(1, 2, 8)‖1
graph.add_edge(1, 2, 8)‖graph.add_edge(1, 7, 11)‖1
graph.add_edge(1, 7, 11)‖graph.add_edge(2, 3, 7)‖1
graph.add_edge(2, 3, 7)‖graph.add_edge(2, 8, 2)‖1
graph.add_edge(2, 8, 2)‖graph.add_edge(2, 5, 4)‖1
graph.add_edge(2, 5, 4)‖graph.add_edge(3, 4, 9)‖1
graph.add_edge(3, 4, 9)‖graph.add_edge(3, 5, 14)‖1
graph.add_edge(3, 5, 14)‖graph.add_edge(4, 5, 10)‖1
graph.add_edge(4, 5, 10)‖graph.add_edge(5, 6, 2)‖1
graph.add_edge(5, 6, 2)‖graph.add_edge(6, 7, 1)‖1
graph.add_edge(6, 7, 1)‖graph.add_edge(6, 8, 6)‖1
graph.add_edge(6, 8, 6)‖graph.add_edge(7, 8, 7)‖1
graph.add_edge(7, 8, 7)‖graph.show_graph()‖1
graph.show_graph()‖graph.dijkstra(0)‖1
graph.dijkstra(0)‖graph.show_path(0, 4)‖1
def print_dist(dist, v):‖"print(""\nVertex Distance"")"‖1
"print(""\nVertex Distance"")"‖for i in range(v):‖1
for i in range(v):‖"if dist[i] != float(""inf""):"‖1
"if dist[i] != float(""inf""):"‖"print(i, ""\t"", int(dist[i]), end=""\t"")"‖1
"print(i, ""\t"", int(dist[i]), end=""\t"")"‖else:‖1
else:‖"print(i, ""\t"", ""INF"", end=""\t"")"‖1
"print(i, ""\t"", ""INF"", end=""\t"")"‖print()‖1
def min_dist(mdist, vset, v):‖"min_val = float(""inf"")"‖1
"min_val = float(""inf"")"‖min_ind = -1‖1
min_ind = -1‖for i in range(v):‖1
for i in range(v):‖if (not vset[i]) and mdist[i] < min_val:‖1
if (not vset[i]) and mdist[i] < min_val:‖min_ind = i‖1
min_ind = i‖min_val = mdist[i]‖1
min_val = mdist[i]‖return min_ind‖1
def dijkstra(graph, v, src):‖"mdist = [float(""inf"") for _ in range(v)]"‖1
"mdist = [float(""inf"") for _ in range(v)]"‖vset = [False for _ in range(v)]‖1
vset = [False for _ in range(v)]‖mdist[src] = 0.0‖1
for _ in range(v - 1):‖u = min_dist(mdist, vset, v)‖1
u = min_dist(mdist, vset, v)‖vset[u] = True‖1
for i in range(v):‖if (‖1
if (‖(not vset[i])‖1
(not vset[i])‖"and graph[u][i] != float(""inf"")"‖1
"and graph[u][i] != float(""inf"")"‖and mdist[u] + graph[u][i] < mdist[i]‖1
and mdist[u] + graph[u][i] < mdist[i]‖):‖1
):‖mdist[i] = mdist[u] + graph[u][i]‖1
"if __name__ == ""__main__"":"‖"V = int(input(""Enter number of vertices: "").strip())"‖1
for i in range(V):‖graph[i][i] = 0.0‖1
for i in range(E):‖"print(""\nEdge "", i + 1)"‖1
"print(""\nEdge "", i + 1)"‖"src = int(input(""Enter source:"").strip())"‖1
"src = int(input(""Enter source:"").strip())"‖"dst = int(input(""Enter destination:"").strip())"‖1
"dst = int(input(""Enter destination:"").strip())"‖"weight = float(input(""Enter weight:"").strip())"‖1
"weight = float(input(""Enter weight:"").strip())"‖graph[src][dst] = weight‖1
"gsrc = int(input(""\nEnter shortest path source:"").strip())"‖dijkstra(graph, V, gsrc)‖1
class Graph:‖def __init__(self):‖2
def __init__(self):‖self.vertex = {}‖1
def print_graph(self) -> None:‖print(self.vertex)‖1
print(self.vertex)‖for i in self.vertex:‖1
for i in self.vertex:‖"print(i, "" -> "", "" -> "".join([str(j) for j in self.vertex[i]]))"‖1
if from_vertex in self.vertex:‖self.vertex[from_vertex].append(to_vertex)‖1
self.vertex[from_vertex].append(to_vertex)‖else:‖1
for i in range(len(self.vertex)):‖if not visited[i]:‖1
if not visited[i]:‖self.dfs_recursive(i, visited)‖1
for i in self.vertex:‖if not visited[i]:‖1
if not visited[i]:‖"print("" "", end="""")"‖1
"print("" "", end="""")"‖self.dfs_recursive(i, visited)‖1
g.print_graph()‖"print(""DFS:"")"‖1
"print(""DFS:"")"‖g.dfs()‖1
from collections import deque‖from collections.abc import Iterator‖1
@dataclass‖class Edge:‖1
destination_vertex: int‖weight: int‖1
def __init__(self, size: int):‖self._graph: list[list[Edge]] = [[] for _ in range(size)]‖1
self._graph: list[list[Edge]] = [[] for _ in range(size)]‖self._size = size‖1
def __getitem__(self, vertex: int) -> Iterator[Edge]:‖return iter(self._graph[vertex])‖1
@property‖def size(self):‖1
def size(self):‖return self._size‖1
def add_edge(self, from_vertex: int, to_vertex: int, weight: int):‖if weight not in (0, 1):‖1
if weight not in (0, 1):‖"raise ValueError(""Edge weight must be either 0 or 1."")"‖1
if to_vertex < 0 or to_vertex >= self.size:‖"raise ValueError(""Vertex indexes must be in [0; size)."")"‖1
def get_shortest_path(self, start_vertex: int, finish_vertex: int) -> int | None:‖queue = deque([start_vertex])‖1
queue = deque([start_vertex])‖distances: list[int | None] = [None] * self.size‖1
distances: list[int | None] = [None] * self.size‖distances[start_vertex] = 0‖1
while queue:‖current_vertex = queue.popleft()‖1
current_vertex = queue.popleft()‖current_distance = distances[current_vertex]‖1
current_distance = distances[current_vertex]‖if current_distance is None:‖1
if current_distance is None:‖continue‖1
for edge in self[current_vertex]:‖new_distance = current_distance + edge.weight‖1
new_distance = current_distance + edge.weight‖dest_vertex_distance = distances[edge.destination_vertex]‖1
dest_vertex_distance = distances[edge.destination_vertex]‖if (‖1
if (‖isinstance(dest_vertex_distance, int)‖1
isinstance(dest_vertex_distance, int)‖and new_distance >= dest_vertex_distance‖1
and new_distance >= dest_vertex_distance‖):‖1
continue‖distances[edge.destination_vertex] = new_distance‖1
distances[edge.destination_vertex] = new_distance‖if edge.weight == 0:‖1
if edge.weight == 0:‖queue.appendleft(edge.destination_vertex)‖1
queue.appendleft(edge.destination_vertex)‖else:‖1
else:‖queue.append(edge.destination_vertex)‖1
if distances[finish_vertex] is None:‖"raise ValueError(""No path from start_vertex to finish_vertex."")"‖1
def dijkstra(‖grid: np.ndarray,‖1
grid: np.ndarray,‖source: tuple[int, int],‖1
source: tuple[int, int],‖destination: tuple[int, int],‖1
destination: tuple[int, int],‖allow_diagonal: bool,‖1
allow_diagonal: bool,‖) -> tuple[float | int, list[tuple[int, int]]]:‖1
) -> tuple[float | int, list[tuple[int, int]]]:‖rows, cols = grid.shape‖1
rows, cols = grid.shape‖dx = [-1, 1, 0, 0]‖1
dx = [-1, 1, 0, 0]‖dy = [0, 0, -1, 1]‖1
dy = [0, 0, -1, 1]‖if allow_diagonal:‖1
if allow_diagonal:‖dx += [-1, -1, 1, 1]‖1
dx += [-1, -1, 1, 1]‖dy += [-1, 1, -1, 1]‖1
queue, visited = [(0, source)], set()‖matrix = np.full((rows, cols), np.inf)‖1
matrix = np.full((rows, cols), np.inf)‖matrix[source] = 0‖1
matrix[source] = 0‖predecessors = np.empty((rows, cols), dtype=object)‖1
predecessors = np.empty((rows, cols), dtype=object)‖predecessors[source] = None‖1
while queue:‖(dist, (x, y)) = heappop(queue)‖1
(dist, (x, y)) = heappop(queue)‖if (x, y) in visited:‖1
if (x, y) in visited:‖continue‖1
continue‖visited.add((x, y))‖1
if (x, y) == destination:‖path = []‖1
path = []‖while (x, y) != source:‖1
while (x, y) != source:‖path.append((x, y))‖1
path.append((x, y))‖x, y = predecessors[x, y]‖1
x, y = predecessors[x, y]‖path.append(source)‖1
path.append(source)‖path.reverse()‖1
path.reverse()‖return float(matrix[destination]), path‖1
for i in range(len(dx)):‖nx, ny = x + dx[i], y + dy[i]‖1
nx, ny = x + dx[i], y + dy[i]‖if 0 <= nx < rows and 0 <= ny < cols:‖1
if 0 <= nx < rows and 0 <= ny < cols:‖next_node = grid[nx][ny]‖1
next_node = grid[nx][ny]‖if next_node == 1 and matrix[nx, ny] > dist + 1:‖1
if next_node == 1 and matrix[nx, ny] > dist + 1:‖heappush(queue, (dist + 1, (nx, ny)))‖1
heappush(queue, (dist + 1, (nx, ny)))‖matrix[nx, ny] = dist + 1‖1
matrix[nx, ny] = dist + 1‖predecessors[nx, ny] = (x, y)‖1
heap = [(0, start)]‖visited = set()‖1
visited = set()‖while heap:‖1
while heap:‖(cost, u) = heapq.heappop(heap)‖1
(cost, u) = heapq.heappop(heap)‖if u in visited:‖1
if u in visited:‖continue‖1
continue‖visited.add(u)‖1
visited.add(u)‖if u == end:‖1
if u == end:‖return cost‖1
return cost‖for v, c in graph[u]:‖1
for v, c in graph[u]:‖if v in visited:‖1
if v in visited:‖continue‖1
continue‖next_item = cost + c‖1
next_item = cost + c‖heapq.heappush(heap, (next_item, v))‖1
heapq.heappush(heap, (next_item, v))‖return -1‖1
G = {‖"""A"": [[""B"", 2], [""C"", 5]],"‖1
"""A"": [[""B"", 2], [""C"", 5]],"‖"""B"": [[""A"", 2], [""D"", 3], [""E"", 1], [""F"", 1]],"‖1
"""B"": [[""A"", 2], [""D"", 3], [""E"", 1], [""F"", 1]],"‖"""C"": [[""A"", 5], [""F"", 3]],"‖1
"""C"": [[""A"", 5], [""F"", 3]],"‖"""D"": [[""B"", 3]],"‖1
"""D"": [[""B"", 3]],"‖"""E"": [[""B"", 4], [""F"", 3]],"‖1
"""E"": [[""B"", 4], [""F"", 3]],"‖"""F"": [[""C"", 3], [""E"", 3]],"‖1
"""F"": [[""C"", 3], [""E"", 3]],"‖}‖1
G2 = {‖"""B"": [[""C"", 1]],"‖1
"""D"": [[""F"", 1]],"‖"""E"": [[""B"", 1], [""F"", 3]],"‖1
"""E"": [[""B"", 1], [""F"", 3]],"‖"""F"": [],"‖1
"""F"": [],"‖}‖1
G3 = {‖"""B"": [[""C"", 1]],"‖1
"short_distance = dijkstra(G, ""E"", ""C"")"‖print(short_distance)‖1
"short_distance = dijkstra(G2, ""E"", ""F"")"‖print(short_distance)‖1
"short_distance = dijkstra(G3, ""E"", ""F"")"‖print(short_distance)‖1
def _input(message):‖"return input(message).strip().split("" "")"‖1
def initialize_unweighted_directed_graph(‖node_count: int, edge_count: int‖1
node_count: int, edge_count: int‖) -> dict[int, list[int]]:‖2
) -> dict[int, list[int]]:‖graph: dict[int, list[int]] = {}‖2
graph: dict[int, list[int]] = {}‖for i in range(node_count):‖2
for i in range(node_count):‖graph[i + 1] = []‖3
for e in range(edge_count):‖"x, y = (int(i) for i in _input(f""Edge {e + 1}: <node1> <node2> ""))"‖2
"x, y = (int(i) for i in _input(f""Edge {e + 1}: <node1> <node2> ""))"‖graph[x].append(y)‖2
graph[x].append(y)‖return graph‖1
def initialize_unweighted_undirected_graph(‖node_count: int, edge_count: int‖1
graph[x].append(y)‖graph[y].append(x)‖1
graph[y].append(x)‖return graph‖1
def initialize_weighted_undirected_graph(‖node_count: int, edge_count: int‖1
node_count: int, edge_count: int‖) -> dict[int, list[tuple[int, int]]]:‖1
) -> dict[int, list[tuple[int, int]]]:‖graph: dict[int, list[tuple[int, int]]] = {}‖1
graph: dict[int, list[tuple[int, int]]] = {}‖for i in range(node_count):‖1
for e in range(edge_count):‖"x, y, w = (int(i) for i in _input(f""Edge {e + 1}: <node1> <node2> <weight> ""))"‖1
"x, y, w = (int(i) for i in _input(f""Edge {e + 1}: <node1> <node2> <weight> ""))"‖graph[x].append((y, w))‖1
graph[x].append((y, w))‖graph[y].append((x, w))‖1
graph[y].append((x, w))‖return graph‖1
"if __name__ == ""__main__"":"‖"n, m = (int(i) for i in _input(""Number of nodes and edges: ""))"‖1
graph_choice = int(‖_input(‖1
_input(‖"""Press 1 or 2 or 3 \n"""‖1
"""Press 1 or 2 or 3 \n"""‖"""1. Unweighted directed \n"""‖1
"""1. Unweighted directed \n"""‖"""2. Unweighted undirected \n"""‖1
"""2. Unweighted undirected \n"""‖"""3. Weighted undirected \n"""‖1
"""3. Weighted undirected \n"""‖)[0]‖1
)[0]‖)‖1
g = {‖1: initialize_unweighted_directed_graph,‖1
1: initialize_unweighted_directed_graph,‖2: initialize_unweighted_undirected_graph,‖1
2: initialize_unweighted_undirected_graph,‖3: initialize_weighted_undirected_graph,‖1
3: initialize_weighted_undirected_graph,‖}[graph_choice](n, m)‖1
vis, _s = {s}, [s]‖print(s)‖1
print(s)‖while _s:‖1
while _s:‖flag = 0‖1
flag = 0‖for i in g[_s[-1]]:‖1
for i in g[_s[-1]]:‖if i not in vis:‖1
if i not in vis:‖_s.append(i)‖1
_s.append(i)‖vis.add(i)‖1
vis.add(i)‖flag = 1‖1
flag = 1‖print(i)‖1
print(i)‖break‖1
break‖if not flag:‖1
if not flag:‖_s.pop()‖1
vis, q = {s}, deque([s])‖print(s)‖1
print(s)‖while q:‖1
while q:‖u = q.popleft()‖1
u = q.popleft()‖for v in g[u]:‖1
for v in g[u]:‖if v not in vis:‖1
if v not in vis:‖vis.add(v)‖1
vis.add(v)‖q.append(v)‖1
q.append(v)‖print(v)‖1
dist, known, path = {s: 0}, set(), {s: 0}‖while True:‖2
while True:‖if len(known) == len(g) - 1:‖2
if len(known) == len(g) - 1:‖break‖2
break‖mini = 100000‖2
mini = 100000‖for key, value in dist:‖1
for key, value in dist:‖if key not in known and value < mini:‖1
if key not in known and value < mini:‖mini = value‖2
mini = value‖u = key‖2
u = key‖known.add(u)‖2
known.add(u)‖for v in g[u]:‖2
for v in g[u]:‖if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):‖1
if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):‖dist[v[0]] = dist[u] + v[1]‖1
dist[v[0]] = dist[u] + v[1]‖path[v[0]] = u‖1
path[v[0]] = u‖for key, value in dist.items():‖1
for key, value in dist.items():‖if key != s:‖1
if key != s:‖print(value)‖1
def topo(g, ind=None, q=None):‖if q is None:‖1
if q is None:‖q = [1]‖1
q = [1]‖if ind is None:‖1
if ind is None:‖ind = [0] * (len(g) + 1)‖1
ind = [0] * (len(g) + 1)‖for u in g:‖1
for u in g:‖for v in g[u]:‖1
for v in g[u]:‖ind[v] += 1‖1
ind[v] += 1‖q = deque()‖1
q = deque()‖for i in g:‖1
for i in g:‖if ind[i] == 0:‖1
if ind[i] == 0:‖q.append(i)‖1
q.append(i)‖if len(q) == 0:‖1
if len(q) == 0:‖return‖1
return‖v = q.popleft()‖1
v = q.popleft()‖print(v)‖1
print(v)‖for w in g[v]:‖1
for w in g[v]:‖ind[w] -= 1‖1
ind[w] -= 1‖if ind[w] == 0:‖1
if ind[w] == 0:‖q.append(w)‖1
q.append(w)‖topo(g, ind, q)‖1
n = int(input().strip())‖a = []‖1
a = []‖for _ in range(n):‖1
for _ in range(n):‖a.append(tuple(map(int, input().strip().split())))‖1
a.append(tuple(map(int, input().strip().split())))‖return a, n‖1
def floy(a_and_n):‖(a, n) = a_and_n‖1
(a, n) = a_and_n‖dist = list(a)‖1
dist = list(a)‖path = [[0] * n for i in range(n)]‖1
path = [[0] * n for i in range(n)]‖for k in range(n):‖1
for k in range(n):‖for i in range(n):‖1
for j in range(n):‖if dist[i][j] > dist[i][k] + dist[k][j]:‖1
if dist[i][j] > dist[i][k] + dist[k][j]:‖dist[i][j] = dist[i][k] + dist[k][j]‖1
dist[i][j] = dist[i][k] + dist[k][j]‖path[i][k] = k‖1
path[i][k] = k‖print(dist)‖1
def prim(g, s):‖dist, known, path = {s: 0}, set(), {s: 0}‖1
mini = 100000‖for key, value in dist.items():‖1
for key, value in dist.items():‖if key not in known and value < mini:‖1
for v in g[u]:‖if v[0] not in known and v[1] < dist.get(v[0], 100000):‖1
if v[0] not in known and v[1] < dist.get(v[0], 100000):‖dist[v[0]] = v[1]‖1
dist[v[0]] = v[1]‖path[v[0]] = u‖1
path[v[0]] = u‖return dist‖1
"n, m = tuple(map(int, input().split("" "")))"‖edges = []‖1
edges = []‖for _ in range(m):‖1
for _ in range(m):‖"edges.append(tuple(map(int, input().split("" ""))))"‖1
"edges.append(tuple(map(int, input().split("" ""))))"‖return edges, n‖1
(e, n) = e_and_n‖e.sort(reverse=True, key=lambda x: x[2])‖1
e.sort(reverse=True, key=lambda x: x[2])‖s = [{i} for i in range(1, n + 1)]‖1
s = [{i} for i in range(1, n + 1)]‖while True:‖1
while True:‖if len(s) == 1:‖1
if len(s) == 1:‖break‖1
break‖print(s)‖1
print(s)‖x = e.pop()‖1
x = e.pop()‖for i in range(len(s)):‖1
for i in range(len(s)):‖if x[0] in s[i]:‖1
if x[0] in s[i]:‖break‖1
break‖for j in range(len(s)):‖1
for j in range(len(s)):‖if x[1] in s[j]:‖1
if x[1] in s[j]:‖if i == j:‖1
if i == j:‖break‖1
break‖s[j].update(s[i])‖1
s[j].update(s[i])‖s.pop(i)‖1
s.pop(i)‖break‖1
isolated = []‖for node in graph:‖1
for node in graph:‖if not graph[node]:‖1
if not graph[node]:‖isolated.append(node)‖1
isolated.append(node)‖return isolated‖1
class Node:‖value: int = 0‖1
value: int = 0‖"neighbors: list[""Node""] | None = None"‖1
def __post_init__(self) -> None:‖self.neighbors = self.neighbors or []‖1
def __hash__(self) -> int:‖return id(self)‖1
def clone_graph(node: Node | None) -> Node | None:‖if not node:‖1
if not node:‖return None‖1
while stack:‖original = stack.pop()‖1
if original in originals_to_clones:‖continue‖1
for original, clone in originals_to_clones.items():‖for neighbor in original.neighbors or []:‖1
for neighbor in original.neighbors or []:‖cloned_neighbor = originals_to_clones[neighbor]‖1
if not clone.neighbors:‖clone.neighbors = []‖1
edge_array = [‖['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12', 'cd-e2', 'ce-e4',‖1
['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12', 'cd-e2', 'ce-e4',‖'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3', 'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3'],‖1
'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3', 'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3'],‖['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'cd-e2', 'de-e1', 'df-e8',‖1
['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'cd-e2', 'de-e1', 'df-e8',‖'ef-e3', 'eg-e2', 'fg-e6'],‖1
'ef-e3', 'eg-e2', 'fg-e6'],‖['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'de-e1', 'df-e8', 'dg-e5', 'ef-e3', 'eg-e2',‖1
['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'de-e1', 'df-e8', 'dg-e5', 'ef-e3', 'eg-e2',‖'eh-e12', 'fg-e6', 'fh-e10', 'gh-e6'],‖1
'eh-e12', 'fg-e6', 'fh-e10', 'gh-e6'],‖['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'bh-e12', 'cd-e2', 'df-e8', 'dh-e10'],‖1
['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'bh-e12', 'cd-e2', 'df-e8', 'dh-e10'],‖['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'cd-e2', 'ce-e4', 'de-e1', 'df-e8',‖1
['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'cd-e2', 'ce-e4', 'de-e1', 'df-e8',‖'dg-e5', 'ef-e3', 'eg-e2', 'fg-e6']‖1
'dg-e5', 'ef-e3', 'eg-e2', 'fg-e6']‖]‖1
def get_distinct_edge(edge_array):‖distinct_edge = set()‖1
distinct_edge = set()‖for row in edge_array:‖1
for row in edge_array:‖for item in row:‖1
for item in row:‖distinct_edge.add(item[0])‖1
distinct_edge.add(item[0])‖return list(distinct_edge)‖1
def get_bitcode(edge_array, distinct_edge):‖"bitcode = [""0""] * len(edge_array)"‖1
"bitcode = [""0""] * len(edge_array)"‖for i, row in enumerate(edge_array):‖1
for i, row in enumerate(edge_array):‖for item in row:‖1
for item in row:‖if distinct_edge in item[0]:‖1
if distinct_edge in item[0]:‖"bitcode[i] = ""1"""‖1
"bitcode[i] = ""1"""‖break‖1
break‖"return """".join(bitcode)"‖1
def get_frequency_table(edge_array):‖distinct_edge = get_distinct_edge(edge_array)‖1
distinct_edge = get_distinct_edge(edge_array)‖frequency_table = {}‖1
for item in distinct_edge:‖bit = get_bitcode(edge_array, item)‖1
"s = bit.count(""1"")"‖frequency_table[item] = [s, bit]‖1
sorted_frequency_table = [‖[k, v[0], v[1]]‖1
[k, v[0], v[1]]‖for k, v in sorted(frequency_table.items(), key=lambda v: v[1][0], reverse=True)‖1
for k, v in sorted(frequency_table.items(), key=lambda v: v[1][0], reverse=True)‖]‖1
]‖return sorted_frequency_table‖1
def get_nodes(frequency_table):‖nodes = {}‖1
nodes = {}‖for _, item in enumerate(frequency_table):‖1
for _, item in enumerate(frequency_table):‖nodes.setdefault(item[2], []).append(item[0])‖1
nodes.setdefault(item[2], []).append(item[0])‖return nodes‖1
def get_cluster(nodes):‖cluster = {}‖1
cluster = {}‖for key, value in nodes.items():‖1
for key, value in nodes.items():‖"cluster.setdefault(key.count(""1""), {})[key] = value"‖1
"cluster.setdefault(key.count(""1""), {})[key] = value"‖return cluster‖1
def get_support(cluster):‖return [i * 100 / len(cluster) for i in cluster]‖1
def print_all() -> None:‖"print(""\nNodes\n"")"‖1
"print(""\nNodes\n"")"‖for key, value in nodes.items():‖1
for key, value in nodes.items():‖print(key, value)‖1
print(key, value)‖"print(""\nSupport\n"")"‖1
"print(""\nSupport\n"")"‖print(support)‖1
print(support)‖"print(""\n Cluster \n"")"‖1
"print(""\n Cluster \n"")"‖for key, value in sorted(cluster.items(), reverse=True):‖1
for key, value in sorted(cluster.items(), reverse=True):‖print(key, value)‖1
print(key, value)‖"print(""\n Graph\n"")"‖1
"print(""\n Graph\n"")"‖for key, value in graph.items():‖1
for key, value in graph.items():‖print(key, value)‖1
print(key, value)‖"print(""\n Edge List of Frequent subgraphs \n"")"‖1
"print(""\n Edge List of Frequent subgraphs \n"")"‖for edge_list in freq_subgraph_edge_list:‖1
for edge_list in freq_subgraph_edge_list:‖print(edge_list)‖1
def create_edge(nodes, graph, cluster, c1):‖for i in cluster[c1]:‖1
for i in cluster[c1]:‖count = 0‖1
count = 0‖c2 = c1 + 1‖1
c2 = c1 + 1‖while c2 < max(cluster.keys()):‖1
while c2 < max(cluster.keys()):‖for j in cluster[c2]:‖1
for j in cluster[c2]:‖if int(i, 2) & int(j, 2) == int(i, 2):‖1
if int(i, 2) & int(j, 2) == int(i, 2):‖if tuple(nodes[i]) in graph:‖1
if tuple(nodes[i]) in graph:‖graph[tuple(nodes[i])].append(nodes[j])‖1
graph[tuple(nodes[i])].append(nodes[j])‖else:‖1
else:‖graph[tuple(nodes[i])] = [nodes[j]]‖1
graph[tuple(nodes[i])] = [nodes[j]]‖count += 1‖1
count += 1‖if count == 0:‖1
if count == 0:‖c2 = c2 + 1‖1
c2 = c2 + 1‖else:‖1
def construct_graph(cluster, nodes):‖x = cluster[max(cluster.keys())]‖1
x = cluster[max(cluster.keys())]‖"cluster[max(cluster.keys()) + 1] = ""Header"""‖1
"cluster[max(cluster.keys()) + 1] = ""Header"""‖graph = {}‖1
graph = {}‖for i in x:‖1
for i in x:‖"if ([""Header""],) in graph:"‖1
"if ([""Header""],) in graph:"‖"graph[([""Header""],)].append(x[i])"‖1
"graph[([""Header""],)].append(x[i])"‖else:‖1
else:‖"graph[([""Header""],)] = [x[i]]"‖1
"graph[([""Header""],)] = [x[i]]"‖for i in x:‖1
for i in x:‖"graph[(x[i],)] = [[""Header""]]"‖1
"graph[(x[i],)] = [[""Header""]]"‖i = 1‖1
i = 1‖while i < max(cluster) - 1:‖1
while i < max(cluster) - 1:‖create_edge(nodes, graph, cluster, i)‖1
create_edge(nodes, graph, cluster, i)‖i = i + 1‖1
i = i + 1‖return graph‖1
def my_dfs(graph, start, end, path=None):‖path = (path or []) + [start]‖1
path = (path or []) + [start]‖if start == end:‖1
if start == end:‖paths.append(path)‖1
paths.append(path)‖for node in graph[start]:‖1
for node in graph[start]:‖if tuple(node) not in path:‖1
if tuple(node) not in path:‖my_dfs(graph, tuple(node), end, path)‖1
def find_freq_subgraph_given_support(s, cluster, graph):‖k = int(s / 100 * (len(cluster) - 1))‖1
k = int(s / 100 * (len(cluster) - 1))‖for i in cluster[k]:‖1
for i in cluster[k]:‖"my_dfs(graph, tuple(cluster[k][i]), ([""Header""],))"‖1
def freq_subgraphs_edge_list(paths):‖freq_sub_el = []‖1
freq_sub_el = []‖for edges in paths:‖1
for edges in paths:‖el = []‖1
el = []‖for j in range(len(edges) - 1):‖1
for j in range(len(edges) - 1):‖temp = list(edges[j])‖1
temp = list(edges[j])‖for e in temp:‖1
for e in temp:‖edge = (e[0], e[1])‖1
edge = (e[0], e[1])‖el.append(edge)‖1
el.append(edge)‖freq_sub_el.append(el)‖1
freq_sub_el.append(el)‖return freq_sub_el‖1
def preprocess(edge_array):‖for i in range(len(edge_array)):‖1
for i in range(len(edge_array)):‖for j in range(len(edge_array[i])):‖1
for j in range(len(edge_array[i])):‖"t = edge_array[i][j].split(""-"")"‖1
"t = edge_array[i][j].split(""-"")"‖edge_array[i][j] = t‖1
"if __name__ == ""__main__"":"‖preprocess(edge_array)‖1
preprocess(edge_array)‖frequency_table = get_frequency_table(edge_array)‖1
frequency_table = get_frequency_table(edge_array)‖nodes = get_nodes(frequency_table)‖1
nodes = get_nodes(frequency_table)‖cluster = get_cluster(nodes)‖1
cluster = get_cluster(nodes)‖support = get_support(cluster)‖1
support = get_support(cluster)‖graph = construct_graph(cluster, nodes)‖1
graph = construct_graph(cluster, nodes)‖find_freq_subgraph_given_support(60, cluster, graph)‖1
find_freq_subgraph_given_support(60, cluster, graph)‖paths: list = []‖1
paths: list = []‖freq_subgraph_edge_list = freq_subgraphs_edge_list(paths)‖1
freq_subgraph_edge_list = freq_subgraphs_edge_list(paths)‖print_all()‖1
class Dinic:‖def __init__(self, n):‖1
def __init__(self, n):‖self.lvl = [0] * n‖1
self.lvl = [0] * n‖self.ptr = [0] * n‖1
self.ptr = [0] * n‖self.q = [0] * n‖1
self.q = [0] * n‖self.adj = [[] for _ in range(n)]‖1
def add_edge(self, a, b, c, rcap=0):‖self.adj[a].append([b, len(self.adj[b]), c, 0])‖1
self.adj[a].append([b, len(self.adj[b]), c, 0])‖self.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])‖1
def depth_first_search(self, vertex, sink, flow):‖if vertex == sink or not flow:‖1
if vertex == sink or not flow:‖return flow‖1
for i in range(self.ptr[vertex], len(self.adj[vertex])):‖e = self.adj[vertex][i]‖1
e = self.adj[vertex][i]‖if self.lvl[e[0]] == self.lvl[vertex] + 1:‖1
if self.lvl[e[0]] == self.lvl[vertex] + 1:‖p = self.depth_first_search(e[0], sink, min(flow, e[2] - e[3]))‖1
p = self.depth_first_search(e[0], sink, min(flow, e[2] - e[3]))‖if p:‖1
if p:‖self.adj[vertex][i][3] += p‖1
self.adj[vertex][i][3] += p‖self.adj[e[0]][e[1]][3] -= p‖1
self.adj[e[0]][e[1]][3] -= p‖return p‖1
return p‖self.ptr[vertex] = self.ptr[vertex] + 1‖1
self.ptr[vertex] = self.ptr[vertex] + 1‖return 0‖1
def max_flow(self, source, sink):‖flow, self.q[0] = 0, source‖1
flow, self.q[0] = 0, source‖for l in range(31):‖1
for l in range(31):‖while True:‖1
while True:‖self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)‖1
self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)‖qi, qe, self.lvl[source] = 0, 1, 1‖1
qi, qe, self.lvl[source] = 0, 1, 1‖while qi < qe and not self.lvl[sink]:‖1
while qi < qe and not self.lvl[sink]:‖v = self.q[qi]‖1
v = self.q[qi]‖qi += 1‖1
qi += 1‖for e in self.adj[v]:‖1
for e in self.adj[v]:‖if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):‖1
if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):‖self.q[qe] = e[0]‖1
self.q[qe] = e[0]‖qe += 1‖1
qe += 1‖self.lvl[e[0]] = self.lvl[v] + 1‖1
p = self.depth_first_search(source, sink, INF)‖while p:‖1
while p:‖flow += p‖1
flow += p‖p = self.depth_first_search(source, sink, INF)‖1
if not self.lvl[sink]:‖break‖1
graph = Dinic(10)‖source = 0‖1
source = 0‖sink = 9‖1
sink = 9‖for vertex in range(1, 5):‖1
for vertex in range(1, 5):‖graph.add_edge(source, vertex, 1)‖1
graph.add_edge(source, vertex, 1)‖for vertex in range(5, 9):‖1
for vertex in range(5, 9):‖graph.add_edge(vertex, sink, 1)‖1
graph.add_edge(vertex, sink, 1)‖for vertex in range(1, 5):‖1
for vertex in range(1, 5):‖graph.add_edge(vertex, vertex + 4, 1)‖1
visited[vert] = True‖connected_verts = []‖1
for neighbour in graph[vert]:‖if not visited[neighbour]:‖2
if not visited[neighbour]:‖connected_verts += dfs(graph, neighbour, visited)‖1
graph_size = len(graph)‖visited = graph_size * [False]‖1
visited = graph_size * [False]‖components_list = []‖1
for i in range(graph_size):‖if not visited[i]:‖1
if not visited[i]:‖i_connected = dfs(graph, i, visited)‖1
i_connected = dfs(graph, i, visited)‖components_list.append(i_connected)‖1
def dfs(u, graph, visited_edge, path=None):‖path = (path or []) + [u]‖1
path = (path or []) + [u]‖for v in graph[u]:‖1
for v in graph[u]:‖if visited_edge[u][v] is False:‖1
if visited_edge[u][v] is False:‖visited_edge[u][v], visited_edge[v][u] = True, True‖1
visited_edge[u][v], visited_edge[v][u] = True, True‖path = dfs(v, graph, visited_edge, path)‖1
path = dfs(v, graph, visited_edge, path)‖return path‖1
def check_circuit_or_path(graph, max_node):‖odd_degree_nodes = 0‖1
odd_degree_nodes = 0‖odd_node = -1‖1
odd_node = -1‖for i in range(max_node):‖1
for i in range(max_node):‖if i not in graph:‖1
if i not in graph:‖continue‖1
continue‖if len(graph[i]) % 2 == 1:‖1
if len(graph[i]) % 2 == 1:‖odd_degree_nodes += 1‖1
odd_degree_nodes += 1‖odd_node = i‖1
odd_node = i‖if odd_degree_nodes == 0:‖1
if odd_degree_nodes == 0:‖return 1, odd_node‖1
return 1, odd_node‖if odd_degree_nodes == 2:‖1
if odd_degree_nodes == 2:‖return 2, odd_node‖1
return 2, odd_node‖return 3, odd_node‖1
def check_euler(graph, max_node):‖visited_edge = [[False for _ in range(max_node + 1)] for _ in range(max_node + 1)]‖1
visited_edge = [[False for _ in range(max_node + 1)] for _ in range(max_node + 1)]‖check, odd_node = check_circuit_or_path(graph, max_node)‖1
check, odd_node = check_circuit_or_path(graph, max_node)‖if check == 3:‖1
if check == 3:‖"print(""graph is not Eulerian"")"‖1
"print(""graph is not Eulerian"")"‖"print(""no path"")"‖1
"print(""no path"")"‖return‖1
return‖start_node = 1‖1
start_node = 1‖if check == 2:‖1
if check == 2:‖start_node = odd_node‖1
start_node = odd_node‖"print(""graph has a Euler path"")"‖1
"print(""graph has a Euler path"")"‖if check == 1:‖1
if check == 1:‖"print(""graph has a Euler cycle"")"‖1
"print(""graph has a Euler cycle"")"‖path = dfs(start_node, graph, visited_edge)‖1
path = dfs(start_node, graph, visited_edge)‖print(path)‖1
def main():‖g1 = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}‖1
g1 = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}‖g2 = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}‖1
g2 = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}‖g3 = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}‖1
g3 = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}‖g4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}‖1
g4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}‖g5 = {‖1
g5 = {‖1: [],‖1
1: [],‖2: [],‖1
}‖max_node = 10‖1
max_node = 10‖check_euler(g1, max_node)‖1
check_euler(g1, max_node)‖check_euler(g2, max_node)‖1
check_euler(g2, max_node)‖check_euler(g3, max_node)‖1
check_euler(g3, max_node)‖check_euler(g4, max_node)‖1
check_euler(g4, max_node)‖check_euler(g5, max_node)‖1
argmax = heapq.heappop(queue)[1][0]‖chosen_vertices.add(argmax)‖1
if elem[0] == 0:‖continue‖1
if argmax in elem[1][1]:‖index = elem[1][1].index(argmax)‖1
index = elem[1][1].index(argmax)‖del elem[1][1][index]‖1
del elem[1][1][index]‖elem[0] += 1‖1
heapq.heapify(queue)‖return chosen_vertices‖1
graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}‖"print(f""Minimum vertex cover:\n{greedy_min_vertex_cover(graph)}"")"‖1
def longest_distance(graph):‖indegree = [0] * len(graph)‖1
indegree = [0] * len(graph)‖queue = []‖2
queue = []‖long_dist = [1] * len(graph)‖1
for values in graph.values():‖for i in values:‖2
for i in values:‖indegree[i] += 1‖2
for i in range(len(indegree)):‖if indegree[i] == 0:‖2
if indegree[i] == 0:‖queue.append(i)‖2
vertex = queue.pop(0)‖for x in graph[vertex]:‖1
for x in graph[vertex]:‖indegree[x] -= 1‖1
if indegree[x] == 0:‖queue.append(x)‖1
graph = {0: [2, 3, 4], 1: [2, 7], 2: [5], 3: [5, 7], 4: [7], 5: [6], 6: [7], 7: []}‖longest_distance(graph)‖1
def _print_dist(dist, v):‖"print(""\nThe shortest path matrix using Floyd Warshall algorithm\n"")"‖1
"print(""\nThe shortest path matrix using Floyd Warshall algorithm\n"")"‖for i in range(v):‖1
for i in range(v):‖for j in range(v):‖2
for j in range(v):‖"if dist[i][j] != float(""inf""):"‖1
"if dist[i][j] != float(""inf""):"‖"print(int(dist[i][j]), end=""\t"")"‖1
"print(int(dist[i][j]), end=""\t"")"‖else:‖1
else:‖"print(""INF"", end=""\t"")"‖1
"print(""INF"", end=""\t"")"‖print()‖1
for j in range(v):‖dist[i][j] = graph[i][j]‖1
for j in range(v):‖if (‖1
if (‖"dist[i][k] != float(""inf"")"‖1
"dist[i][k] != float(""inf"")"‖"and dist[k][j] != float(""inf"")"‖1
"and dist[k][j] != float(""inf"")"‖and dist[i][k] + dist[k][j] < dist[i][j]‖1
and dist[i][k] + dist[k][j] < dist[i][j]‖):‖1
):‖dist[i][j] = dist[i][k] + dist[k][j]‖1
_print_dist(dist, v)‖return dist, v‖1
"if __name__ == ""__main__"":"‖"v = int(input(""Enter number of vertices: ""))"‖1
"v = int(input(""Enter number of vertices: ""))"‖"e = int(input(""Enter number of edges: ""))"‖1
for i in range(v):‖graph[i][i] = 0.0‖1
for i in range(e):‖"print(""\nEdge "", i + 1)"‖1
"print(""\nEdge "", i + 1)"‖"src = int(input(""Enter source:""))"‖1
"src = int(input(""Enter source:""))"‖"dst = int(input(""Enter destination:""))"‖1
"dst = int(input(""Enter destination:""))"‖"weight = float(input(""Enter weight:""))"‖1
"weight = float(input(""Enter weight:""))"‖graph[src][dst] = weight‖1
def stable_matching(‖donor_pref: list[list[int]], recipient_pref: list[list[int]]‖1
donor_pref: list[list[int]], recipient_pref: list[list[int]]‖) -> list[int]:‖1
) -> list[int]:‖assert len(donor_pref) == len(recipient_pref)‖1
n = len(donor_pref)‖unmatched_donors = list(range(n))‖1
unmatched_donors = list(range(n))‖donor_record = [-1] * n‖1
donor_record = [-1] * n‖rec_record = [-1] * n‖1
rec_record = [-1] * n‖num_donations = [0] * n‖1
while unmatched_donors:‖donor = unmatched_donors[0]‖1
donor = unmatched_donors[0]‖donor_preference = donor_pref[donor]‖1
donor_preference = donor_pref[donor]‖recipient = donor_preference[num_donations[donor]]‖1
recipient = donor_preference[num_donations[donor]]‖num_donations[donor] += 1‖1
num_donations[donor] += 1‖rec_preference = recipient_pref[recipient]‖1
rec_preference = recipient_pref[recipient]‖prev_donor = rec_record[recipient]‖1
if prev_donor != -1:‖if rec_preference.index(prev_donor) > rec_preference.index(donor):‖1
if rec_preference.index(prev_donor) > rec_preference.index(donor):‖rec_record[recipient] = donor‖1
rec_record[recipient] = donor‖donor_record[donor] = recipient‖2
donor_record[donor] = recipient‖unmatched_donors.append(prev_donor)‖1
unmatched_donors.append(prev_donor)‖unmatched_donors.remove(donor)‖1
unmatched_donors.remove(donor)‖else:‖1
else:‖rec_record[recipient] = donor‖1
donor_record[donor] = recipient‖unmatched_donors.remove(donor)‖1
unmatched_donors.remove(donor)‖return donor_record‖1
from collections import deque‖from math import floor‖1
from math import floor‖from random import random‖1
from random import random‖from time import time‖1
class DirectedGraph:‖def __init__(self):‖1
def __init__(self):‖self.graph = {}‖2
def add_pair(self, u, v, w=1):‖if self.graph.get(u):‖1
if self.graph.get(u):‖if self.graph[u].count([w, v]) == 0:‖1
if self.graph[u].count([w, v]) == 0:‖self.graph[u].append([w, v])‖2
self.graph[u].append([w, v])‖else:‖2
else:‖self.graph[u] = [[w, v]]‖1
self.graph[u] = [[w, v]]‖if not self.graph.get(v):‖1
if not self.graph.get(v):‖self.graph[v] = []‖1
def all_nodes(self):‖return list(self.graph)‖2
def remove_pair(self, u, v):‖if self.graph.get(u):‖2
if self.graph.get(u):‖for _ in self.graph[u]:‖2
for _ in self.graph[u]:‖if _[1] == v:‖2
if _[1] == v:‖self.graph[u].remove(_)‖2
def dfs(self, s=-2, d=-1):‖if s == d:‖2
if s == d:‖return []‖2
return []‖stack = []‖2
stack = []‖visited = []‖7
visited = []‖if s == -2:‖5
if s == -2:‖s = next(iter(self.graph))‖5
s = next(iter(self.graph))‖stack.append(s)‖7
stack.append(s)‖visited.append(s)‖7
visited.append(s)‖ss = s‖3
if len(self.graph[s]) != 0:‖ss = s‖7
ss = s‖for node in self.graph[s]:‖7
for node in self.graph[s]:‖if visited.count(node[1]) < 1:‖5
if visited.count(node[1]) < 1:‖if node[1] == d:‖2
if node[1] == d:‖visited.append(d)‖2
visited.append(d)‖return visited‖2
return visited‖else:‖2
else:‖stack.append(node[1])‖2
stack.append(node[1])‖visited.append(node[1])‖7
visited.append(node[1])‖ss = node[1]‖7
ss = node[1]‖break‖7
if s == ss:‖stack.pop()‖6
stack.pop()‖if len(stack) != 0:‖2
if len(stack) != 0:‖s = stack[len(stack) - 1]‖7
s = stack[len(stack) - 1]‖else:‖7
else:‖s = ss‖3
if len(stack) == 0:‖return visited‖2
def fill_graph_randomly(self, c=-1):‖if c == -1:‖2
if c == -1:‖c = floor(random() * 10000) + 10‖2
c = floor(random() * 10000) + 10‖for i in range(c):‖2
for _ in range(floor(random() * 102) + 1):‖n = floor(random() * c) + 1‖2
n = floor(random() * c) + 1‖if n != i:‖2
if n != i:‖self.add_pair(i, n, 1)‖2
def bfs(self, s=-2):‖d = deque()‖2
d = deque()‖visited = []‖2
s = next(iter(self.graph))‖d.append(s)‖2
d.append(s)‖visited.append(s)‖2
visited.append(s)‖while d:‖2
while d:‖s = d.popleft()‖2
s = d.popleft()‖if len(self.graph[s]) != 0:‖2
if len(self.graph[s]) != 0:‖for node in self.graph[s]:‖2
if visited.count(node[1]) < 1:‖d.append(node[1])‖2
d.append(node[1])‖visited.append(node[1])‖2
visited.append(node[1])‖return visited‖2
def in_degree(self, u):‖count = 0‖1
count = 0‖for x in self.graph:‖1
for x in self.graph:‖for y in self.graph[x]:‖1
for y in self.graph[x]:‖if y[1] == u:‖1
if y[1] == u:‖count += 1‖1
def out_degree(self, u):‖return len(self.graph[u])‖1
def topological_sort(self, s=-2):‖stack = []‖1
ss = s‖sorted_nodes = []‖1
if visited.count(node[1]) < 1:‖stack.append(node[1])‖5
if s == ss:‖sorted_nodes.append(stack.pop())‖1
sorted_nodes.append(stack.pop())‖if len(stack) != 0:‖1
if len(stack) == 0:‖return sorted_nodes‖1
def cycle_nodes(self):‖stack = []‖2
visited = []‖s = next(iter(self.graph))‖4
visited.append(s)‖parent = -2‖4
parent = -2‖indirect_parents = []‖4
indirect_parents = []‖ss = s‖4
ss = s‖on_the_way_back = False‖4
on_the_way_back = False‖anticipating_nodes = set()‖4
for node in self.graph[s]:‖if (‖4
if (‖visited.count(node[1]) > 0‖4
visited.count(node[1]) > 0‖and node[1] != parent‖4
and node[1] != parent‖and indirect_parents.count(node[1]) > 0‖4
and indirect_parents.count(node[1]) > 0‖and not on_the_way_back‖4
and not on_the_way_back‖):‖4
):‖len_stack = len(stack) - 1‖2
len_stack = len(stack) - 1‖while len_stack >= 0:‖2
while len_stack >= 0:‖if stack[len_stack] == node[1]:‖2
if stack[len_stack] == node[1]:‖anticipating_nodes.add(node[1])‖2
anticipating_nodes.add(node[1])‖break‖4
else:‖anticipating_nodes.add(stack[len_stack])‖2
anticipating_nodes.add(stack[len_stack])‖len_stack -= 1‖2
len_stack -= 1‖if visited.count(node[1]) < 1:‖2
stack.pop()‖on_the_way_back = True‖4
on_the_way_back = True‖if len(stack) != 0:‖4
else:‖on_the_way_back = False‖4
on_the_way_back = False‖indirect_parents.append(parent)‖4
indirect_parents.append(parent)‖parent = s‖4
parent = s‖s = ss‖4
if len(stack) == 0:‖return list(anticipating_nodes)‖2
def has_cycle(self):‖stack = []‖2
):‖len_stack_minus_one = len(stack) - 1‖2
len_stack_minus_one = len(stack) - 1‖while len_stack_minus_one >= 0:‖2
while len_stack_minus_one >= 0:‖if stack[len_stack_minus_one] == node[1]:‖2
if stack[len_stack_minus_one] == node[1]:‖anticipating_nodes.add(node[1])‖2
else:‖return True‖3
return True‖if visited.count(node[1]) < 1:‖2
if len(stack) == 0:‖return False‖2
def dfs_time(self, s=-2, e=-1):‖begin = time()‖2
begin = time()‖self.dfs(s, e)‖2
self.dfs(s, e)‖end = time()‖2
end = time()‖return end - begin‖4
def bfs_time(self, s=-2):‖begin = time()‖2
begin = time()‖self.bfs(s)‖2
self.bfs(s)‖end = time()‖2
if self.graph[v].count([w, u]) == 0:‖self.graph[v].append([w, u])‖1
self.graph[v].append([w, u])‖else:‖1
if self.graph.get(v):‖for _ in self.graph[v]:‖1
for _ in self.graph[v]:‖if _[1] == u:‖1
if _[1] == u:‖self.graph[v].remove(_)‖1
def degree(self, u):‖return len(self.graph[u])‖1
class Graph:‖def __init__(self, vertices: int) -> None:‖1
def __init__(self, vertices: int) -> None:‖self.vertices = vertices‖1
self.vertices = vertices‖self.graph = [[0] * vertices for _ in range(vertices)]‖1
def print_solution(self, distances_from_source: list[int]) -> None:‖"print(""Vertex \t Distance from Source"")"‖1
"print(""Vertex \t Distance from Source"")"‖for vertex in range(self.vertices):‖1
for vertex in range(self.vertices):‖"print(vertex, ""\t\t"", distances_from_source[vertex])"‖1
def minimum_distance(‖self, distances_from_source: list[int], visited: list[bool]‖1
self, distances_from_source: list[int], visited: list[bool]‖) -> int:‖1
minimum = 1e7‖min_index = 0‖1
for vertex in range(self.vertices):‖if distances_from_source[vertex] < minimum and visited[vertex] is False:‖1
if distances_from_source[vertex] < minimum and visited[vertex] is False:‖minimum = distances_from_source[vertex]‖1
minimum = distances_from_source[vertex]‖min_index = vertex‖1
min_index = vertex‖return min_index‖1
distances = [int(1e7)] * self.vertices‖distances[source] = 0‖1
distances[source] = 0‖visited = [False] * self.vertices‖1
for _ in range(self.vertices):‖u = self.minimum_distance(distances, visited)‖1
u = self.minimum_distance(distances, visited)‖visited[u] = True‖1
for v in range(self.vertices):‖if (‖1
if (‖self.graph[u][v] > 0‖1
self.graph[u][v] > 0‖and visited[v] is False‖1
and visited[v] is False‖and distances[v] > distances[u] + self.graph[u][v]‖1
and distances[v] > distances[u] + self.graph[u][v]‖):‖1
):‖distances[v] = distances[u] + self.graph[u][v]‖1
"if __name__ == ""__main__"":"‖graph = Graph(9)‖1
graph = Graph(9)‖graph.graph = [‖1
graph.graph = [‖[0, 4, 0, 0, 0, 0, 0, 8, 0],‖1
[0, 4, 0, 0, 0, 0, 0, 8, 0],‖[4, 0, 8, 0, 0, 0, 0, 11, 0],‖1
[4, 0, 8, 0, 0, 0, 0, 11, 0],‖[0, 8, 0, 7, 0, 4, 0, 0, 2],‖1
[0, 8, 0, 7, 0, 4, 0, 0, 2],‖[0, 0, 7, 0, 9, 14, 0, 0, 0],‖1
[0, 0, 7, 0, 9, 14, 0, 0, 0],‖[0, 0, 0, 9, 0, 10, 0, 0, 0],‖1
[0, 0, 0, 9, 0, 10, 0, 0, 0],‖[0, 0, 4, 14, 10, 0, 2, 0, 0],‖1
[0, 0, 4, 14, 10, 0, 2, 0, 0],‖[0, 0, 0, 0, 0, 2, 0, 1, 6],‖1
[0, 0, 0, 0, 0, 2, 0, 1, 6],‖[8, 11, 0, 0, 0, 0, 1, 0, 7],‖1
[8, 11, 0, 0, 0, 0, 1, 0, 7],‖[0, 0, 2, 0, 0, 0, 6, 7, 0],‖1
[0, 0, 2, 0, 0, 0, 6, 7, 0],‖]‖1
]‖graph.dijkstra(0)‖1
from pprint import pformat‖from typing import Generic, TypeVar‖3
self.adj_list: dict[T, list[T]] = {}‖self.directed = directed‖2
def add_edge(‖self, source_vertex: T, destination_vertex: T‖1
self, source_vertex: T, destination_vertex: T‖) -> GraphAdjacencyList[T]:‖1
if source_vertex in self.adj_list and destination_vertex in self.adj_list:‖self.adj_list[source_vertex].append(destination_vertex)‖1
self.adj_list[source_vertex].append(destination_vertex)‖self.adj_list[destination_vertex].append(source_vertex)‖1
elif source_vertex in self.adj_list:‖self.adj_list[source_vertex].append(destination_vertex)‖2
self.adj_list[source_vertex].append(destination_vertex)‖self.adj_list[destination_vertex] = [source_vertex]‖1
elif destination_vertex in self.adj_list:‖self.adj_list[destination_vertex].append(source_vertex)‖1
self.adj_list[destination_vertex].append(source_vertex)‖self.adj_list[source_vertex] = [destination_vertex]‖1
else:‖self.adj_list[source_vertex] = [destination_vertex]‖2
self.adj_list[source_vertex] = [destination_vertex]‖self.adj_list[destination_vertex] = [source_vertex]‖1
elif source_vertex in self.adj_list and destination_vertex in self.adj_list:‖self.adj_list[source_vertex].append(destination_vertex)‖1
self.adj_list[source_vertex].append(destination_vertex)‖self.adj_list[destination_vertex] = []‖1
elif destination_vertex in self.adj_list:‖self.adj_list[source_vertex] = [destination_vertex]‖1
self.adj_list[source_vertex] = [destination_vertex]‖self.adj_list[destination_vertex] = []‖1
def __repr__(self) -> str:‖return pformat(self.adj_list)‖2
if not grid or not grid[0]:‖"raise TypeError(""The grid does not contain the appropriate information"")"‖1
for cell_n in range(1, len(grid[0])):‖grid[0][cell_n] += grid[0][cell_n - 1]‖1
grid[0][cell_n] += grid[0][cell_n - 1]‖row_above = grid[0]‖1
for row_n in range(1, len(grid)):‖current_row = grid[row_n]‖1
current_row = grid[row_n]‖grid[row_n] = fill_row(current_row, row_above)‖1
grid[row_n] = fill_row(current_row, row_above)‖row_above = grid[row_n]‖1
current_row[0] += row_above[0]‖for cell_n in range(1, len(current_row)):‖1
for cell_n in range(1, len(current_row)):‖current_row[cell_n] += min(current_row[cell_n - 1], row_above[cell_n])‖1
clothes = {‖"0: ""underwear"","‖1
"0: ""underwear"","‖"1: ""pants"","‖1
"1: ""pants"","‖"2: ""belt"","‖1
"2: ""belt"","‖"3: ""suit"","‖1
"3: ""suit"","‖"4: ""shoe"","‖1
"4: ""shoe"","‖"5: ""socks"","‖1
"5: ""socks"","‖"6: ""shirt"","‖1
"6: ""shirt"","‖"7: ""tie"","‖1
"7: ""tie"","‖"8: ""watch"","‖1
"8: ""watch"","‖}‖1
visited = [0 for x in range(len(graph))]‖stack = []‖1
def print_stack(stack, clothes):‖order = 1‖1
order = 1‖while stack:‖1
while stack:‖current_clothing = stack.pop()‖1
current_clothing = stack.pop()‖print(order, clothes[current_clothing])‖1
print(order, clothes[current_clothing])‖order += 1‖1
def depth_first_search(u, visited, graph):‖visited[u] = 1‖1
visited[u] = 1‖for v in graph[u]:‖1
for v in graph[u]:‖if not visited[v]:‖1
if not visited[v]:‖depth_first_search(v, visited, graph)‖2
def topological_sort(graph, visited):‖for v in range(len(graph)):‖1
for v in range(len(graph)):‖if not visited[v]:‖1
"if __name__ == ""__main__"":"‖topological_sort(graph, visited)‖1
topological_sort(graph, visited)‖print(stack)‖1
print(stack)‖print_stack(stack, clothes)‖1
ret = 1‖visited[start] = True‖1
visited[start] = True‖for v in tree[start]:‖1
for v in tree[start]:‖if v not in visited:‖1
if v not in visited:‖ret += dfs(v)‖1
ret += dfs(v)‖if ret % 2 == 0:‖1
if ret % 2 == 0:‖cuts.append(start)‖1
cuts.append(start)‖return ret‖1
def even_tree():‖dfs(1)‖1
"if __name__ == ""__main__"":"‖n, m = 10, 9‖1
n, m = 10, 9‖tree = defaultdict(list)‖1
tree = defaultdict(list)‖visited: dict[int, bool] = {}‖1
visited: dict[int, bool] = {}‖cuts: list[int] = []‖1
cuts: list[int] = []‖count = 0‖1
count = 0‖edges = [(2, 1), (3, 1), (4, 3), (5, 2), (6, 1), (7, 2), (8, 6), (9, 8), (10, 8)]‖1
edges = [(2, 1), (3, 1), (4, 3), (5, 2), (6, 1), (7, 2), (8, 6), (9, 8), (10, 8)]‖for u, v in edges:‖1
for u, v in edges:‖tree[u].append(v)‖1
tree[u].append(v)‖tree[v].append(u)‖1
tree[v].append(u)‖even_tree()‖1
even_tree()‖print(len(cuts) - 1)‖1
def __get_demo_graph(index):‖return [‖1
return [‖{‖1
{‖0: [1, 2],‖1
8: [5, 7],‖},‖1
},‖{‖3
{‖0: [6],‖1
0: [6],‖1: [9],‖1
1: [9],‖2: [4, 5],‖1
2: [4, 5],‖3: [4],‖1
3: [4],‖4: [2, 3],‖1
4: [2, 3],‖5: [2],‖1
5: [2],‖6: [0, 7],‖1
6: [0, 7],‖7: [6],‖1
7: [6],‖8: [],‖1
8: [],‖9: [1],‖1
9: [1],‖},‖1
{‖0: [4],‖1
0: [4],‖1: [6],‖1
1: [6],‖2: [],‖1
2: [],‖3: [5, 6, 7],‖1
3: [5, 6, 7],‖4: [0, 6],‖1
4: [0, 6],‖5: [3, 8, 9],‖1
5: [3, 8, 9],‖6: [1, 3, 4, 7],‖1
6: [1, 3, 4, 7],‖7: [3, 6, 8, 9],‖1
7: [3, 6, 8, 9],‖8: [5, 7],‖1
8: [5, 7],‖9: [5, 7],‖1
9: [5, 7],‖},‖1
{‖0: [1, 3],‖1
0: [1, 3],‖1: [0, 2, 4],‖1
1: [0, 2, 4],‖2: [1, 3, 4],‖1
2: [1, 3, 4],‖3: [0, 2, 4],‖1
3: [0, 2, 4],‖4: [1, 2, 3],‖1
4: [1, 2, 3],‖},‖1
},‖][index]‖1
id_ = 0‖n = len(graph)‖1
n = len(graph)‖low = [0] * n‖1
def dfs(at, parent, bridges, id_):‖visited[at] = True‖1
visited[at] = True‖low[at] = id_‖1
low[at] = id_‖id_ += 1‖1
id_ += 1‖for to in graph[at]:‖1
elif not visited[to]:‖dfs(to, at, bridges, id_)‖1
dfs(to, at, bridges, id_)‖low[at] = min(low[at], low[to])‖1
low[at] = min(low[at], low[to])‖if id_ <= low[to]:‖1
if id_ <= low[to]:‖bridges.append((at, to) if at < to else (to, at))‖1
bridges.append((at, to) if at < to else (to, at))‖else:‖1
bridges: list[tuple[int, int]] = []‖for i in range(n):‖1
if not visited[i]:‖dfs(i, -1, bridges, id_)‖1
dfs(i, -1, bridges, id_)‖return bridges‖1
class FlowNetwork:‖def __init__(self, graph, sources, sinks):‖1
def __init__(self, graph, sources, sinks):‖self.source_index = None‖1
self.source_index = None‖self.sink_index = None‖1
self.sink_index = None‖self.graph = graph‖1
self._normalize_graph(sources, sinks)‖self.vertices_count = len(graph)‖1
self.vertices_count = len(graph)‖self.maximum_flow_algorithm = None‖1
def _normalize_graph(self, sources, sinks):‖if sources is int:‖1
if sources is int:‖sources = [sources]‖1
sources = [sources]‖if sinks is int:‖1
if sinks is int:‖sinks = [sinks]‖1
if len(sources) == 0 or len(sinks) == 0:‖return‖1
self.source_index = sources[0]‖self.sink_index = sinks[0]‖1
if len(sources) > 1 or len(sinks) > 1:‖max_input_flow = 0‖1
max_input_flow = 0‖for i in sources:‖1
for i in sources:‖max_input_flow += sum(self.graph[i])‖1
size = len(self.graph) + 1‖for room in self.graph:‖2
for room in self.graph:‖room.insert(0, 0)‖1
room.insert(0, 0)‖self.graph.insert(0, [0] * size)‖1
self.graph.insert(0, [0] * size)‖for i in sources:‖1
for i in sources:‖self.graph[0][i + 1] = max_input_flow‖1
self.graph[0][i + 1] = max_input_flow‖self.source_index = 0‖1
for room in self.graph:‖room.append(0)‖1
room.append(0)‖self.graph.append([0] * size)‖1
self.graph.append([0] * size)‖for i in sinks:‖1
for i in sinks:‖self.graph[i + 1][size - 1] = max_input_flow‖1
self.graph[i + 1][size - 1] = max_input_flow‖self.sink_index = size - 1‖1
def find_maximum_flow(self):‖if self.maximum_flow_algorithm is None:‖1
if self.maximum_flow_algorithm is None:‖"raise Exception(""You need to set maximum flow algorithm before."")"‖1
"raise Exception(""You need to set maximum flow algorithm before."")"‖if self.source_index is None or self.sink_index is None:‖1
if self.source_index is None or self.sink_index is None:‖return 0‖1
self.maximum_flow_algorithm.execute()‖return self.maximum_flow_algorithm.getMaximumFlow()‖1
def set_maximum_flow_algorithm(self, algorithm):‖self.maximum_flow_algorithm = algorithm(self)‖1
class FlowNetworkAlgorithmExecutor:‖def __init__(self, flow_network):‖1
def __init__(self, flow_network):‖self.flow_network = flow_network‖1
self.flow_network = flow_network‖self.verticies_count = flow_network.verticesCount‖1
self.verticies_count = flow_network.verticesCount‖self.source_index = flow_network.sourceIndex‖1
self.source_index = flow_network.sourceIndex‖self.sink_index = flow_network.sinkIndex‖1
self.graph = flow_network.graph‖self.executed = False‖1
def execute(self):‖if not self.executed:‖1
if not self.executed:‖self._algorithm()‖1
self._algorithm()‖self.executed = True‖1
def _algorithm(self):‖pass‖1
class MaximumFlowAlgorithmExecutor(FlowNetworkAlgorithmExecutor):‖def __init__(self, flow_network):‖1
def __init__(self, flow_network):‖super().__init__(flow_network)‖2
def get_maximum_flow(self):‖if not self.executed:‖1
if not self.executed:‖"raise Exception(""You should execute algorithm before using its result!"")"‖1
class PushRelabelExecutor(MaximumFlowAlgorithmExecutor):‖def __init__(self, flow_network):‖1
self.heights = [0] * self.verticies_count‖self.excesses = [0] * self.verticies_count‖1
def _algorithm(self):‖self.heights[self.source_index] = self.verticies_count‖1
for nextvertex_index, bandwidth in enumerate(self.graph[self.source_index]):‖self.preflow[self.source_index][nextvertex_index] += bandwidth‖1
self.preflow[self.source_index][nextvertex_index] += bandwidth‖self.preflow[nextvertex_index][self.source_index] -= bandwidth‖1
self.preflow[nextvertex_index][self.source_index] -= bandwidth‖self.excesses[nextvertex_index] += bandwidth‖1
vertices_list = [‖i‖1
i‖for i in range(self.verticies_count)‖1
for i in range(self.verticies_count)‖if i not in {self.source_index, self.sink_index}‖1
if i not in {self.source_index, self.sink_index}‖]‖1
i = 0‖while i < len(vertices_list):‖1
while i < len(vertices_list):‖vertex_index = vertices_list[i]‖1
vertex_index = vertices_list[i]‖previous_height = self.heights[vertex_index]‖1
previous_height = self.heights[vertex_index]‖self.process_vertex(vertex_index)‖1
self.process_vertex(vertex_index)‖if self.heights[vertex_index] > previous_height:‖1
vertices_list.insert(0, vertices_list.pop(i))‖i = 0‖1
def process_vertex(self, vertex_index):‖while self.excesses[vertex_index] > 0:‖1
while self.excesses[vertex_index] > 0:‖for neighbour_index in range(self.verticies_count):‖1
if (‖self.graph[vertex_index][neighbour_index]‖1
self.graph[vertex_index][neighbour_index]‖- self.preflow[vertex_index][neighbour_index]‖1
- self.preflow[vertex_index][neighbour_index]‖> 0‖1
> 0‖and self.heights[vertex_index] > self.heights[neighbour_index]‖1
and self.heights[vertex_index] > self.heights[neighbour_index]‖):‖1
):‖self.push(vertex_index, neighbour_index)‖1
def push(self, from_index, to_index):‖preflow_delta = min(‖1
preflow_delta = min(‖self.excesses[from_index],‖1
self.excesses[from_index],‖self.graph[from_index][to_index] - self.preflow[from_index][to_index],‖1
self.graph[from_index][to_index] - self.preflow[from_index][to_index],‖)‖1
)‖self.preflow[from_index][to_index] += preflow_delta‖1
self.preflow[from_index][to_index] += preflow_delta‖self.preflow[to_index][from_index] -= preflow_delta‖1
self.preflow[to_index][from_index] -= preflow_delta‖self.excesses[from_index] -= preflow_delta‖1
self.excesses[from_index] -= preflow_delta‖self.excesses[to_index] += preflow_delta‖1
def relabel(self, vertex_index):‖min_height = None‖1
min_height = None‖for to_index in range(self.verticies_count):‖1
for to_index in range(self.verticies_count):‖if (‖1
if (‖self.graph[vertex_index][to_index]‖1
self.graph[vertex_index][to_index]‖- self.preflow[vertex_index][to_index]‖1
- self.preflow[vertex_index][to_index]‖> 0‖1
> 0‖) and (min_height is None or self.heights[to_index] < min_height):‖1
) and (min_height is None or self.heights[to_index] < min_height):‖min_height = self.heights[to_index]‖1
if min_height is not None:‖self.heights[vertex_index] = min_height + 1‖1
"if __name__ == ""__main__"":"‖entrances = [0]‖1
entrances = [0]‖exits = [3]‖1
import random‖import unittest‖2
import unittest‖from pprint import pformat‖2
class GraphAdjacencyList(Generic[T]):‖def __init__(‖1
def __init__(‖self, vertices: list[T], edges: list[list[T]], directed: bool = True‖2
self, vertices: list[T], edges: list[list[T]], directed: bool = True‖) -> None:‖2
) -> None:‖self.adj_list: dict[T, list[T]] = {}‖1
edges = edges or []‖vertices = vertices or []‖2
for vertex in vertices:‖self.add_vertex(vertex)‖2
for edge in edges:‖if len(edge) != 2:‖2
if len(edge) != 2:‖"msg = f""Invalid input: {edge} is the wrong length."""‖1
"msg = f""Invalid input: {edge} is the wrong length."""‖raise ValueError(msg)‖1
raise ValueError(msg)‖self.add_edge(edge[0], edge[1])‖2
def add_vertex(self, vertex: T) -> None:‖if self.contains_vertex(vertex):‖2
if self.contains_vertex(vertex):‖"msg = f""Incorrect input: {vertex} is already in the graph."""‖1
"msg = f""Incorrect input: {vertex} is already in the graph."""‖raise ValueError(msg)‖1
raise ValueError(msg)‖self.adj_list[vertex] = []‖1
def add_edge(self, source_vertex: T, destination_vertex: T) -> None:‖if not (‖2
if not (‖self.contains_vertex(source_vertex)‖6
self.contains_vertex(source_vertex)‖and self.contains_vertex(destination_vertex)‖6
and self.contains_vertex(destination_vertex)‖):‖6
):‖msg = (‖6
msg = (‖"f""Incorrect input: Either {source_vertex} or """‖4
"f""Incorrect input: Either {source_vertex} or """‖"f""{destination_vertex} does not exist"""‖4
"f""{destination_vertex} does not exist"""‖)‖4
raise ValueError(msg)‖if self.contains_edge(source_vertex, destination_vertex):‖2
if self.contains_edge(source_vertex, destination_vertex):‖msg = (‖2
msg = (‖"""Incorrect input: The edge already exists between """‖2
"""Incorrect input: The edge already exists between """‖"f""{source_vertex} and {destination_vertex}"""‖2
"f""{source_vertex} and {destination_vertex}"""‖)‖4
self.adj_list[source_vertex].append(destination_vertex)‖if not self.directed:‖1
if not self.directed:‖self.adj_list[destination_vertex].append(source_vertex)‖1
def remove_vertex(self, vertex: T) -> None:‖if not self.contains_vertex(vertex):‖2
if not self.contains_vertex(vertex):‖"msg = f""Incorrect input: {vertex} does not exist in this graph."""‖2
"msg = f""Incorrect input: {vertex} does not exist in this graph."""‖raise ValueError(msg)‖2
for neighbor in self.adj_list[vertex]:‖self.adj_list[neighbor].remove(vertex)‖1
self.adj_list[neighbor].remove(vertex)‖else:‖1
for edge_list in self.adj_list.values():‖if vertex in edge_list:‖1
if vertex in edge_list:‖edge_list.remove(vertex)‖1
def remove_edge(self, source_vertex: T, destination_vertex: T) -> None:‖if not (‖2
raise ValueError(msg)‖if not self.contains_edge(source_vertex, destination_vertex):‖2
if not self.contains_edge(source_vertex, destination_vertex):‖msg = (‖2
msg = (‖"""Incorrect input: The edge does NOT exist between """‖2
"""Incorrect input: The edge does NOT exist between """‖"f""{source_vertex} and {destination_vertex}"""‖2
self.adj_list[source_vertex].remove(destination_vertex)‖if not self.directed:‖1
if not self.directed:‖self.adj_list[destination_vertex].remove(source_vertex)‖1
def contains_vertex(self, vertex: T) -> bool:‖return vertex in self.adj_list‖1
def contains_edge(self, source_vertex: T, destination_vertex: T) -> bool:‖if not (‖2
msg = (‖"f""Incorrect input: Either {source_vertex} """‖2
"f""Incorrect input: Either {source_vertex} """‖"f""or {destination_vertex} does not exist."""‖2
"f""or {destination_vertex} does not exist."""‖)‖2
def clear_graph(self) -> None:‖self.adj_list = {}‖1
class TestGraphAdjacencyList(unittest.TestCase):‖def __assert_graph_edge_exists_check(‖1
def __assert_graph_edge_exists_check(‖self,‖2
self,‖undirected_graph: GraphAdjacencyList,‖4
undirected_graph: GraphAdjacencyList,‖directed_graph: GraphAdjacencyList,‖4
directed_graph: GraphAdjacencyList,‖edge: list[int],‖2
edge: list[int],‖) -> None:‖4
) -> None:‖assert undirected_graph.contains_edge(edge[0], edge[1])‖2
assert undirected_graph.contains_edge(edge[0], edge[1])‖assert undirected_graph.contains_edge(edge[1], edge[0])‖2
assert undirected_graph.contains_edge(edge[1], edge[0])‖assert directed_graph.contains_edge(edge[0], edge[1])‖2
def __assert_graph_edge_does_not_exist_check(‖self,‖2
) -> None:‖assert not undirected_graph.contains_edge(edge[0], edge[1])‖2
assert not undirected_graph.contains_edge(edge[0], edge[1])‖assert not undirected_graph.contains_edge(edge[1], edge[0])‖2
assert not undirected_graph.contains_edge(edge[1], edge[0])‖assert not directed_graph.contains_edge(edge[0], edge[1])‖2
def __assert_graph_vertex_exists_check(‖self,‖2
directed_graph: GraphAdjacencyList,‖vertex: int,‖2
vertex: int,‖) -> None:‖4
) -> None:‖assert undirected_graph.contains_vertex(vertex)‖2
assert undirected_graph.contains_vertex(vertex)‖assert directed_graph.contains_vertex(vertex)‖2
def __assert_graph_vertex_does_not_exist_check(‖self,‖2
) -> None:‖assert not undirected_graph.contains_vertex(vertex)‖2
assert not undirected_graph.contains_vertex(vertex)‖assert not directed_graph.contains_vertex(vertex)‖2
def __generate_random_edges(‖self, vertices: list[int], edge_pick_count: int‖2
self, vertices: list[int], edge_pick_count: int‖) -> list[list[int]]:‖2
) -> list[list[int]]:‖assert edge_pick_count <= len(vertices)‖2
random_source_vertices: list[int] = random.sample(‖vertices[0 : int(len(vertices) / 2)], edge_pick_count‖2
vertices[0 : int(len(vertices) / 2)], edge_pick_count‖)‖2
)‖random_destination_vertices: list[int] = random.sample(‖2
random_destination_vertices: list[int] = random.sample(‖vertices[int(len(vertices) / 2) :], edge_pick_count‖2
vertices[int(len(vertices) / 2) :], edge_pick_count‖)‖2
)‖random_edges: list[list[int]] = []‖2
for source in random_source_vertices:‖for dest in random_destination_vertices:‖2
for dest in random_destination_vertices:‖random_edges.append([source, dest])‖2
def __generate_graphs(‖self, vertex_count: int, min_val: int, max_val: int, edge_pick_count: int‖2
self, vertex_count: int, min_val: int, max_val: int, edge_pick_count: int‖) -> tuple[GraphAdjacencyList, GraphAdjacencyList, list[int], list[list[int]]]:‖1
) -> tuple[GraphAdjacencyList, GraphAdjacencyList, list[int], list[list[int]]]:‖if max_val - min_val + 1 < vertex_count:‖1
if max_val - min_val + 1 < vertex_count:‖raise ValueError(‖2
raise ValueError(‖"""Will result in duplicate vertices. Either increase range """‖1
"""Will result in duplicate vertices. Either increase range """‖"""between min_val and max_val or decrease vertex count."""‖1
"""between min_val and max_val or decrease vertex count."""‖)‖1
random_vertices: list[int] = random.sample(‖range(min_val, max_val + 1), vertex_count‖2
range(min_val, max_val + 1), vertex_count‖)‖2
)‖random_edges: list[list[int]] = self.__generate_random_edges(‖2
random_edges: list[list[int]] = self.__generate_random_edges(‖random_vertices, edge_pick_count‖2
random_vertices, edge_pick_count‖)‖2
undirected_graph = GraphAdjacencyList(‖vertices=random_vertices, edges=random_edges, directed=False‖1
vertices=random_vertices, edges=random_edges, directed=False‖)‖2
)‖directed_graph = GraphAdjacencyList(‖5
directed_graph = GraphAdjacencyList(‖vertices=random_vertices, edges=random_edges, directed=True‖1
vertices=random_vertices, edges=random_edges, directed=True‖)‖2
def test_init_check(self) -> None:‖(‖2
(‖undirected_graph,‖18
undirected_graph,‖directed_graph,‖18
directed_graph,‖random_vertices,‖18
random_vertices,‖random_edges,‖18
random_edges,‖) = self.__generate_graphs(20, 0, 100, 4)‖16
for num in random_vertices:‖self.__assert_graph_vertex_exists_check(‖6
self.__assert_graph_vertex_exists_check(‖undirected_graph, directed_graph, num‖6
undirected_graph, directed_graph, num‖)‖8
for edge in random_edges:‖self.__assert_graph_edge_exists_check(‖4
self.__assert_graph_edge_exists_check(‖undirected_graph, directed_graph, edge‖8
undirected_graph, directed_graph, edge‖)‖12
)‖assert not undirected_graph.directed‖1
assert not undirected_graph.directed‖assert directed_graph.directed‖2
def test_contains_vertex(self) -> None:‖random_vertices: list[int] = random.sample(range(101), 20)‖2
undirected_graph = GraphAdjacencyList(‖vertices=random_vertices, edges=[], directed=False‖3
vertices=random_vertices, edges=[], directed=False‖)‖6
directed_graph = GraphAdjacencyList(‖vertices=random_vertices, edges=[], directed=True‖3
vertices=random_vertices, edges=[], directed=True‖)‖6
for num in range(101):‖assert (num in random_vertices) == undirected_graph.contains_vertex(num)‖2
assert (num in random_vertices) == undirected_graph.contains_vertex(num)‖assert (num in random_vertices) == directed_graph.contains_vertex(num)‖2
def test_add_vertices(self) -> None:‖random_vertices: list[int] = random.sample(range(101), 20)‖2
undirected_graph: GraphAdjacencyList = GraphAdjacencyList(‖vertices=[], edges=[], directed=False‖1
vertices=[], edges=[], directed=False‖)‖2
)‖directed_graph: GraphAdjacencyList = GraphAdjacencyList(‖1
directed_graph: GraphAdjacencyList = GraphAdjacencyList(‖vertices=[], edges=[], directed=True‖1
vertices=[], edges=[], directed=True‖)‖2
for num in random_vertices:‖undirected_graph.add_vertex(num)‖2
for num in random_vertices:‖directed_graph.add_vertex(num)‖2
def test_remove_vertices(self) -> None:‖random_vertices: list[int] = random.sample(range(101), 20)‖2
undirected_graph.remove_vertex(num)‖directed_graph.remove_vertex(num)‖2
self.__assert_graph_vertex_does_not_exist_check(‖undirected_graph, directed_graph, num‖2
def test_add_and_remove_vertices_repeatedly(self) -> None:‖random_vertices1: list[int] = random.sample(range(51), 20)‖2
random_vertices1: list[int] = random.sample(range(51), 20)‖random_vertices2: list[int] = random.sample(range(51, 101), 20)‖2
undirected_graph = GraphAdjacencyList(‖vertices=random_vertices1, edges=[], directed=False‖1
vertices=random_vertices1, edges=[], directed=False‖)‖2
directed_graph = GraphAdjacencyList(‖vertices=random_vertices1, edges=[], directed=True‖1
vertices=random_vertices1, edges=[], directed=True‖)‖2
for i, _ in enumerate(random_vertices1):‖undirected_graph.add_vertex(random_vertices2[i])‖2
undirected_graph.add_vertex(random_vertices2[i])‖directed_graph.add_vertex(random_vertices2[i])‖2
self.__assert_graph_vertex_exists_check(‖undirected_graph, directed_graph, random_vertices2[i]‖2
undirected_graph, directed_graph, random_vertices2[i]‖)‖4
undirected_graph.remove_vertex(random_vertices1[i])‖directed_graph.remove_vertex(random_vertices1[i])‖2
self.__assert_graph_vertex_does_not_exist_check(‖undirected_graph, directed_graph, random_vertices1[i]‖2
undirected_graph, directed_graph, random_vertices1[i]‖)‖2
for i, _ in enumerate(random_vertices1):‖undirected_graph.remove_vertex(random_vertices2[i])‖2
undirected_graph.remove_vertex(random_vertices2[i])‖directed_graph.remove_vertex(random_vertices2[i])‖2
self.__assert_graph_vertex_does_not_exist_check(‖undirected_graph, directed_graph, random_vertices2[i]‖2
vertex_count = 20‖(‖2
random_edges,‖) = self.__generate_graphs(vertex_count, 0, 100, 4)‖2
all_possible_edges: list[list[int]] = []‖for i in range(vertex_count - 1):‖2
for i in range(vertex_count - 1):‖for j in range(i + 1, vertex_count):‖2
for j in range(i + 1, vertex_count):‖all_possible_edges.append([random_vertices[i], random_vertices[j]])‖2
all_possible_edges.append([random_vertices[i], random_vertices[j]])‖all_possible_edges.append([random_vertices[j], random_vertices[i]])‖2
for edge in all_possible_edges:‖if edge in random_edges:‖2
if edge in random_edges:‖self.__assert_graph_edge_exists_check(‖2
)‖elif [edge[1], edge[0]] in random_edges:‖2
self.__assert_graph_edge_exists_check(‖undirected_graph, directed_graph, [edge[1], edge[0]]‖2
undirected_graph, directed_graph, [edge[1], edge[0]]‖)‖2
else:‖self.__assert_graph_edge_does_not_exist_check(‖2
self.__assert_graph_edge_does_not_exist_check(‖undirected_graph, directed_graph, edge‖4
random_vertices: list[int] = random.sample(range(101), 15)‖random_edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)‖2
for edge in random_edges:‖undirected_graph.add_edge(edge[0], edge[1])‖2
undirected_graph.add_edge(edge[0], edge[1])‖directed_graph.add_edge(edge[0], edge[1])‖2
directed_graph.add_edge(edge[0], edge[1])‖self.__assert_graph_edge_exists_check(‖2
)‖undirected_graph.remove_edge(edge[0], edge[1])‖2
undirected_graph.remove_edge(edge[0], edge[1])‖directed_graph.remove_edge(edge[0], edge[1])‖2
directed_graph.remove_edge(edge[0], edge[1])‖self.__assert_graph_edge_does_not_exist_check(‖2
def test_add_and_remove_edges_repeatedly(self) -> None:‖(‖2
while len(more_random_edges) != len(random_edges):‖edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)‖4
edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)‖for edge in edges:‖4
for edge in edges:‖if len(more_random_edges) == len(random_edges):‖4
if len(more_random_edges) == len(random_edges):‖break‖4
break‖elif edge not in more_random_edges and edge not in random_edges:‖4
elif edge not in more_random_edges and edge not in random_edges:‖more_random_edges.append(edge)‖4
for i, _ in enumerate(random_edges):‖undirected_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])‖2
undirected_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])‖directed_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])‖2
self.__assert_graph_edge_exists_check(‖undirected_graph, directed_graph, more_random_edges[i]‖2
undirected_graph, directed_graph, more_random_edges[i]‖)‖2
undirected_graph.remove_edge(random_edges[i][0], random_edges[i][1])‖directed_graph.remove_edge(random_edges[i][0], random_edges[i][1])‖2
self.__assert_graph_edge_does_not_exist_check(‖undirected_graph, directed_graph, random_edges[i]‖2
undirected_graph, directed_graph, random_edges[i]‖)‖2
def test_add_vertex_exception_check(self) -> None:‖(‖2
for vertex in random_vertices:‖with pytest.raises(ValueError):‖4
with pytest.raises(ValueError):‖undirected_graph.add_vertex(vertex)‖2
undirected_graph.add_vertex(vertex)‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖directed_graph.add_vertex(vertex)‖2
def test_remove_vertex_exception_check(self) -> None:‖(‖2
for i in range(101):‖if i not in random_vertices:‖2
if i not in random_vertices:‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖undirected_graph.remove_vertex(i)‖2
undirected_graph.remove_vertex(i)‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖directed_graph.remove_vertex(i)‖2
def test_add_edge_exception_check(self) -> None:‖(‖2
for edge in random_edges:‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖undirected_graph.add_edge(edge[0], edge[1])‖2
undirected_graph.add_edge(edge[0], edge[1])‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖directed_graph.add_edge(edge[0], edge[1])‖2
def test_remove_edge_exception_check(self) -> None:‖(‖2
for edge in more_random_edges:‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖undirected_graph.remove_edge(edge[0], edge[1])‖2
undirected_graph.remove_edge(edge[0], edge[1])‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖directed_graph.remove_edge(edge[0], edge[1])‖2
def test_contains_edge_exception_check(self) -> None:‖(‖2
with pytest.raises(ValueError):‖undirected_graph.contains_edge(vertex, 102)‖2
undirected_graph.contains_edge(vertex, 102)‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖directed_graph.contains_edge(vertex, 102)‖2
with pytest.raises(ValueError):‖undirected_graph.contains_edge(103, 102)‖2
undirected_graph.contains_edge(103, 102)‖with pytest.raises(ValueError):‖2
with pytest.raises(ValueError):‖directed_graph.contains_edge(103, 102)‖2
def __init__(self):‖self.num_vertices = 0‖1
self.num_vertices = 0‖self.num_edges = 0‖1
self.num_edges = 0‖self.adjacency = {}‖1
def add_vertex(self, vertex):‖if vertex not in self.adjacency:‖1
if vertex not in self.adjacency:‖self.adjacency[vertex] = {}‖1
self.adjacency[vertex] = {}‖self.num_vertices += 1‖1
self.add_vertex(head)‖self.add_vertex(tail)‖1
if head == tail:‖return‖1
self.adjacency[head][tail] = weight‖self.adjacency[tail][head] = weight‖2
def distinct_weight(self):‖edges = self.get_edges()‖1
edges = self.get_edges()‖for edge in edges:‖1
for edge in edges:‖head, tail, weight = edge‖4
head, tail, weight = edge‖edges.remove((tail, head, weight))‖2
edges.remove((tail, head, weight))‖for i in range(len(edges)):‖1
for i in range(len(edges)):‖edges[i] = list(edges[i])‖1
edges.sort(key=lambda e: e[2])‖for i in range(len(edges) - 1):‖1
for i in range(len(edges) - 1):‖if edges[i][2] >= edges[i + 1][2]:‖1
if edges[i][2] >= edges[i + 1][2]:‖edges[i + 1][2] = edges[i][2] + 1‖1
edges[i + 1][2] = edges[i][2] + 1‖for edge in edges:‖1
head, tail, weight = edge‖self.adjacency[head][tail] = weight‖1
def __str__(self):‖"string = """""‖1
"string = """""‖for tail in self.adjacency:‖1
for tail in self.adjacency:‖for head in self.adjacency[tail]:‖2
for head in self.adjacency[tail]:‖weight = self.adjacency[head][tail]‖1
weight = self.adjacency[head][tail]‖"string += f""{head} -> {tail} == {weight}\n"""‖1
"string += f""{head} -> {tail} == {weight}\n"""‖"return string.rstrip(""\n"")"‖1
def get_edges(self):‖output = []‖1
output = []‖for tail in self.adjacency:‖1
for head in self.adjacency[tail]:‖output.append((tail, head, self.adjacency[head][tail]))‖1
output.append((tail, head, self.adjacency[head][tail]))‖return output‖1
def get_vertices(self):‖return self.adjacency.keys()‖1
@staticmethod‖def build(vertices=None, edges=None):‖1
def build(vertices=None, edges=None):‖g = Graph()‖1
g = Graph()‖if vertices is None:‖1
if vertices is None:‖vertices = []‖1
vertices = []‖if edges is None:‖1
if edges is None:‖edge = []‖1
edge = []‖for vertex in vertices:‖1
for vertex in vertices:‖g.add_vertex(vertex)‖1
g.add_vertex(vertex)‖for edge in edges:‖1
for edge in edges:‖g.add_edge(*edge)‖1
g.add_edge(*edge)‖return g‖1
def __init__(self):‖self.parent = {}‖1
self.parent = {}‖self.rank = {}‖1
def __len__(self):‖return len(self.parent)‖1
def make_set(self, item):‖if item in self.parent:‖1
if item in self.parent:‖return self.find(item)‖1
self.parent[item] = item‖self.rank[item] = 0‖1
self.rank[item] = 0‖return item‖1
def find(self, item):‖if item not in self.parent:‖1
if item not in self.parent:‖return self.make_set(item)‖1
return self.make_set(item)‖if item != self.parent[item]:‖1
if item != self.parent[item]:‖self.parent[item] = self.find(self.parent[item])‖1
self.parent[item] = self.find(self.parent[item])‖return self.parent[item]‖1
def union(self, item1, item2):‖root1 = self.find(item1)‖1
root1 = self.find(item1)‖root2 = self.find(item2)‖1
if root1 == root2:‖return root1‖1
if self.rank[root1] > self.rank[root2]:‖self.parent[root2] = root1‖1
self.parent[root2] = root1‖return root1‖2
if self.rank[root1] < self.rank[root2]:‖self.parent[root1] = root2‖1
self.parent[root1] = root2‖return root2‖1
if self.rank[root1] == self.rank[root2]:‖self.rank[root1] += 1‖1
self.rank[root1] += 1‖self.parent[root2] = root1‖1
return root1‖return None‖1
@staticmethod‖def boruvka_mst(graph):‖1
def boruvka_mst(graph):‖num_components = graph.num_vertices‖1
union_find = Graph.UnionFind()‖mst_edges = []‖1
mst_edges = []‖while num_components > 1:‖1
while num_components > 1:‖cheap_edge = {}‖1
cheap_edge = {}‖for vertex in graph.get_vertices():‖1
for vertex in graph.get_vertices():‖cheap_edge[vertex] = -1‖1
edges = graph.get_edges()‖for edge in edges:‖1
edges.remove((tail, head, weight))‖for edge in edges:‖1
head, tail, weight = edge‖set1 = union_find.find(head)‖1
set1 = union_find.find(head)‖set2 = union_find.find(tail)‖1
set2 = union_find.find(tail)‖if set1 != set2:‖1
if set1 != set2:‖if cheap_edge[set1] == -1 or cheap_edge[set1][2] > weight:‖1
if cheap_edge[set1] == -1 or cheap_edge[set1][2] > weight:‖cheap_edge[set1] = [head, tail, weight]‖1
if cheap_edge[set2] == -1 or cheap_edge[set2][2] > weight:‖cheap_edge[set2] = [head, tail, weight]‖1
cheap_edge[set2] = [head, tail, weight]‖for head_tail_weight in cheap_edge.values():‖1
for head_tail_weight in cheap_edge.values():‖if head_tail_weight != -1:‖1
if head_tail_weight != -1:‖head, tail, weight = head_tail_weight‖1
head, tail, weight = head_tail_weight‖if union_find.find(head) != union_find.find(tail):‖1
if union_find.find(head) != union_find.find(tail):‖union_find.union(head, tail)‖1
union_find.union(head, tail)‖mst_edges.append(head_tail_weight)‖1
mst_edges.append(head_tail_weight)‖num_components = num_components - 1‖1
num_components = num_components - 1‖mst = Graph.build(edges=mst_edges)‖1
mst = Graph.build(edges=mst_edges)‖return mst‖1
TEST_GRAPH = {‖"""1"": [""2"", ""3"", ""4"", ""5""],"‖1
"""1"": [""2"", ""3"", ""4"", ""5""],"‖"""2"": [""1"", ""3"", ""4"", ""5""],"‖1
"""2"": [""1"", ""3"", ""4"", ""5""],"‖"""3"": [""1"", ""2"", ""4"", ""5"", ""10""],"‖1
"""3"": [""1"", ""2"", ""4"", ""5"", ""10""],"‖"""4"": [""1"", ""2"", ""3"", ""5"", ""6""],"‖1
"""4"": [""1"", ""2"", ""3"", ""5"", ""6""],"‖"""5"": [""1"", ""2"", ""3"", ""4"", ""7""],"‖1
"""5"": [""1"", ""2"", ""3"", ""4"", ""7""],"‖"""6"": [""7"", ""8"", ""9"", ""10"", ""4""],"‖1
"""6"": [""7"", ""8"", ""9"", ""10"", ""4""],"‖"""7"": [""6"", ""8"", ""9"", ""10"", ""5""],"‖1
"""7"": [""6"", ""8"", ""9"", ""10"", ""5""],"‖"""8"": [""6"", ""7"", ""9"", ""10""],"‖1
"""8"": [""6"", ""7"", ""9"", ""10""],"‖"""9"": [""6"", ""7"", ""8"", ""10""],"‖1
"""9"": [""6"", ""7"", ""8"", ""10""],"‖"""10"": [""6"", ""7"", ""8"", ""9"", ""3""],"‖1
"""10"": [""6"", ""7"", ""8"", ""9"", ""3""],"‖}‖1
u = random.choice(list(graph_copy.keys()))‖v = random.choice(graph_copy[u])‖1
uv = u + v‖uv_neighbors = list(set(graph_copy[u] + graph_copy[v]))‖1
uv_neighbors = list(set(graph_copy[u] + graph_copy[v]))‖uv_neighbors.remove(u)‖1
uv_neighbors.remove(u)‖uv_neighbors.remove(v)‖1
uv_neighbors.remove(v)‖graph_copy[uv] = uv_neighbors‖1
graph_copy[uv] = uv_neighbors‖for neighbor in uv_neighbors:‖1
for neighbor in uv_neighbors:‖graph_copy[neighbor].append(uv)‖1
del graph_copy[u]‖del graph_copy[v]‖1
del graph_copy[v]‖for neighbor in uv_neighbors:‖1
for neighbor in uv_neighbors:‖if u in graph_copy[neighbor]:‖1
if u in graph_copy[neighbor]:‖graph_copy[neighbor].remove(u)‖1
graph_copy[neighbor].remove(u)‖if v in graph_copy[neighbor]:‖1
if v in graph_copy[neighbor]:‖graph_copy[neighbor].remove(v)‖1
groups = [contracted_nodes[node] for node in graph_copy]‖return {‖1
return {‖(node, neighbor)‖1
(node, neighbor)‖for node in groups[0]‖1
for node in groups[0]‖for neighbor in graph[node]‖1
for neighbor in graph[node]‖if neighbor in groups[1]‖1
if neighbor in groups[1]‖}‖1
"if __name__ == ""__main__"":"‖print(partition_graph(TEST_GRAPH))‖1
class GraphAdjacencyMatrix(Generic[T]):‖def __init__(‖1
) -> None:‖self.directed = directed‖1
self.directed = directed‖self.vertex_to_index: dict[T, int] = {}‖1
self.vertex_to_index: dict[T, int] = {}‖self.adj_matrix: list[list[int]] = []‖1
if len(edge) != 2:‖"msg = f""Invalid input: {edge} must have length 2."""‖1
"msg = f""Invalid input: {edge} must have length 2."""‖raise ValueError(msg)‖1
u: int = self.vertex_to_index[source_vertex]‖v: int = self.vertex_to_index[destination_vertex]‖2
v: int = self.vertex_to_index[destination_vertex]‖self.adj_matrix[u][v] = 1‖1
self.adj_matrix[u][v] = 1‖if not self.directed:‖1
if not self.directed:‖self.adj_matrix[v][u] = 1‖1
v: int = self.vertex_to_index[destination_vertex]‖self.adj_matrix[u][v] = 0‖1
self.adj_matrix[u][v] = 0‖if not self.directed:‖1
if not self.directed:‖self.adj_matrix[v][u] = 0‖1
if self.contains_vertex(vertex):‖"msg = f""Incorrect input: {vertex} already exists in this graph."""‖1
"msg = f""Incorrect input: {vertex} already exists in this graph."""‖raise ValueError(msg)‖1
for row in self.adj_matrix:‖row.append(0)‖1
self.adj_matrix.append([0] * (len(self.adj_matrix) + 1))‖self.vertex_to_index[vertex] = len(self.adj_matrix) - 1‖1
start_index = self.vertex_to_index[vertex]‖self.adj_matrix.pop(start_index)‖1
for lst in self.adj_matrix:‖lst.pop(start_index)‖1
for inner_vertex in self.vertex_to_index:‖if self.vertex_to_index[inner_vertex] >= start_index:‖1
if self.vertex_to_index[inner_vertex] >= start_index:‖self.vertex_to_index[inner_vertex] = (‖1
self.vertex_to_index[inner_vertex] = (‖self.vertex_to_index[inner_vertex] - 1‖1
self.vertex_to_index[inner_vertex] - 1‖)‖1
def contains_vertex(self, vertex: T) -> bool:‖return vertex in self.vertex_to_index‖1
u = self.vertex_to_index[source_vertex]‖v = self.vertex_to_index[destination_vertex]‖1
v = self.vertex_to_index[destination_vertex]‖return self.adj_matrix[u][v] == 1‖1
def clear_graph(self) -> None:‖self.vertex_to_index = {}‖1
self.vertex_to_index = {}‖self.adj_matrix = []‖1
def __repr__(self) -> str:‖"first = ""Adj Matrix:\n"" + pformat(self.adj_matrix)"‖1
"first = ""Adj Matrix:\n"" + pformat(self.adj_matrix)"‖"second = ""\nVertex to index mapping:\n"" + pformat(self.vertex_to_index)"‖1
"second = ""\nVertex to index mapping:\n"" + pformat(self.vertex_to_index)"‖return first + second‖1
class TestGraphMatrix(unittest.TestCase):‖def __assert_graph_edge_exists_check(‖1
self,‖undirected_graph: GraphAdjacencyMatrix,‖4
undirected_graph: GraphAdjacencyMatrix,‖directed_graph: GraphAdjacencyMatrix,‖4
directed_graph: GraphAdjacencyMatrix,‖edge: list[int],‖2
directed_graph: GraphAdjacencyMatrix,‖vertex: int,‖2
self, vertex_count: int, min_val: int, max_val: int, edge_pick_count: int‖) -> tuple[GraphAdjacencyMatrix, GraphAdjacencyMatrix, list[int], list[list[int]]]:‖1
) -> tuple[GraphAdjacencyMatrix, GraphAdjacencyMatrix, list[int], list[list[int]]]:‖if max_val - min_val + 1 < vertex_count:‖1
raise ValueError(‖"""Will result in duplicate vertices. Either increase """‖1
"""Will result in duplicate vertices. Either increase """‖"""range between min_val and max_val or decrease vertex count"""‖1
"""range between min_val and max_val or decrease vertex count"""‖)‖1
undirected_graph = GraphAdjacencyMatrix(‖vertices=random_vertices, edges=random_edges, directed=False‖1
)‖directed_graph = GraphAdjacencyMatrix(‖5
directed_graph = GraphAdjacencyMatrix(‖vertices=random_vertices, edges=random_edges, directed=True‖1
undirected_graph = GraphAdjacencyMatrix(‖vertices=random_vertices, edges=[], directed=False‖3
directed_graph = GraphAdjacencyMatrix(‖vertices=random_vertices, edges=[], directed=True‖3
undirected_graph: GraphAdjacencyMatrix = GraphAdjacencyMatrix(‖vertices=[], edges=[], directed=False‖1
)‖directed_graph: GraphAdjacencyMatrix = GraphAdjacencyMatrix(‖1
directed_graph: GraphAdjacencyMatrix = GraphAdjacencyMatrix(‖vertices=[], edges=[], directed=True‖1
undirected_graph = GraphAdjacencyMatrix(‖vertices=random_vertices1, edges=[], directed=False‖1
directed_graph = GraphAdjacencyMatrix(‖vertices=random_vertices1, edges=[], directed=True‖1
from collections import Counter‖from random import random‖1
def __init__(self):‖self.connections = {}‖1
def add_node(self, node: str) -> None:‖self.connections[node] = {}‖1
def add_transition_probability(‖self, node1: str, node2: str, probability: float‖1
self, node1: str, node2: str, probability: float‖) -> None:‖1
) -> None:‖if node1 not in self.connections:‖1
if node1 not in self.connections:‖self.add_node(node1)‖1
self.add_node(node1)‖if node2 not in self.connections:‖1
if node2 not in self.connections:‖self.add_node(node2)‖1
self.add_node(node2)‖self.connections[node1][node2] = probability‖1
def get_nodes(self) -> list[str]:‖return list(self.connections)‖1
def transition(self, node: str) -> str:‖current_probability = 0‖1
current_probability = 0‖random_value = random()‖1
for dest in self.connections[node]:‖current_probability += self.connections[node][dest]‖1
current_probability += self.connections[node][dest]‖if current_probability > random_value:‖1
if current_probability > random_value:‖return dest‖1
return dest‖"return """""‖1
def get_transitions(‖start: str, transitions: list[tuple[str, str, float]], steps: int‖1
start: str, transitions: list[tuple[str, str, float]], steps: int‖) -> dict[str, int]:‖1
for node1, node2, probability in transitions:‖graph.add_transition_probability(node1, node2, probability)‖1
visited = Counter(graph.get_nodes())‖node = start‖1
for _ in range(steps):‖node = graph.transition(node)‖1
node = graph.transition(node)‖visited[node] += 1‖1
TEST_GRIDS = [‖[‖1
[‖[0, 0, 0, 0, 0, 0, 0],‖1
[0, 0, 0, 0, 1, 0, 0],‖],‖1
],‖[‖2
[‖[0, 0, 0, 1, 1, 0, 0],‖1
[0, 0, 0, 1, 1, 0, 0],‖[0, 0, 0, 0, 1, 0, 1],‖1
[0, 0, 0, 0, 1, 0, 1],‖[0, 0, 0, 1, 1, 0, 0],‖1
[0, 0, 0, 1, 1, 0, 0],‖[0, 1, 0, 0, 1, 0, 0],‖1
[0, 1, 0, 0, 1, 0, 0],‖[1, 0, 0, 1, 1, 0, 1],‖1
[1, 0, 0, 1, 1, 0, 1],‖[0, 0, 0, 0, 0, 0, 0],‖1
[0, 0, 0, 0, 0, 0, 0],‖],‖1
[‖[0, 0, 1, 0, 0],‖1
[0, 0, 1, 0, 0],‖[0, 1, 0, 0, 0],‖1
[0, 1, 0, 0, 0],‖[0, 0, 1, 0, 1],‖1
[0, 0, 1, 0, 1],‖[1, 0, 0, 1, 1],‖1
[1, 0, 0, 1, 1],‖[0, 0, 0, 0, 0],‖1
[0, 0, 0, 0, 0],‖],‖1
],‖]‖1
goal_y: int,‖g_cost: float,‖1
g_cost: float,‖parent: Node | None,‖1
parent: Node | None,‖):‖1
self.parent = parent‖self.f_cost = self.calculate_heuristic()‖1
def calculate_heuristic(self) -> float:‖dx = abs(self.pos_x - self.goal_x)‖1
dx = abs(self.pos_x - self.goal_x)‖dy = abs(self.pos_y - self.goal_y)‖1
dy = abs(self.pos_y - self.goal_y)‖return dx + dy‖1
def __lt__(self, other) -> bool:‖return self.f_cost < other.f_cost‖1
def __eq__(self, other) -> bool:‖return self.pos == other.pos‖1
def __init__(‖self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]‖1
self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]‖):‖1
):‖self.grid = grid‖1
self.grid = grid‖self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)‖1
def search(self) -> Path | None:‖while self.open_nodes:‖1
def get_successors(self, parent: Node) -> list[Node]:‖return [‖1
return [‖Node(‖1
pos_y,‖self.target.pos_x,‖1
self.target.pos_x,‖self.target.pos_y,‖1
self.target.pos_y,‖parent.g_cost + 1,‖1
)‖for action in delta‖1
for action in delta‖if (‖1
if (‖0 <= (pos_x := parent.pos_x + action[1]) < len(self.grid[0])‖1
0 <= (pos_x := parent.pos_x + action[1]) < len(self.grid[0])‖and 0 <= (pos_y := parent.pos_y + action[0]) < len(self.grid)‖1
and 0 <= (pos_y := parent.pos_y + action[0]) < len(self.grid)‖and self.grid[pos_y][pos_x] == 0‖1
and self.grid[pos_y][pos_x] == 0‖)‖1
)‖]‖2
"if __name__ == ""__main__"":"‖for idx, grid in enumerate(TEST_GRIDS):‖1
for idx, grid in enumerate(TEST_GRIDS):‖"print(f""==grid-{idx + 1}=="")"‖1
greedy_bf = GreedyBestFirst(grid, init, goal)‖path = greedy_bf.search()‖1
path = greedy_bf.search()‖if path:‖1
if path:‖for pos_x, pos_y in path:‖1
for pos_x, pos_y in path:‖grid[pos_x][pos_y] = 2‖1
def kruskal(‖num_nodes: int, edges: list[tuple[int, int, int]]‖1
num_nodes: int, edges: list[tuple[int, int, int]]‖) -> list[tuple[int, int, int]]:‖1
) -> list[tuple[int, int, int]]:‖edges = sorted(edges, key=lambda edge: edge[2])‖1
def find_parent(i):‖if i != parent[i]:‖1
if i != parent[i]:‖parent[i] = find_parent(parent[i])‖1
parent[i] = find_parent(parent[i])‖return parent[i]‖1
minimum_spanning_tree_cost = 0‖minimum_spanning_tree = []‖1
for edge in edges:‖parent_a = find_parent(edge[0])‖1
parent_a = find_parent(edge[0])‖parent_b = find_parent(edge[1])‖1
parent_b = find_parent(edge[1])‖if parent_a != parent_b:‖1
if parent_a != parent_b:‖minimum_spanning_tree_cost += edge[2]‖1
minimum_spanning_tree_cost += edge[2]‖minimum_spanning_tree.append(edge)‖1
minimum_spanning_tree.append(edge)‖parent[parent_a] = parent_b‖1
"if __name__ == ""__main__"":"‖num_nodes, num_edges = list(map(int, input().strip().split()))‖1
num_nodes, num_edges = list(map(int, input().strip().split()))‖edges = []‖1
for _ in range(num_edges):‖node1, node2, cost = (int(x) for x in input().strip().split())‖1
node1, node2, cost = (int(x) for x in input().strip().split())‖edges.append((node1, node2, cost))‖1
queue = []‖topo_order = []‖1
topo_order = []‖processed_vertices_count = 0‖1
vertex = queue.pop(0)‖processed_vertices_count += 1‖1
processed_vertices_count += 1‖topo_order.append(vertex)‖1
for neighbor in graph[vertex]:‖indegree[neighbor] -= 1‖1
indegree[neighbor] -= 1‖if indegree[neighbor] == 0:‖1
if indegree[neighbor] == 0:‖queue.append(neighbor)‖1
if processed_vertices_count != len(graph):‖return None‖1
return None‖return topo_order‖1
while edges:‖from_node, to_node = edges.pop()‖1
from_node, to_node = edges.pop()‖chosen_vertices.add(from_node)‖1
chosen_vertices.add(from_node)‖chosen_vertices.add(to_node)‖1
chosen_vertices.add(to_node)‖for edge in edges.copy():‖1
for edge in edges.copy():‖if from_node in edge or to_node in edge:‖1
if from_node in edge or to_node in edge:‖edges.discard(edge)‖1
edges.discard(edge)‖return chosen_vertices‖1
def get_edges(graph: dict) -> set:‖edges = set()‖1
edges = set()‖for from_node, to_nodes in graph.items():‖1
for from_node, to_nodes in graph.items():‖for to_node in to_nodes:‖1
for to_node in to_nodes:‖edges.add((from_node, to_node))‖1
edges.add((from_node, to_node))‖return edges‖1
import sys‖from collections import defaultdict‖1
class Heap:‖def __init__(self):‖1
def __init__(self):‖self.node_position = []‖1
def get_position(self, vertex):‖return self.node_position[vertex]‖1
def set_position(self, vertex, pos):‖self.node_position[vertex] = pos‖1
def top_to_bottom(self, heap, start, size, positions):‖if start > size // 2 - 1:‖1
if start > size // 2 - 1:‖return‖1
else:‖if 2 * start + 2 >= size:‖1
if 2 * start + 2 >= size:‖smallest_child = 2 * start + 1‖1
smallest_child = 2 * start + 1‖elif heap[2 * start + 1] < heap[2 * start + 2]:‖1
elif heap[2 * start + 1] < heap[2 * start + 2]:‖smallest_child = 2 * start + 1‖1
smallest_child = 2 * start + 1‖else:‖1
else:‖smallest_child = 2 * start + 2‖1
smallest_child = 2 * start + 2‖if heap[smallest_child] < heap[start]:‖1
if heap[smallest_child] < heap[start]:‖temp, temp1 = heap[smallest_child], positions[smallest_child]‖1
temp, temp1 = heap[smallest_child], positions[smallest_child]‖heap[smallest_child], positions[smallest_child] = (‖1
heap[smallest_child], positions[smallest_child] = (‖heap[start],‖1
heap[start],‖positions[start],‖1
positions[start],‖)‖1
)‖heap[start], positions[start] = temp, temp1‖1
temp = self.get_position(positions[smallest_child])‖self.set_position(‖1
self.set_position(‖positions[smallest_child], self.get_position(positions[start])‖1
positions[smallest_child], self.get_position(positions[start])‖)‖1
)‖self.set_position(positions[start], temp)‖1
def bottom_to_top(self, val, index, heap, position):‖temp = position[index]‖1
while index != 0:‖parent = int((index - 2) / 2) if index % 2 == 0 else int((index - 1) / 2)‖1
if val < heap[parent]:‖heap[index] = heap[parent]‖1
heap[index] = heap[parent]‖position[index] = position[parent]‖1
position[index] = position[parent]‖self.set_position(position[parent], index)‖1
self.set_position(position[parent], index)‖else:‖1
else:‖heap[index] = val‖1
heap[index] = val‖position[index] = temp‖1
position[index] = temp‖self.set_position(temp, index)‖1
self.set_position(temp, index)‖break‖1
break‖index = parent‖1
index = parent‖else:‖1
else:‖heap[0] = val‖1
heap[0] = val‖position[0] = temp‖1
position[0] = temp‖self.set_position(temp, 0)‖1
def heapify(self, heap, positions):‖start = len(heap) // 2 - 1‖1
start = len(heap) // 2 - 1‖for i in range(start, -1, -1):‖1
for i in range(start, -1, -1):‖self.top_to_bottom(heap, i, len(heap), positions)‖1
def delete_minimum(self, heap, positions):‖temp = positions[0]‖1
temp = positions[0]‖heap[0] = sys.maxsize‖1
heap[0] = sys.maxsize‖self.top_to_bottom(heap, 0, len(heap), positions)‖1
self.top_to_bottom(heap, 0, len(heap), positions)‖return temp‖1
visited = [0] * len(adjacency_list)‖nbr_tv = [-1] * len(adjacency_list)‖1
distance_tv = []‖positions = []‖1
for vertex in range(len(adjacency_list)):‖distance_tv.append(sys.maxsize)‖1
distance_tv.append(sys.maxsize)‖positions.append(vertex)‖1
positions.append(vertex)‖heap.node_position.append(vertex)‖1
tree_edges = []‖visited[0] = 1‖1
visited[0] = 1‖distance_tv[0] = sys.maxsize‖1
distance_tv[0] = sys.maxsize‖for neighbor, distance in adjacency_list[0]:‖1
for neighbor, distance in adjacency_list[0]:‖nbr_tv[neighbor] = 0‖1
nbr_tv[neighbor] = 0‖distance_tv[neighbor] = distance‖1
distance_tv[neighbor] = distance‖heap.heapify(distance_tv, positions)‖1
for _ in range(1, len(adjacency_list)):‖vertex = heap.delete_minimum(distance_tv, positions)‖1
vertex = heap.delete_minimum(distance_tv, positions)‖if visited[vertex] == 0:‖1
if visited[vertex] == 0:‖tree_edges.append((nbr_tv[vertex], vertex))‖1
tree_edges.append((nbr_tv[vertex], vertex))‖visited[vertex] = 1‖1
visited[vertex] = 1‖for neighbor, distance in adjacency_list[vertex]:‖1
for neighbor, distance in adjacency_list[vertex]:‖if (‖1
if (‖visited[neighbor] == 0‖1
visited[neighbor] == 0‖and distance < distance_tv[heap.get_position(neighbor)]‖1
and distance < distance_tv[heap.get_position(neighbor)]‖):‖1
):‖distance_tv[heap.get_position(neighbor)] = distance‖1
distance_tv[heap.get_position(neighbor)] = distance‖heap.bottom_to_top(‖1
heap.bottom_to_top(‖distance, heap.get_position(neighbor), distance_tv, positions‖1
distance, heap.get_position(neighbor), distance_tv, positions‖)‖1
)‖nbr_tv[neighbor] = vertex‖1
nbr_tv[neighbor] = vertex‖return tree_edges‖1
"edges_number = int(input(""Enter number of edges: "").strip())"‖adjacency_list = defaultdict(list)‖1
adjacency_list = defaultdict(list)‖for _ in range(edges_number):‖1
for _ in range(edges_number):‖edge = [int(x) for x in input().strip().split()]‖1
edge = [int(x) for x in input().strip().split()]‖adjacency_list[edge[0]].append([edge[1], edge[2]])‖1
adjacency_list[edge[0]].append([edge[1], edge[2]])‖adjacency_list[edge[1]].append([edge[0], edge[2]])‖1
adjacency_list[edge[1]].append([edge[0], edge[2]])‖print(prisms_algorithm(adjacency_list))‖1
import heapq‖import sys‖1
class PriorityQueue:‖def __init__(self):‖1
def __init__(self):‖self.elements = []‖1
self.elements = []‖self.set = set()‖1
def minkey(self):‖if not self.empty():‖1
if not self.empty():‖return self.elements[0][0]‖1
return self.elements[0][0]‖else:‖1
else:‖"return float(""inf"")"‖1
def empty(self):‖return len(self.elements) == 0‖1
def put(self, item, priority):‖if item not in self.set:‖1
if item not in self.set:‖heapq.heappush(self.elements, (priority, item))‖1
heapq.heappush(self.elements, (priority, item))‖self.set.add(item)‖1
self.set.add(item)‖else:‖1
temp = []‖(pri, x) = heapq.heappop(self.elements)‖1
(pri, x) = heapq.heappop(self.elements)‖while x != item:‖1
while x != item:‖temp.append((pri, x))‖1
temp.append((pri, x))‖(pri, x) = heapq.heappop(self.elements)‖1
(pri, x) = heapq.heappop(self.elements)‖temp.append((priority, item))‖1
temp.append((priority, item))‖for pro, xxx in temp:‖1
for pro, xxx in temp:‖heapq.heappush(self.elements, (pro, xxx))‖1
def remove_element(self, item):‖if item in self.set:‖1
if item in self.set:‖self.set.remove(item)‖1
self.set.remove(item)‖temp = []‖1
temp = []‖(pro, x) = heapq.heappop(self.elements)‖1
(pro, x) = heapq.heappop(self.elements)‖while x != item:‖1
while x != item:‖temp.append((pro, x))‖1
temp.append((pro, x))‖(pro, x) = heapq.heappop(self.elements)‖1
(pro, x) = heapq.heappop(self.elements)‖for prito, yyy in temp:‖1
for prito, yyy in temp:‖heapq.heappush(self.elements, (prito, yyy))‖1
def top_show(self):‖return self.elements[0][1]‖1
def get(self):‖(priority, item) = heapq.heappop(self.elements)‖1
(priority, item) = heapq.heappop(self.elements)‖self.set.remove(item)‖1
self.set.remove(item)‖return (priority, item)‖1
a = np.array(p)‖b = np.array(goal)‖1
b = np.array(goal)‖return np.linalg.norm(a - b)‖1
def key(start: TPos, i: int, goal: TPos, g_function: dict[TPos, float]):‖ans = g_function[start] + W1 * heuristics[i](start, goal)‖1
ans = g_function[start] + W1 * heuristics[i](start, goal)‖return ans‖1
def do_something(back_pointer, goal, start):‖grid = np.char.chararray((n, n))‖1
grid = np.char.chararray((n, n))‖for i in range(n):‖1
for j in range(n):‖"grid[i][j] = ""*"""‖1
for j in range(n):‖if (j, (n - 1) - i) in blocks:‖1
if (j, (n - 1) - i) in blocks:‖"grid[i][j] = ""#"""‖1
"grid[0][(n - 1)] = ""-"""‖x = back_pointer[goal]‖1
x = back_pointer[goal]‖while x != start:‖2
while x != start:‖(x_c, y_c) = x‖1
"grid[(n - 1) - y_c][x_c] = ""-"""‖x = back_pointer[x]‖1
x = back_pointer[x]‖"grid[(n - 1)][0] = ""-"""‖1
for j in range(n):‖if (i, j) == (0, n - 1):‖1
if (i, j) == (0, n - 1):‖"print(grid[i][j], end="" "")"‖1
"print(grid[i][j], end="" "")"‖"print(""<-- End position"", end="" "")"‖1
"print(""<-- End position"", end="" "")"‖else:‖1
else:‖"print(grid[i][j], end="" "")"‖1
"print(grid[i][j], end="" "")"‖print()‖1
print()‖"print(""^"")"‖2
"print(""^"")"‖"print(""Start position"")"‖2
"print(""Start position"")"‖print()‖2
print()‖"print(""# is an obstacle"")"‖2
"print(""# is an obstacle"")"‖"print(""- is the path taken by algorithm"")"‖2
"print(""- is the path taken by algorithm"")"‖"print(""PATH TAKEN BY THE ALGORITHM IS:-"")"‖1
"print(""PATH TAKEN BY THE ALGORITHM IS:-"")"‖x = back_pointer[goal]‖1
while x != start:‖"print(x, end="" "")"‖1
"print(x, end="" "")"‖x = back_pointer[x]‖1
x = back_pointer[x]‖print(x)‖1
print(x)‖sys.exit()‖1
def valid(p: TPos):‖if p[0] < 0 or p[0] > n - 1:‖1
if p[0] < 0 or p[0] > n - 1:‖return False‖1
return False‖return not (p[1] < 0 or p[1] > n - 1)‖1
def expand_state(‖s,‖1
s,‖j,‖1
j,‖visited,‖1
visited,‖g_function,‖3
g_function,‖close_list_anchor,‖3
close_list_anchor,‖close_list_inad,‖3
close_list_inad,‖open_list,‖3
open_list,‖back_pointer,‖3
back_pointer,‖):‖1
):‖for itera in range(n_heuristic):‖1
for itera in range(n_heuristic):‖open_list[itera].remove_element(s)‖1
(x, y) = s‖left = (x - 1, y)‖1
left = (x - 1, y)‖right = (x + 1, y)‖1
right = (x + 1, y)‖up = (x, y + 1)‖1
up = (x, y + 1)‖down = (x, y - 1)‖1
for neighbours in [left, right, up, down]:‖if neighbours not in blocks:‖1
if neighbours not in blocks:‖if valid(neighbours) and neighbours not in visited:‖1
visited.add(neighbours)‖back_pointer[neighbours] = -1‖1
back_pointer[neighbours] = -1‖"g_function[neighbours] = float(""inf"")"‖1
if valid(neighbours) and g_function[neighbours] > g_function[s] + 1:‖g_function[neighbours] = g_function[s] + 1‖1
g_function[neighbours] = g_function[s] + 1‖back_pointer[neighbours] = s‖1
back_pointer[neighbours] = s‖if neighbours not in close_list_anchor:‖1
if neighbours not in close_list_anchor:‖open_list[0].put(neighbours, key(neighbours, 0, goal, g_function))‖1
open_list[0].put(neighbours, key(neighbours, 0, goal, g_function))‖if neighbours not in close_list_inad:‖1
if neighbours not in close_list_inad:‖for var in range(1, n_heuristic):‖1
for var in range(1, n_heuristic):‖if key(neighbours, var, goal, g_function) <= W2 * key(‖1
if key(neighbours, var, goal, g_function) <= W2 * key(‖neighbours, 0, goal, g_function‖1
neighbours, 0, goal, g_function‖):‖1
):‖open_list[j].put(‖1
open_list[j].put(‖neighbours, key(neighbours, var, goal, g_function)‖1
neighbours, key(neighbours, var, goal, g_function)‖)‖1
def make_common_ground():‖some_list = []‖1
some_list = []‖for x in range(1, 5):‖1
for x in range(1, 5):‖for y in range(1, 6):‖1
for y in range(1, 6):‖some_list.append((x, y))‖1
for x in range(15, 20):‖some_list.append((x, 17))‖1
for x in range(10, 19):‖for y in range(1, 15):‖1
for y in range(1, 15):‖some_list.append((x, y))‖1
for x in range(1, 4):‖for y in range(12, 19):‖1
for y in range(12, 19):‖some_list.append((x, y))‖1
some_list.append((x, y))‖for x in range(3, 13):‖1
for x in range(3, 13):‖for y in range(16, 19):‖1
for y in range(16, 19):‖some_list.append((x, y))‖1
some_list.append((x, y))‖return some_list‖1
blocks_blk = [‖(0, 1),‖1
(0, 1),‖(1, 1),‖1
(2, 1),‖(3, 1),‖1
(3, 1),‖(4, 1),‖1
(4, 1),‖(5, 1),‖1
(5, 1),‖(6, 1),‖1
(6, 1),‖(7, 1),‖1
(7, 1),‖(8, 1),‖1
(8, 1),‖(9, 1),‖1
(9, 1),‖(10, 1),‖1
(10, 1),‖(11, 1),‖1
(11, 1),‖(12, 1),‖1
(12, 1),‖(13, 1),‖1
(13, 1),‖(14, 1),‖1
(14, 1),‖(15, 1),‖1
(15, 1),‖(16, 1),‖1
(16, 1),‖(17, 1),‖1
(17, 1),‖(18, 1),‖1
(18, 1),‖(19, 1),‖1
(19, 1),‖]‖1
]‖blocks_all = make_common_ground()‖1
W1 = 1‖W2 = 1‖1
W2 = 1‖n = 20‖1
n = 20‖n_heuristic = 3‖1
start = (0, 0)‖goal = (n - 1, n - 1)‖1
def multi_a_star(start: TPos, goal: TPos, n_heuristic: int):‖"g_function = {start: 0, goal: float(""inf"")}"‖1
"g_function = {start: 0, goal: float(""inf"")}"‖back_pointer = {start: -1, goal: -1}‖1
back_pointer = {start: -1, goal: -1}‖open_list = []‖1
open_list = []‖visited = set()‖1
for i in range(n_heuristic):‖open_list.append(PriorityQueue())‖1
open_list.append(PriorityQueue())‖open_list[i].put(start, key(start, i, goal, g_function))‖1
close_list_anchor: list[int] = []‖close_list_inad: list[int] = []‖1
close_list_inad: list[int] = []‖"while open_list[0].minkey() < float(""inf""):"‖1
"while open_list[0].minkey() < float(""inf""):"‖for i in range(1, n_heuristic):‖1
if open_list[i].minkey() <= W2 * open_list[0].minkey():‖global t‖1
global t‖t += 1‖1
t += 1‖if g_function[goal] <= open_list[i].minkey():‖1
if g_function[goal] <= open_list[i].minkey():‖"if g_function[goal] < float(""inf""):"‖1
"if g_function[goal] < float(""inf""):"‖do_something(back_pointer, goal, start)‖2
do_something(back_pointer, goal, start)‖else:‖2
else:‖_, get_s = open_list[i].top_show()‖1
_, get_s = open_list[i].top_show()‖visited.add(get_s)‖1
visited.add(get_s)‖expand_state(‖2
expand_state(‖get_s,‖2
get_s,‖i,‖1
i,‖visited,‖1
back_pointer,‖)‖2
)‖close_list_inad.append(get_s)‖1
close_list_inad.append(get_s)‖elif g_function[goal] <= open_list[0].minkey():‖1
elif g_function[goal] <= open_list[0].minkey():‖"if g_function[goal] < float(""inf""):"‖1
else:‖get_s = open_list[0].top_show()‖1
get_s = open_list[0].top_show()‖visited.add(get_s)‖1
get_s,‖0,‖1
0,‖visited,‖1
)‖close_list_anchor.append(get_s)‖1
close_list_anchor.append(get_s)‖"print(""No path found to goal"")"‖1
"print(""No path found to goal"")"‖print()‖1
print()‖for i in range(n - 1, -1, -1):‖1
for i in range(n - 1, -1, -1):‖for j in range(n):‖1
for j in range(n):‖if (j, i) in blocks:‖1
if (j, i) in blocks:‖"print(""#"", end="" "")"‖1
"print(""#"", end="" "")"‖elif (j, i) in back_pointer:‖1
elif (j, i) in back_pointer:‖if (j, i) == (n - 1, n - 1):‖1
if (j, i) == (n - 1, n - 1):‖"print(""*"", end="" "")"‖1
"print(""*"", end="" "")"‖else:‖1
else:‖"print(""-"", end="" "")"‖1
"print(""-"", end="" "")"‖else:‖1
else:‖"print(""*"", end="" "")"‖1
"print(""*"", end="" "")"‖if (j, i) == (n - 1, n - 1):‖1
if (j, i) == (n - 1, n - 1):‖"print(""<-- End position"", end="" "")"‖1
"print(""<-- End position"", end="" "")"‖print()‖1
"if __name__ == ""__main__"":"‖multi_a_star(start, goal, n_heuristic)‖1
from sys import maxsize‖from typing import Generic, TypeVar‖1
def get_parent_position(position: int) -> int:‖return (position - 1) // 2‖1
def get_child_left_position(position: int) -> int:‖return (2 * position) + 1‖1
def get_child_right_position(position: int) -> int:‖return (2 * position) + 2‖1
def __init__(self) -> None:‖self.heap: list[tuple[T, int]] = []‖1
self.heap: list[tuple[T, int]] = []‖self.position_map: dict[T, int] = {}‖1
self.position_map: dict[T, int] = {}‖self.elements: int = 0‖1
def __len__(self) -> int:‖return self.elements‖1
def __repr__(self) -> str:‖return str(self.heap)‖1
self.heap.append((elem, weight))‖self.position_map[elem] = self.elements‖1
self.position_map[elem] = self.elements‖self.elements += 1‖1
self.elements += 1‖self._bubble_up(elem)‖1
if self.elements > 1:‖self._swap_nodes(0, self.elements - 1)‖1
self._swap_nodes(0, self.elements - 1)‖elem, _ = self.heap.pop()‖1
elem, _ = self.heap.pop()‖del self.position_map[elem]‖1
del self.position_map[elem]‖self.elements -= 1‖1
self.elements -= 1‖if self.elements > 0:‖1
if self.elements > 0:‖bubble_down_elem, _ = self.heap[0]‖1
bubble_down_elem, _ = self.heap[0]‖self._bubble_down(bubble_down_elem)‖1
self._bubble_down(bubble_down_elem)‖return elem‖1
position = self.position_map[elem]‖self.heap[position] = (elem, weight)‖1
self.heap[position] = (elem, weight)‖if position > 0:‖1
if position > 0:‖parent_position = get_parent_position(position)‖1
parent_position = get_parent_position(position)‖_, parent_weight = self.heap[parent_position]‖1
_, parent_weight = self.heap[parent_position]‖if parent_weight > weight:‖2
if parent_weight > weight:‖self._bubble_up(elem)‖1
self._bubble_up(elem)‖else:‖1
else:‖self._bubble_down(elem)‖2
self._bubble_down(elem)‖else:‖1
curr_pos = self.position_map[elem]‖if curr_pos == 0:‖1
if curr_pos == 0:‖return None‖1
return None‖parent_position = get_parent_position(curr_pos)‖1
parent_position = get_parent_position(curr_pos)‖_, weight = self.heap[curr_pos]‖1
_, weight = self.heap[curr_pos]‖_, parent_weight = self.heap[parent_position]‖1
if parent_weight > weight:‖self._swap_nodes(parent_position, curr_pos)‖1
self._swap_nodes(parent_position, curr_pos)‖return self._bubble_up(elem)‖1
return self._bubble_up(elem)‖return None‖1
curr_pos = self.position_map[elem]‖_, weight = self.heap[curr_pos]‖1
_, weight = self.heap[curr_pos]‖child_left_position = get_child_left_position(curr_pos)‖1
child_left_position = get_child_left_position(curr_pos)‖child_right_position = get_child_right_position(curr_pos)‖1
child_right_position = get_child_right_position(curr_pos)‖if child_left_position < self.elements and child_right_position < self.elements:‖1
if child_left_position < self.elements and child_right_position < self.elements:‖_, child_left_weight = self.heap[child_left_position]‖1
_, child_left_weight = self.heap[child_left_position]‖_, child_right_weight = self.heap[child_right_position]‖1
_, child_right_weight = self.heap[child_right_position]‖if child_right_weight < child_left_weight and child_right_weight < weight:‖1
if child_right_weight < child_left_weight and child_right_weight < weight:‖self._swap_nodes(child_right_position, curr_pos)‖1
self._swap_nodes(child_right_position, curr_pos)‖return self._bubble_down(elem)‖2
return self._bubble_down(elem)‖if child_left_position < self.elements:‖1
if child_left_position < self.elements:‖_, child_left_weight = self.heap[child_left_position]‖1
_, child_left_weight = self.heap[child_left_position]‖if child_left_weight < weight:‖1
if child_left_weight < weight:‖self._swap_nodes(child_left_position, curr_pos)‖1
self._swap_nodes(child_left_position, curr_pos)‖return self._bubble_down(elem)‖1
return self._bubble_down(elem)‖else:‖1
return None‖if child_right_position < self.elements:‖1
if child_right_position < self.elements:‖_, child_right_weight = self.heap[child_right_position]‖1
_, child_right_weight = self.heap[child_right_position]‖if child_right_weight < weight:‖1
if child_right_weight < weight:‖self._swap_nodes(child_right_position, curr_pos)‖1
return self._bubble_down(elem)‖return None‖1
node1_elem = self.heap[node1_pos][0]‖node2_elem = self.heap[node2_pos][0]‖1
node2_elem = self.heap[node2_pos][0]‖self.heap[node1_pos], self.heap[node2_pos] = (‖1
self.heap[node1_pos], self.heap[node2_pos] = (‖self.heap[node2_pos],‖1
self.heap[node2_pos],‖self.heap[node1_pos],‖1
self.heap[node1_pos],‖)‖1
)‖self.position_map[node1_elem] = node2_pos‖1
self.position_map[node1_elem] = node2_pos‖self.position_map[node2_elem] = node1_pos‖1
def __init__(self) -> None:‖self.connections: dict[T, dict[T, int]] = {}‖1
self.connections: dict[T, dict[T, int]] = {}‖self.nodes: int = 0‖1
def __repr__(self) -> str:‖return str(self.connections)‖1
def __len__(self) -> int:‖return self.nodes‖1
if node not in self.connections:‖self.connections[node] = {}‖2
self.connections[node] = {}‖self.nodes += 1‖1
self.add_node(node1)‖self.add_node(node2)‖2
self.add_node(node2)‖self.connections[node1][node2] = weight‖2
self.connections[node1][node2] = weight‖self.connections[node2][node1] = weight‖2
def prims_algo(‖graph: GraphUndirectedWeighted[T],‖1
graph: GraphUndirectedWeighted[T],‖) -> tuple[dict[T, int], dict[T, T | None]]:‖1
dist: dict[T, int] = {node: maxsize for node in graph.connections}‖parent: dict[T, T | None] = {node: None for node in graph.connections}‖1
priority_queue: MinPriorityQueue[T] = MinPriorityQueue()‖for node, weight in dist.items():‖1
for node, weight in dist.items():‖priority_queue.push(node, weight)‖1
if priority_queue.is_empty():‖return dist, parent‖1
node = priority_queue.extract_min()‖dist[node] = 0‖1
dist[node] = 0‖for neighbour in graph.connections[node]:‖1
for neighbour in graph.connections[node]:‖if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:‖2
if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:‖dist[neighbour] = dist[node] + graph.connections[node][neighbour]‖2
dist[neighbour] = dist[node] + graph.connections[node][neighbour]‖priority_queue.update_key(neighbour, dist[neighbour])‖2
priority_queue.update_key(neighbour, dist[neighbour])‖parent[neighbour] = node‖2
while not priority_queue.is_empty():‖node = priority_queue.extract_min()‖1
node = priority_queue.extract_min()‖for neighbour in graph.connections[node]:‖1
parent[neighbour] = node‖return dist, parent‖1
def random_graph(‖vertices_number: int, probability: float, directed: bool = False‖1
vertices_number: int, probability: float, directed: bool = False‖) -> dict:‖1
) -> dict:‖graph: dict = {i: [] for i in range(vertices_number)}‖1
if probability >= 1:‖return complete_graph(vertices_number)‖1
if probability <= 0:‖return graph‖1
for i in range(vertices_number):‖for j in range(i + 1, vertices_number):‖1
for j in range(i + 1, vertices_number):‖if random.random() < probability:‖1
if random.random() < probability:‖graph[i].append(j)‖1
graph[i].append(j)‖if not directed:‖1
graph[j].append(i)‖return graph‖1
def complete_graph(vertices_number: int) -> dict:‖return {‖1
return {‖i: [j for j in range(vertices_number) if i != j] for i in range(vertices_number)‖1
i: [j for j in range(vertices_number) if i != j] for i in range(vertices_number)‖}‖1
def test_kruskal_successful_result():‖num_nodes = 9‖1
num_nodes = 9‖edges = [‖1
edges = [‖[0, 1, 4],‖2
[0, 1, 4],‖[0, 7, 8],‖2
[0, 7, 8],‖[1, 2, 8],‖2
[1, 2, 8],‖[7, 8, 7],‖2
[7, 8, 7],‖[7, 6, 1],‖2
[7, 6, 1],‖[2, 8, 2],‖4
[2, 8, 2],‖[8, 6, 6],‖2
[8, 6, 6],‖[2, 3, 7],‖2
[2, 3, 7],‖[2, 5, 4],‖2
[2, 5, 4],‖[6, 5, 2],‖2
[6, 5, 2],‖[3, 5, 14],‖2
[3, 5, 14],‖[3, 4, 9],‖2
[3, 4, 9],‖[5, 4, 10],‖2
[5, 4, 10],‖[1, 7, 11],‖2
[1, 7, 11],‖]‖2
expected = [‖[7, 6, 1],‖2
[2, 8, 2],‖[6, 5, 2],‖2
[6, 5, 2],‖[0, 1, 4],‖2
[0, 1, 4],‖[2, 5, 4],‖2
[2, 5, 4],‖[2, 3, 7],‖2
[2, 3, 7],‖[0, 7, 8],‖2
[0, 7, 8],‖[3, 4, 9],‖2
[3, 4, 9],‖]‖2
@dataclass‖class GasStation:‖1
class GasStation:‖gas_quantity: int‖1
gas_quantity: int‖cost: int‖1
def get_gas_stations(‖gas_quantities: list[int], costs: list[int]‖1
gas_quantities: list[int], costs: list[int]‖) -> tuple[GasStation, ...]:‖1
) -> tuple[GasStation, ...]:‖return tuple(‖1
return tuple(‖GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)‖1
GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)‖)‖1
def can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:‖total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)‖1
total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)‖total_cost = sum(gas_station.cost for gas_station in gas_stations)‖1
total_cost = sum(gas_station.cost for gas_station in gas_stations)‖if total_gas < total_cost:‖1
if total_gas < total_cost:‖return -1‖1
start = 0‖net = 0‖1
net = 0‖for i, gas_station in enumerate(gas_stations):‖1
for i, gas_station in enumerate(gas_stations):‖net += gas_station.gas_quantity - gas_station.cost‖1
net += gas_station.gas_quantity - gas_station.cost‖if net < 0:‖1
if net < 0:‖start = i + 1‖1
start = i + 1‖net = 0‖1
net = 0‖return start‖1
def dfs(u):‖global graph, reversed_graph, scc, component, visit, stack‖1
global graph, reversed_graph, scc, component, visit, stack‖if visit[u]:‖2
if visit[u]:‖return‖2
return‖visit[u] = True‖2
visit[u] = True‖for v in graph[u]:‖1
for v in graph[u]:‖dfs(v)‖1
dfs(v)‖stack.append(u)‖1
def dfs2(u):‖global graph, reversed_graph, scc, component, visit, stack‖1
visit[u] = True‖component.append(u)‖1
component.append(u)‖for v in reversed_graph[u]:‖1
for v in reversed_graph[u]:‖dfs2(v)‖1
def kosaraju():‖global graph, reversed_graph, scc, component, visit, stack‖1
global graph, reversed_graph, scc, component, visit, stack‖for i in range(n):‖1
for i in range(n):‖dfs(i)‖1
dfs(i)‖visit = [False] * n‖1
visit = [False] * n‖for i in stack[::-1]:‖1
for i in stack[::-1]:‖if visit[i]:‖1
if visit[i]:‖continue‖1
continue‖component = []‖1
component = []‖dfs2(i)‖1
dfs2(i)‖scc.append(component)‖1
scc.append(component)‖return scc‖1
graph: list[list[int]] = [[] for _ in range(n)]‖reversed_graph: list[list[int]] = [[] for i in range(n)]‖1
for _ in range(m):‖u, v = list(map(int, input().strip().split()))‖1
u, v = list(map(int, input().strip().split()))‖graph[u].append(v)‖1
graph[u].append(v)‖reversed_graph[v].append(u)‖1
stack: list[int] = []‖visit: list[bool] = [False] * n‖1
visit: list[bool] = [False] * n‖scc: list[int] = []‖1
scc: list[int] = []‖component: list[int] = []‖1
component: list[int] = []‖print(kosaraju())‖1
import heapq as hq‖import math‖1
import math‖from collections.abc import Iterator‖1
def __init__(self, id_):‖self.id = str(id_)‖1
self.id = str(id_)‖self.key = None‖1
self.key = None‖self.pi = None‖1
self.pi = None‖self.neighbors = []‖1
self.neighbors = []‖self.edges = {}‖1
def __lt__(self, other):‖return self.key < other.key‖1
def __repr__(self):‖return self.id‖1
def add_neighbor(self, vertex):‖self.neighbors.append(vertex)‖1
def add_edge(self, vertex, weight):‖self.edges[vertex.id] = weight‖1
graph[a - 1].add_neighbor(graph[b - 1])‖graph[b - 1].add_neighbor(graph[a - 1])‖1
graph[a - 1].add_edge(graph[b - 1], edge)‖graph[b - 1].add_edge(graph[a - 1], edge)‖1
def prim(graph: list, root: Vertex) -> list:‖a = []‖1
a = []‖for u in graph:‖1
for u in graph:‖u.key = math.inf‖2
u.key = math.inf‖u.pi = None‖2
u.pi = None‖root.key = 0‖2
root.key = 0‖q = graph[:]‖1
q = graph[:]‖while q:‖1
while q:‖u = min(q)‖1
u = min(q)‖q.remove(u)‖1
q.remove(u)‖for v in u.neighbors:‖1
for v in u.neighbors:‖if (v in q) and (u.edges[v.id] < v.key):‖1
if (v in q) and (u.edges[v.id] < v.key):‖v.pi = u‖1
v.pi = u‖v.key = u.edges[v.id]‖2
v.key = u.edges[v.id]‖for i in range(1, len(graph)):‖1
for i in range(1, len(graph)):‖a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))‖1
a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))‖return a‖1
def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:‖for u in graph:‖1
h = list(graph)‖hq.heapify(h)‖1
while h:‖u = hq.heappop(h)‖1
u = hq.heappop(h)‖for v in u.neighbors:‖1
for v in u.neighbors:‖if (v in h) and (u.edges[v.id] < v.key):‖1
if (v in h) and (u.edges[v.id] < v.key):‖v.pi = u‖1
v.key = u.edges[v.id]‖hq.heapify(h)‖1
for i in range(1, len(graph)):‖yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)‖1
def fractional_knapsack(‖value: list[int], weight: list[int], capacity: int‖1
value: list[int], weight: list[int], capacity: int‖) -> tuple[float, list[float]]:‖1
) -> tuple[float, list[float]]:‖index = list(range(len(value)))‖1
index = list(range(len(value)))‖ratio = [v / w for v, w in zip(value, weight)]‖1
ratio = [v / w for v, w in zip(value, weight)]‖index.sort(key=lambda i: ratio[i], reverse=True)‖1
max_value: float = 0‖fractions: list[float] = [0] * len(value)‖1
fractions: list[float] = [0] * len(value)‖for i in index:‖1
for i in index:‖if weight[i] <= capacity:‖1
if weight[i] <= capacity:‖fractions[i] = 1‖1
fractions[i] = 1‖max_value += value[i]‖1
max_value += value[i]‖capacity -= weight[i]‖1
capacity -= weight[i]‖else:‖1
else:‖fractions[i] = capacity / weight[i]‖1
fractions[i] = capacity / weight[i]‖max_value += value[i] * capacity / weight[i]‖1
max_value += value[i] * capacity / weight[i]‖break‖1
n = len(g)‖stack: deque[int] = deque()‖1
stack: deque[int] = deque()‖on_stack = [False for _ in range(n)]‖1
on_stack = [False for _ in range(n)]‖index_of = [-1 for _ in range(n)]‖1
index_of = [-1 for _ in range(n)]‖lowlink_of = index_of[:]‖1
def strong_connect(v: int, index: int, components: list[list[int]]) -> int:‖index_of[v] = index‖1
index_of[v] = index‖lowlink_of[v] = index‖1
lowlink_of[v] = index‖index += 1‖1
index += 1‖stack.append(v)‖1
stack.append(v)‖on_stack[v] = True‖1
for w in g[v]:‖if index_of[w] == -1:‖1
if index_of[w] == -1:‖index = strong_connect(w, index, components)‖1
index = strong_connect(w, index, components)‖lowlink_of[v] = (‖1
lowlink_of[v] = (‖lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]‖2
lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]‖)‖2
)‖elif on_stack[w]:‖1
elif on_stack[w]:‖lowlink_of[v] = (‖1
if lowlink_of[v] == index_of[v]:‖component = []‖1
component = []‖w = stack.pop()‖1
w = stack.pop()‖on_stack[w] = False‖2
on_stack[w] = False‖component.append(w)‖2
component.append(w)‖while w != v:‖1
while w != v:‖w = stack.pop()‖1
component.append(w)‖components.append(component)‖1
components.append(component)‖return index‖1
components: list[list[int]] = []‖for v in range(n):‖1
for v in range(n):‖if index_of[v] == -1:‖1
if index_of[v] == -1:‖strong_connect(v, 0, components)‖1
def create_graph(n: int, edges: list[tuple[int, int]]) -> list[list[int]]:‖g: list[list[int]] = [[] for _ in range(n)]‖1
g: list[list[int]] = [[] for _ in range(n)]‖for u, v in edges:‖1
for u, v in edges:‖g[u].append(v)‖1
g[u].append(v)‖return g‖1
n_vertices = 7‖source = [0, 0, 1, 2, 3, 3, 4, 4, 6]‖1
source = [0, 0, 1, 2, 3, 3, 4, 4, 6]‖target = [1, 3, 2, 0, 1, 4, 5, 6, 5]‖1
target = [1, 3, 2, 0, 1, 4, 5, 6, 5]‖edges = list(zip(source, target))‖1
edges = list(zip(source, target))‖g = create_graph(n_vertices, edges)‖1
def find_minimum_change(denominations: list[int], value: str) -> list[int]:‖total_value = int(value)‖1
while int(total_value) >= int(denomination):‖total_value -= int(denomination)‖1
total_value -= int(denomination)‖answer.append(denomination)‖1
"if __name__ == ""__main__"":"‖denominations = []‖1
denominations = []‖"value = ""0"""‖1
if (‖"input(""Do you want to enter your denominations ? (yY/n): "").strip().lower()"‖1
"input(""Do you want to enter your denominations ? (yY/n): "").strip().lower()"‖"== ""y"""‖1
"== ""y"""‖):‖1
):‖"n = int(input(""Enter the number of denominations you want to add: "").strip())"‖1
for i in range(n):‖"denominations.append(int(input(f""Denomination {i}: "").strip()))"‖1
"denominations.append(int(input(f""Denomination {i}: "").strip()))"‖"value = input(""Enter the change you want to make in Indian Currency: "").strip()"‖1
"value = input(""Enter the change you want to make in Indian Currency: "").strip()"‖else:‖1
denominations = [1, 2, 5, 10, 20, 50, 100, 500, 2000]‖"value = input(""Enter the change you want to make: "").strip()"‖1
if int(value) == 0 or int(value) < 0:‖"print(""The total value cannot be zero or negative."")"‖1
else:‖"print(f""Following is minimal change for {value}: "")"‖1
"print(f""Following is minimal change for {value}: "")"‖answer = find_minimum_change(denominations, value)‖1
for i in range(len(answer)):‖"print(answer[i], end="" "")"‖1
def test_prim_successful_result():‖num_nodes, num_edges = 9, 14  # noqa: F841‖1
num_nodes, num_edges = 9, 14  # noqa: F841‖edges = [‖1
adjacency = defaultdict(list)‖for node1, node2, cost in edges:‖1
for node1, node2, cost in edges:‖adjacency[node1].append([node2, cost])‖1
adjacency[node1].append([node2, cost])‖adjacency[node2].append([node1, cost])‖1
for answer in expected:‖edge = tuple(answer[:2])‖1
edge = tuple(answer[:2])‖reverse = tuple(edge[::-1])‖1
reverse = tuple(edge[::-1])‖assert edge in result or reverse in result‖1
class Node:‖def __init__(self, name):‖1
def __init__(self, name):‖self.name = name‖1
self.name = name‖self.inbound = []‖1
self.inbound = []‖self.outbound = []‖1
def add_inbound(self, node):‖self.inbound.append(node)‖1
def add_outbound(self, node):‖self.outbound.append(node)‖1
def __repr__(self):‖"return f""<node={self.name} inbound={self.inbound} outbound={self.outbound}>"""‖1
def page_rank(nodes, limit=3, d=0.85):‖ranks = {}‖1
ranks = {}‖for node in nodes:‖1
for node in nodes:‖ranks[node.name] = 1‖1
outbounds = {}‖for node in nodes:‖1
for node in nodes:‖outbounds[node.name] = len(node.outbound)‖1
for i in range(limit):‖"print(f""======= Iteration {i + 1} ======="")"‖1
"print(f""======= Iteration {i + 1} ======="")"‖for _, node in enumerate(nodes):‖1
for _, node in enumerate(nodes):‖ranks[node.name] = (1 - d) + d * sum(‖1
ranks[node.name] = (1 - d) + d * sum(‖ranks[ib] / outbounds[ib] for ib in node.inbound‖1
ranks[ib] / outbounds[ib] for ib in node.inbound‖)‖1
)‖print(ranks)‖1
def main():‖"names = list(input(""Enter Names of the Nodes: "").split())"‖1
for ri, row in enumerate(graph):‖for ci, col in enumerate(row):‖1
for ci, col in enumerate(row):‖if col == 1:‖1
if col == 1:‖nodes[ci].add_inbound(names[ri])‖1
nodes[ci].add_inbound(names[ri])‖nodes[ri].add_outbound(names[ci])‖1
"print(""======= Nodes ======="")"‖for node in nodes:‖1
def __init__(self, data: T) -> None:‖self.data = data‖1
self.data = data‖self.parent = self‖1
self.parent = self‖self.rank = 0‖1
elem_ref = self.map[data]‖if elem_ref != elem_ref.parent:‖1
if elem_ref != elem_ref.parent:‖elem_ref.parent = self.find_set(elem_ref.parent.data)‖1
elem_ref.parent = self.find_set(elem_ref.parent.data)‖return elem_ref.parent‖1
def link(‖self, node1: DisjointSetTreeNode[T], node2: DisjointSetTreeNode[T]‖1
self, node1: DisjointSetTreeNode[T], node2: DisjointSetTreeNode[T]‖) -> None:‖1
if node1.rank > node2.rank:‖node2.parent = node1‖1
node2.parent = node1‖else:‖1
else:‖node1.parent = node2‖1
node1.parent = node2‖if node1.rank == node2.rank:‖1
if node1.rank == node2.rank:‖node2.rank += 1‖1
class GraphUndirectedWeighted(Generic[T]):‖def __init__(self) -> None:‖1
edges = []‖seen = set()‖1
seen = set()‖for start in self.connections:‖1
for start in self.connections:‖for end in self.connections[start]:‖1
for end in self.connections[start]:‖if (start, end) not in seen:‖1
if (start, end) not in seen:‖seen.add((end, start))‖1
seen.add((end, start))‖edges.append((start, end, self.connections[start][end]))‖1
edges.append((start, end, self.connections[start][end]))‖edges.sort(key=lambda x: x[2])‖1
disjoint_set = DisjointSetTree[T]()‖for node in self.connections:‖1
for node in self.connections:‖disjoint_set.make_set(node)‖1
num_edges = 0‖index = 0‖1
index = 0‖graph = GraphUndirectedWeighted[T]()‖1
graph = GraphUndirectedWeighted[T]()‖while num_edges < len(self.connections) - 1:‖1
while num_edges < len(self.connections) - 1:‖u, v, w = edges[index]‖1
u, v, w = edges[index]‖index += 1‖1
index += 1‖parent_u = disjoint_set.find_set(u)‖1
parent_u = disjoint_set.find_set(u)‖parent_v = disjoint_set.find_set(v)‖1
parent_v = disjoint_set.find_set(v)‖if parent_u != parent_v:‖1
if parent_u != parent_v:‖num_edges += 1‖1
num_edges += 1‖graph.add_edge(u, v, w)‖1
graph.add_edge(u, v, w)‖disjoint_set.union(u, v)‖1
disjoint_set.union(u, v)‖return graph‖1
def max_profit(prices: list[int]) -> int:‖if not prices:‖1
if not prices:‖return 0‖1
min_price = prices[0]‖max_profit: int = 0‖1
for price in prices:‖min_price = min(price, min_price)‖1
min_price = min(price, min_price)‖max_profit = max(price - min_price, max_profit)‖1
doctest.testmod()‖print(max_profit([7, 1, 5, 3, 6, 4]))‖1
from dataclasses import dataclass‖from operator import attrgetter‖2
@dataclass‖class Item:‖1
class Item:‖weight: int‖1
weight: int‖value: int‖1
@property‖def ratio(self) -> float:‖1
def ratio(self) -> float:‖return self.value / self.weight‖1
def fractional_cover(items: list[Item], capacity: int) -> float:‖if capacity < 0:‖1
if capacity < 0:‖"raise ValueError(""Capacity cannot be negative"")"‖1
total_value = 0.0‖remaining_capacity = capacity‖1
"for item in sorted(items, key=attrgetter(""ratio""), reverse=True):"‖if remaining_capacity == 0:‖1
if remaining_capacity == 0:‖break‖1
weight_taken = min(item.weight, remaining_capacity)‖total_value += weight_taken * item.ratio‖1
total_value += weight_taken * item.ratio‖remaining_capacity -= weight_taken‖1
if result := doctest.testmod().failed:‖"print(f""{result} test(s) failed"")"‖1
"print(f""{result} test(s) failed"")"‖else:‖1
else:‖"print(""All tests passed"")"‖1
"def text_to_bits(text, encoding=""utf-8"", errors=""surrogatepass""):"‖"bits = bin(int.from_bytes(text.encode(encoding, errors), ""big""))[2:]"‖1
"bits = bin(int.from_bytes(text.encode(encoding, errors), ""big""))[2:]"‖return bits.zfill(8 * ((len(bits) + 7) // 8))‖1
"def text_from_bits(bits, encoding=""utf-8"", errors=""surrogatepass""):"‖n = int(bits, 2)‖1
n = int(bits, 2)‖"return n.to_bytes((n.bit_length() + 7) // 8, ""big"").decode(encoding, errors) or ""\0"""‖1
def emitter_converter(size_par, data):‖if size_par + len(data) <= 2**size_par - (len(data) - 1):‖1
if size_par + len(data) <= 2**size_par - (len(data) - 1):‖"raise ValueError(""size of parity don't match with size of data"")"‖1
data_out = []‖parity = []‖2
parity = []‖bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]‖1
if qtd_bp < size_par:‖if (np.log(x) / np.log(2)).is_integer():‖1
if (np.log(x) / np.log(2)).is_integer():‖"data_out_gab.append(""P"")"‖1
"data_out_gab.append(""P"")"‖qtd_bp = qtd_bp + 1‖3
qtd_bp = qtd_bp + 1‖else:‖3
else:‖"data_out_gab.append(""D"")"‖4
"data_out_gab.append(""D"")"‖else:‖1
"if data_out_gab[-1] == ""D"":"‖data_ord.append(data[cont_data])‖1
data_ord.append(data[cont_data])‖cont_data += 1‖1
cont_data += 1‖else:‖2
else:‖data_ord.append(None)‖2
qtd_bp = 0‖for bp in range(1, size_par + 1):‖2
for cont_loop, x in enumerate(data_ord):‖if x is not None:‖2
if x is not None:‖try:‖2
try:‖aux = (bin_pos[cont_loop])[-1 * (bp)]‖2
aux = (bin_pos[cont_loop])[-1 * (bp)]‖except IndexError:‖2
except IndexError:‖"aux = ""0"""‖2
"aux = ""0"""‖"if aux == ""1"" and x == ""1"":"‖2
"if aux == ""1"" and x == ""1"":"‖cont_bo += 1‖2
cont_bo += 1‖parity.append(cont_bo % 2)‖1
cont_bp = 0‖for x in range(size_par + len(data)):‖1
for x in range(size_par + len(data)):‖if data_ord[x] is None:‖1
if data_ord[x] is None:‖data_out.append(str(parity[cont_bp]))‖2
data_out.append(str(parity[cont_bp]))‖cont_bp += 1‖2
cont_bp += 1‖else:‖2
else:‖data_out.append(data_ord[x])‖2
parity_received = []‖data_output = []‖1
if qtd_bp < size_par and (np.log(i) / np.log(2)).is_integer():‖"data_out_gab.append(""P"")"‖1
"if data_out_gab[-1] == ""D"":"‖data_output.append(item)‖1
data_output.append(item)‖else:‖1
else:‖parity_received.append(item)‖1
parity = []‖bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data_output) + 1)]‖1
if qtd_bp < size_par and (np.log(x) / np.log(2)).is_integer():‖"data_out_gab.append(""P"")"‖1
"if data_out_gab[-1] == ""D"":"‖data_ord.append(data_output[cont_data])‖1
data_ord.append(data_output[cont_data])‖cont_data += 1‖1
cont_bo = 0‖for cont_loop, x in enumerate(data_ord):‖1
cont_bo += 1‖parity.append(str(cont_bo % 2))‖1
cont_bp = 0‖for x in range(size_par + len(data_output)):‖1
for x in range(size_par + len(data_output)):‖if data_ord[x] is None:‖1
ack = parity_received == parity‖return data_output, ack‖1
def validate_adjacency_list(graph: list[list[int | None]]) -> None:‖if not isinstance(graph, list):‖1
if not isinstance(graph, list):‖"raise ValueError(""Graph should be a list of lists."")"‖1
for node_index, neighbors in enumerate(graph):‖if not isinstance(neighbors, list):‖1
if not isinstance(neighbors, list):‖no_neighbors_message: str = (‖1
no_neighbors_message: str = (‖"f""Node {node_index} should have a list of neighbors."""‖1
"f""Node {node_index} should have a list of neighbors."""‖)‖1
)‖raise ValueError(no_neighbors_message)‖1
raise ValueError(no_neighbors_message)‖for neighbor_index in neighbors:‖1
for neighbor_index in neighbors:‖if (‖1
if (‖not isinstance(neighbor_index, int)‖1
not isinstance(neighbor_index, int)‖or neighbor_index < 0‖1
or neighbor_index < 0‖or neighbor_index >= len(graph)‖1
or neighbor_index >= len(graph)‖):‖1
):‖invalid_neighbor_message: str = (‖1
invalid_neighbor_message: str = (‖"f""Invalid neighbor {neighbor_index} in node {node_index} """‖1
"f""Invalid neighbor {neighbor_index} in node {node_index} """‖"f""adjacency list."""‖1
"f""adjacency list."""‖)‖1
)‖raise ValueError(invalid_neighbor_message)‖1
def lanczos_iteration(‖graph: list[list[int | None]], num_eigenvectors: int‖1
graph: list[list[int | None]], num_eigenvectors: int‖) -> tuple[np.ndarray, np.ndarray]:‖2
) -> tuple[np.ndarray, np.ndarray]:‖num_nodes: int = len(graph)‖1
num_nodes: int = len(graph)‖if not (1 <= num_eigenvectors <= num_nodes):‖1
if not (1 <= num_eigenvectors <= num_nodes):‖raise ValueError(‖1
raise ValueError(‖"""Number of eigenvectors must be between 1 and the number of """‖1
"""Number of eigenvectors must be between 1 and the number of """‖"""nodes in the graph."""‖1
"""nodes in the graph."""‖)‖1
orthonormal_basis: np.ndarray = np.zeros((num_nodes, num_eigenvectors))‖tridiagonal_matrix: np.ndarray = np.zeros((num_eigenvectors, num_eigenvectors))‖1
rng = np.random.default_rng()‖initial_vector: np.ndarray = rng.random(num_nodes)‖1
initial_vector: np.ndarray = rng.random(num_nodes)‖initial_vector /= np.sqrt(np.dot(initial_vector, initial_vector))‖1
initial_vector /= np.sqrt(np.dot(initial_vector, initial_vector))‖orthonormal_basis[:, 0] = initial_vector‖1
prev_beta: float = 0.0‖for iter_index in range(num_eigenvectors):‖1
for iter_index in range(num_eigenvectors):‖result_vector: np.ndarray = multiply_matrix_vector(‖1
result_vector: np.ndarray = multiply_matrix_vector(‖graph, orthonormal_basis[:, iter_index]‖1
graph, orthonormal_basis[:, iter_index]‖)‖1
)‖if iter_index > 0:‖1
if iter_index > 0:‖result_vector -= prev_beta * orthonormal_basis[:, iter_index - 1]‖1
result_vector -= prev_beta * orthonormal_basis[:, iter_index - 1]‖alpha_value: float = np.dot(orthonormal_basis[:, iter_index], result_vector)‖1
alpha_value: float = np.dot(orthonormal_basis[:, iter_index], result_vector)‖result_vector -= alpha_value * orthonormal_basis[:, iter_index]‖1
prev_beta = np.sqrt(np.dot(result_vector, result_vector))‖if iter_index < num_eigenvectors - 1 and prev_beta > 1e-10:‖1
if iter_index < num_eigenvectors - 1 and prev_beta > 1e-10:‖orthonormal_basis[:, iter_index + 1] = result_vector / prev_beta‖1
orthonormal_basis[:, iter_index + 1] = result_vector / prev_beta‖tridiagonal_matrix[iter_index, iter_index] = alpha_value‖1
tridiagonal_matrix[iter_index, iter_index] = alpha_value‖if iter_index < num_eigenvectors - 1:‖1
if iter_index < num_eigenvectors - 1:‖tridiagonal_matrix[iter_index, iter_index + 1] = prev_beta‖1
tridiagonal_matrix[iter_index, iter_index + 1] = prev_beta‖tridiagonal_matrix[iter_index + 1, iter_index] = prev_beta‖1
tridiagonal_matrix[iter_index + 1, iter_index] = prev_beta‖return tridiagonal_matrix, orthonormal_basis‖1
def multiply_matrix_vector(‖graph: list[list[int | None]], vector: np.ndarray‖1
graph: list[list[int | None]], vector: np.ndarray‖) -> np.ndarray:‖1
) -> np.ndarray:‖num_nodes: int = len(graph)‖1
num_nodes: int = len(graph)‖if vector.shape[0] != num_nodes:‖1
if vector.shape[0] != num_nodes:‖"raise ValueError(""Vector length must match the number of nodes in the graph."")"‖1
result: np.ndarray = np.zeros(num_nodes)‖for node_index, neighbors in enumerate(graph):‖1
for node_index, neighbors in enumerate(graph):‖for neighbor_index in neighbors:‖1
for neighbor_index in neighbors:‖result[node_index] += vector[neighbor_index]‖1
result[node_index] += vector[neighbor_index]‖return result‖1
def find_lanczos_eigenvectors(‖graph: list[list[int | None]], num_eigenvectors: int‖1
) -> tuple[np.ndarray, np.ndarray]:‖validate_adjacency_list(graph)‖1
validate_adjacency_list(graph)‖tridiagonal_matrix, orthonormal_basis = lanczos_iteration(graph, num_eigenvectors)‖1
tridiagonal_matrix, orthonormal_basis = lanczos_iteration(graph, num_eigenvectors)‖eigenvalues, eigenvectors = np.linalg.eigh(tridiagonal_matrix)‖1
eigenvalues, eigenvectors = np.linalg.eigh(tridiagonal_matrix)‖return eigenvalues[::-1], np.dot(orthonormal_basis, eigenvectors[:, ::-1])‖1
def main() -> None:‖import doctest‖1
def topology_sort(‖graph: dict[int, list[int]], vert: int, visited: list[bool]‖1
graph: dict[int, list[int]], vert: int, visited: list[bool]‖) -> list[int]:‖1
visited[vert] = True‖order = []‖1
if not visited[neighbour]:‖order += topology_sort(graph, neighbour, visited)‖1
def find_components(‖reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]‖1
reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]‖) -> list[int]:‖1
visited[vert] = True‖component = [vert]‖1
for neighbour in reversed_graph[vert]:‖if not visited[neighbour]:‖1
if not visited[neighbour]:‖component += find_components(reversed_graph, neighbour, visited)‖1
visited = len(graph) * [False]‖reversed_graph: dict[int, list[int]] = {vert: [] for vert in range(len(graph))}‖1
for vert, neighbours in graph.items():‖for neighbour in neighbours:‖1
for neighbour in neighbours:‖reversed_graph[neighbour].append(vert)‖1
order = []‖for i, was_visited in enumerate(visited):‖1
for i, was_visited in enumerate(visited):‖if not was_visited:‖1
if not was_visited:‖order += topology_sort(graph, i, visited)‖1
components_list = []‖visited = len(graph) * [False]‖1
for i in range(len(graph)):‖vert = order[len(graph) - i - 1]‖1
vert = order[len(graph) - i - 1]‖if not visited[vert]:‖1
if not visited[vert]:‖component = find_components(reversed_graph, vert, visited)‖1
component = find_components(reversed_graph, vert, visited)‖components_list.append(component)‖1
from heapq import heappop, heappush‖from sys import maxsize‖1
min_heap: list[tuple[int, int, int]] = []‖current_max = -maxsize - 1‖1
for i, items in enumerate(nums):‖heappush(min_heap, (items[0], i, 0))‖1
heappush(min_heap, (items[0], i, 0))‖current_max = max(current_max, items[0])‖1
while min_heap:‖current_min, list_index, element_index = heappop(min_heap)‖1
if current_max - current_min < smallest_range[1] - smallest_range[0]:‖smallest_range = [current_min, current_max]‖1
if element_index == len(nums[list_index]) - 1:‖break‖1
next_element = nums[list_index][element_index + 1]‖heappush(min_heap, (next_element, list_index, element_index + 1))‖1
heappush(min_heap, (next_element, list_index, element_index + 1))‖current_max = max(current_max, next_element)‖1
testmod()‖"print(f""{smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]])}"")"‖1
import argparse‖import struct‖1
import struct‖import unittest‖1
def __init__(self, data: bytes) -> None:‖self.data = data‖1
self.hashes = [‖0x6A09E667,‖1
0x6A09E667,‖0xBB67AE85,‖1
0xBB67AE85,‖0x3C6EF372,‖1
0x3C6EF372,‖0xA54FF53A,‖1
0xA54FF53A,‖0x510E527F,‖1
0x510E527F,‖0x9B05688C,‖1
0x9B05688C,‖0x1F83D9AB,‖1
0x1F83D9AB,‖0x5BE0CD19,‖1
0x5BE0CD19,‖]‖1
self.round_constants = [‖0x428A2F98,‖1
0x428A2F98,‖0x71374491,‖1
0x71374491,‖0xB5C0FBCF,‖1
0xB5C0FBCF,‖0xE9B5DBA5,‖1
0xE9B5DBA5,‖0x3956C25B,‖1
0x3956C25B,‖0x59F111F1,‖1
0x59F111F1,‖0x923F82A4,‖1
0x923F82A4,‖0xAB1C5ED5,‖1
0xAB1C5ED5,‖0xD807AA98,‖1
0xD807AA98,‖0x12835B01,‖1
0x12835B01,‖0x243185BE,‖1
0x243185BE,‖0x550C7DC3,‖1
0x550C7DC3,‖0x72BE5D74,‖1
0x72BE5D74,‖0x80DEB1FE,‖1
0x80DEB1FE,‖0x9BDC06A7,‖1
0x9BDC06A7,‖0xC19BF174,‖1
0xC19BF174,‖0xE49B69C1,‖1
0xE49B69C1,‖0xEFBE4786,‖1
0xEFBE4786,‖0x0FC19DC6,‖1
0x0FC19DC6,‖0x240CA1CC,‖1
0x240CA1CC,‖0x2DE92C6F,‖1
0x2DE92C6F,‖0x4A7484AA,‖1
0x4A7484AA,‖0x5CB0A9DC,‖1
0x5CB0A9DC,‖0x76F988DA,‖1
0x76F988DA,‖0x983E5152,‖1
0x983E5152,‖0xA831C66D,‖1
0xA831C66D,‖0xB00327C8,‖1
0xB00327C8,‖0xBF597FC7,‖1
0xBF597FC7,‖0xC6E00BF3,‖1
0xC6E00BF3,‖0xD5A79147,‖1
0xD5A79147,‖0x06CA6351,‖1
0x06CA6351,‖0x14292967,‖1
0x14292967,‖0x27B70A85,‖1
0x27B70A85,‖0x2E1B2138,‖1
0x2E1B2138,‖0x4D2C6DFC,‖1
0x4D2C6DFC,‖0x53380D13,‖1
0x53380D13,‖0x650A7354,‖1
0x650A7354,‖0x766A0ABB,‖1
0x766A0ABB,‖0x81C2C92E,‖1
0x81C2C92E,‖0x92722C85,‖1
0x92722C85,‖0xA2BFE8A1,‖1
0xA2BFE8A1,‖0xA81A664B,‖1
0xA81A664B,‖0xC24B8B70,‖1
0xC24B8B70,‖0xC76C51A3,‖1
0xC76C51A3,‖0xD192E819,‖1
0xD192E819,‖0xD6990624,‖1
0xD6990624,‖0xF40E3585,‖1
0xF40E3585,‖0x106AA070,‖1
0x106AA070,‖0x19A4C116,‖1
0x19A4C116,‖0x1E376C08,‖1
0x1E376C08,‖0x2748774C,‖1
0x2748774C,‖0x34B0BCB5,‖1
0x34B0BCB5,‖0x391C0CB3,‖1
0x391C0CB3,‖0x4ED8AA4A,‖1
0x4ED8AA4A,‖0x5B9CCA4F,‖1
0x5B9CCA4F,‖0x682E6FF3,‖1
0x682E6FF3,‖0x748F82EE,‖1
0x748F82EE,‖0x78A5636F,‖1
0x78A5636F,‖0x84C87814,‖1
0x84C87814,‖0x8CC70208,‖1
0x8CC70208,‖0x90BEFFFA,‖1
0x90BEFFFA,‖0xA4506CEB,‖1
0xA4506CEB,‖0xBEF9A3F7,‖1
0xBEF9A3F7,‖0xC67178F2,‖1
0xC67178F2,‖]‖1
self.preprocessed_data = self.preprocessing(self.data)‖self.final_hash()‖1
@staticmethod‖def preprocessing(data: bytes) -> bytes:‖1
def preprocessing(data: bytes) -> bytes:‖"padding = b""\x80"" + (b""\x00"" * (63 - (len(data) + 8) % 64))"‖1
"padding = b""\x80"" + (b""\x00"" * (63 - (len(data) + 8) % 64))"‖"big_endian_integer = struct.pack("">Q"", (len(data) * 8))"‖1
"big_endian_integer = struct.pack("">Q"", (len(data) * 8))"‖return data + padding + big_endian_integer‖1
self.blocks = [‖self.preprocessed_data[x : x + 64]‖1
self.preprocessed_data[x : x + 64]‖for x in range(0, len(self.preprocessed_data), 64)‖1
for x in range(0, len(self.preprocessed_data), 64)‖]‖1
for index in range(64):‖if index > 15:‖1
s0 = (‖self.ror(words[index - 15], 7)‖1
self.ror(words[index - 15], 7)‖^ self.ror(words[index - 15], 18)‖1
^ self.ror(words[index - 15], 18)‖^ (words[index - 15] >> 3)‖1
^ (words[index - 15] >> 3)‖)‖1
)‖s1 = (‖1
s1 = (‖self.ror(words[index - 2], 17)‖1
self.ror(words[index - 2], 17)‖^ self.ror(words[index - 2], 19)‖1
^ self.ror(words[index - 2], 19)‖^ (words[index - 2] >> 10)‖1
^ (words[index - 2] >> 10)‖)‖1
words[index] = (‖words[index - 16] + s0 + words[index - 7] + s1‖1
words[index - 16] + s0 + words[index - 7] + s1‖) % 0x100000000‖1
s1 = self.ror(e, 6) ^ self.ror(e, 11) ^ self.ror(e, 25)‖ch = (e & f) ^ ((~e & (0xFFFFFFFF)) & g)‖1
ch = (e & f) ^ ((~e & (0xFFFFFFFF)) & g)‖temp1 = (‖1
temp1 = (‖h + s1 + ch + self.round_constants[index] + words[index]‖1
h + s1 + ch + self.round_constants[index] + words[index]‖) % 0x100000000‖1
) % 0x100000000‖s0 = self.ror(a, 2) ^ self.ror(a, 13) ^ self.ror(a, 22)‖1
s0 = self.ror(a, 2) ^ self.ror(a, 13) ^ self.ror(a, 22)‖maj = (a & b) ^ (a & c) ^ (b & c)‖1
maj = (a & b) ^ (a & c) ^ (b & c)‖temp2 = (s0 + maj) % 0x100000000‖1
h, g, f, e, d, c, b, a = (‖g,‖1
g,‖f,‖1
f,‖e,‖1
e,‖((d + temp1) % 0x100000000),‖1
((d + temp1) % 0x100000000),‖c,‖1
c,‖b,‖1
b,‖a,‖1
a,‖((temp1 + temp2) % 0x100000000),‖1
((temp1 + temp2) % 0x100000000),‖)‖1
self.hashes = [‖((element + mutated_hash_values[index]) % 0x100000000)‖1
((element + mutated_hash_values[index]) % 0x100000000)‖for index, element in enumerate(self.hashes)‖1
for index, element in enumerate(self.hashes)‖]‖1
def ror(self, value: int, rotations: int) -> int:‖return 0xFFFFFFFF & (value << (32 - rotations)) | (value >> rotations)‖1
def test_match_hashes(self) -> None:‖import hashlib‖1
"msg = bytes(""Test String"", ""utf-8"")"‖assert SHA256(msg).hash == hashlib.sha256(msg).hexdigest()‖1
parser = argparse.ArgumentParser()‖parser.add_argument(‖3
parser.add_argument(‖"""-s"","‖1
"""-s"","‖"""--string"","‖1
"""--string"","‖"dest=""input_string"","‖2
"dest=""input_string"","‖"default=""Hello World!! Welcome to Cryptography"","‖2
"default=""Hello World!! Welcome to Cryptography"","‖"help=""Hash the string"","‖2
"help=""Hash the string"","‖)‖2
)‖parser.add_argument(‖6
parser.add_argument(‖"""-f"", ""--file"", dest=""input_file"", help=""Hash contents of a file"""‖1
"""-f"", ""--file"", dest=""input_file"", help=""Hash contents of a file"""‖)‖1
if args.input_file:‖"with open(args.input_file, ""rb"") as f:"‖2
"with open(args.input_file, ""rb"") as f:"‖hash_input = f.read()‖2
hash_input = f.read()‖else:‖2
else:‖"hash_input = bytes(input_string, ""utf-8"")"‖2
def sdbm(plain_text: str) -> int:‖hash_value = 0‖1
hash_value = 0‖for plain_chr in plain_text:‖1
for plain_chr in plain_text:‖hash_value = (‖1
hash_value = (‖ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value‖1
ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value‖)‖1
)‖return hash_value‖1
def minimum_waiting_time(queries: list[int]) -> int:‖n = len(queries)‖1
n = len(queries)‖if n in (0, 1):‖1
if n in (0, 1):‖return 0‖1
return 0‖return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))‖1
def calc_profit(profit: list, weight: list, max_weight: int) -> int:‖if len(profit) != len(weight):‖1
if len(profit) != len(weight):‖"raise ValueError(""The length of profit and weight must be same."")"‖1
"raise ValueError(""The length of profit and weight must be same."")"‖if max_weight <= 0:‖1
if max_weight <= 0:‖"raise ValueError(""max_weight must greater than zero."")"‖1
"raise ValueError(""max_weight must greater than zero."")"‖if any(p < 0 for p in profit):‖1
if any(p < 0 for p in profit):‖"raise ValueError(""Profit can not be negative."")"‖1
"raise ValueError(""Profit can not be negative."")"‖if any(w < 0 for w in weight):‖1
if any(w < 0 for w in weight):‖"raise ValueError(""Weight can not be negative."")"‖1
length = len(sorted_profit_by_weight)‖limit = 0‖1
limit = 0‖gain = 0‖1
gain = 0‖i = 0‖1
biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]‖index = profit_by_weight.index(biggest_profit_by_weight)‖1
index = profit_by_weight.index(biggest_profit_by_weight)‖profit_by_weight[index] = -1‖1
if max_weight - limit >= weight[index]:‖limit += weight[index]‖1
gain += 1 * profit[index]‖else:‖1
gain += (max_weight - limit) / weight[index] * profit[index]‖break‖1
break‖i += 1‖2
i += 1‖return gain‖1
"if __name__ == ""__main__"":"‖print(‖3
print(‖"""Input profits, weights, and then max_weight (all positive ints) separated by """‖1
"""Input profits, weights, and then max_weight (all positive ints) separated by """‖"""spaces."""‖1
"""spaces."""‖)‖1
"profit = [int(x) for x in input(""Input profits separated by spaces: "").split()]"‖"weight = [int(x) for x in input(""Input weights separated by spaces: "").split()]"‖1
"weight = [int(x) for x in input(""Input weights separated by spaces: "").split()]"‖"max_weight = int(input(""Max weight allowed: ""))"‖1
from bisect import bisect‖from itertools import accumulate‖1
r = sorted(zip(vl, wt), key=lambda x: x[0] / x[1], reverse=True)‖vl, wt = [i[0] for i in r], [i[1] for i in r]‖1
vl, wt = [i[0] for i in r], [i[1] for i in r]‖acc = list(accumulate(wt))‖1
acc = list(accumulate(wt))‖k = bisect(acc, w)‖1
k = bisect(acc, w)‖return (‖1
return (‖0‖1
0‖if k == 0‖1
if k == 0‖else sum(vl[:k]) + (w - acc[k - 1]) * (vl[k]) / (wt[k])‖1
else sum(vl[:k]) + (w - acc[k - 1]) * (vl[k]) / (wt[k])‖if k != n‖1
if k != n‖else sum(vl[:k])‖1
else sum(vl[:k])‖)‖1
def adler32(plain_text: str) -> int:‖a = 1‖1
a = 1‖b = 0‖1
b = 0‖for plain_chr in plain_text:‖1
for plain_chr in plain_text:‖a = (a + ord(plain_chr)) % MOD_ADLER‖1
a = (a + ord(plain_chr)) % MOD_ADLER‖b = (b + a) % MOD_ADLER‖1
b = (b + a) % MOD_ADLER‖return (b << 16) | a‖1
def optimal_merge_pattern(files: list) -> float:‖optimal_merge_cost = 0‖1
optimal_merge_cost = 0‖while len(files) > 1:‖1
while len(files) > 1:‖temp = 0‖1
for _ in range(2):‖min_index = files.index(min(files))‖1
min_index = files.index(min(files))‖temp += files[min_index]‖1
temp += files[min_index]‖files.pop(min_index)‖1
files.pop(min_index)‖files.append(temp)‖1
files.append(temp)‖optimal_merge_cost += temp‖1
optimal_merge_cost += temp‖return optimal_merge_cost‖1
K = [0.33, 0.44, 0.55, 0.44, 0.33]‖t = 3‖1
t = 3‖m = 5‖1
buffer_space: list[float] = []‖params_space: list[float] = []‖1
def push(seed):‖global buffer_space, params_space, machine_time, K, m, t‖1
buffer_space[key] = round(float(r * value * (1 - value)), 10)‖params_space[key] = r‖1
assert max(buffer_space) < 1‖assert max(params_space) < 4‖1
def pull():‖global buffer_space, params_space, machine_time, K, m, t‖1
def xorshift(x, y):‖x ^= y >> 13‖1
x ^= y >> 13‖y ^= x << 17‖1
y ^= x << 17‖x ^= y >> 5‖1
x ^= y >> 5‖return x‖1
r = params_space[key]‖value = buffer_space[key]‖1
buffer_space[key] = round(float(r * value * (1 - value)), 10)‖params_space[key] = (machine_time * 0.01 + r * 1.01) % 1 + 3‖1
x = int(buffer_space[(key + 2) % m] * (10**10))‖y = int(buffer_space[(key - 2) % m] * (10**10))‖1
def reset():‖global buffer_space, params_space, machine_time, K, m, t‖1
buffer_space = K‖params_space = [0] * m‖1
params_space = [0] * m‖machine_time = 0‖1
message = random.sample(range(0xFFFFFFFF), 100)‖for chunk in message:‖1
for chunk in message:‖push(chunk)‖1
"while inp in (""e"", ""E""):"‖"print(f""{format(pull(), '#04x')}"")"‖1
"print(f""{format(pull(), '#04x')}"")"‖print(buffer_space)‖1
print(buffer_space)‖print(params_space)‖1
print(params_space)‖"inp = input(""(e)exit? "").strip()"‖1
def knapsack(‖weights: list, values: list, number_of_items: int, max_weight: int, index: int‖1
weights: list, values: list, number_of_items: int, max_weight: int, index: int‖) -> int:‖1
) -> int:‖if index == number_of_items:‖1
if index == number_of_items:‖return 0‖1
return 0‖ans1 = 0‖1
ans1 = 0‖ans2 = 0‖1
ans2 = 0‖ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)‖1
ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)‖if weights[index] <= max_weight:‖1
if weights[index] <= max_weight:‖ans2 = values[index] + knapsack(‖1
ans2 = values[index] + knapsack(‖weights, values, number_of_items, max_weight - weights[index], index + 1‖1
weights, values, number_of_items, max_weight - weights[index], index + 1‖)‖1
)‖return max(ans1, ans2)‖1
from collections.abc import Generator‖from math import sin‖1
def to_little_endian(string_32: bytes) -> bytes:‖if len(string_32) != 32:‖1
if len(string_32) != 32:‖"raise ValueError(""Input must be of length 32"")"‖1
"little_endian = b"""""‖for i in [3, 2, 1, 0]:‖1
for i in [3, 2, 1, 0]:‖little_endian += string_32[8 * i : 8 * i + 8]‖1
little_endian += string_32[8 * i : 8 * i + 8]‖return little_endian‖1
def reformat_hex(i: int) -> bytes:‖if i < 0:‖1
if i < 0:‖"raise ValueError(""Input must be non-negative"")"‖3
"hex_rep = format(i, ""08x"")[-8:]"‖"little_endian_hex = b"""""‖1
"little_endian_hex = b"""""‖for j in [3, 2, 1, 0]:‖1
for j in [3, 2, 1, 0]:‖"little_endian_hex += hex_rep[2 * j : 2 * j + 2].encode(""utf-8"")"‖1
"little_endian_hex += hex_rep[2 * j : 2 * j + 2].encode(""utf-8"")"‖return little_endian_hex‖1
def preprocess(message: bytes) -> bytes:‖"bit_string = b"""""‖1
"bit_string = b"""""‖for char in message:‖1
for char in message:‖"bit_string += format(char, ""08b"").encode(""utf-8"")"‖1
"bit_string += format(char, ""08b"").encode(""utf-8"")"‖"start_len = format(len(bit_string), ""064b"").encode(""utf-8"")"‖1
"bit_string += b""1"""‖while len(bit_string) % 512 != 448:‖1
while len(bit_string) % 512 != 448:‖"bit_string += b""0"""‖1
"bit_string += b""0"""‖bit_string += to_little_endian(start_len[32:]) + to_little_endian(start_len[:32])‖1
def get_block_words(bit_string: bytes) -> Generator[list[int]]:‖if len(bit_string) % 512 != 0:‖1
if len(bit_string) % 512 != 0:‖"raise ValueError(""Input must have length that's a multiple of 512"")"‖1
for pos in range(0, len(bit_string), 512):‖block = bit_string[pos : pos + 512]‖1
block = bit_string[pos : pos + 512]‖block_words = []‖1
block_words = []‖for i in range(0, 512, 32):‖1
for i in range(0, 512, 32):‖block_words.append(int(to_little_endian(block[i : i + 32]), 2))‖1
block_words.append(int(to_little_endian(block[i : i + 32]), 2))‖yield block_words‖1
def not_32(i: int) -> int:‖if i < 0:‖1
"i_str = format(i, ""032b"")"‖"new_str = """""‖1
"new_str = """""‖for c in i_str:‖1
for c in i_str:‖"new_str += ""1"" if c == ""0"" else ""0"""‖1
"new_str += ""1"" if c == ""0"" else ""0"""‖return int(new_str, 2)‖1
def sum_32(a: int, b: int) -> int:‖return (a + b) % 2**32‖1
def left_rotate_32(i: int, shift: int) -> int:‖if i < 0:‖1
"raise ValueError(""Input must be non-negative"")"‖if shift < 0:‖1
if shift < 0:‖"raise ValueError(""Shift must be non-negative"")"‖1
"raise ValueError(""Shift must be non-negative"")"‖return ((i << shift) ^ (i >> (32 - shift))) % 2**32‖1
a0 = 0x67452301‖b0 = 0xEFCDAB89‖1
b0 = 0xEFCDAB89‖c0 = 0x98BADCFE‖1
c0 = 0x98BADCFE‖d0 = 0x10325476‖1
shift_amounts = [‖7,‖1
7,‖12,‖4
12,‖17,‖4
17,‖22,‖4
22,‖7,‖3
22,‖5,‖1
5,‖9,‖4
9,‖14,‖4
14,‖20,‖4
20,‖5,‖3
20,‖4,‖1
4,‖11,‖4
11,‖16,‖4
16,‖23,‖4
23,‖4,‖3
23,‖6,‖1
6,‖10,‖4
10,‖15,‖4
15,‖21,‖4
21,‖6,‖3
21,‖]‖1
for block_words in get_block_words(bit_string):‖a = a0‖1
a = a0‖b = b0‖1
b = b0‖c = c0‖1
c = c0‖d = d0‖1
for i in range(64):‖if i <= 15:‖1
f = d ^ (b & (c ^ d))‖g = i‖1
g = i‖elif i <= 31:‖1
f = c ^ (d & (b ^ c))‖g = (5 * i + 1) % 16‖1
g = (5 * i + 1) % 16‖elif i <= 47:‖1
elif i <= 47:‖f = b ^ c ^ d‖1
f = b ^ c ^ d‖g = (3 * i + 5) % 16‖1
g = (3 * i + 5) % 16‖else:‖1
else:‖f = c ^ (b | not_32(d))‖1
f = c ^ (b | not_32(d))‖g = (7 * i) % 16‖1
g = (7 * i) % 16‖f = (f + a + added_consts[i] + block_words[g]) % 2**32‖1
f = (f + a + added_consts[i] + block_words[g]) % 2**32‖a = d‖1
a = d‖d = c‖1
d = c‖c = b‖1
c = b‖b = sum_32(b, left_rotate_32(f, shift_amounts[i]))‖1
a0 = sum_32(a0, a)‖b0 = sum_32(b0, b)‖1
b0 = sum_32(b0, b)‖c0 = sum_32(c0, c)‖1
c0 = sum_32(c0, c)‖d0 = sum_32(d0, d)‖1
digest = reformat_hex(a0) + reformat_hex(b0) + reformat_hex(c0) + reformat_hex(d0)‖return digest‖1
if counter == 0 or capacity == 0:‖return 0‖1
if weights[counter - 1] > capacity:‖return knapsack(capacity, weights, values, counter - 1)‖1
return knapsack(capacity, weights, values, counter - 1)‖else:‖1
else:‖left_capacity = capacity - weights[counter - 1]‖1
left_capacity = capacity - weights[counter - 1]‖new_value_included = values[counter - 1] + knapsack(‖1
new_value_included = values[counter - 1] + knapsack(‖left_capacity, weights, values, counter - 1‖1
left_capacity, weights, values, counter - 1‖)‖1
)‖without_new_value = knapsack(capacity, weights, values, counter - 1)‖1
without_new_value = knapsack(capacity, weights, values, counter - 1)‖return max(new_value_included, without_new_value)‖1
def elf_hash(data: str) -> int:‖hash_ = x = 0‖1
hash_ = x = 0‖for letter in data:‖1
for letter in data:‖hash_ = (hash_ << 4) + ord(letter)‖1
hash_ = (hash_ << 4) + ord(letter)‖x = hash_ & 0xF0000000‖1
x = hash_ & 0xF0000000‖if x != 0:‖1
if x != 0:‖hash_ ^= x >> 24‖1
hash_ ^= x >> 24‖hash_ &= ~x‖1
hash_ &= ~x‖return hash_‖1
import argparse‖import hashlib‖1
import hashlib‖import struct‖1
self.data = data‖self.h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]‖1
@staticmethod‖def rotate(n, b):‖1
def rotate(n, b):‖return ((n << b) | (n >> (32 - b))) & 0xFFFFFFFF‖1
def padding(self):‖"padding = b""\x80"" + b""\x00"" * (63 - (len(self.data) + 8) % 64)"‖1
"padding = b""\x80"" + b""\x00"" * (63 - (len(self.data) + 8) % 64)"‖"padded_data = self.data + padding + struct.pack("">Q"", 8 * len(self.data))"‖1
"padded_data = self.data + padding + struct.pack("">Q"", 8 * len(self.data))"‖return padded_data‖1
def split_blocks(self):‖return [‖1
return [‖self.padded_data[i : i + 64] for i in range(0, len(self.padded_data), 64)‖1
self.padded_data[i : i + 64] for i in range(0, len(self.padded_data), 64)‖]‖1
def expand_block(self, block):‖"w = list(struct.unpack("">16L"", block)) + [0] * 64"‖1
"w = list(struct.unpack("">16L"", block)) + [0] * 64"‖for i in range(16, 80):‖1
for i in range(16, 80):‖w[i] = self.rotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1)‖1
w[i] = self.rotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1)‖return w‖1
def final_hash(self):‖self.padded_data = self.padding()‖1
self.padded_data = self.padding()‖self.blocks = self.split_blocks()‖1
self.blocks = self.split_blocks()‖for block in self.blocks:‖1
for block in self.blocks:‖expanded_block = self.expand_block(block)‖1
expanded_block = self.expand_block(block)‖a, b, c, d, e = self.h‖1
a, b, c, d, e = self.h‖for i in range(80):‖1
for i in range(80):‖if 0 <= i < 20:‖1
if 0 <= i < 20:‖f = (b & c) | ((~b) & d)‖1
f = (b & c) | ((~b) & d)‖k = 0x5A827999‖1
k = 0x5A827999‖elif 20 <= i < 40:‖1
elif 20 <= i < 40:‖f = b ^ c ^ d‖1
f = b ^ c ^ d‖k = 0x6ED9EBA1‖1
k = 0x6ED9EBA1‖elif 40 <= i < 60:‖1
elif 40 <= i < 60:‖f = (b & c) | (b & d) | (c & d)‖1
f = (b & c) | (b & d) | (c & d)‖k = 0x8F1BBCDC‖1
k = 0x8F1BBCDC‖elif 60 <= i < 80:‖1
elif 60 <= i < 80:‖f = b ^ c ^ d‖1
f = b ^ c ^ d‖k = 0xCA62C1D6‖1
k = 0xCA62C1D6‖a, b, c, d, e = (‖1
a, b, c, d, e = (‖self.rotate(a, 5) + f + e + k + expanded_block[i] & 0xFFFFFFFF,‖1
self.rotate(a, 5) + f + e + k + expanded_block[i] & 0xFFFFFFFF,‖a,‖1
a,‖self.rotate(b, 30),‖1
self.rotate(b, 30),‖c,‖1
c,‖d,‖1
d,‖)‖1
)‖self.h = (‖1
self.h = (‖self.h[0] + a & 0xFFFFFFFF,‖1
self.h[0] + a & 0xFFFFFFFF,‖self.h[1] + b & 0xFFFFFFFF,‖1
self.h[1] + b & 0xFFFFFFFF,‖self.h[2] + c & 0xFFFFFFFF,‖1
self.h[2] + c & 0xFFFFFFFF,‖self.h[3] + d & 0xFFFFFFFF,‖1
self.h[3] + d & 0xFFFFFFFF,‖self.h[4] + e & 0xFFFFFFFF,‖1
self.h[4] + e & 0xFFFFFFFF,‖)‖1
)‖"return (""{:08x}"" * 5).format(*self.h)"‖1
def test_sha1_hash():‖"msg = b""Test String"""‖1
"msg = b""Test String"""‖assert SHA1Hash(msg).final_hash() == hashlib.sha1(msg).hexdigest()‖1
"parser = argparse.ArgumentParser(description=""Process some strings or files"")"‖parser.add_argument(‖1
parser.add_argument(‖"""--string"","‖1
)‖"parser.add_argument(""--file"", dest=""input_file"", help=""Hash contents of a file"")"‖1
"parser.add_argument(""--file"", dest=""input_file"", help=""Hash contents of a file"")"‖args = parser.parse_args()‖1
args = parser.parse_args()‖input_string = args.input_string‖1
"hash_input = bytes(input_string, ""utf-8"")"‖print(SHA1Hash(hash_input).final_hash())‖1
main()‖import doctest‖2
class Test(unittest.TestCase):‖def test_base_case(self):‖1
def test_base_case(self):‖cap = 0‖1
cap = 0‖val = [0]‖1
val = [0]‖w = [0]‖1
w = [0]‖c = len(val)‖1
c = len(val)‖assert k.knapsack(cap, w, val, c) == 0‖2
val = [60]‖w = [10]‖1
w = [10]‖c = len(val)‖1
def test_easy_case(self):‖cap = 3‖1
cap = 3‖val = [1, 2, 3]‖1
val = [1, 2, 3]‖w = [3, 2, 1]‖1
w = [3, 2, 1]‖c = len(val)‖1
c = len(val)‖assert k.knapsack(cap, w, val, c) == 5‖1
def test_knapsack(self):‖cap = 50‖1
cap = 50‖val = [60, 100, 120]‖1
val = [60, 100, 120]‖w = [10, 20, 30]‖1
w = [10, 20, 30]‖c = len(val)‖1
c = len(val)‖assert k.knapsack(cap, w, val, c) == 220‖1
def is_luhn(string: str) -> bool:‖check_digit: int‖1
check_digit: int‖_vector: list[str] = list(string)‖1
_vector: list[str] = list(string)‖__vector, check_digit = _vector[:-1], int(_vector[-1])‖1
__vector, check_digit = _vector[:-1], int(_vector[-1])‖vector: list[int] = [int(digit) for digit in __vector]‖1
vector.reverse()‖for i, digit in enumerate(vector):‖1
for i, digit in enumerate(vector):‖if i & 1 == 0:‖1
if i & 1 == 0:‖doubled: int = digit * 2‖1
doubled: int = digit * 2‖if doubled > 9:‖1
if doubled > 9:‖doubled -= 9‖1
doubled -= 9‖check_digit += doubled‖1
check_digit += doubled‖else:‖1
else:‖check_digit += digit‖1
doctest.testmod()‖"assert is_luhn(""79927398713"")"‖1
"assert is_luhn(""79927398713"")"‖"assert not is_luhn(""79927398714"")"‖1
def fletcher16(text: str) -> int:‖"data = bytes(text, ""ascii"")"‖1
"data = bytes(text, ""ascii"")"‖sum1 = 0‖1
sum1 = 0‖sum2 = 0‖1
sum2 = 0‖for character in data:‖1
for character in data:‖sum1 = (sum1 + character) % 255‖1
sum1 = (sum1 + character) % 255‖sum2 = (sum1 + sum2) % 255‖1
sum2 = (sum1 + sum2) % 255‖return (sum2 << 8) | sum1‖1
alphabets = [chr(i) for i in range(32, 126)]‖gear_one = list(range(len(alphabets)))‖1
gear_one = list(range(len(alphabets)))‖gear_two = list(range(len(alphabets)))‖1
gear_two = list(range(len(alphabets)))‖gear_three = list(range(len(alphabets)))‖1
gear_three = list(range(len(alphabets)))‖reflector = list(reversed(range(len(alphabets))))‖1
reflector = list(reversed(range(len(alphabets))))‖code = []‖1
code = []‖gear_one_pos = gear_two_pos = gear_three_pos = 0‖1
def rotator():‖global gear_one_pos‖1
global gear_one_pos‖global gear_two_pos‖1
global gear_two_pos‖global gear_three_pos‖1
global gear_three_pos‖i = gear_one[0]‖1
i = gear_one[0]‖gear_one.append(i)‖1
gear_one.append(i)‖del gear_one[0]‖1
del gear_one[0]‖gear_one_pos += 1‖1
gear_one_pos += 1‖if gear_one_pos % int(len(alphabets)) == 0:‖1
if gear_one_pos % int(len(alphabets)) == 0:‖i = gear_two[0]‖1
i = gear_two[0]‖gear_two.append(i)‖1
gear_two.append(i)‖del gear_two[0]‖1
del gear_two[0]‖gear_two_pos += 1‖1
gear_two_pos += 1‖if gear_two_pos % int(len(alphabets)) == 0:‖1
if gear_two_pos % int(len(alphabets)) == 0:‖i = gear_three[0]‖1
i = gear_three[0]‖gear_three.append(i)‖1
gear_three.append(i)‖del gear_three[0]‖1
del gear_three[0]‖gear_three_pos += 1‖1
def engine(input_character):‖target = alphabets.index(input_character)‖1
target = alphabets.index(input_character)‖target = gear_one[target]‖1
target = gear_one[target]‖target = gear_two[target]‖1
target = gear_two[target]‖target = gear_three[target]‖1
target = gear_three[target]‖target = reflector[target]‖1
target = reflector[target]‖target = gear_three.index(target)‖1
target = gear_three.index(target)‖target = gear_two.index(target)‖1
target = gear_two.index(target)‖target = gear_one.index(target)‖1
target = gear_one.index(target)‖code.append(alphabets[target])‖1
code.append(alphabets[target])‖rotator()‖1
"if __name__ == ""__main__"":"‖"decode = list(input(""Type your message:\n""))"‖1
"decode = list(input(""Type your message:\n""))"‖while True:‖1
while True:‖try:‖2
try:‖"token = int(input(""Please set token:(must be only digits)\n""))"‖1
"token = int(input(""Please set token:(must be only digits)\n""))"‖break‖1
break‖except Exception as error:‖1
except Exception as error:‖print(error)‖1
print(error)‖for _ in range(token):‖1
for _ in range(token):‖rotator()‖1
rotator()‖for j in decode:‖1
for j in decode:‖engine(j)‖1
engine(j)‖"print(""\n"" + """".join(code))"‖1
"print(""\n"" + """".join(code))"‖print(‖1
print(‖"f""\nYour Token is {token} please write it down.\nIf you want to decode """‖1
"f""\nYour Token is {token} please write it down.\nIf you want to decode """‖"""this message again you should input same digits as token!"""‖1
"""this message again you should input same digits as token!"""‖)‖1
rows, columns = np.shape(table)‖if rows != columns:‖1
if rows != columns:‖msg = (‖1
msg = (‖"""'table' has to be of square shaped array but got a """‖1
"""'table' has to be of square shaped array but got a """‖"f""{rows}x{columns} array:\n{table}"""‖1
"f""{rows}x{columns} array:\n{table}"""‖)‖1
lower = np.zeros((rows, columns))‖upper = np.zeros((rows, columns))‖1
for i in range(columns):‖for j in range(i):‖1
for j in range(i):‖total = np.sum(lower[i, :i] * upper[:i, j])‖1
total = np.sum(lower[i, :i] * upper[:i, j])‖if upper[j][j] == 0:‖1
if upper[j][j] == 0:‖"raise ArithmeticError(""No LU decomposition exists"")"‖1
"raise ArithmeticError(""No LU decomposition exists"")"‖lower[i][j] = (table[i][j] - total) / upper[j][j]‖1
lower[i][j] = (table[i][j] - total) / upper[j][j]‖lower[i][i] = 1‖1
lower[i][i] = 1‖for j in range(i, columns):‖1
for j in range(i, columns):‖total = np.sum(lower[i, :i] * upper[:i, j])‖1
total = np.sum(lower[i, :i] * upper[:i, j])‖upper[i][j] = table[i][j] - total‖1
upper[i][j] = table[i][j] - total‖return lower, upper‖1
def is_hermitian(matrix: np.ndarray) -> bool:‖return np.array_equal(matrix, matrix.conjugate().T)‖1
def rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:‖v_star = v.conjugate().T‖1
v_star = v.conjugate().T‖v_star_dot = v_star.dot(a)‖1
v_star_dot = v_star.dot(a)‖assert isinstance(v_star_dot, np.ndarray)‖1
assert isinstance(v_star_dot, np.ndarray)‖return (v_star_dot.dot(v)) / (v_star.dot(v))‖1
def tests() -> None:‖a = np.array([[2, 2 + 1j, 4], [2 - 1j, 3, 1j], [4, -1j, 1]])‖1
a = np.array([[2, 2 + 1j, 4], [2 - 1j, 3, 1j], [4, -1j, 1]])‖v = np.array([[1], [2], [3]])‖1
v = np.array([[1], [2], [3]])‖"assert is_hermitian(a), f""{a} is not hermitian."""‖1
"assert is_hermitian(a), f""{a} is not hermitian."""‖print(rayleigh_quotient(a, v))‖1
a = np.array([[1, 2, 4], [2, 3, -1], [4, -1, 1]])‖"assert is_hermitian(a), f""{a} is not hermitian."""‖1
"assert is_hermitian(a), f""{a} is not hermitian."""‖assert rayleigh_quotient(a, v) == float(3)‖1
doctest.testmod()‖tests()‖1
def djb2(s: str) -> int:‖hash_value = 5381‖1
hash_value = 5381‖for x in s:‖1
for x in s:‖hash_value = ((hash_value << 5) + hash_value) + ord(x)‖1
hash_value = ((hash_value << 5) + hash_value) + ord(x)‖return hash_value & 0xFFFFFFFF‖1
def solve_linear_system(matrix: np.ndarray) -> np.ndarray:‖ab = np.copy(matrix)‖1
ab = np.copy(matrix)‖num_of_rows = ab.shape[0]‖1
num_of_rows = ab.shape[0]‖num_of_columns = ab.shape[1] - 1‖1
num_of_columns = ab.shape[1] - 1‖x_lst: list[float] = []‖1
if num_of_rows != num_of_columns:‖"raise ValueError(""Matrix is not square"")"‖1
for i in range(column_num, num_of_columns):‖if abs(ab[i][column_num]) > abs(ab[column_num][column_num]):‖1
if abs(ab[i][column_num]) > abs(ab[column_num][column_num]):‖ab[[column_num, i]] = ab[[i, column_num]]‖1
if abs(ab[column_num, column_num]) < 1e-8:‖"raise ValueError(""Matrix is singular"")"‖1
if column_num != 0:‖for i in range(column_num, num_of_rows):‖1
for i in range(column_num, num_of_rows):‖ab[i, :] -= (‖1
ab[i, :] -= (‖ab[i, column_num - 1]‖1
ab[i, column_num - 1]‖/ ab[column_num - 1, column_num - 1]‖1
/ ab[column_num - 1, column_num - 1]‖* ab[column_num - 1, :]‖1
* ab[column_num - 1, :]‖)‖1
for column_num in range(num_of_rows - 1, -1, -1):‖x = ab[column_num, -1] / ab[column_num, column_num]‖1
x = ab[column_num, -1] / ab[column_num, column_num]‖x_lst.insert(0, x)‖1
x_lst.insert(0, x)‖for i in range(column_num - 1, -1, -1):‖1
for i in range(column_num - 1, -1, -1):‖ab[i, -1] -= ab[i, column_num] * x‖1
example_matrix = np.array(‖[‖1
[‖[5.0, -5.0, -3.0, 4.0, -11.0],‖1
[5.0, -5.0, -3.0, 4.0, -11.0],‖[1.0, -4.0, 6.0, -4.0, -10.0],‖1
[1.0, -4.0, 6.0, -4.0, -10.0],‖[-2.0, -5.0, 4.0, -5.0, -12.0],‖1
[-2.0, -5.0, 4.0, -5.0, -12.0],‖[-3.0, -3.0, 5.0, -5.0, 8.0],‖1
[-3.0, -3.0, 5.0, -5.0, 8.0],‖],‖1
],‖dtype=float,‖1
dtype=float,‖)‖1
"print(f""Matrix:\n{example_matrix}"")"‖"print(f""{solve_linear_system(example_matrix) = }"")"‖1
def __init__(‖self, tableau: np.ndarray, n_vars: int, n_artificial_vars: int‖1
self, tableau: np.ndarray, n_vars: int, n_artificial_vars: int‖) -> None:‖1
) -> None:‖"if tableau.dtype != ""float64"":"‖1
"if tableau.dtype != ""float64"":"‖"raise TypeError(""Tableau must have type float64"")"‖1
if not (tableau[:, -1] >= 0).all():‖"raise ValueError(""RHS must be > 0"")"‖1
if n_vars < 2 or n_artificial_vars < 0:‖raise ValueError(‖1
raise ValueError(‖"""number of (artificial) variables must be a natural number"""‖1
"""number of (artificial) variables must be a natural number"""‖)‖1
self.tableau = tableau‖self.n_rows, n_cols = tableau.shape‖1
if self.n_artificial_vars:‖"self.objectives.append(""min"")"‖1
self.row_idx = None‖self.col_idx = None‖1
def generate_col_titles(self) -> list[str]:‖args = (self.n_vars, self.n_slack)‖1
"string_starts = [""x"", ""s""]"‖titles = []‖1
titles = []‖for i in range(2):‖1
for i in range(2):‖for j in range(args[i]):‖1
for j in range(args[i]):‖titles.append(string_starts[i] + str(j + 1))‖1
titles.append(string_starts[i] + str(j + 1))‖"titles.append(""RHS"")"‖1
"titles.append(""RHS"")"‖return titles‖1
def find_pivot(self) -> tuple[Any, Any]:‖objective = self.objectives[-1]‖1
"sign = (objective == ""min"") - (objective == ""max"")"‖col_idx = np.argmax(sign * self.tableau[0, :-1])‖1
if sign * self.tableau[0, col_idx] <= 0:‖self.stop_iter = True‖1
self.stop_iter = True‖return 0, 0‖1
row_idx = np.nanargmin(quotients) + self.n_stages‖return row_idx, col_idx‖1
for idx, coeff in enumerate(self.tableau[:, col_idx]):‖self.tableau[idx] += -coeff * piv_row‖1
self.tableau[idx] += -coeff * piv_row‖self.tableau[row_idx] = piv_row‖1
self.tableau[row_idx] = piv_row‖return self.tableau‖1
if not self.objectives:‖return self.tableau‖1
self.n_stages = 1‖self.n_rows -= 1‖1
self.n_rows -= 1‖self.n_artificial_vars = 0‖1
self.n_artificial_vars = 0‖self.stop_iter = False‖1
self.stop_iter = False‖return self.tableau‖1
self.tableau = self.change_stage()‖else:‖1
else:‖self.tableau = self.pivot(row_idx, col_idx)‖1
self.tableau = self.pivot(row_idx, col_idx)‖return {}‖1
nonzero = np.nonzero(self.tableau[:, i])‖n_nonzero = len(nonzero[0])‖1
nonzero_rowidx = nonzero[0][0]‖nonzero_val = self.tableau[nonzero_rowidx, i]‖1
if n_nonzero == 1 and nonzero_val == 1:‖rhs_val = self.tableau[nonzero_rowidx, -1]‖1
rhs_val = self.tableau[nonzero_rowidx, -1]‖output_dict[self.col_titles[i]] = rhs_val‖1
output_dict[self.col_titles[i]] = rhs_val‖return output_dict‖1
import numpy as np‖from numpy import float64‖2
from numpy import float64‖from numpy.typing import NDArray‖2
def jacobi_iteration_method(‖coefficient_matrix: NDArray[float64],‖1
coefficient_matrix: NDArray[float64],‖constant_matrix: NDArray[float64],‖1
constant_matrix: NDArray[float64],‖init_val: list[float],‖1
init_val: list[float],‖iterations: int,‖1
iterations: int,‖) -> list[float]:‖1
rows1, cols1 = coefficient_matrix.shape‖rows2, cols2 = constant_matrix.shape‖1
if rows1 != cols1:‖"msg = f""Coefficient matrix dimensions must be nxn but received {rows1}x{cols1}"""‖1
"msg = f""Coefficient matrix dimensions must be nxn but received {rows1}x{cols1}"""‖raise ValueError(msg)‖1
if cols2 != 1:‖"msg = f""Constant matrix must be nx1 but received {rows2}x{cols2}"""‖1
"msg = f""Constant matrix must be nx1 but received {rows2}x{cols2}"""‖raise ValueError(msg)‖1
if rows1 != rows2:‖msg = (‖1
msg = (‖"""Coefficient and constant matrices dimensions must be nxn and nx1 but """‖1
"""Coefficient and constant matrices dimensions must be nxn and nx1 but """‖"f""received {rows1}x{cols1} and {rows2}x{cols2}"""‖1
"f""received {rows1}x{cols1} and {rows2}x{cols2}"""‖)‖1
if len(init_val) != rows1:‖msg = (‖1
msg = (‖"""Number of initial values must be equal to number of rows in coefficient """‖1
"""Number of initial values must be equal to number of rows in coefficient """‖"f""matrix but received {len(init_val)} and {rows1}"""‖1
"f""matrix but received {len(init_val)} and {rows1}"""‖)‖1
if iterations <= 0:‖"raise ValueError(""Iterations must be at least 1"")"‖1
table: NDArray[float64] = np.concatenate(‖(coefficient_matrix, constant_matrix), axis=1‖1
(coefficient_matrix, constant_matrix), axis=1‖)‖1
i_row, i_col = np.where(masks)‖ind = i_col.reshape(-1, rows - 1)‖1
for _ in range(iterations):‖arr = np.take(init_val, ind)‖1
arr = np.take(init_val, ind)‖sum_product_rows = np.sum((-1) * no_diagonals * arr, axis=1)‖1
sum_product_rows = np.sum((-1) * no_diagonals * arr, axis=1)‖new_val = (sum_product_rows + val_last) / denominator‖1
new_val = (sum_product_rows + val_last) / denominator‖init_val = new_val‖1
for i in range(rows):‖total = 0‖1
total = 0‖for j in range(cols - 1):‖1
for j in range(cols - 1):‖if i == j:‖1
if i == j:‖continue‖1
continue‖else:‖2
else:‖total += table[i][j]‖1
if table[i][i] <= total:‖"raise ValueError(""Coefficient matrix is not strictly diagonally dominant"")"‖1
def schur_complement(‖mat_a: np.ndarray,‖1
mat_a: np.ndarray,‖mat_b: np.ndarray,‖1
mat_b: np.ndarray,‖mat_c: np.ndarray,‖1
mat_c: np.ndarray,‖pseudo_inv: np.ndarray | None = None,‖1
pseudo_inv: np.ndarray | None = None,‖) -> np.ndarray:‖1
) -> np.ndarray:‖shape_a = np.shape(mat_a)‖1
shape_a = np.shape(mat_a)‖shape_b = np.shape(mat_b)‖1
shape_b = np.shape(mat_b)‖shape_c = np.shape(mat_c)‖1
if shape_a[0] != shape_b[0]:‖msg = (‖1
msg = (‖"""Expected the same number of rows for A and B. """‖1
"""Expected the same number of rows for A and B. """‖"f""Instead found A of size {shape_a} and B of size {shape_b}"""‖1
"f""Instead found A of size {shape_a} and B of size {shape_b}"""‖)‖1
if shape_b[1] != shape_c[1]:‖msg = (‖1
msg = (‖"""Expected the same number of columns for B and C. """‖1
"""Expected the same number of columns for B and C. """‖"f""Instead found B of size {shape_b} and C of size {shape_c}"""‖1
"f""Instead found B of size {shape_b} and C of size {shape_c}"""‖)‖1
a_inv = pseudo_inv‖if a_inv is None:‖1
if a_inv is None:‖try:‖1
try:‖a_inv = np.linalg.inv(mat_a)‖1
a_inv = np.linalg.inv(mat_a)‖except np.linalg.LinAlgError:‖1
except np.linalg.LinAlgError:‖raise ValueError(‖1
raise ValueError(‖"""Input matrix A is not invertible. Cannot compute Schur complement."""‖1
"""Input matrix A is not invertible. Cannot compute Schur complement."""‖)‖1
class TestSchurComplement(unittest.TestCase):‖def test_schur_complement(self) -> None:‖1
def test_schur_complement(self) -> None:‖a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])‖1
a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])‖b = np.array([[0, 3], [3, 0], [2, 3]])‖3
b = np.array([[0, 3], [3, 0], [2, 3]])‖c = np.array([[2, 1], [6, 3]])‖2
det_x = np.linalg.det(input_matrix)‖det_a = np.linalg.det(a)‖1
det_a = np.linalg.det(a)‖det_s = np.linalg.det(s)‖1
def test_improper_a_b_dimensions(self) -> None:‖a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])‖1
with pytest.raises(ValueError):‖schur_complement(a, b, c)‖2
def test_improper_b_c_dimensions(self) -> None:‖a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])‖1
b = np.array([[0, 3], [3, 0], [2, 3]])‖c = np.array([[2, 1, 3], [6, 3, 5]])‖1
doctest.testmod()‖unittest.main()‖1
rows = len(matrix)‖columns = len(matrix[0])‖1
columns = len(matrix[0])‖rank = min(rows, columns)‖1
for col in range(row + 1, rows):‖multiplier = matrix[col][row] / matrix[row][row]‖1
multiplier = matrix[col][row] / matrix[row][row]‖for i in range(row, columns):‖1
for i in range(row, columns):‖matrix[col][i] -= multiplier * matrix[row][i]‖1
matrix[col][i] -= multiplier * matrix[row][i]‖else:‖1
reduce = True‖for i in range(row + 1, rows):‖1
for i in range(row + 1, rows):‖if matrix[i][row] != 0:‖1
if matrix[i][row] != 0:‖matrix[row], matrix[i] = matrix[i], matrix[row]‖1
matrix[row], matrix[i] = matrix[i], matrix[row]‖reduce = False‖1
reduce = False‖break‖1
break‖if reduce:‖1
if reduce:‖rank -= 1‖1
rank -= 1‖for i in range(rows):‖1
for i in range(rows):‖matrix[i][row] = matrix[i][rank]‖1
def test_sorted(self):‖profit = [10, 20, 30, 40, 50, 60]‖1
profit = [10, 20, 30, 40, 50, 60]‖weight = [2, 4, 6, 8, 10, 12]‖1
weight = [2, 4, 6, 8, 10, 12]‖max_weight = 100‖1
max_weight = 100‖assert kp.calc_profit(profit, weight, max_weight) == 210‖1
from .lib import (‖Matrix,‖1
Matrix,‖Vector,‖1
Vector,‖axpy,‖1
axpy,‖square_zero_matrix,‖1
square_zero_matrix,‖unit_basis_vector,‖1
unit_basis_vector,‖zero_vector,‖1
zero_vector,‖)‖1
class Test(unittest.TestCase):‖def test_component(self) -> None:‖1
def test_component(self) -> None:‖x = Vector([1, 2, 3])‖1
x = Vector([1, 2, 3])‖assert x.component(0) == 1‖1
assert x.component(0) == 1‖assert x.component(2) == 3‖1
assert x.component(2) == 3‖_ = Vector()‖1
def test_str(self) -> None:‖x = Vector([0, 0, 0, 0, 0, 1])‖1
x = Vector([0, 0, 0, 0, 0, 1])‖"assert str(x) == ""(0,0,0,0,0,1)"""‖1
def test_size(self) -> None:‖x = Vector([1, 2, 3, 4])‖1
x = Vector([1, 2, 3, 4])‖assert len(x) == 4‖1
def test_euclidean_length(self) -> None:‖x = Vector([1, 2])‖1
x = Vector([1, 2])‖y = Vector([1, 2, 3, 4, 5])‖1
y = Vector([1, 2, 3, 4, 5])‖z = Vector([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])‖1
z = Vector([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])‖w = Vector([1, -1, 1, -1, 2, -3, 4, -5])‖1
w = Vector([1, -1, 1, -1, 2, -3, 4, -5])‖assert x.euclidean_length() == pytest.approx(2.236, abs=1e-3)‖1
assert x.euclidean_length() == pytest.approx(2.236, abs=1e-3)‖assert y.euclidean_length() == pytest.approx(7.416, abs=1e-3)‖1
assert y.euclidean_length() == pytest.approx(7.416, abs=1e-3)‖assert z.euclidean_length() == 0‖1
assert z.euclidean_length() == 0‖assert w.euclidean_length() == pytest.approx(7.616, abs=1e-3)‖1
def test_add(self) -> None:‖x = Vector([1, 2, 3])‖1
x = Vector([1, 2, 3])‖y = Vector([1, 1, 1])‖2
y = Vector([1, 1, 1])‖assert (x + y).component(0) == 2‖1
assert (x + y).component(0) == 2‖assert (x + y).component(1) == 3‖1
assert (x + y).component(1) == 3‖assert (x + y).component(2) == 4‖1
def test_sub(self) -> None:‖x = Vector([1, 2, 3])‖1
y = Vector([1, 1, 1])‖assert (x - y).component(0) == 0‖1
assert (x - y).component(0) == 0‖assert (x - y).component(1) == 1‖1
assert (x - y).component(1) == 1‖assert (x - y).component(2) == 2‖1
def test_mul(self) -> None:‖x = Vector([1, 2, 3])‖1
x = Vector([1, 2, 3])‖a = Vector([2, -1, 4])‖1
a = Vector([2, -1, 4])‖b = Vector([1, -2, -1])‖1
b = Vector([1, -2, -1])‖"assert str(x * 3.0) == ""(3.0,6.0,9.0)"""‖1
"assert str(x * 3.0) == ""(3.0,6.0,9.0)"""‖assert a * b == 0‖1
def test_zero_vector(self) -> None:‖"assert str(zero_vector(10)).count(""0"") == 10"‖1
def test_unit_basis_vector(self) -> None:‖"assert str(unit_basis_vector(3, 1)) == ""(0,1,0)"""‖1
def test_axpy(self) -> None:‖x = Vector([1, 2, 3])‖1
x = Vector([1, 2, 3])‖y = Vector([1, 0, 1])‖1
y = Vector([1, 0, 1])‖"assert str(axpy(2, x, y)) == ""(3,4,7)"""‖1
def test_copy(self) -> None:‖x = Vector([1, 0, 0, 0, 0, 0])‖1
x = Vector([1, 0, 0, 0, 0, 0])‖y = x.copy()‖1
y = x.copy()‖assert str(x) == str(y)‖1
def test_change_component(self) -> None:‖x = Vector([1, 0, 0])‖1
x = Vector([1, 0, 0])‖x.change_component(0, 0)‖1
x.change_component(0, 0)‖x.change_component(1, 1)‖1
x.change_component(1, 1)‖"assert str(x) == ""(0,1,0)"""‖1
def test_str_matrix(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖"assert str(a) == ""|1,2,3|\n|2,4,5|\n|6,7,8|\n"""‖1
def test_minor(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖minors = [[-3, -14, -10], [-5, -10, -5], [-2, -1, 0]]‖1
minors = [[-3, -14, -10], [-5, -10, -5], [-2, -1, 0]]‖for x in range(a.height()):‖1
for x in range(a.height()):‖for y in range(a.width()):‖2
for y in range(a.width()):‖assert minors[x][y] == a.minor(x, y)‖1
def test_cofactor(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖cofactors = [[-3, 14, -10], [5, -10, 5], [-2, 1, 0]]‖1
cofactors = [[-3, 14, -10], [5, -10, 5], [-2, 1, 0]]‖for x in range(a.height()):‖1
for y in range(a.width()):‖assert cofactors[x][y] == a.cofactor(x, y)‖1
def test_determinant(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖assert a.determinant() == -5‖1
def test__mul__matrix(self) -> None:‖a = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3)‖1
a = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3)‖x = Vector([1, 2, 3])‖1
x = Vector([1, 2, 3])‖"assert str(a * x) == ""(14,32,50)"""‖1
"assert str(a * x) == ""(14,32,50)"""‖"assert str(a * 2) == ""|2,4,6|\n|8,10,12|\n|14,16,18|\n"""‖1
def test_change_component_matrix(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖a.change_component(0, 2, 5)‖1
a.change_component(0, 2, 5)‖"assert str(a) == ""|1,2,5|\n|2,4,5|\n|6,7,8|\n"""‖1
def test_component_matrix(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖assert a.component(2, 1) == 7, 0.01‖1
def test__add__matrix(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖b = Matrix([[1, 2, 7], [2, 4, 5], [6, 7, 10]], 3, 3)‖2
b = Matrix([[1, 2, 7], [2, 4, 5], [6, 7, 10]], 3, 3)‖"assert str(a + b) == ""|2,4,10|\n|4,8,10|\n|12,14,18|\n"""‖1
def test__sub__matrix(self) -> None:‖a = Matrix([[1, 2, 3], [2, 4, 5], [6, 7, 8]], 3, 3)‖1
b = Matrix([[1, 2, 7], [2, 4, 5], [6, 7, 10]], 3, 3)‖"assert str(a - b) == ""|0,0,-4|\n|0,0,0|\n|0,0,-2|\n"""‖1
def test_square_zero_matrix(self) -> None:‖assert str(square_zero_matrix(5)) == (‖1
assert str(square_zero_matrix(5)) == (‖"""|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n"""‖1
"""|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n"""‖)‖1
def scaling(scaling_factor: float) -> list[list[float]]:‖scaling_factor = float(scaling_factor)‖1
scaling_factor = float(scaling_factor)‖return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]‖1
def rotation(angle: float) -> list[list[float]]:‖c, s = cos(angle), sin(angle)‖1
c, s = cos(angle), sin(angle)‖return [[c, -s], [s, c]]‖1
def projection(angle: float) -> list[list[float]]:‖c, s = cos(angle), sin(angle)‖1
c, s = cos(angle), sin(angle)‖cs = c * s‖2
cs = c * s‖return [[c * c, cs], [cs, s * s]]‖1
def reflection(angle: float) -> list[list[float]]:‖c, s = cos(angle), sin(angle)‖1
cs = c * s‖return [[2 * c - 1, 2 * cs], [2 * cs, 2 * s - 1]]‖1
"print(f""    {scaling(5) = }"")"‖"print(f""  {rotation(45) = }"")"‖1
"print(f""  {rotation(45) = }"")"‖"print(f""{projection(45) = }"")"‖1
"print(f""{projection(45) = }"")"‖"print(f""{reflection(45) = }"")"‖1
if np.allclose(matrix, matrix.T) is False:‖return False‖1
def _create_spd_matrix(dimension: int) -> Any:‖rng = np.random.default_rng()‖1
rng = np.random.default_rng()‖random_matrix = rng.normal(size=(dimension, dimension))‖1
random_matrix = rng.normal(size=(dimension, dimension))‖spd_matrix = np.dot(random_matrix, random_matrix.T)‖1
spd_matrix = np.dot(random_matrix, random_matrix.T)‖assert _is_matrix_spd(spd_matrix)‖1
assert _is_matrix_spd(spd_matrix)‖return spd_matrix‖1
def conjugate_gradient(‖spd_matrix: np.ndarray,‖1
spd_matrix: np.ndarray,‖load_vector: np.ndarray,‖1
load_vector: np.ndarray,‖max_iterations: int = 1000,‖1
max_iterations: int = 1000,‖tol: float = 1e-8,‖1
tol: float = 1e-8,‖) -> Any:‖1
assert np.shape(spd_matrix)[0] == np.shape(spd_matrix)[1]‖assert np.shape(load_vector)[0] == np.shape(spd_matrix)[0]‖1
assert np.shape(load_vector)[0] == np.shape(spd_matrix)[0]‖assert _is_matrix_spd(spd_matrix)‖1
x0 = np.zeros((np.shape(load_vector)[0], 1))‖r0 = np.copy(load_vector)‖1
r0 = np.copy(load_vector)‖p0 = np.copy(r0)‖1
error_residual = 1e9‖error_x_solution = 1e9‖1
error_x_solution = 1e9‖error = 1e9‖1
error_residual = np.linalg.norm(r - r0)‖error_x_solution = np.linalg.norm(x - x0)‖1
error_x_solution = np.linalg.norm(x - x0)‖error = np.maximum(error_residual, error_x_solution)‖1
x0 = np.copy(x)‖r0 = np.copy(r)‖1
r0 = np.copy(r)‖p0 = np.copy(p)‖1
iterations += 1‖if iterations > max_iterations:‖1
if iterations > max_iterations:‖break‖1
dimension = 3‖spd_matrix = _create_spd_matrix(dimension)‖1
spd_matrix = _create_spd_matrix(dimension)‖rng = np.random.default_rng()‖1
rng = np.random.default_rng()‖x_true = rng.normal(size=(dimension, 1))‖1
x_true = rng.normal(size=(dimension, 1))‖b = np.dot(spd_matrix, x_true)‖1
assert np.linalg.norm(x_numpy - x_true) <= 1e-6‖assert np.linalg.norm(x_conjugate_gradient - x_true) <= 1e-6‖1
doctest.testmod()‖test_conjugate_gradient()‖1
def power_iteration(‖input_matrix: np.ndarray,‖1
input_matrix: np.ndarray,‖vector: np.ndarray,‖1
vector: np.ndarray,‖error_tol: float = 1e-12,‖1
error_tol: float = 1e-12,‖max_iterations: int = 100,‖1
max_iterations: int = 100,‖) -> tuple[float, np.ndarray]:‖1
assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)‖is_complex = np.iscomplexobj(input_matrix)‖1
is_complex = np.iscomplexobj(input_matrix)‖if is_complex:‖1
convergence = False‖lambda_previous = 0‖1
lambda_previous = 0‖iterations = 0‖1
iterations = 0‖error = 1e12‖1
vector_h = vector.conj().T if is_complex else vector.T‖lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))‖1
error = np.abs(lambda_ - lambda_previous) / lambda_‖iterations += 1‖1
if error <= error_tol or iterations >= max_iterations:‖convergence = True‖1
if is_complex:‖lambda_ = np.real(lambda_)‖1
def test_power_iteration() -> None:‖real_input_matrix = np.array([[41, 4, 20], [4, 26, 30], [20, 30, 50]])‖1
real_input_matrix = np.array([[41, 4, 20], [4, 26, 30], [20, 30, 50]])‖real_vector = np.array([41, 4, 20])‖1
real_vector = np.array([41, 4, 20])‖complex_input_matrix = real_input_matrix.astype(np.complex128)‖1
complex_input_matrix = real_input_matrix.astype(np.complex128)‖imag_matrix = np.triu(1j * complex_input_matrix, 1)‖1
imag_matrix = np.triu(1j * complex_input_matrix, 1)‖complex_input_matrix += imag_matrix‖1
complex_input_matrix += imag_matrix‖complex_input_matrix += -1 * imag_matrix.T‖1
complex_input_matrix += -1 * imag_matrix.T‖complex_vector = np.array([41, 4, 20]).astype(np.complex128)‖1
"for problem_type in [""real"", ""complex""]:"‖"if problem_type == ""real"":"‖1
"if problem_type == ""real"":"‖input_matrix = real_input_matrix‖1
input_matrix = real_input_matrix‖vector = real_vector‖1
vector = real_vector‖"elif problem_type == ""complex"":"‖1
"elif problem_type == ""complex"":"‖input_matrix = complex_input_matrix‖1
input_matrix = complex_input_matrix‖vector = complex_vector‖1
doctest.testmod()‖test_power_iteration()‖1
import numpy as np‖import scipy.fftpack as fft‖1
import scipy.fftpack as fft‖from scipy.signal import get_window‖1
def mfcc(‖audio: np.ndarray,‖1
audio: np.ndarray,‖sample_rate: int,‖2
sample_rate: int,‖ftt_size: int = 1024,‖1
ftt_size: int = 1024,‖hop_length: int = 20,‖1
hop_length: int = 20,‖mel_filter_num: int = 10,‖1
mel_filter_num: int = 10,‖dct_filter_num: int = 40,‖1
dct_filter_num: int = 40,‖) -> np.ndarray:‖1
) -> np.ndarray:‖"logging.info(f""Sample rate: {sample_rate}Hz"")"‖1
"logging.info(f""Sample rate: {sample_rate}Hz"")"‖"logging.info(f""Audio duration: {len(audio) / sample_rate}s"")"‖1
"logging.info(f""Audio duration: {len(audio) / sample_rate}s"")"‖"logging.info(f""Audio min: {np.min(audio)}"")"‖1
"logging.info(f""Audio min: {np.min(audio)}"")"‖"logging.info(f""Audio max: {np.max(audio)}"")"‖1
"logging.info(f""Normalized audio min: {np.min(audio_normalized)}"")"‖"logging.info(f""Normalized audio max: {np.max(audio_normalized)}"")"‖1
audio_framed = audio_frames(‖audio_normalized, sample_rate, ftt_size=ftt_size, hop_length=hop_length‖1
audio_normalized, sample_rate, ftt_size=ftt_size, hop_length=hop_length‖)‖1
"logging.info(f""Framed audio shape: {audio_framed.shape}"")"‖"logging.info(f""First frame: {audio_framed[0]}"")"‖1
"window = get_window(""hann"", ftt_size, fftbins=True)"‖audio_windowed = audio_framed * window‖1
"logging.info(f""Windowed audio shape: {audio_windowed.shape}"")"‖"logging.info(f""First frame: {audio_windowed[0]}"")"‖1
audio_fft = calculate_fft(audio_windowed, ftt_size)‖"logging.info(f""fft audio shape: {audio_fft.shape}"")"‖1
"logging.info(f""fft audio shape: {audio_fft.shape}"")"‖"logging.info(f""First frame: {audio_fft[0]}"")"‖1
audio_power = calculate_signal_power(audio_fft)‖"logging.info(f""power audio shape: {audio_power.shape}"")"‖1
"logging.info(f""power audio shape: {audio_power.shape}"")"‖"logging.info(f""First frame: {audio_power[0]}"")"‖1
filters = mel_spaced_filterbank(sample_rate, mel_filter_num, ftt_size)‖"logging.info(f""filters shape: {filters.shape}"")"‖1
audio_filtered = np.dot(filters, np.transpose(audio_power))‖audio_log = 10.0 * np.log10(audio_filtered)‖1
audio_log = 10.0 * np.log10(audio_filtered)‖"logging.info(f""audio_log shape: {audio_log.shape}"")"‖1
dct_filters = discrete_cosine_transform(dct_filter_num, mel_filter_num)‖cepstral_coefficents = np.dot(dct_filters, audio_log)‖1
"logging.info(f""cepstral_coefficents shape: {cepstral_coefficents.shape}"")"‖return cepstral_coefficents‖1
def audio_frames(‖audio: np.ndarray,‖1
sample_rate: int,‖hop_length: int = 20,‖1
hop_length: int = 20,‖ftt_size: int = 1024,‖1
ftt_size: int = 1024,‖) -> np.ndarray:‖1
for n in range(frame_count):‖frames[n] = audio[n * hop_size : n * hop_size + ftt_size]‖1
audio_fft = np.empty(‖(int(1 + ftt_size // 2), audio_transposed.shape[1]),‖1
(int(1 + ftt_size // 2), audio_transposed.shape[1]),‖dtype=np.complex64,‖1
dtype=np.complex64,‖"order=""F"","‖1
"order=""F"","‖)‖1
for n in range(audio_fft.shape[1]):‖audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]‖1
def mel_spaced_filterbank(‖sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024‖1
sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024‖) -> np.ndarray:‖1
) -> np.ndarray:‖freq_min = 0‖1
freq_min = 0‖freq_high = sample_rate // 2‖1
"logging.info(f""Minimum frequency: {freq_min}"")"‖"logging.info(f""Maximum frequency: {freq_high}"")"‖1
filter_points, mel_freqs = get_filter_points(‖sample_rate,‖1
sample_rate,‖freq_min,‖1
freq_min,‖freq_high,‖1
freq_high,‖mel_filter_num,‖1
mel_filter_num,‖ftt_size,‖1
ftt_size,‖)‖1
enorm = 2.0 / (mel_freqs[2 : mel_filter_num + 2] - mel_freqs[:mel_filter_num])‖return filters * enorm[:, np.newaxis]‖1
def get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:‖num_filters = len(filter_points) - 2‖1
num_filters = len(filter_points) - 2‖filters = np.zeros((num_filters, int(ftt_size / 2) + 1))‖1
for n in range(num_filters):‖start = filter_points[n]‖1
start = filter_points[n]‖mid = filter_points[n + 1]‖1
mid = filter_points[n + 1]‖end = filter_points[n + 2]‖1
def get_filter_points(‖sample_rate: int,‖1
sample_rate: int,‖freq_min: int,‖1
freq_min: int,‖freq_high: int,‖1
freq_high: int,‖mel_filter_num: int = 10,‖1
mel_filter_num: int = 10,‖ftt_size: int = 1024,‖1
ftt_size: int = 1024,‖) -> tuple[np.ndarray, np.ndarray]:‖1
fmin_mel = freq_to_mel(freq_min)‖fmax_mel = freq_to_mel(freq_high)‖1
"logging.info(f""MEL min: {fmin_mel}"")"‖"logging.info(f""MEL max: {fmax_mel}"")"‖1
def discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:‖basis = np.empty((dct_filter_num, filter_num))‖1
basis = np.empty((dct_filter_num, filter_num))‖basis[0, :] = 1.0 / np.sqrt(filter_num)‖1
for i in range(1, dct_filter_num):‖basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)‖1
"def example(wav_file_path: str = ""./path-to-file/sample.wav"") -> np.ndarray:"‖from scipy.io import wavfile‖1
def retroactive_resolution(‖coefficients: NDArray[float64], vector: NDArray[float64]‖1
coefficients: NDArray[float64], vector: NDArray[float64]‖) -> NDArray[float64]:‖2
x: NDArray[float64] = np.zeros((rows, 1), dtype=float)‖for row in reversed(range(rows)):‖1
for row in reversed(range(rows)):‖total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])‖1
total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])‖x[row, 0] = (vector[row][0] - total[0]) / coefficients[row, row]‖1
def gaussian_elimination(‖coefficients: NDArray[float64], vector: NDArray[float64]‖1
rows, columns = np.shape(coefficients)‖if rows != columns:‖1
if rows != columns:‖return np.array((), dtype=float)‖1
augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)‖"augmented_mat = augmented_mat.astype(""float64"")"‖1
for row in range(rows - 1):‖pivot = augmented_mat[row, row]‖1
pivot = augmented_mat[row, row]‖for col in range(row + 1, columns):‖1
for col in range(row + 1, columns):‖factor = augmented_mat[col, row] / pivot‖1
factor = augmented_mat[col, row] / pivot‖augmented_mat[col, :] -= factor * augmented_mat[row, :]‖1
x = retroactive_resolution(‖augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]‖1
augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]‖)‖1
def points_to_polynomial(coordinates: list[list[int]]) -> str:‖if len(coordinates) == 0 or not all(len(pair) == 2 for pair in coordinates):‖1
if len(coordinates) == 0 or not all(len(pair) == 2 for pair in coordinates):‖"raise ValueError(""The program cannot work out a fitting polynomial."")"‖1
if len({tuple(pair) for pair in coordinates}) != len(coordinates):‖"raise ValueError(""The program cannot work out a fitting polynomial."")"‖1
set_x = {x for x, _ in coordinates}‖if len(set_x) == 1:‖1
if len(set_x) == 1:‖"return f""x={coordinates[0][0]}"""‖1
if len(set_x) != len(coordinates):‖"raise ValueError(""The program cannot work out a fitting polynomial."")"‖1
matrix: list[list[float]] = [‖[‖1
[‖coordinates[count_of_line][0] ** (x - (count_in_line + 1))‖1
coordinates[count_of_line][0] ** (x - (count_in_line + 1))‖for count_in_line in range(x)‖1
for count_in_line in range(x)‖]‖1
]‖for count_of_line in range(x)‖1
for count_of_line in range(x)‖]‖1
for count in range(x):‖for number in range(x):‖1
for number in range(x):‖if count == number:‖1
if count == number:‖continue‖1
continue‖fraction = matrix[number][count] / matrix[count][count]‖1
fraction = matrix[number][count] / matrix[count][count]‖for counting_columns, item in enumerate(matrix[count]):‖1
solution: list[str] = [‖str(vector[count] / matrix[count][count]) for count in range(x)‖1
str(vector[count] / matrix[count][count]) for count in range(x)‖]‖1
for count in range(x):‖"remove_e: list[str] = solution[count].split(""E"")"‖1
"remove_e: list[str] = solution[count].split(""E"")"‖if len(remove_e) > 1:‖1
if len(remove_e) > 1:‖"solution[count] = f""{remove_e[0]}*10^{remove_e[1]}"""‖1
"solution[count] = f""{remove_e[0]}*10^{remove_e[1]}"""‖"solved += f""x^{x - (count + 1)}*{solution[count]}"""‖1
"solved += f""x^{x - (count + 1)}*{solution[count]}"""‖if count + 1 != x:‖1
if count + 1 != x:‖"solved += ""+"""‖1
"if __name__ == ""__main__"":"‖print(points_to_polynomial([]))‖1
print(points_to_polynomial([]))‖print(points_to_polynomial([[]]))‖1
print(points_to_polynomial([[]]))‖print(points_to_polynomial([[1, 0], [2, 0], [3, 0]]))‖1
print(points_to_polynomial([[1, 0], [2, 0], [3, 0]]))‖print(points_to_polynomial([[1, 1], [2, 1], [3, 1]]))‖1
print(points_to_polynomial([[1, 1], [2, 1], [3, 1]]))‖print(points_to_polynomial([[1, 3], [2, 3], [3, 3]]))‖1
print(points_to_polynomial([[1, 3], [2, 3], [3, 3]]))‖print(points_to_polynomial([[1, 1], [2, 2], [3, 3]]))‖1
print(points_to_polynomial([[1, 1], [2, 2], [3, 3]]))‖print(points_to_polynomial([[1, 1], [2, 4], [3, 9]]))‖1
print(points_to_polynomial([[1, 1], [2, 4], [3, 9]]))‖print(points_to_polynomial([[1, 3], [2, 6], [3, 11]]))‖1
print(points_to_polynomial([[1, 3], [2, 6], [3, 11]]))‖print(points_to_polynomial([[1, -3], [2, -6], [3, -11]]))‖1
print(points_to_polynomial([[1, -3], [2, -6], [3, -11]]))‖print(points_to_polynomial([[1, 5], [2, 2], [3, 9]]))‖1
def load_data() -> list[list[str]]:‖"return [[""milk""], [""milk"", ""butter""], [""milk"", ""bread""], [""milk"", ""bread"", ""chips""]]"‖1
def prune(itemset: list, candidates: list, length: int) -> list:‖pruned = []‖1
pruned = []‖for candidate in candidates:‖1
for candidate in candidates:‖is_subsequence = True‖1
is_subsequence = True‖for item in candidate:‖1
for item in candidate:‖if item not in itemset or itemset.count(item) < length - 1:‖1
if item not in itemset or itemset.count(item) < length - 1:‖is_subsequence = False‖1
is_subsequence = False‖break‖1
break‖if is_subsequence:‖1
if is_subsequence:‖pruned.append(candidate)‖1
pruned.append(candidate)‖return pruned‖1
def apriori(data: list[list[str]], min_support: int) -> list[tuple[list[str], int]]:‖itemset = [list(transaction) for transaction in data]‖1
itemset = [list(transaction) for transaction in data]‖frequent_itemsets = []‖1
frequent_itemsets = []‖length = 1‖1
counts = [0] * len(itemset)‖for transaction in data:‖1
for transaction in data:‖for j, candidate in enumerate(itemset):‖1
for j, candidate in enumerate(itemset):‖if all(item in transaction for item in candidate):‖1
if all(item in transaction for item in candidate):‖counts[j] += 1‖1
for i, item in enumerate(itemset):‖frequent_itemsets.append((sorted(item), counts[i]))‖1
length += 1‖itemset = prune(itemset, list(combinations(itemset, length)), length)‖1
frequent_itemsets = apriori(data=load_data(), min_support=2)‖"print(""\n"".join(f""{itemset}: {support}"" for itemset, support in frequent_itemsets))"‖1
name: str‖count: int‖1
count: int‖parent: TreeNode | None = None‖1
parent: TreeNode | None = None‖children: dict[str, TreeNode] = field(default_factory=dict)‖1
children: dict[str, TreeNode] = field(default_factory=dict)‖node_link: TreeNode | None = None‖1
def __repr__(self) -> str:‖"return f""TreeNode({self.name!r}, {self.count!r}, {self.parent!r})"""‖1
def inc(self, num_occur: int) -> None:‖self.count += num_occur‖1
def disp(self, ind: int = 1) -> None:‖"print(f""{'  ' * ind} {self.name}  {self.count}"")"‖1
"print(f""{'  ' * ind} {self.name}  {self.count}"")"‖for child in self.children.values():‖1
for child in self.children.values():‖child.disp(ind + 1)‖1
def create_tree(data_set: list, min_sup: int = 1) -> tuple[TreeNode, dict]:‖header_table: dict = {}‖1
header_table: dict = {}‖for trans in data_set:‖1
for trans in data_set:‖for item in trans:‖1
for item in trans:‖header_table[item] = header_table.get(item, [0, None])‖1
header_table[item] = header_table.get(item, [0, None])‖header_table[item][0] += 1‖1
for k in list(header_table):‖if header_table[k][0] < min_sup:‖1
if header_table[k][0] < min_sup:‖del header_table[k]‖1
if not (freq_item_set := set(header_table)):‖"return TreeNode(""Null Set"", 1, None), {}"‖1
for key, value in header_table.items():‖header_table[key] = [value, None]‖1
"fp_tree = TreeNode(""Null Set"", 1, None)"‖for tran_set in data_set:‖1
for tran_set in data_set:‖local_d = {‖1
local_d = {‖item: header_table[item][0] for item in tran_set if item in freq_item_set‖1
item: header_table[item][0] for item in tran_set if item in freq_item_set‖}‖1
}‖if local_d:‖1
if local_d:‖sorted_items = sorted(‖1
sorted_items = sorted(‖local_d.items(), key=lambda item_info: item_info[1], reverse=True‖1
local_d.items(), key=lambda item_info: item_info[1], reverse=True‖)‖1
)‖ordered_items = [item[0] for item in sorted_items]‖1
ordered_items = [item[0] for item in sorted_items]‖update_tree(ordered_items, fp_tree, header_table, 1)‖1
def update_tree(items: list, in_tree: TreeNode, header_table: dict, count: int) -> None:‖if items[0] in in_tree.children:‖1
if items[0] in in_tree.children:‖in_tree.children[items[0]].inc(count)‖1
in_tree.children[items[0]].inc(count)‖else:‖1
else:‖in_tree.children[items[0]] = TreeNode(items[0], count, in_tree)‖1
in_tree.children[items[0]] = TreeNode(items[0], count, in_tree)‖if header_table[items[0]][1] is None:‖1
if header_table[items[0]][1] is None:‖header_table[items[0]][1] = in_tree.children[items[0]]‖1
header_table[items[0]][1] = in_tree.children[items[0]]‖else:‖1
else:‖update_header(header_table[items[0]][1], in_tree.children[items[0]])‖1
update_header(header_table[items[0]][1], in_tree.children[items[0]])‖if len(items) > 1:‖1
if len(items) > 1:‖update_tree(items[1:], in_tree.children[items[0]], header_table, count)‖1
def update_header(node_to_test: TreeNode, target_node: TreeNode) -> TreeNode:‖while node_to_test.node_link is not None:‖1
while node_to_test.node_link is not None:‖node_to_test = node_to_test.node_link‖1
node_to_test = node_to_test.node_link‖if node_to_test.node_link is None:‖1
if node_to_test.node_link is None:‖node_to_test.node_link = target_node‖1
def ascend_tree(leaf_node: TreeNode, prefix_path: list[str]) -> None:‖if leaf_node.parent is not None:‖1
if leaf_node.parent is not None:‖prefix_path.append(leaf_node.name)‖1
prefix_path.append(leaf_node.name)‖ascend_tree(leaf_node.parent, prefix_path)‖1
def find_prefix_path(base_pat: frozenset, tree_node: TreeNode | None) -> dict:‖cond_pats: dict = {}‖1
cond_pats: dict = {}‖while tree_node is not None:‖1
while tree_node is not None:‖prefix_path: list = []‖1
prefix_path: list = []‖ascend_tree(tree_node, prefix_path)‖1
ascend_tree(tree_node, prefix_path)‖if len(prefix_path) > 1:‖1
if len(prefix_path) > 1:‖cond_pats[frozenset(prefix_path[1:])] = tree_node.count‖1
cond_pats[frozenset(prefix_path[1:])] = tree_node.count‖tree_node = tree_node.node_link‖1
tree_node = tree_node.node_link‖return cond_pats‖1
def mine_tree(‖in_tree: TreeNode,‖1
in_tree: TreeNode,‖header_table: dict,‖1
header_table: dict,‖min_sup: int,‖1
min_sup: int,‖pre_fix: set,‖1
pre_fix: set,‖freq_item_list: list,‖1
freq_item_list: list,‖) -> None:‖1
) -> None:‖sorted_items = sorted(header_table.items(), key=lambda item_info: item_info[1][0])‖1
sorted_items = sorted(header_table.items(), key=lambda item_info: item_info[1][0])‖big_l = [item[0] for item in sorted_items]‖1
big_l = [item[0] for item in sorted_items]‖for base_pat in big_l:‖1
for base_pat in big_l:‖new_freq_set = pre_fix.copy()‖1
new_freq_set = pre_fix.copy()‖new_freq_set.add(base_pat)‖1
new_freq_set.add(base_pat)‖freq_item_list.append(new_freq_set)‖1
freq_item_list.append(new_freq_set)‖cond_patt_bases = find_prefix_path(base_pat, header_table[base_pat][1])‖1
cond_patt_bases = find_prefix_path(base_pat, header_table[base_pat][1])‖my_cond_tree, my_head = create_tree(list(cond_patt_bases), min_sup)‖1
my_cond_tree, my_head = create_tree(list(cond_patt_bases), min_sup)‖if my_head is not None:‖1
header_table[base_pat][1] = update_header(‖header_table[base_pat][1], my_cond_tree‖1
header_table[base_pat][1], my_cond_tree‖)‖1
)‖mine_tree(my_cond_tree, my_head, min_sup, new_freq_set, freq_item_list)‖1
testmod()‖data_set: list[frozenset] = [‖1
data_set: list[frozenset] = [‖"frozenset([""bread"", ""milk"", ""cheese""]),"‖1
"frozenset([""bread"", ""milk"", ""cheese""]),"‖"frozenset([""bread"", ""milk""]),"‖1
"frozenset([""bread"", ""milk""]),"‖"frozenset([""bread"", ""diapers""]),"‖1
"frozenset([""bread"", ""diapers""]),"‖"frozenset([""bread"", ""milk"", ""diapers""]),"‖1
"frozenset([""bread"", ""milk"", ""diapers""]),"‖"frozenset([""milk"", ""diapers""]),"‖1
"frozenset([""milk"", ""diapers""]),"‖"frozenset([""milk"", ""cheese""]),"‖1
"frozenset([""milk"", ""cheese""]),"‖"frozenset([""diapers"", ""cheese""]),"‖1
"frozenset([""diapers"", ""cheese""]),"‖"frozenset([""bread"", ""milk"", ""cheese"", ""diapers""]),"‖1
"frozenset([""bread"", ""milk"", ""cheese"", ""diapers""]),"‖]‖1
]‖"print(f""{len(data_set) = }"")"‖1
"print(f""{len(data_set) = }"")"‖fp_tree, header_table = create_tree(data_set, min_sup=3)‖1
fp_tree, header_table = create_tree(data_set, min_sup=3)‖"print(f""{fp_tree = }"")"‖1
"print(f""{fp_tree = }"")"‖"print(f""{len(header_table) = }"")"‖1
"print(f""{len(header_table) = }"")"‖freq_items: list = []‖1
freq_items: list = []‖mine_tree(fp_tree, header_table, 3, set(), freq_items)‖1
mine_tree(fp_tree, header_table, 3, set(), freq_items)‖"print(f""{freq_items = }"")"‖1
import numpy as np‖from sklearn.datasets import load_iris‖1
from sklearn.datasets import load_iris‖from sklearn.metrics import accuracy_score‖1
from sklearn.metrics import accuracy_score‖from sklearn.model_selection import train_test_split‖1
from sklearn.model_selection import train_test_split‖from sklearn.tree import DecisionTreeRegressor‖1
class GradientBoostingClassifier:‖def __init__(self, n_estimators: int = 100, learning_rate: float = 0.1) -> None:‖1
def __init__(self, n_estimators: int = 100, learning_rate: float = 0.1) -> None:‖self.n_estimators = n_estimators‖1
self.n_estimators = n_estimators‖self.learning_rate = learning_rate‖1
self.learning_rate = learning_rate‖self.models: list[tuple[DecisionTreeRegressor, float]] = []‖1
def fit(self, features: np.ndarray, target: np.ndarray) -> None:‖for _ in range(self.n_estimators):‖1
model = DecisionTreeRegressor(max_depth=1)‖model.fit(features, residuals)‖1
predictions = np.zeros(features.shape[0])‖for model, learning_rate in self.models:‖1
for model, learning_rate in self.models:‖predictions += learning_rate * model.predict(features)‖1
predictions += learning_rate * model.predict(features)‖return np.sign(predictions)‖1
def gradient(self, target: np.ndarray, y_pred: np.ndarray) -> np.ndarray:‖return -target / (1 + np.exp(target * y_pred))‖1
"if __name__ == ""__main__"":"‖iris = load_iris()‖1
iris = load_iris()‖X, y = iris.data, iris.target‖1
X, y = iris.data, iris.target‖X_train, X_test, y_train, y_test = train_test_split(‖1
X_train, X_test, y_train, y_test = train_test_split(‖X, y, test_size=0.2, random_state=42‖1
X, y, test_size=0.2, random_state=42‖)‖1
clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)‖clf.fit(X_train, y_train)‖1
y_pred = clf.predict(X_test)‖accuracy = accuracy_score(y_test, y_pred)‖1
accuracy = accuracy_score(y_test, y_pred)‖"print(f""Accuracy: {accuracy:.2f}"")"‖1
from collections import Counter‖from heapq import nsmallest‖1
import numpy as np‖from sklearn import datasets‖1
from sklearn import datasets‖from sklearn.model_selection import train_test_split‖1
class KNN:‖def __init__(‖1
self,‖train_data: np.ndarray[float],‖1
train_data: np.ndarray[float],‖train_target: np.ndarray[int],‖1
train_target: np.ndarray[int],‖class_labels: list[str],‖1
class_labels: list[str],‖) -> None:‖1
) -> None:‖self.data = zip(train_data, train_target)‖1
self.data = zip(train_data, train_target)‖self.labels = class_labels‖1
@staticmethod‖def _euclidean_distance(a: np.ndarray[float], b: np.ndarray[float]) -> float:‖1
def _euclidean_distance(a: np.ndarray[float], b: np.ndarray[float]) -> float:‖return float(np.linalg.norm(a - b))‖1
distances = (‖(self._euclidean_distance(data_point[0], pred_point), data_point[1])‖1
(self._euclidean_distance(data_point[0], pred_point), data_point[1])‖for data_point in self.data‖1
for data_point in self.data‖)‖1
result = Counter(votes).most_common(1)[0][0]‖return self.labels[result]‖1
"X = np.array(iris[""data""])"‖"y = np.array(iris[""target""])"‖1
"y = np.array(iris[""target""])"‖"iris_classes = iris[""target_names""]"‖1
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)‖iris_point = np.array([4.4, 3.1, 1.3, 1.4])‖1
iris_point = np.array([4.4, 3.1, 1.3, 1.4])‖classifier = KNN(X_train, y_train, iris_classes)‖1
classifier = KNN(X_train, y_train, iris_classes)‖print(classifier.classify(iris_point, k=3))‖1
import random‖from collections.abc import Collection‖1
from collections.abc import Collection‖from typing import overload‖1
def __init__(self, components: Collection[float] | None = None) -> None:‖if components is None:‖1
if components is None:‖components = []‖1
components = []‖self.__components = list(components)‖1
def __len__(self) -> int:‖return len(self.__components)‖1
def __str__(self) -> str:‖"return ""("" + "","".join(map(str, self.__components)) + "")"""‖1
def __add__(self, other: Vector) -> Vector:‖size = len(self)‖1
size = len(self)‖if size == len(other):‖2
if size == len(other):‖result = [self.__components[i] + other.component(i) for i in range(size)]‖1
result = [self.__components[i] + other.component(i) for i in range(size)]‖return Vector(result)‖1
return Vector(result)‖else:‖2
else:‖"raise Exception(""must have the same size"")"‖2
def __sub__(self, other: Vector) -> Vector:‖size = len(self)‖1
if size == len(other):‖result = [self.__components[i] - other.component(i) for i in range(size)]‖1
result = [self.__components[i] - other.component(i) for i in range(size)]‖return Vector(result)‖1
def __eq__(self, other: object) -> bool:‖if not isinstance(other, Vector):‖1
if not isinstance(other, Vector):‖return NotImplemented‖1
return NotImplemented‖if len(self) != len(other):‖1
return False‖return all(self.component(i) == other.component(i) for i in range(len(self)))‖1
@overload‖def __mul__(self, other: float) -> Vector: ...‖1
@overload‖def __mul__(self, other: Vector) -> float: ...‖1
def __mul__(self, other: float | Vector) -> float | Vector:‖if isinstance(other, (float, int)):‖1
if isinstance(other, (float, int)):‖ans = [c * other for c in self.__components]‖1
ans = [c * other for c in self.__components]‖return Vector(ans)‖1
return Vector(ans)‖elif isinstance(other, Vector) and len(self) == len(other):‖1
elif isinstance(other, Vector) and len(self) == len(other):‖size = len(self)‖1
size = len(self)‖prods = [self.__components[i] * other.component(i) for i in range(size)]‖1
prods = [self.__components[i] * other.component(i) for i in range(size)]‖return sum(prods)‖1
return sum(prods)‖else:‖1
else:‖"raise Exception(""invalid operand!"")"‖1
def copy(self) -> Vector:‖return Vector(self.__components)‖1
def component(self, i: int) -> float:‖if isinstance(i, int) and -len(self.__components) <= i < len(self.__components):‖1
if isinstance(i, int) and -len(self.__components) <= i < len(self.__components):‖return self.__components[i]‖1
return self.__components[i]‖else:‖1
else:‖"raise Exception(""index out of range"")"‖1
assert -len(self.__components) <= pos < len(self.__components)‖self.__components[pos] = value‖1
def euclidean_length(self) -> float:‖if len(self.__components) == 0:‖1
if len(self.__components) == 0:‖"raise Exception(""Vector is empty"")"‖1
"raise Exception(""Vector is empty"")"‖squares = [c**2 for c in self.__components]‖1
squares = [c**2 for c in self.__components]‖return math.sqrt(sum(squares))‖1
def angle(self, other: Vector, deg: bool = False) -> float:‖num = self * other‖1
num = self * other‖den = self.euclidean_length() * other.euclidean_length()‖1
den = self.euclidean_length() * other.euclidean_length()‖if deg:‖1
if deg:‖return math.degrees(math.acos(num / den))‖1
return math.degrees(math.acos(num / den))‖else:‖1
else:‖return math.acos(num / den)‖1
assert isinstance(dimension, int)‖return Vector([0] * dimension)‖1
assert isinstance(dimension, int)‖assert isinstance(pos, int)‖1
assert isinstance(pos, int)‖ans = [0] * dimension‖1
ans = [0] * dimension‖ans[pos] = 1‖1
ans[pos] = 1‖return Vector(ans)‖1
assert isinstance(x, Vector)‖assert isinstance(y, Vector)‖1
assert isinstance(y, Vector)‖assert isinstance(scalar, (int, float))‖1
assert isinstance(scalar, (int, float))‖return x * scalar + y‖1
def random_vector(n: int, a: int, b: int) -> Vector:‖random.seed(None)‖1
random.seed(None)‖ans = [random.randint(a, b) for _ in range(n)]‖1
ans = [random.randint(a, b) for _ in range(n)]‖return Vector(ans)‖1
def __init__(self, matrix: list[list[float]], w: int, h: int) -> None:‖self.__matrix = matrix‖1
self.__matrix = matrix‖self.__width = w‖1
self.__width = w‖self.__height = h‖1
def __str__(self) -> str:‖"ans = """""‖1
"ans = """""‖for i in range(self.__height):‖1
for i in range(self.__height):‖"ans += ""|"""‖1
"ans += ""|"""‖for j in range(self.__width):‖1
for j in range(self.__width):‖if j < self.__width - 1:‖1
if j < self.__width - 1:‖"ans += str(self.__matrix[i][j]) + "","""‖1
"ans += str(self.__matrix[i][j]) + "","""‖else:‖1
else:‖"ans += str(self.__matrix[i][j]) + ""|\n"""‖1
"ans += str(self.__matrix[i][j]) + ""|\n"""‖return ans‖1
def __add__(self, other: Matrix) -> Matrix:‖if self.__width == other.width() and self.__height == other.height():‖1
if self.__width == other.width() and self.__height == other.height():‖matrix = []‖2
matrix = []‖for i in range(self.__height):‖2
for i in range(self.__height):‖row = [‖2
row = [‖self.__matrix[i][j] + other.component(i, j)‖1
self.__matrix[i][j] + other.component(i, j)‖for j in range(self.__width)‖1
for j in range(self.__width)‖]‖3
]‖matrix.append(row)‖2
matrix.append(row)‖return Matrix(matrix, self.__width, self.__height)‖2
return Matrix(matrix, self.__width, self.__height)‖else:‖2
else:‖"raise Exception(""matrix must have the same dimension!"")"‖1
def __sub__(self, other: Matrix) -> Matrix:‖if self.__width == other.width() and self.__height == other.height():‖1
row = [‖self.__matrix[i][j] - other.component(i, j)‖1
self.__matrix[i][j] - other.component(i, j)‖for j in range(self.__width)‖1
else:‖"raise Exception(""matrices must have the same dimension!"")"‖1
@overload‖def __mul__(self, other: float) -> Matrix: ...‖1
@overload‖def __mul__(self, other: Vector) -> Vector: ...‖1
def __mul__(self, other: float | Vector) -> Vector | Matrix:‖if isinstance(other, Vector):‖1
if isinstance(other, Vector):‖if len(other) == self.__width:‖1
if len(other) == self.__width:‖ans = zero_vector(self.__height)‖1
ans = zero_vector(self.__height)‖for i in range(self.__height):‖1
for i in range(self.__height):‖prods = [‖1
prods = [‖self.__matrix[i][j] * other.component(j)‖1
self.__matrix[i][j] * other.component(j)‖for j in range(self.__width)‖1
]‖ans.change_component(i, sum(prods))‖1
ans.change_component(i, sum(prods))‖return ans‖1
return ans‖else:‖1
else:‖raise Exception(‖1
raise Exception(‖"""vector must have the same size as the """‖1
"""vector must have the same size as the """‖"""number of columns of the matrix!"""‖1
"""number of columns of the matrix!"""‖)‖1
)‖elif isinstance(other, (int, float)):‖1
elif isinstance(other, (int, float)):‖matrix = [‖1
matrix = [‖[self.__matrix[i][j] * other for j in range(self.__width)]‖1
[self.__matrix[i][j] * other for j in range(self.__width)]‖for i in range(self.__height)‖1
for i in range(self.__height)‖]‖1
]‖return Matrix(matrix, self.__width, self.__height)‖1
return Matrix(matrix, self.__width, self.__height)‖return None‖1
def height(self) -> int:‖return self.__height‖1
def width(self) -> int:‖return self.__width‖1
def component(self, x: int, y: int) -> float:‖if 0 <= x < self.__height and 0 <= y < self.__width:‖1
if 0 <= x < self.__height and 0 <= y < self.__width:‖return self.__matrix[x][y]‖1
return self.__matrix[x][y]‖else:‖1
else:‖"raise Exception(""change_component: indices out of bounds"")"‖2
def change_component(self, x: int, y: int, value: float) -> None:‖if 0 <= x < self.__height and 0 <= y < self.__width:‖1
if 0 <= x < self.__height and 0 <= y < self.__width:‖self.__matrix[x][y] = value‖1
self.__matrix[x][y] = value‖else:‖1
def minor(self, x: int, y: int) -> float:‖if self.__height != self.__width:‖1
if self.__height != self.__width:‖"raise Exception(""Matrix is not square"")"‖3
"raise Exception(""Matrix is not square"")"‖minor = self.__matrix[:x] + self.__matrix[x + 1 :]‖1
minor = self.__matrix[:x] + self.__matrix[x + 1 :]‖for i in range(len(minor)):‖1
for i in range(len(minor)):‖minor[i] = minor[i][:y] + minor[i][y + 1 :]‖1
minor[i] = minor[i][:y] + minor[i][y + 1 :]‖return Matrix(minor, self.__width - 1, self.__height - 1).determinant()‖1
def cofactor(self, x: int, y: int) -> float:‖if self.__height != self.__width:‖1
"raise Exception(""Matrix is not square"")"‖if 0 <= x < self.__height and 0 <= y < self.__width:‖1
if 0 <= x < self.__height and 0 <= y < self.__width:‖return (-1) ** (x + y) * self.minor(x, y)‖1
return (-1) ** (x + y) * self.minor(x, y)‖else:‖1
else:‖"raise Exception(""Indices out of bounds"")"‖1
def determinant(self) -> float:‖if self.__height != self.__width:‖1
"raise Exception(""Matrix is not square"")"‖if self.__height < 1:‖1
if self.__height < 1:‖"raise Exception(""Matrix has no element"")"‖1
"raise Exception(""Matrix has no element"")"‖elif self.__height == 1:‖1
elif self.__height == 1:‖return self.__matrix[0][0]‖1
return self.__matrix[0][0]‖elif self.__height == 2:‖1
elif self.__height == 2:‖return (‖1
return (‖self.__matrix[0][0] * self.__matrix[1][1]‖1
self.__matrix[0][0] * self.__matrix[1][1]‖- self.__matrix[0][1] * self.__matrix[1][0]‖1
- self.__matrix[0][1] * self.__matrix[1][0]‖)‖1
else:‖cofactor_prods = [‖1
cofactor_prods = [‖self.__matrix[0][y] * self.cofactor(0, y) for y in range(self.__width)‖1
self.__matrix[0][y] * self.cofactor(0, y) for y in range(self.__width)‖]‖1
]‖return sum(cofactor_prods)‖1
def square_zero_matrix(n: int) -> Matrix:‖ans: list[list[float]] = [[0] * n for _ in range(n)]‖1
ans: list[list[float]] = [[0] * n for _ in range(n)]‖return Matrix(ans, n, n)‖1
def random_matrix(width: int, height: int, a: int, b: int) -> Matrix:‖random.seed(None)‖1
random.seed(None)‖matrix: list[list[float]] = [‖1
matrix: list[list[float]] = [‖[random.randint(a, b) for _ in range(width)] for _ in range(height)‖1
[random.randint(a, b) for _ in range(width)] for _ in range(height)‖]‖1
]‖return Matrix(matrix, width, height)‖1
def __init__(self):‖self.position = (0, 0)‖1
self.position = (0, 0)‖self.parent = None‖1
self.parent = None‖self.g = 0‖1
self.g = 0‖self.h = 0‖1
self.h = 0‖self.f = 0‖1
def __eq__(self, cell):‖return self.position == cell.position‖1
def showcell(self):‖print(self.position)‖1
def __init__(self, world_size=(5, 5)):‖self.w = np.zeros(world_size)‖1
self.w = np.zeros(world_size)‖self.world_x_limit = world_size[0]‖1
self.world_x_limit = world_size[0]‖self.world_y_limit = world_size[1]‖1
def show(self):‖print(self.w)‖1
def get_neighbours(self, cell):‖neughbour_cord = [‖1
neughbour_cord = [‖(-1, -1),‖1
(-1, -1),‖(-1, 0),‖1
(-1, 0),‖(-1, 1),‖1
(-1, 1),‖(0, -1),‖1
(0, -1),‖(0, 1),‖1
(0, 1),‖(1, -1),‖1
(1, -1),‖(1, 0),‖1
(1, 0),‖(1, 1),‖1
(1, 1),‖]‖1
]‖current_x = cell.position[0]‖1
current_x = cell.position[0]‖current_y = cell.position[1]‖1
current_y = cell.position[1]‖neighbours = []‖1
neighbours = []‖for n in neughbour_cord:‖1
for n in neughbour_cord:‖x = current_x + n[0]‖1
x = current_x + n[0]‖y = current_y + n[1]‖1
y = current_y + n[1]‖if 0 <= x < self.world_x_limit and 0 <= y < self.world_y_limit:‖1
if 0 <= x < self.world_x_limit and 0 <= y < self.world_y_limit:‖c = Cell()‖1
c = Cell()‖c.position = (x, y)‖1
c.position = (x, y)‖c.parent = cell‖1
c.parent = cell‖neighbours.append(c)‖1
neighbours.append(c)‖return neighbours‖1
def astar(world, start, goal):‖_open = []‖1
_open = []‖_closed = []‖1
_closed = []‖_open.append(start)‖1
while _open:‖min_f = np.argmin([n.f for n in _open])‖1
min_f = np.argmin([n.f for n in _open])‖current = _open[min_f]‖1
current = _open[min_f]‖_closed.append(_open.pop(min_f))‖1
_closed.append(_open.pop(min_f))‖if current == goal:‖1
if current == goal:‖break‖1
break‖for n in world.get_neighbours(current):‖1
for n in world.get_neighbours(current):‖for c in _closed:‖1
for c in _closed:‖if c == n:‖1
if c == n:‖continue‖1
continue‖n.g = current.g + 1‖1
n.g = current.g + 1‖x1, y1 = n.position‖1
x1, y1 = n.position‖x2, y2 = goal.position‖1
x2, y2 = goal.position‖n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2‖1
n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2‖n.f = n.h + n.g‖1
for c in _open:‖if c == n and c.f < n.f:‖1
if c == n and c.f < n.f:‖continue‖1
continue‖_open.append(n)‖1
_open.append(n)‖path = []‖1
path = []‖while current.parent is not None:‖1
while current.parent is not None:‖path.append(current.position)‖1
path.append(current.position)‖current = current.parent‖1
current = current.parent‖path.append(current.position)‖1
path.append(current.position)‖return path[::-1]‖1
"if __name__ == ""__main__"":"‖world = Gridworld()‖1
start = Cell()‖start.position = (0, 0)‖1
start.position = (0, 0)‖goal = Cell()‖1
goal = Cell()‖goal.position = (4, 4)‖1
goal.position = (4, 4)‖"print(f""path from {start.position} to {goal.position}"")"‖1
"print(f""path from {start.position} to {goal.position}"")"‖s = astar(world, start, goal)‖1
for i in s:‖world.w[i] = 1‖1
world.w[i] = 1‖print(world.w)‖1
from collections.abc import Callable‖from math import log‖1
from math import log‖from os import name, system‖1
from os import name, system‖from random import gauss, seed‖1
from random import gauss, seed‖from typing import TypeVar‖1
def gaussian_distribution(mean: float, std_dev: float, instance_count: int) -> list:‖seed(1)‖1
seed(1)‖return [gauss(mean, std_dev) for _ in range(instance_count)]‖1
def calculate_variance(items: list, means: list, total_count: int) -> float:‖squared_diff = []‖1
n_classes = len(means)‖return 1 / (total_count - n_classes) * sum(squared_diff)‖1
def predict_y_values(‖x_items: list, means: list, variance: float, probabilities: list‖1
x_items: list, means: list, variance: float, probabilities: list‖) -> list:‖1
for j in range(len(x_items[i])):‖temp = []‖1
temp.append(‖x_items[i][j] * (means[k] / variance)‖1
x_items[i][j] * (means[k] / variance)‖- (means[k] ** 2 / (2 * variance))‖1
- (means[k] ** 2 / (2 * variance))‖+ log(probabilities[k])‖1
+ log(probabilities[k])‖)‖1
def valid_input(‖input_type: Callable[[object], num],‖1
input_type: Callable[[object], num],‖input_msg: str,‖1
input_msg: str,‖err_msg: str,‖1
err_msg: str,‖condition: Callable[[num], bool] = lambda _: True,‖1
condition: Callable[[num], bool] = lambda _: True,‖default: str | None = None,‖1
default: str | None = None,‖) -> num:‖1
) -> num:‖while True:‖1
try:‖user_input = input_type(input(input_msg).strip() or default)‖1
user_input = input_type(input(input_msg).strip() or default)‖if condition(user_input):‖1
if condition(user_input):‖return user_input‖1
return user_input‖else:‖1
else:‖"print(f""{user_input}: {err_msg}"")"‖1
"print(f""{user_input}: {err_msg}"")"‖continue‖1
continue‖except ValueError:‖1
except ValueError:‖print(‖1
print(‖"f""{user_input}: Incorrect input type, expected {input_type.__name__!r}"""‖1
"f""{user_input}: Incorrect input type, expected {input_type.__name__!r}"""‖)‖1
def main():‖while True:‖1
while True:‖"print("" Linear Discriminant Analysis "".center(50, ""*""))"‖1
"print("" Linear Discriminant Analysis "".center(50, ""*""))"‖"print(""*"" * 50, ""\n"")"‖1
"print(""*"" * 50, ""\n"")"‖"print(""First of all we should specify the number of classes that"")"‖1
"print(""First of all we should specify the number of classes that"")"‖"print(""we want to generate as training dataset"")"‖1
n_classes = valid_input(‖input_type=int,‖1
input_type=int,‖condition=lambda x: x > 0,‖2
condition=lambda x: x > 0,‖"input_msg=""Enter the number of classes (Data Groupings): "","‖1
"input_msg=""Enter the number of classes (Data Groupings): "","‖"err_msg=""Number of classes should be positive!"","‖1
"err_msg=""Number of classes should be positive!"","‖)‖1
std_dev = valid_input(‖input_type=float,‖1
input_type=float,‖condition=lambda x: x >= 0,‖1
condition=lambda x: x >= 0,‖input_msg=(‖1
input_msg=(‖"""Enter the value of standard deviation"""‖1
"""Enter the value of standard deviation"""‖"""(Default value is 1.0 for all classes): """‖1
"""(Default value is 1.0 for all classes): """‖),‖1
),‖"err_msg=""Standard deviation should not be negative!"","‖1
"err_msg=""Standard deviation should not be negative!"","‖"default=""1.0"","‖1
"default=""1.0"","‖)‖1
counts = []‖for i in range(n_classes):‖1
for i in range(n_classes):‖user_count = valid_input(‖1
user_count = valid_input(‖input_type=int,‖1
condition=lambda x: x > 0,‖"input_msg=(f""Enter The number of instances for class_{i + 1}: ""),"‖1
"input_msg=(f""Enter The number of instances for class_{i + 1}: ""),"‖"err_msg=""Number of instances should be positive!"","‖1
"err_msg=""Number of instances should be positive!"","‖)‖1
)‖counts.append(user_count)‖1
counts.append(user_count)‖"print(""-"" * 100)"‖1
user_means = []‖for a in range(n_classes):‖1
for a in range(n_classes):‖user_mean = valid_input(‖1
user_mean = valid_input(‖input_type=float,‖1
input_type=float,‖"input_msg=(f""Enter the value of mean for class_{a + 1}: ""),"‖1
"input_msg=(f""Enter the value of mean for class_{a + 1}: ""),"‖"err_msg=""This is an invalid value."","‖1
"err_msg=""This is an invalid value."","‖)‖1
)‖user_means.append(user_mean)‖1
user_means.append(user_mean)‖"print(""-"" * 100)"‖1
for i, count in enumerate(counts, 1):‖"print(f""Number of instances in class_{i} is: {count}"")"‖1
"print(f""Number of instances in class_{i} is: {count}"")"‖"print(""-"" * 100)"‖1
for i, user_mean in enumerate(user_means, 1):‖"print(f""Mean of class_{i} is: {user_mean}"")"‖1
"print(f""Mean of class_{i} is: {user_mean}"")"‖"print(""-"" * 100)"‖1
x = [‖gaussian_distribution(user_means[j], std_dev, counts[j])‖1
gaussian_distribution(user_means[j], std_dev, counts[j])‖for j in range(n_classes)‖1
for j in range(n_classes)‖]‖1
]‖"print(""Generated Normal Distribution: \n"", x)"‖1
"print(""Generated Normal Distribution: \n"", x)"‖"print(""-"" * 100)"‖1
y = y_generator(n_classes, counts)‖"print(""Generated Corresponding Ys: \n"", y)"‖1
"print(""Generated Corresponding Ys: \n"", y)"‖"print(""-"" * 100)"‖1
for i, actual_mean in enumerate(actual_means, 1):‖"print(f""Actual(Real) mean of class_{i} is: {actual_mean}"")"‖1
"print(f""Actual(Real) mean of class_{i} is: {actual_mean}"")"‖"print(""-"" * 100)"‖1
probabilities = [‖calculate_probabilities(counts[i], sum(counts)) for i in range(n_classes)‖1
calculate_probabilities(counts[i], sum(counts)) for i in range(n_classes)‖]‖1
for i, probability in enumerate(probabilities, 1):‖"print(f""Probability of class_{i} is: {probability}"")"‖1
"print(f""Probability of class_{i} is: {probability}"")"‖"print(""-"" * 100)"‖1
variance = calculate_variance(x, actual_means, sum(counts))‖"print(""Variance: "", variance)"‖1
"print(""Variance: "", variance)"‖"print(""-"" * 100)"‖1
pre_indexes = predict_y_values(x, actual_means, variance, probabilities)‖"print(""-"" * 100)"‖1
"print(f""Accuracy: {accuracy(y, pre_indexes)}"")"‖"print(""-"" * 100)"‖1
"print(""-"" * 100)"‖"print("" DONE "".center(100, ""+""))"‖1
"if input(""Press any key to restart or 'q' for quit: "").strip().lower() == ""q"":"‖"print(""\n"" + ""GoodBye!"".center(100, ""-"") + ""\n"")"‖1
"print(""\n"" + ""GoodBye!"".center(100, ""-"") + ""\n"")"‖break‖1
break‖"system(""cls"" if name == ""nt"" else ""clear"")"‖1
class DecisionTree:‖def __init__(self, depth=5, min_leaf_size=5):‖1
def __init__(self, depth=5, min_leaf_size=5):‖self.depth = depth‖1
self.depth = depth‖self.decision_boundary = 0‖1
self.decision_boundary = 0‖self.left = None‖1
self.right = None‖self.min_leaf_size = min_leaf_size‖1
self.min_leaf_size = min_leaf_size‖self.prediction = None‖1
def mean_squared_error(self, labels, prediction):‖if labels.ndim != 1:‖1
if labels.ndim != 1:‖"print(""Error: Input labels must be one dimensional"")"‖1
def train(self, x, y):‖if x.ndim != 1:‖1
if x.ndim != 1:‖"raise ValueError(""Input data set must be one-dimensional"")"‖1
"raise ValueError(""Input data set must be one-dimensional"")"‖if len(x) != len(y):‖1
if len(x) != len(y):‖"raise ValueError(""x and y have different lengths"")"‖1
"raise ValueError(""x and y have different lengths"")"‖if y.ndim != 1:‖1
if y.ndim != 1:‖"raise ValueError(""Data set labels must be one-dimensional"")"‖1
if len(x) < 2 * self.min_leaf_size:‖self.prediction = np.mean(y)‖1
self.prediction = np.mean(y)‖return‖2
if self.depth == 1:‖self.prediction = np.mean(y)‖1
best_split = 0‖min_error = self.mean_squared_error(x, np.mean(y)) * 2‖1
for i in range(len(x)):‖if len(x[:i]) < self.min_leaf_size:‖1
if len(x[:i]) < self.min_leaf_size:‖continue‖1
continue‖elif len(x[i:]) < self.min_leaf_size:‖1
elif len(x[i:]) < self.min_leaf_size:‖continue‖1
else:‖error_left = self.mean_squared_error(x[:i], np.mean(y[:i]))‖1
error_left = self.mean_squared_error(x[:i], np.mean(y[:i]))‖error_right = self.mean_squared_error(x[i:], np.mean(y[i:]))‖1
error_right = self.mean_squared_error(x[i:], np.mean(y[i:]))‖error = error_left + error_right‖1
error = error_left + error_right‖if error < min_error:‖1
if error < min_error:‖best_split = i‖1
best_split = i‖min_error = error‖1
if best_split != 0:‖left_x = x[:best_split]‖1
left_x = x[:best_split]‖left_y = y[:best_split]‖1
left_y = y[:best_split]‖right_x = x[best_split:]‖1
right_x = x[best_split:]‖right_y = y[best_split:]‖1
self.decision_boundary = x[best_split]‖self.left = DecisionTree(‖1
self.left = DecisionTree(‖depth=self.depth - 1, min_leaf_size=self.min_leaf_size‖1
depth=self.depth - 1, min_leaf_size=self.min_leaf_size‖)‖2
)‖self.right = DecisionTree(‖1
self.right = DecisionTree(‖depth=self.depth - 1, min_leaf_size=self.min_leaf_size‖1
)‖self.left.train(left_x, left_y)‖1
self.left.train(left_x, left_y)‖self.right.train(right_x, right_y)‖1
self.right.train(right_x, right_y)‖else:‖1
else:‖self.prediction = np.mean(y)‖1
def predict(self, x):‖if self.prediction is not None:‖1
if self.prediction is not None:‖return self.prediction‖1
return self.prediction‖elif self.left or self.right is not None:‖1
elif self.left or self.right is not None:‖if x >= self.decision_boundary:‖1
if x >= self.decision_boundary:‖return self.right.predict(x)‖1
return self.right.predict(x)‖else:‖1
else:‖return self.left.predict(x)‖1
return self.left.predict(x)‖else:‖1
else:‖"print(""Error: Decision tree not yet trained"")"‖1
"print(""Error: Decision tree not yet trained"")"‖return None‖1
@staticmethod‖def helper_mean_squared_error_test(labels, prediction):‖1
def helper_mean_squared_error_test(labels, prediction):‖squared_error_sum = float(0)‖1
squared_error_sum = float(0)‖for label in labels:‖1
for label in labels:‖squared_error_sum += (label - prediction) ** 2‖1
def main():‖x = np.arange(-1.0, 1.0, 0.005)‖1
x = np.arange(-1.0, 1.0, 0.005)‖y = np.sin(x)‖1
tree = DecisionTree(depth=10, min_leaf_size=10)‖tree.train(x, y)‖1
rng = np.random.default_rng()‖test_cases = (rng.random(10) * 2) - 1‖1
test_cases = (rng.random(10) * 2) - 1‖predictions = np.array([tree.predict(x) for x in test_cases])‖1
predictions = np.array([tree.predict(x) for x in test_cases])‖avg_error = np.mean((predictions - test_cases) ** 2)‖1
"print(""Test values: "" + str(test_cases))"‖"print(""Predictions: "" + str(predictions))"‖1
"print(""Predictions: "" + str(predictions))"‖"print(""Average error: "" + str(avg_error))"‖1
from collections import defaultdict‖from enum import Enum‖1
from enum import Enum‖from types import TracebackType‖1
from types import TracebackType‖from typing import Any‖1
import numpy as np‖from typing_extensions import Self‖1
ADD = 0‖SUB = 1‖1
SUB = 1‖MUL = 2‖1
MUL = 2‖DIV = 3‖1
DIV = 3‖MATMUL = 4‖1
MATMUL = 4‖POWER = 5‖1
POWER = 5‖NOOP = 6‖1
def __init__(self, value: Any) -> None:‖self.value = np.array(value)‖1
def __repr__(self) -> str:‖"return f""Variable({self.value})"""‖1
def to_ndarray(self) -> np.ndarray:‖return self.value‖1
def __add__(self, other: Variable) -> Variable:‖result = Variable(self.value + other.value)‖1
if tracker.enabled:‖tracker.append(OpType.ADD, params=[self, other], output=result)‖1
tracker.append(OpType.ADD, params=[self, other], output=result)‖return result‖1
def __sub__(self, other: Variable) -> Variable:‖result = Variable(self.value - other.value)‖1
if tracker.enabled:‖tracker.append(OpType.SUB, params=[self, other], output=result)‖1
tracker.append(OpType.SUB, params=[self, other], output=result)‖return result‖1
def __mul__(self, other: Variable) -> Variable:‖result = Variable(self.value * other.value)‖1
if tracker.enabled:‖tracker.append(OpType.MUL, params=[self, other], output=result)‖1
tracker.append(OpType.MUL, params=[self, other], output=result)‖return result‖1
def __truediv__(self, other: Variable) -> Variable:‖result = Variable(self.value / other.value)‖1
if tracker.enabled:‖tracker.append(OpType.DIV, params=[self, other], output=result)‖1
tracker.append(OpType.DIV, params=[self, other], output=result)‖return result‖1
def __matmul__(self, other: Variable) -> Variable:‖result = Variable(self.value @ other.value)‖1
if tracker.enabled:‖tracker.append(OpType.MATMUL, params=[self, other], output=result)‖1
tracker.append(OpType.MATMUL, params=[self, other], output=result)‖return result‖1
def __pow__(self, power: int) -> Variable:‖result = Variable(self.value**power)‖1
if tracker.enabled:‖tracker.append(‖1
tracker.append(‖OpType.POWER,‖1
OpType.POWER,‖params=[self],‖1
params=[self],‖output=result,‖1
output=result,‖"other_params={""power"": power},"‖1
"other_params={""power"": power},"‖)‖1
)‖return result‖1
def add_param_to(self, param_to: Operation) -> None:‖self.param_to.append(param_to)‖1
def add_result_of(self, result_of: Operation) -> None:‖self.result_of = result_of‖1
self,‖op_type: OpType,‖2
op_type: OpType,‖other_params: dict | None = None,‖1
other_params: dict | None = None,‖) -> None:‖2
) -> None:‖self.op_type = op_type‖1
self.op_type = op_type‖self.other_params = {} if other_params is None else other_params‖1
def add_params(self, params: list[Variable]) -> None:‖self.params = params‖1
def add_output(self, output: Variable) -> None:‖self.output = output‖1
def __eq__(self, value) -> bool:‖return self.op_type == value if isinstance(value, OpType) else False‖1
def __new__(cls) -> Self:‖if cls.instance is None:‖1
if cls.instance is None:‖cls.instance = super().__new__(cls)‖1
cls.instance = super().__new__(cls)‖return cls.instance‖1
def __init__(self) -> None:‖self.enabled = False‖1
def __enter__(self) -> Self:‖self.enabled = True‖1
self.enabled = True‖return self‖1
def __exit__(‖self,‖1
self,‖exc_type: type[BaseException] | None,‖1
exc_type: type[BaseException] | None,‖exc: BaseException | None,‖1
exc: BaseException | None,‖traceback: TracebackType | None,‖1
traceback: TracebackType | None,‖) -> None:‖1
) -> None:‖self.enabled = False‖1
def append(‖self,‖1
op_type: OpType,‖params: list[Variable],‖1
params: list[Variable],‖output: Variable,‖1
output: Variable,‖other_params: dict | None = None,‖1
) -> None:‖operation = Operation(op_type, other_params=other_params)‖1
operation = Operation(op_type, other_params=other_params)‖param_nodes = []‖1
param_nodes = []‖for param in params:‖1
for param in params:‖param.add_param_to(operation)‖1
param.add_param_to(operation)‖param_nodes.append(param)‖1
param_nodes.append(param)‖output.add_result_of(operation)‖1
operation.add_params(param_nodes)‖operation.add_output(output)‖1
partial_deriv = defaultdict(lambda: 0)‖partial_deriv[target] = np.ones_like(target.to_ndarray())‖1
operation_queue = [target.result_of]‖while len(operation_queue) > 0:‖1
while len(operation_queue) > 0:‖operation = operation_queue.pop()‖1
operation = operation_queue.pop()‖for param in operation.params:‖1
dparam_doutput = self.derivative(param, operation)‖dparam_dtarget = dparam_doutput * partial_deriv[operation.output]‖1
dparam_dtarget = dparam_doutput * partial_deriv[operation.output]‖partial_deriv[param] += dparam_dtarget‖1
if param.result_of and param.result_of != OpType.NOOP:‖operation_queue.append(param.result_of)‖1
def derivative(self, param: Variable, operation: Operation) -> np.ndarray:‖params = operation.params‖1
if operation == OpType.ADD:‖return np.ones_like(params[0].to_ndarray(), dtype=np.float64)‖1
return np.ones_like(params[0].to_ndarray(), dtype=np.float64)‖if operation == OpType.SUB:‖1
if operation == OpType.SUB:‖if params[0] == param:‖1
if params[0] == param:‖return np.ones_like(params[0].to_ndarray(), dtype=np.float64)‖1
return np.ones_like(params[0].to_ndarray(), dtype=np.float64)‖return -np.ones_like(params[1].to_ndarray(), dtype=np.float64)‖1
return -np.ones_like(params[1].to_ndarray(), dtype=np.float64)‖if operation == OpType.MUL:‖1
if operation == OpType.MUL:‖return (‖1
return (‖params[1].to_ndarray().T‖2
params[1].to_ndarray().T‖if params[0] == param‖2
if params[0] == param‖else params[0].to_ndarray().T‖2
else params[0].to_ndarray().T‖)‖2
)‖if operation == OpType.DIV:‖1
if operation == OpType.DIV:‖if params[0] == param:‖1
if params[0] == param:‖return 1 / params[1].to_ndarray()‖1
return 1 / params[1].to_ndarray()‖return -params[0].to_ndarray() / (params[1].to_ndarray() ** 2)‖1
return -params[0].to_ndarray() / (params[1].to_ndarray() ** 2)‖if operation == OpType.MATMUL:‖1
if operation == OpType.MATMUL:‖return (‖1
)‖if operation == OpType.POWER:‖1
if operation == OpType.POWER:‖"power = operation.other_params[""power""]"‖1
"power = operation.other_params[""power""]"‖return power * (params[0].to_ndarray() ** (power - 1))‖1
"err_msg = f""invalid operation type: {operation.op_type}"""‖raise ValueError(err_msg)‖1
x_min = min(data)‖x_max = max(data)‖1
mu = mean(data)‖sigma = stdev(data)‖1
from matplotlib import pyplot as plt‖from sklearn import datasets‖1
def sigmoid_function(z: float | np.ndarray) -> float | np.ndarray:‖return 1 / (1 + np.exp(-z))‖1
def cost_function(h: np.ndarray, y: np.ndarray) -> float:‖return float((-y * np.log(h) - (1 - y) * np.log(1 - h)).mean())‖1
def log_likelihood(x, y, weights):‖scores = np.dot(x, weights)‖1
scores = np.dot(x, weights)‖return np.sum(y * scores - np.log(1 + np.exp(scores)))‖1
def logistic_reg(alpha, x, y, max_iterations=70000):‖theta = np.zeros(x.shape[1])‖1
for iterations in range(max_iterations):‖z = np.dot(x, theta)‖1
z = np.dot(x, theta)‖h = sigmoid_function(z)‖2
h = sigmoid_function(z)‖gradient = np.dot(x.T, h - y) / y.size‖1
gradient = np.dot(x.T, h - y) / y.size‖theta = theta - alpha * gradient‖1
theta = theta - alpha * gradient‖z = np.dot(x, theta)‖1
h = sigmoid_function(z)‖j = cost_function(h, y)‖1
j = cost_function(h, y)‖if iterations % 100 == 0:‖1
if iterations % 100 == 0:‖"print(f""loss: {j} \t"")"‖1
"print(f""loss: {j} \t"")"‖return theta‖1
iris = datasets.load_iris()‖x = iris.data[:, :2]‖1
x = iris.data[:, :2]‖y = (iris.target != 0) * 1‖1
alpha = 0.1‖theta = logistic_reg(alpha, x, y, max_iterations=70000)‖1
theta = logistic_reg(alpha, x, y, max_iterations=70000)‖"print(""theta: "", theta)"‖1
def predict_prob(x):‖return sigmoid_function(‖1
return sigmoid_function(‖np.dot(x, theta)‖1
np.dot(x, theta)‖)‖1
plt.figure(figsize=(10, 6))‖"plt.scatter(x[y == 0][:, 0], x[y == 0][:, 1], color=""b"", label=""0"")"‖1
"plt.scatter(x[y == 0][:, 0], x[y == 0][:, 1], color=""b"", label=""0"")"‖"plt.scatter(x[y == 1][:, 0], x[y == 1][:, 1], color=""r"", label=""1"")"‖1
"plt.scatter(x[y == 1][:, 0], x[y == 1][:, 1], color=""r"", label=""1"")"‖(x1_min, x1_max) = (x[:, 0].min(), x[:, 0].max())‖1
(x1_min, x1_max) = (x[:, 0].min(), x[:, 0].max())‖(x2_min, x2_max) = (x[:, 1].min(), x[:, 1].max())‖1
(x2_min, x2_max) = (x[:, 1].min(), x[:, 1].max())‖(xx1, xx2) = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))‖1
(xx1, xx2) = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))‖grid = np.c_[xx1.ravel(), xx2.ravel()]‖1
grid = np.c_[xx1.ravel(), xx2.ravel()]‖probs = predict_prob(grid).reshape(xx1.shape)‖1
probs = predict_prob(grid).reshape(xx1.shape)‖"plt.contour(xx1, xx2, probs, [0.5], linewidths=1, colors=""black"")"‖1
class SelfOrganizingMap:‖def get_winner(self, weights: list[list[float]], sample: list[int]) -> int:‖1
def get_winner(self, weights: list[list[float]], sample: list[int]) -> int:‖d0 = 0.0‖1
d0 = 0.0‖d1 = 0.0‖1
d1 = 0.0‖for i in range(len(sample)):‖1
for i in range(len(sample)):‖d0 += math.pow((sample[i] - weights[0][i]), 2)‖1
d0 += math.pow((sample[i] - weights[0][i]), 2)‖d1 += math.pow((sample[i] - weights[1][i]), 2)‖1
d1 += math.pow((sample[i] - weights[1][i]), 2)‖return 0 if d0 > d1 else 1‖1
return 0 if d0 > d1 else 1‖return 0‖1
def update(‖self, weights: list[list[int | float]], sample: list[int], j: int, alpha: float‖1
self, weights: list[list[int | float]], sample: list[int], j: int, alpha: float‖) -> list[list[int | float]]:‖1
) -> list[list[int | float]]:‖for i in range(len(weights)):‖1
for i in range(len(weights)):‖weights[j][i] += alpha * (sample[i] - weights[j][i])‖1
weights[j][i] += alpha * (sample[i] - weights[j][i])‖return weights‖1
self_organizing_map = SelfOrganizingMap()‖epochs = 3‖1
epochs = 3‖alpha = 0.5‖1
for _ in range(epochs):‖for j in range(len(training_samples)):‖1
sample = [0, 0, 0, 1]‖winner = self_organizing_map.get_winner(weights, sample)‖1
"print(f""Clusters that the test sample belongs to : {winner}"")"‖"print(f""Weights that have been trained : {weights}"")"‖1
import numpy as np‖import requests‖1
def collect_dataset():‖response = requests.get(‖1
response = requests.get(‖"""https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/"""‖1
"""https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/"""‖"""master/Week1/ADRvsRating.csv"","‖1
"""master/Week1/ADRvsRating.csv"","‖timeout=10,‖1
timeout=10,‖)‖1
)‖lines = response.text.splitlines()‖1
lines = response.text.splitlines()‖data = []‖1
data = []‖for item in lines:‖1
for item in lines:‖"item = item.split("","")"‖1
"item = item.split("","")"‖data.append(item)‖1
data.append(item)‖data.pop(0)‖1
data.pop(0)‖dataset = np.matrix(data)‖1
dataset = np.matrix(data)‖return dataset‖1
def run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):‖n = len_data‖1
prod = np.dot(theta, data_x.transpose())‖prod -= data_y.transpose()‖2
prod -= data_y.transpose()‖sum_grad = np.dot(prod, data_x)‖1
sum_grad = np.dot(prod, data_x)‖theta = theta - (alpha / n) * sum_grad‖1
theta = theta - (alpha / n) * sum_grad‖return theta‖1
def sum_of_square_error(data_x, data_y, len_data, theta):‖prod = np.dot(theta, data_x.transpose())‖1
prod -= data_y.transpose()‖sum_elem = np.sum(np.square(prod))‖1
sum_elem = np.sum(np.square(prod))‖error = sum_elem / (2 * len_data)‖1
error = sum_elem / (2 * len_data)‖return error‖1
def run_linear_regression(data_x, data_y):‖iterations = 100000‖1
iterations = 100000‖alpha = 0.0001550‖1
no_features = data_x.shape[1]‖len_data = data_x.shape[0] - 1‖1
for i in range(iterations):‖theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)‖1
theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)‖error = sum_of_square_error(data_x, data_y, len_data, theta)‖1
error = sum_of_square_error(data_x, data_y, len_data, theta)‖"print(f""At Iteration {i + 1} - Error is {error:.5f}"")"‖1
def mean_absolute_error(predicted_y, original_y):‖total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))‖1
total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))‖return total / len(original_y)‖1
def main():‖data = collect_dataset()‖1
len_data = data.shape[0]‖data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float)‖1
data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float)‖data_y = data[:, -1].astype(float)‖1
theta = run_linear_regression(data_x, data_y)‖len_result = theta.shape[1]‖1
len_result = theta.shape[1]‖"print(""Resultant Feature vector : "")"‖1
"print(""Resultant Feature vector : "")"‖for i in range(len_result):‖1
for i in range(len_result):‖"print(f""{theta[0, i]:.5f}"")"‖1
import numpy as np‖import pandas as pd‖4
import pandas as pd‖from matplotlib import pyplot as plt‖2
from matplotlib import pyplot as plt‖from sklearn.metrics import pairwise_distances‖1
rng = np.random.default_rng(seed)‖n = data.shape[0]‖1
def centroid_pairwise_dist(x, centroids):‖"return pairwise_distances(x, centroids, metric=""euclidean"")"‖1
def revise_centroids(data, k, cluster_assignment):‖new_centroids = []‖1
new_centroids = []‖for i in range(k):‖1
centroid = member_data_points.mean(axis=0)‖new_centroids.append(centroid)‖1
new_centroids.append(centroid)‖new_centroids = np.array(new_centroids)‖1
def compute_heterogeneity(data, k, centroids, cluster_assignment):‖heterogeneity = 0.0‖1
heterogeneity = 0.0‖for i in range(k):‖1
distances = pairwise_distances(‖"member_data_points, [centroids[i]], metric=""euclidean"""‖1
"member_data_points, [centroids[i]], metric=""euclidean"""‖)‖1
)‖squared_distances = distances**2‖1
squared_distances = distances**2‖heterogeneity += np.sum(squared_distances)‖1
def plot_heterogeneity(heterogeneity, k):‖plt.figure(figsize=(7, 4))‖1
plt.figure(figsize=(7, 4))‖plt.plot(heterogeneity, linewidth=4)‖1
plt.plot(heterogeneity, linewidth=4)‖"plt.xlabel(""# Iterations"")"‖1
"plt.xlabel(""# Iterations"")"‖"plt.ylabel(""Heterogeneity"")"‖1
"plt.ylabel(""Heterogeneity"")"‖"plt.title(f""Heterogeneity of clustering over time, K={k:d}"")"‖1
"plt.title(f""Heterogeneity of clustering over time, K={k:d}"")"‖"plt.rcParams.update({""font.size"": 16})"‖1
"plt.rcParams.update({""font.size"": 16})"‖plt.show()‖1
def kmeans(‖data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False‖1
data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False‖):‖1
centroids = initial_centroids[:]‖prev_cluster_assignment = None‖1
for itr in range(maxiter):‖if verbose:‖1
if verbose:‖"print(itr, end="""")"‖1
if (‖prev_cluster_assignment is not None‖1
prev_cluster_assignment is not None‖and (prev_cluster_assignment == cluster_assignment).all()‖1
and (prev_cluster_assignment == cluster_assignment).all()‖):‖1
):‖break‖2
if prev_cluster_assignment is not None:‖num_changed = np.sum(prev_cluster_assignment != cluster_assignment)‖1
num_changed = np.sum(prev_cluster_assignment != cluster_assignment)‖if verbose:‖1
if verbose:‖print(‖1
print(‖"f""    {num_changed:5d} elements changed their cluster assignment."""‖1
"f""    {num_changed:5d} elements changed their cluster assignment."""‖)‖1
score = compute_heterogeneity(data, k, centroids, cluster_assignment)‖record_heterogeneity.append(score)‖1
if False:‖from sklearn import datasets as ds‖1
dataset = ds.load_iris()‖k = 3‖1
k = 3‖heterogeneity = []‖1
heterogeneity = []‖"initial_centroids = get_initial_centroids(dataset[""data""], k, seed=0)"‖1
"initial_centroids = get_initial_centroids(dataset[""data""], k, seed=0)"‖centroids, cluster_assignment = kmeans(‖1
centroids, cluster_assignment = kmeans(‖"dataset[""data""],"‖1
"dataset[""data""],"‖k,‖1
k,‖initial_centroids,‖1
initial_centroids,‖maxiter=400,‖1
maxiter=400,‖record_heterogeneity=heterogeneity,‖1
record_heterogeneity=heterogeneity,‖verbose=True,‖1
verbose=True,‖)‖1
)‖plot_heterogeneity(heterogeneity, k)‖1
def report_generator(‖predicted: pd.DataFrame, clustering_variables: np.ndarray, fill_missing_report=None‖1
predicted: pd.DataFrame, clustering_variables: np.ndarray, fill_missing_report=None‖) -> pd.DataFrame:‖1
if fill_missing_report:‖predicted = predicted.fillna(value=fill_missing_report)‖1
predicted = predicted.fillna(value=fill_missing_report)‖"predicted[""dummy""] = 1"‖1
"predicted[""dummy""] = 1"‖numeric_cols = predicted.select_dtypes(np.number).columns‖1
numeric_cols = predicted.select_dtypes(np.number).columns‖report = (‖1
report = (‖"predicted.groupby([""Cluster""])["‖1
"predicted.groupby([""Cluster""])["‖numeric_cols‖1
numeric_cols‖]‖1
]‖.agg(‖1
.agg(‖[‖1
[‖"(""sum"", ""sum""),"‖1
"(""sum"", ""sum""),"‖"(""mean_with_zeros"", lambda x: np.mean(np.nan_to_num(x))),"‖1
"(""mean_with_zeros"", lambda x: np.mean(np.nan_to_num(x))),"‖"(""mean_without_zeros"", lambda x: x.replace(0, np.nan).mean()),"‖1
"(""mean_without_zeros"", lambda x: x.replace(0, np.nan).mean()),"‖(‖1
(‖"""mean_25-75"","‖1
"""mean_25-75"","‖lambda x: np.mean(‖1
lambda x: np.mean(‖np.nan_to_num(‖1
np.nan_to_num(‖sorted(x)[‖1
sorted(x)[‖round(len(x) * 25 / 100) : round(len(x) * 75 / 100)‖1
round(len(x) * 25 / 100) : round(len(x) * 75 / 100)‖]‖1
)‖),‖1
),‖),‖1
),‖"(""mean_with_na"", ""mean""),"‖1
"(""mean_with_na"", ""mean""),"‖"(""min"", lambda x: x.min()),"‖1
"(""min"", lambda x: x.min()),"‖"(""5%"", lambda x: x.quantile(0.05)),"‖1
"(""5%"", lambda x: x.quantile(0.05)),"‖"(""25%"", lambda x: x.quantile(0.25)),"‖1
"(""25%"", lambda x: x.quantile(0.25)),"‖"(""50%"", lambda x: x.quantile(0.50)),"‖1
"(""50%"", lambda x: x.quantile(0.50)),"‖"(""75%"", lambda x: x.quantile(0.75)),"‖1
"(""75%"", lambda x: x.quantile(0.75)),"‖"(""95%"", lambda x: x.quantile(0.95)),"‖1
"(""95%"", lambda x: x.quantile(0.95)),"‖"(""max"", lambda x: x.max()),"‖1
"(""max"", lambda x: x.max()),"‖"(""count"", lambda x: x.count()),"‖1
"(""count"", lambda x: x.count()),"‖"(""stdev"", lambda x: x.std()),"‖1
"(""stdev"", lambda x: x.std()),"‖"(""mode"", lambda x: x.mode()[0]),"‖1
"(""mode"", lambda x: x.mode()[0]),"‖"(""median"", lambda x: x.median()),"‖1
"(""median"", lambda x: x.median()),"‖"(""# > 0"", lambda x: (x > 0).sum()),"‖1
"(""# > 0"", lambda x: (x > 0).sum()),"‖]‖1
)‖.T.reset_index()‖1
.T.reset_index()‖".rename(index=str, columns={""level_0"": ""Features"", ""level_1"": ""Type""})"‖1
".rename(index=str, columns={""level_0"": ""Features"", ""level_1"": ""Type""})"‖)‖1
clustersize = report[‖"(report[""Features""] == ""dummy"") & (report[""Type""] == ""count"")"‖1
"(report[""Features""] == ""dummy"") & (report[""Type""] == ""count"")"‖].copy()‖1
"clustersize.Type = ""ClusterSize"""‖"clustersize.Features = ""# of Customers"""‖1
clusterproportion = pd.DataFrame(‖clustersize.iloc[:, 2:].to_numpy() / clustersize.iloc[:, 2:].to_numpy().sum()‖1
clustersize.iloc[:, 2:].to_numpy() / clustersize.iloc[:, 2:].to_numpy().sum()‖)‖1
"clusterproportion[""Type""] = ""% of Customers"""‖"clusterproportion[""Features""] = ""ClusterProportion"""‖1
"clusterproportion[""Features""] = ""ClusterProportion"""‖cols = clusterproportion.columns.tolist()‖1
cols = clusterproportion.columns.tolist()‖cols = cols[-2:] + cols[:-2]‖1
cols = cols[-2:] + cols[:-2]‖clusterproportion = clusterproportion[cols]‖1
clusterproportion = clusterproportion[cols]‖clusterproportion.columns = report.columns‖1
a = pd.DataFrame(‖abs(‖1
abs(‖"report[report[""Type""] == ""count""].iloc[:, 2:].to_numpy()"‖1
"report[report[""Type""] == ""count""].iloc[:, 2:].to_numpy()"‖- clustersize.iloc[:, 2:].to_numpy()‖1
- clustersize.iloc[:, 2:].to_numpy()‖)‖1
)‖"a[""Features""] = 0"‖1
"a[""Features""] = 0"‖"a[""Type""] = ""# of nan"""‖1
"a.Features = report[report[""Type""] == ""count""].Features.tolist()"‖cols = a.columns.tolist()‖1
cols = a.columns.tolist()‖cols = cols[-2:] + cols[:-2]‖1
cols = cols[-2:] + cols[:-2]‖a = a[cols]‖1
a = a[cols]‖a.columns = report.columns‖1
report = pd.concat([report, a, clustersize, clusterproportion], axis=0)‖"report[""Mark""] = report[""Features""].isin(clustering_variables)"‖1
"report[""Mark""] = report[""Features""].isin(clustering_variables)"‖cols = report.columns.tolist()‖1
cols = report.columns.tolist()‖cols = cols[0:2] + cols[-1:] + cols[2:-1]‖1
cols = cols[0:2] + cols[-1:] + cols[2:-1]‖report = report[cols]‖1
report = report[cols]‖sorter1 = {‖1
sorter1 = {‖"""ClusterSize"": 9,"‖1
"""ClusterSize"": 9,"‖"""ClusterProportion"": 8,"‖1
"""ClusterProportion"": 8,"‖"""mean_with_zeros"": 7,"‖1
"""mean_with_zeros"": 7,"‖"""mean_with_na"": 6,"‖1
"""mean_with_na"": 6,"‖"""max"": 5,"‖1
"""max"": 5,"‖"""50%"": 4,"‖1
"""50%"": 4,"‖"""min"": 3,"‖1
"""min"": 3,"‖"""25%"": 2,"‖1
"""25%"": 2,"‖"""75%"": 1,"‖1
"""75%"": 1,"‖"""# of nan"": 0,"‖1
"""# of nan"": 0,"‖"""# > 0"": -1,"‖1
"""# > 0"": -1,"‖"""sum_with_na"": -2,"‖1
"""sum_with_na"": -2,"‖}‖1
}‖report = (‖1
report = (‖report.assign(‖1
report.assign(‖Sorter1=lambda x: x.Type.map(sorter1),‖1
Sorter1=lambda x: x.Type.map(sorter1),‖Sorter2=lambda x: list(reversed(range(len(x)))),‖1
Sorter2=lambda x: list(reversed(range(len(x)))),‖)‖1
)‖".sort_values([""Sorter1"", ""Mark"", ""Sorter2""], ascending=False)"‖1
".sort_values([""Sorter1"", ""Mark"", ""Sorter2""], ascending=False)"‖".drop([""Sorter1"", ""Sorter2""], axis=1)"‖1
".drop([""Sorter1"", ""Sorter2""], axis=1)"‖)‖1
)‖"report.columns.name = """""‖1
"report.columns.name = """""‖report = report.reset_index()‖1
report = report.reset_index()‖"report = report.drop(columns=[""index""])"‖1
"report = report.drop(columns=[""index""])"‖return report‖1
def binary_cross_entropy(‖y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15‖1
y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15‖) -> float:‖3
) -> float:‖if len(y_true) != len(y_pred):‖3
if len(y_true) != len(y_pred):‖"raise ValueError(""Input arrays must have the same length."")"‖7
y_pred = np.clip(y_pred, epsilon, 1 - epsilon)‖bce_loss = -(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))‖1
bce_loss = -(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))‖return np.mean(bce_loss)‖1
def binary_focal_cross_entropy(‖y_true: np.ndarray,‖1
y_true: np.ndarray,‖y_pred: np.ndarray,‖2
y_pred: np.ndarray,‖gamma: float = 2.0,‖1
gamma: float = 2.0,‖alpha: float = 0.25,‖1
alpha: float = 0.25,‖epsilon: float = 1e-15,‖1
epsilon: float = 1e-15,‖) -> float:‖2
bcfe_loss = -(‖alpha * (1 - y_pred) ** gamma * y_true * np.log(y_pred)‖1
alpha * (1 - y_pred) ** gamma * y_true * np.log(y_pred)‖+ (1 - alpha) * y_pred**gamma * (1 - y_true) * np.log(1 - y_pred)‖1
+ (1 - alpha) * y_pred**gamma * (1 - y_true) * np.log(1 - y_pred)‖)‖1
def categorical_cross_entropy(‖y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15‖1
) -> float:‖if y_true.shape != y_pred.shape:‖2
if y_true.shape != y_pred.shape:‖"raise ValueError(""Input arrays must have the same shape."")"‖1
if np.any((y_true != 0) & (y_true != 1)) or np.any(y_true.sum(axis=1) != 1):‖"raise ValueError(""y_true must be one-hot encoded."")"‖2
if not np.all(np.isclose(np.sum(y_pred, axis=1), 1, rtol=epsilon, atol=epsilon)):‖"raise ValueError(""Predicted probabilities must sum to approximately 1."")"‖2
y_pred = np.clip(y_pred, epsilon, 1)‖return -np.sum(y_true * np.log(y_pred))‖1
def categorical_focal_cross_entropy(‖y_true: np.ndarray,‖1
y_pred: np.ndarray,‖alpha: np.ndarray = None,‖1
alpha: np.ndarray = None,‖gamma: float = 2.0,‖1
gamma: float = 2.0,‖epsilon: float = 1e-15,‖1
if y_true.shape != y_pred.shape:‖"raise ValueError(""Shape of y_true and y_pred must be the same."")"‖1
if alpha is None:‖alpha = np.ones(y_true.shape[1])‖1
if len(alpha) != y_true.shape[1]:‖"raise ValueError(""Length of alpha must match the number of classes."")"‖1
cfce_loss = -np.sum(‖alpha * np.power(1 - y_pred, gamma) * y_true * np.log(y_pred), axis=1‖1
alpha * np.power(1 - y_pred, gamma) * y_true * np.log(y_pred), axis=1‖)‖1
def hinge_loss(y_true: np.ndarray, y_pred: np.ndarray) -> float:‖if len(y_true) != len(y_pred):‖1
if len(y_true) != len(y_pred):‖"raise ValueError(""Length of predicted and actual array must be same."")"‖1
if np.any((y_true != -1) & (y_true != 1)):‖"raise ValueError(""y_true can have values -1 or 1 only."")"‖1
hinge_losses = np.maximum(0, 1.0 - (y_true * y_pred))‖return np.mean(hinge_losses)‖1
def huber_loss(y_true: np.ndarray, y_pred: np.ndarray, delta: float) -> float:‖if len(y_true) != len(y_pred):‖1
huber_mse = 0.5 * (y_true - y_pred) ** 2‖huber_mae = delta * (np.abs(y_true - y_pred) - 0.5 * delta)‖1
huber_mae = delta * (np.abs(y_true - y_pred) - 0.5 * delta)‖return np.where(np.abs(y_true - y_pred) <= delta, huber_mse, huber_mae).mean()‖1
def mean_squared_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:‖if len(y_true) != len(y_pred):‖1
squared_errors = (y_true - y_pred) ** 2‖return np.mean(squared_errors)‖1
def mean_absolute_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:‖if len(y_true) != len(y_pred):‖1
def mean_squared_logarithmic_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:‖if len(y_true) != len(y_pred):‖1
squared_logarithmic_errors = (np.log1p(y_true) - np.log1p(y_pred)) ** 2‖return np.mean(squared_logarithmic_errors)‖1
def mean_absolute_percentage_error(‖y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15‖1
if len(y_true) != len(y_pred):‖"raise ValueError(""The length of the two arrays should be the same."")"‖2
y_true = np.where(y_true == 0, epsilon, y_true)‖absolute_percentage_diff = np.abs((y_true - y_pred) / y_true)‖1
def perplexity_loss(‖y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-7‖1
y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-7‖) -> float:‖1
if y_true.shape[0] != y_pred.shape[0]:‖"raise ValueError(""Batch size of y_true and y_pred must be equal."")"‖1
"raise ValueError(""Batch size of y_true and y_pred must be equal."")"‖if y_true.shape[1] != y_pred.shape[1]:‖1
if y_true.shape[1] != y_pred.shape[1]:‖"raise ValueError(""Sentence length of y_true and y_pred must be equal."")"‖1
"raise ValueError(""Sentence length of y_true and y_pred must be equal."")"‖if np.max(y_true) > vocab_size:‖1
if np.max(y_true) > vocab_size:‖"raise ValueError(""Label value must not be greater than vocabulary size."")"‖1
filter_matrix = np.array(‖[[list(np.eye(vocab_size)[word]) for word in sentence] for sentence in y_true]‖1
[[list(np.eye(vocab_size)[word]) for word in sentence] for sentence in y_true]‖)‖1
diff = np.abs(y_true - y_pred)‖loss = np.where(diff < beta, 0.5 * diff**2 / beta, diff - 0.5 * beta)‖1
loss = np.where(diff < beta, 0.5 * diff**2 / beta, diff - 0.5 * beta)‖return np.mean(loss)‖1
def kullback_leibler_divergence(y_true: np.ndarray, y_pred: np.ndarray) -> float:‖if len(y_true) != len(y_pred):‖1
kl_loss = y_true * np.log(y_true / y_pred)‖return np.sum(kl_loss)‖1
import pytest‖from scipy.linalg import eigh‖1
def covariance_within_classes(‖features: np.ndarray, labels: np.ndarray, classes: int‖1
features: np.ndarray, labels: np.ndarray, classes: int‖) -> np.ndarray:‖2
covariance_sum = np.nan‖for i in range(classes):‖2
for i in range(classes):‖data = features[:, labels == i]‖2
data = features[:, labels == i]‖data_mean = data.mean(1)‖1
centered_data = data - column_reshape(data_mean)‖if i > 0:‖1
covariance_sum += np.dot(centered_data, centered_data.T)‖else:‖1
def covariance_between_classes(‖features: np.ndarray, labels: np.ndarray, classes: int‖1
general_data_mean = features.mean(1)‖covariance_sum = np.nan‖1
data = features[:, labels == i]‖device_data = data.shape[1]‖1
device_data = data.shape[1]‖data_mean = data.mean(1)‖1
data_mean = data.mean(1)‖if i > 0:‖1
covariance_sum += device_data * np.dot(‖column_reshape(data_mean) - column_reshape(general_data_mean),‖1
column_reshape(data_mean) - column_reshape(general_data_mean),‖(column_reshape(data_mean) - column_reshape(general_data_mean)).T,‖2
(column_reshape(data_mean) - column_reshape(general_data_mean)).T,‖)‖2
covariance_sum = device_data * np.dot(‖column_reshape(data_mean) - column_reshape(general_data_mean),‖1
if features.any():‖data_mean = features.mean(1)‖1
centered_data = features - np.reshape(data_mean, (data_mean.size, 1))‖covariance_matrix = np.dot(centered_data, centered_data.T) / features.shape[1]‖1
covariance_matrix = np.dot(centered_data, centered_data.T) / features.shape[1]‖_, eigenvectors = np.linalg.eigh(covariance_matrix)‖1
projected_data = np.dot(filtered_eigenvectors.T, features)‖"logging.info(""Principal Component Analysis computed"")"‖1
return projected_data‖else:‖2
else:‖"logging.basicConfig(level=logging.ERROR, format=""%(message)s"", force=True)"‖2
"logging.basicConfig(level=logging.ERROR, format=""%(message)s"", force=True)"‖"logging.error(""Dataset empty"")"‖2
"logging.error(""Dataset empty"")"‖raise AssertionError‖2
def linear_discriminant_analysis(‖features: np.ndarray, labels: np.ndarray, classes: int, dimensions: int‖1
features: np.ndarray, labels: np.ndarray, classes: int, dimensions: int‖) -> np.ndarray:‖1
if features.any:‖_, eigenvectors = eigh(‖1
_, eigenvectors = eigh(‖covariance_between_classes(features, labels, classes),‖1
covariance_between_classes(features, labels, classes),‖covariance_within_classes(features, labels, classes),‖1
covariance_within_classes(features, labels, classes),‖)‖1
)‖filtered_eigenvectors = eigenvectors[:, ::-1][:, :dimensions]‖1
filtered_eigenvectors = eigenvectors[:, ::-1][:, :dimensions]‖svd_matrix, _, _ = np.linalg.svd(filtered_eigenvectors)‖1
svd_matrix, _, _ = np.linalg.svd(filtered_eigenvectors)‖filtered_svd_matrix = svd_matrix[:, 0:dimensions]‖1
filtered_svd_matrix = svd_matrix[:, 0:dimensions]‖projected_data = np.dot(filtered_svd_matrix.T, features)‖1
projected_data = np.dot(filtered_svd_matrix.T, features)‖"logging.info(""Linear Discriminant Analysis computed"")"‖1
features = np.array([[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]])‖labels = np.array([0, 0, 0, 1, 1])‖1
labels = np.array([0, 0, 0, 1, 1])‖classes = 2‖1
classes = 2‖dimensions = 2‖1
with pytest.raises(AssertionError) as error_info:‖projected_data = linear_discriminant_analysis(‖1
projected_data = linear_discriminant_analysis(‖features, labels, classes, dimensions‖1
features, labels, classes, dimensions‖)‖1
)‖if isinstance(projected_data, np.ndarray):‖1
if isinstance(projected_data, np.ndarray):‖raise AssertionError(‖1
raise AssertionError(‖"""Did not raise AssertionError for dimensions > classes"""‖1
"""Did not raise AssertionError for dimensions > classes"""‖)‖1
)‖assert error_info.type is AssertionError‖1
def test_principal_component_analysis() -> None:‖features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])‖1
features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])‖dimensions = 2‖1
dimensions = 2‖expected_output = np.array([[6.92820323, 8.66025404, 10.39230485], [3.0, 3.0, 3.0]])‖1
with pytest.raises(AssertionError) as error_info:‖output = principal_component_analysis(features, dimensions)‖1
output = principal_component_analysis(features, dimensions)‖if not np.allclose(expected_output, output):‖1
if not np.allclose(expected_output, output):‖raise AssertionError‖1
raise AssertionError‖assert error_info.type is AssertionError‖1
train_data = (‖((5, 2, 3), 15),‖1
((5, 2, 3), 15),‖((6, 5, 9), 25),‖1
((6, 5, 9), 25),‖((11, 12, 13), 41),‖1
((11, 12, 13), 41),‖((1, 1, 1), 8),‖1
((1, 1, 1), 8),‖((11, 12, 13), 41),‖1
((11, 12, 13), 41),‖)‖1
)‖test_data = (((515, 22, 13), 555), ((61, 35, 49), 150))‖1
test_data = (((515, 22, 13), 555), ((61, 35, 49), 150))‖parameter_vector = [2, 4, 1, 5]‖1
parameter_vector = [2, 4, 1, 5]‖m = len(train_data)‖1
m = len(train_data)‖LEARNING_RATE = 0.009‖1
"def _error(example_no, data_set=""train""):"‖return calculate_hypothesis_value(example_no, data_set) - output(‖1
return calculate_hypothesis_value(example_no, data_set) - output(‖example_no, data_set‖1
example_no, data_set‖)‖1
def _hypothesis_value(data_input_tuple):‖hyp_val = 0‖1
hyp_val = 0‖for i in range(len(parameter_vector) - 1):‖1
for i in range(len(parameter_vector) - 1):‖hyp_val += data_input_tuple[i] * parameter_vector[i + 1]‖1
hyp_val += data_input_tuple[i] * parameter_vector[i + 1]‖hyp_val += parameter_vector[0]‖1
hyp_val += parameter_vector[0]‖return hyp_val‖1
def output(example_no, data_set):‖"if data_set == ""train"":"‖1
"if data_set == ""train"":"‖return train_data[example_no][1]‖1
return train_data[example_no][1]‖"elif data_set == ""test"":"‖1
"elif data_set == ""test"":"‖return test_data[example_no][1]‖1
return test_data[example_no][1]‖return None‖1
def calculate_hypothesis_value(example_no, data_set):‖"if data_set == ""train"":"‖1
"if data_set == ""train"":"‖return _hypothesis_value(train_data[example_no][0])‖1
return _hypothesis_value(train_data[example_no][0])‖"elif data_set == ""test"":"‖1
"elif data_set == ""test"":"‖return _hypothesis_value(test_data[example_no][0])‖1
return _hypothesis_value(test_data[example_no][0])‖return None‖1
def summation_of_cost_derivative(index, end=m):‖summation_value = 0‖1
summation_value = 0‖for i in range(end):‖1
for i in range(end):‖if index == -1:‖1
if index == -1:‖summation_value += _error(i)‖1
summation_value += _error(i)‖else:‖1
else:‖summation_value += _error(i) * train_data[i][0][index]‖1
summation_value += _error(i) * train_data[i][0][index]‖return summation_value‖1
def get_cost_derivative(index):‖cost_derivative_value = summation_of_cost_derivative(index, m) / m‖1
cost_derivative_value = summation_of_cost_derivative(index, m) / m‖return cost_derivative_value‖1
def run_gradient_descent():‖global parameter_vector‖1
absolute_error_limit = 0.000002‖relative_error_limit = 0‖1
relative_error_limit = 0‖j = 0‖1
j = 0‖while True:‖1
while True:‖j += 1‖1
j += 1‖temp_parameter_vector = [0, 0, 0, 0]‖1
temp_parameter_vector = [0, 0, 0, 0]‖for i in range(len(parameter_vector)):‖1
for i in range(len(parameter_vector)):‖cost_derivative = get_cost_derivative(i - 1)‖1
cost_derivative = get_cost_derivative(i - 1)‖temp_parameter_vector[i] = (‖1
temp_parameter_vector[i] = (‖parameter_vector[i] - LEARNING_RATE * cost_derivative‖1
parameter_vector[i] - LEARNING_RATE * cost_derivative‖)‖1
)‖if np.allclose(‖1
if np.allclose(‖parameter_vector,‖1
parameter_vector,‖temp_parameter_vector,‖1
temp_parameter_vector,‖atol=absolute_error_limit,‖1
atol=absolute_error_limit,‖rtol=relative_error_limit,‖1
rtol=relative_error_limit,‖):‖1
break‖parameter_vector = temp_parameter_vector‖1
parameter_vector = temp_parameter_vector‖"print((""Number of iterations:"", j))"‖1
def test_gradient_descent():‖for i in range(len(test_data)):‖1
for i in range(len(test_data)):‖"print((""Actual output value:"", output(i, ""test"")))"‖1
"print((""Actual output value:"", output(i, ""test"")))"‖"print((""Hypothesis output:"", calculate_hypothesis_value(i, ""test"")))"‖1
"if __name__ == ""__main__"":"‖run_gradient_descent()‖1
run_gradient_descent()‖"print(""\nTesting gradient descent for a linear hypothesis function.\n"")"‖1
"print(""\nTesting gradient descent for a linear hypothesis function.\n"")"‖test_gradient_descent()‖1
import sys‖import urllib.request‖1
from matplotlib import pyplot as plt‖from sklearn.datasets import make_blobs, make_circles‖1
from sklearn.datasets import make_blobs, make_circles‖from sklearn.preprocessing import StandardScaler‖1
CANCER_DATASET_URL = (‖"""https://archive.ics.uci.edu/ml/machine-learning-databases/"""‖1
"""https://archive.ics.uci.edu/ml/machine-learning-databases/"""‖"""breast-cancer-wisconsin/wdbc.data"""‖1
"""breast-cancer-wisconsin/wdbc.data"""‖)‖1
class SmoSVM:‖def __init__(‖1
self,‖train,‖1
train,‖kernel_func,‖1
kernel_func,‖alpha_list=None,‖1
alpha_list=None,‖cost=0.4,‖1
cost=0.4,‖b=0.0,‖2
b=0.0,‖tolerance=0.001,‖2
tolerance=0.001,‖auto_norm=True,‖1
auto_norm=True,‖):‖1
):‖self._init = True‖1
self._init = True‖self._auto_norm = auto_norm‖1
self._auto_norm = auto_norm‖self._c = np.float64(cost)‖1
self._c = np.float64(cost)‖self._b = np.float64(b)‖1
self._b = np.float64(b)‖self._tol = np.float64(tolerance) if tolerance > 0.0001 else np.float64(0.001)‖1
self.tags = train[:, 0]‖self.samples = self._norm(train[:, 1:]) if self._auto_norm else train[:, 1:]‖1
self.samples = self._norm(train[:, 1:]) if self._auto_norm else train[:, 1:]‖self.alphas = alpha_list if alpha_list is not None else np.zeros(train.shape[0])‖1
self.alphas = alpha_list if alpha_list is not None else np.zeros(train.shape[0])‖self.Kernel = kernel_func‖1
self._eps = 0.001‖self._all_samples = list(range(self.length))‖1
self._all_samples = list(range(self.length))‖self._K_matrix = self._calculate_k_matrix()‖1
self._K_matrix = self._calculate_k_matrix()‖self._error = np.zeros(self.length)‖1
self._error = np.zeros(self.length)‖self._unbound = []‖1
def fit(self):‖k = self._k‖1
k = self._k‖state = None‖1
state = None‖while True:‖1
try:‖i1, i2 = self.choose_alpha.send(state)‖1
i1, i2 = self.choose_alpha.send(state)‖state = None‖1
state = None‖except StopIteration:‖1
except StopIteration:‖"print(""Optimization done!\nEvery sample satisfy the KKT condition!"")"‖1
"print(""Optimization done!\nEvery sample satisfy the KKT condition!"")"‖break‖1
y1, y2 = self.tags[i1], self.tags[i2]‖a1, a2 = self.alphas[i1].copy(), self.alphas[i2].copy()‖1
a1, a2 = self.alphas[i1].copy(), self.alphas[i2].copy()‖e1, e2 = self._e(i1), self._e(i2)‖1
e1, e2 = self._e(i1), self._e(i2)‖args = (i1, i2, a1, a2, e1, e2, y1, y2)‖1
args = (i1, i2, a1, a2, e1, e2, y1, y2)‖a1_new, a2_new = self._get_new_alpha(*args)‖1
a1_new, a2_new = self._get_new_alpha(*args)‖if not a1_new and not a2_new:‖1
if not a1_new and not a2_new:‖state = False‖1
state = False‖continue‖1
continue‖self.alphas[i1], self.alphas[i2] = a1_new, a2_new‖1
b1_new = np.float64(‖-e1‖1
-e1‖- y1 * k(i1, i1) * (a1_new - a1)‖1
- y1 * k(i1, i1) * (a1_new - a1)‖- y2 * k(i2, i1) * (a2_new - a2)‖1
- y2 * k(i2, i1) * (a2_new - a2)‖+ self._b‖1
+ self._b‖)‖3
)‖b2_new = np.float64(‖1
b2_new = np.float64(‖-e2‖1
-e2‖- y2 * k(i2, i2) * (a2_new - a2)‖1
- y2 * k(i2, i2) * (a2_new - a2)‖- y1 * k(i1, i2) * (a1_new - a1)‖1
- y1 * k(i1, i2) * (a1_new - a1)‖+ self._b‖1
)‖if 0.0 < a1_new < self._c:‖1
if 0.0 < a1_new < self._c:‖b = b1_new‖1
b = b1_new‖if 0.0 < a2_new < self._c:‖1
if 0.0 < a2_new < self._c:‖b = b2_new‖1
b = b2_new‖if not (np.float64(0) < a2_new < self._c) and not (‖1
if not (np.float64(0) < a2_new < self._c) and not (‖np.float64(0) < a1_new < self._c‖1
np.float64(0) < a1_new < self._c‖):‖1
):‖b = (b1_new + b2_new) / 2.0‖1
b = (b1_new + b2_new) / 2.0‖b_old = self._b‖1
b_old = self._b‖self._b = b‖1
self._unbound = [i for i in self._all_samples if self._is_unbound(i)]‖for s in self.unbound:‖1
for s in self.unbound:‖if s in (i1, i2):‖1
if s in (i1, i2):‖continue‖1
continue‖self._error[s] += (‖1
self._error[s] += (‖y1 * (a1_new - a1) * k(i1, s)‖1
y1 * (a1_new - a1) * k(i1, s)‖+ y2 * (a2_new - a2) * k(i2, s)‖1
+ y2 * (a2_new - a2) * k(i2, s)‖+ (self._b - b_old)‖1
+ (self._b - b_old)‖)‖1
if self._is_unbound(i1):‖self._error[i1] = 0‖1
self._error[i1] = 0‖if self._is_unbound(i2):‖1
if self._is_unbound(i2):‖self._error[i2] = 0‖1
def predict(self, test_samples, classify=True):‖if test_samples.shape[1] > self.samples.shape[1]:‖1
if test_samples.shape[1] > self.samples.shape[1]:‖raise ValueError(‖1
raise ValueError(‖"""Test samples' feature length does not equal to that of train samples"""‖1
"""Test samples' feature length does not equal to that of train samples"""‖)‖1
if self._auto_norm:‖test_samples = self._norm(test_samples)‖1
results = []‖for test_sample in test_samples:‖1
for test_sample in test_samples:‖result = self._predict(test_sample)‖1
result = self._predict(test_sample)‖if classify:‖1
if classify:‖results.append(1 if result > 0 else -1)‖1
results.append(1 if result > 0 else -1)‖else:‖1
else:‖results.append(result)‖1
results.append(result)‖return np.array(results)‖1
def _check_obey_kkt(self, index):‖alphas = self.alphas‖1
alphas = self.alphas‖tol = self._tol‖1
tol = self._tol‖r = self._e(index) * self.tags[index]‖1
r = self._e(index) * self.tags[index]‖c = self._c‖1
if isinstance(i2, np.ndarray):‖return self.Kernel(self.samples[i1], i2)‖1
else:‖return self._K_matrix[i1, i2]‖1
if self._is_unbound(index):‖return self._error[index]‖1
else:‖gx = np.dot(self.alphas * self.tags, self._K_matrix[:, index]) + self._b‖1
gx = np.dot(self.alphas * self.tags, self._K_matrix[:, index]) + self._b‖yi = self.tags[index]‖1
yi = self.tags[index]‖return gx - yi‖1
def _calculate_k_matrix(self):‖k_matrix = np.zeros([self.length, self.length])‖1
k_matrix = np.zeros([self.length, self.length])‖for i in self._all_samples:‖1
for i in self._all_samples:‖for j in self._all_samples:‖1
for j in self._all_samples:‖k_matrix[i, j] = np.float64(‖1
k_matrix[i, j] = np.float64(‖self.Kernel(self.samples[i, :], self.samples[j, :])‖1
self.Kernel(self.samples[i, :], self.samples[j, :])‖)‖1
)‖return k_matrix‖1
def _predict(self, sample):‖k = self._k‖1
k = self._k‖predicted_value = (‖1
predicted_value = (‖np.sum(‖1
np.sum(‖[‖1
[‖self.alphas[i1] * self.tags[i1] * k(i1, sample)‖1
self.alphas[i1] * self.tags[i1] * k(i1, sample)‖for i1 in self._all_samples‖1
for i1 in self._all_samples‖]‖1
)‖+ self._b‖1
)‖return predicted_value‖1
def _choose_alphas(self):‖loci = yield from self._choose_a1()‖1
loci = yield from self._choose_a1()‖if not loci:‖1
if not loci:‖return None‖1
return None‖return loci‖1
def _choose_a1(self):‖while True:‖1
while True:‖all_not_obey = True‖1
"print(""Scanning all samples!"")"‖for i1 in [i for i in self._all_samples if self._check_obey_kkt(i)]:‖1
for i1 in [i for i in self._all_samples if self._check_obey_kkt(i)]:‖all_not_obey = False‖1
all_not_obey = False‖yield from self._choose_a2(i1)‖1
"print(""Scanning non-bound samples!"")"‖while True:‖1
while True:‖not_obey = True‖1
not_obey = True‖for i1 in [‖1
for i1 in [‖i‖1
i‖for i in self._all_samples‖1
for i in self._all_samples‖if self._check_obey_kkt(i) and self._is_unbound(i)‖1
if self._check_obey_kkt(i) and self._is_unbound(i)‖]:‖1
]:‖not_obey = False‖1
not_obey = False‖yield from self._choose_a2(i1)‖1
yield from self._choose_a2(i1)‖if not_obey:‖1
if not_obey:‖"print(""All non-bound samples satisfy the KKT condition!"")"‖1
"print(""All non-bound samples satisfy the KKT condition!"")"‖break‖1
break‖if all_not_obey:‖1
if all_not_obey:‖"print(""All samples satisfy the KKT condition!"")"‖1
"print(""All samples satisfy the KKT condition!"")"‖break‖1
break‖return False‖1
def _choose_a2(self, i1):‖self._unbound = [i for i in self._all_samples if self._is_unbound(i)]‖1
if len(self.unbound) > 0:‖tmp_error = self._error.copy().tolist()‖1
tmp_error = self._error.copy().tolist()‖tmp_error_dict = {‖1
tmp_error_dict = {‖index: value‖1
index: value‖for index, value in enumerate(tmp_error)‖1
for index, value in enumerate(tmp_error)‖if self._is_unbound(index)‖1
if self._is_unbound(index)‖}‖1
}‖if self._e(i1) >= 0:‖1
if self._e(i1) >= 0:‖i2 = min(tmp_error_dict, key=lambda index: tmp_error_dict[index])‖1
i2 = min(tmp_error_dict, key=lambda index: tmp_error_dict[index])‖else:‖1
else:‖i2 = max(tmp_error_dict, key=lambda index: tmp_error_dict[index])‖1
i2 = max(tmp_error_dict, key=lambda index: tmp_error_dict[index])‖cmd = yield i1, i2‖1
cmd = yield i1, i2‖if cmd is None:‖3
if cmd is None:‖return‖3
rng = np.random.default_rng()‖for i2 in np.roll(self.unbound, rng.choice(self.length)):‖1
for i2 in np.roll(self.unbound, rng.choice(self.length)):‖cmd = yield i1, i2‖1
for i2 in np.roll(self._all_samples, rng.choice(self.length)):‖cmd = yield i1, i2‖1
def _get_new_alpha(self, i1, i2, a1, a2, e1, e2, y1, y2):‖k = self._k‖1
k = self._k‖if i1 == i2:‖1
if i1 == i2:‖return None, None‖1
s = y1 * y2‖if s == -1:‖1
if s == -1:‖l, h = max(0.0, a2 - a1), min(self._c, self._c + a2 - a1)‖1
l, h = max(0.0, a2 - a1), min(self._c, self._c + a2 - a1)‖else:‖1
else:‖l, h = max(0.0, a2 + a1 - self._c), min(self._c, a2 + a1)‖1
l, h = max(0.0, a2 + a1 - self._c), min(self._c, a2 + a1)‖if l == h:‖1
if l == h:‖return None, None‖1
k11 = k(i1, i1)‖k22 = k(i2, i2)‖1
k22 = k(i2, i2)‖k12 = k(i1, i2)‖1
if (eta := k11 + k22 - 2.0 * k12) > 0.0:‖a2_new_unc = a2 + (y2 * (e1 - e2)) / eta‖1
if a2_new_unc >= h:‖a2_new = h‖1
a2_new = h‖elif a2_new_unc <= l:‖1
elif a2_new_unc <= l:‖a2_new = l‖1
a2_new = l‖else:‖1
else:‖a2_new = a2_new_unc‖1
a2_new = a2_new_unc‖else:‖1
else:‖b = self._b‖1
b = self._b‖l1 = a1 + s * (a2 - l)‖1
l1 = a1 + s * (a2 - l)‖h1 = a1 + s * (a2 - h)‖1
f1 = y1 * (e1 + b) - a1 * k(i1, i1) - s * a2 * k(i1, i2)‖f2 = y2 * (e2 + b) - a2 * k(i2, i2) - s * a1 * k(i1, i2)‖1
f2 = y2 * (e2 + b) - a2 * k(i2, i2) - s * a1 * k(i1, i2)‖ol = (‖1
ol = (‖l1 * f1‖1
l1 * f1‖+ l * f2‖1
+ l * f2‖+ 1 / 2 * l1**2 * k(i1, i1)‖1
+ 1 / 2 * l1**2 * k(i1, i1)‖+ 1 / 2 * l**2 * k(i2, i2)‖1
+ 1 / 2 * l**2 * k(i2, i2)‖+ s * l * l1 * k(i1, i2)‖1
+ s * l * l1 * k(i1, i2)‖)‖1
)‖oh = (‖1
oh = (‖h1 * f1‖1
h1 * f1‖+ h * f2‖1
+ h * f2‖+ 1 / 2 * h1**2 * k(i1, i1)‖1
+ 1 / 2 * h1**2 * k(i1, i1)‖+ 1 / 2 * h**2 * k(i2, i2)‖1
+ 1 / 2 * h**2 * k(i2, i2)‖+ s * h * h1 * k(i1, i2)‖1
+ s * h * h1 * k(i1, i2)‖)‖1
)‖if ol < (oh - self._eps):‖1
if ol < (oh - self._eps):‖a2_new = l‖1
a2_new = l‖elif ol > oh + self._eps:‖1
elif ol > oh + self._eps:‖a2_new = h‖1
a2_new = h‖else:‖1
else:‖a2_new = a2‖1
a1_new = a1 + s * (a2 - a2_new)‖if a1_new < 0:‖1
if a1_new < 0:‖a2_new += s * a1_new‖1
a2_new += s * a1_new‖a1_new = 0‖1
a1_new = 0‖if a1_new > self._c:‖1
if a1_new > self._c:‖a2_new += s * (a1_new - self._c)‖1
a2_new += s * (a1_new - self._c)‖a1_new = self._c‖1
def _norm(self, data):‖if self._init:‖1
if self._init:‖self._min = np.min(data, axis=0)‖1
self._min = np.min(data, axis=0)‖self._max = np.max(data, axis=0)‖1
self._max = np.max(data, axis=0)‖self._init = False‖1
self._init = False‖return (data - self._min) / (self._max - self._min)‖1
return (data - self._min) / (self._max - self._min)‖else:‖1
else:‖return (data - self._min) / (self._max - self._min)‖1
def _is_unbound(self, index):‖return bool(0.0 < self.alphas[index] < self._c)‖1
def _is_support(self, index):‖return bool(self.alphas[index] > 0)‖1
@property‖def unbound(self):‖1
def unbound(self):‖return self._unbound‖1
@property‖def support(self):‖1
def support(self):‖return [i for i in range(self.length) if self._is_support(i)]‖1
@property‖def length(self):‖1
def length(self):‖return self.samples.shape[0]‖1
class Kernel:‖def __init__(self, kernel, degree=1.0, coef0=0.0, gamma=1.0):‖1
def __init__(self, kernel, degree=1.0, coef0=0.0, gamma=1.0):‖self.degree = np.float64(degree)‖1
self.degree = np.float64(degree)‖self.coef0 = np.float64(coef0)‖1
self.coef0 = np.float64(coef0)‖self.gamma = np.float64(gamma)‖1
self.gamma = np.float64(gamma)‖self._kernel_name = kernel‖1
self._kernel_name = kernel‖self._kernel = self._get_kernel(kernel_name=kernel)‖1
self._kernel = self._get_kernel(kernel_name=kernel)‖self._check()‖1
def _polynomial(self, v1, v2):‖return (self.gamma * np.inner(v1, v2) + self.coef0) ** self.degree‖1
def _linear(self, v1, v2):‖return np.inner(v1, v2) + self.coef0‖1
def _rbf(self, v1, v2):‖return np.exp(-1 * (self.gamma * np.linalg.norm(v1 - v2) ** 2))‖1
def _check(self):‖if self._kernel == self._rbf and self.gamma < 0:‖1
if self._kernel == self._rbf and self.gamma < 0:‖"raise ValueError(""gamma value must be non-negative"")"‖1
def _get_kernel(self, kernel_name):‖"maps = {""linear"": self._linear, ""poly"": self._polynomial, ""rbf"": self._rbf}"‖1
"maps = {""linear"": self._linear, ""poly"": self._polynomial, ""rbf"": self._rbf}"‖return maps[kernel_name]‖1
def __call__(self, v1, v2):‖return self._kernel(v1, v2)‖1
def __repr__(self):‖return self._kernel_name‖1
def count_time(func):‖def call_func(*args, **kwargs):‖1
def call_func(*args, **kwargs):‖import time‖1
start_time = time.time()‖func(*args, **kwargs)‖1
func(*args, **kwargs)‖end_time = time.time()‖1
end_time = time.time()‖"print(f""SMO algorithm cost {end_time - start_time} seconds"")"‖1
@count_time‖def test_cancer_data():‖1
def test_cancer_data():‖"print(""Hello!\nStart test SVM using the SMO algorithm!"")"‖1
"if not os.path.exists(r""cancer_data.csv""):"‖request = urllib.request.Request(‖1
request = urllib.request.Request(‖CANCER_DATASET_URL,‖1
CANCER_DATASET_URL,‖"headers={""User-Agent"": ""Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)""},"‖1
"headers={""User-Agent"": ""Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)""},"‖)‖1
)‖response = urllib.request.urlopen(request)‖1
response = urllib.request.urlopen(request)‖"content = response.read().decode(""utf-8"")"‖1
"content = response.read().decode(""utf-8"")"‖"with open(r""cancer_data.csv"", ""w"") as f:"‖1
"with open(r""cancer_data.csv"", ""w"") as f:"‖f.write(content)‖1
data = pd.read_csv(‖"""cancer_data.csv"","‖1
"""cancer_data.csv"","‖header=None,‖1
header=None,‖dtype={0: str},‖1
dtype={0: str},‖)‖1
del data[data.columns.tolist()[0]]‖data = data.dropna(axis=0)‖1
data = data.dropna(axis=0)‖"data = data.replace({""M"": np.float64(1), ""B"": np.float64(-1)})"‖1
"data = data.replace({""M"": np.float64(1), ""B"": np.float64(-1)})"‖samples = np.array(data)[:, :]‖1
train_data, test_data = samples[:328, :], samples[328:, :]‖test_tags, test_samples = test_data[:, 0], test_data[:, 1:]‖1
"my_kernel = Kernel(kernel=""rbf"", degree=5, coef0=1, gamma=0.5)"‖al = np.zeros(train_data.shape[0])‖1
mysvm = SmoSVM(‖train=train_data,‖3
train=train_data,‖kernel_func=my_kernel,‖3
kernel_func=my_kernel,‖alpha_list=al,‖1
alpha_list=al,‖cost=0.4,‖1
tolerance=0.001,‖)‖1
)‖mysvm.fit()‖3
mysvm.fit()‖predict = mysvm.predict(test_samples)‖1
score = 0‖test_num = test_tags.shape[0]‖1
test_num = test_tags.shape[0]‖for i in range(test_tags.shape[0]):‖1
for i in range(test_tags.shape[0]):‖if test_tags[i] == predict[i]:‖1
if test_tags[i] == predict[i]:‖score += 1‖1
score += 1‖"print(f""\nAll: {test_num}\nCorrect: {score}\nIncorrect: {test_num - score}"")"‖1
"print(f""\nAll: {test_num}\nCorrect: {score}\nIncorrect: {test_num - score}"")"‖"print(f""Rough Accuracy: {score / test_tags.shape[0]}"")"‖1
"print(""\nStarting plot, please wait!"")"‖"sys.stdout = open(os.devnull, ""w"")"‖1
ax1 = plt.subplot2grid((2, 2), (0, 0))‖ax2 = plt.subplot2grid((2, 2), (0, 1))‖1
ax2 = plt.subplot2grid((2, 2), (0, 1))‖ax3 = plt.subplot2grid((2, 2), (1, 0))‖1
ax3 = plt.subplot2grid((2, 2), (1, 0))‖ax4 = plt.subplot2grid((2, 2), (1, 1))‖1
ax4 = plt.subplot2grid((2, 2), (1, 1))‖"ax1.set_title(""Linear SVM, cost = 0.1"")"‖1
"ax1.set_title(""Linear SVM, cost = 0.1"")"‖test_linear_kernel(ax1, cost=0.1)‖1
test_linear_kernel(ax1, cost=0.1)‖"ax2.set_title(""Linear SVM, cost = 500"")"‖1
"ax2.set_title(""Linear SVM, cost = 500"")"‖test_linear_kernel(ax2, cost=500)‖1
test_linear_kernel(ax2, cost=500)‖"ax3.set_title(""RBF kernel SVM, cost = 0.1"")"‖1
"ax3.set_title(""RBF kernel SVM, cost = 0.1"")"‖test_rbf_kernel(ax3, cost=0.1)‖1
test_rbf_kernel(ax3, cost=0.1)‖"ax4.set_title(""RBF kernel SVM, cost = 500"")"‖1
"ax4.set_title(""RBF kernel SVM, cost = 500"")"‖test_rbf_kernel(ax4, cost=500)‖1
sys.stdout = sys.__stdout__‖"print(""Plot done!"")"‖1
def test_linear_kernel(ax, cost):‖train_x, train_y = make_blobs(‖1
train_x, train_y = make_blobs(‖n_samples=500, centers=2, n_features=2, random_state=1‖1
n_samples=500, centers=2, n_features=2, random_state=1‖)‖1
)‖train_y[train_y == 0] = -1‖2
train_y[train_y == 0] = -1‖scaler = StandardScaler()‖2
scaler = StandardScaler()‖train_x_scaled = scaler.fit_transform(train_x, train_y)‖2
train_x_scaled = scaler.fit_transform(train_x, train_y)‖train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))‖2
train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))‖"my_kernel = Kernel(kernel=""linear"", degree=5, coef0=1, gamma=0.5)"‖1
"my_kernel = Kernel(kernel=""linear"", degree=5, coef0=1, gamma=0.5)"‖mysvm = SmoSVM(‖1
kernel_func=my_kernel,‖cost=cost,‖2
cost=cost,‖tolerance=0.001,‖2
tolerance=0.001,‖auto_norm=False,‖2
auto_norm=False,‖)‖2
mysvm.fit()‖plot_partition_boundary(mysvm, train_data, ax=ax)‖2
def test_rbf_kernel(ax, cost):‖train_x, train_y = make_circles(‖1
train_x, train_y = make_circles(‖n_samples=500, noise=0.1, factor=0.1, random_state=1‖1
n_samples=500, noise=0.1, factor=0.1, random_state=1‖)‖1
train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))‖"my_kernel = Kernel(kernel=""rbf"", degree=5, coef0=1, gamma=0.5)"‖1
"my_kernel = Kernel(kernel=""rbf"", degree=5, coef0=1, gamma=0.5)"‖mysvm = SmoSVM(‖1
def plot_partition_boundary(‖"model, train_data, ax, resolution=100, colors=(""b"", ""k"", ""r"")"‖1
"model, train_data, ax, resolution=100, colors=(""b"", ""k"", ""r"")"‖):‖1
):‖train_data_x = train_data[:, 1]‖1
train_data_x = train_data[:, 1]‖train_data_y = train_data[:, 2]‖1
train_data_y = train_data[:, 2]‖train_data_tags = train_data[:, 0]‖1
train_data_tags = train_data[:, 0]‖xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)‖1
xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)‖yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)‖1
yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)‖test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(‖1
test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(‖resolution * resolution, 2‖1
resolution * resolution, 2‖)‖1
test_tags = model.predict(test_samples, classify=False)‖grid = test_tags.reshape((len(xrange), len(yrange)))‖1
ax.contour(‖xrange,‖1
xrange,‖yrange,‖1
yrange,‖np.asmatrix(grid).T,‖1
np.asmatrix(grid).T,‖levels=(-1, 0, 1),‖1
levels=(-1, 0, 1),‖"linestyles=(""--"", ""-"", ""--""),"‖1
"linestyles=(""--"", ""-"", ""--""),"‖linewidths=(1, 1, 1),‖1
linewidths=(1, 1, 1),‖colors=colors,‖1
colors=colors,‖)‖1
ax.scatter(‖train_data_x,‖1
train_data_x,‖train_data_y,‖1
train_data_y,‖c=train_data_tags,‖1
c=train_data_tags,‖cmap=plt.cm.Dark2,‖1
cmap=plt.cm.Dark2,‖lw=0,‖1
lw=0,‖alpha=0.5,‖1
alpha=0.5,‖)‖1
support = model.support‖ax.scatter(‖1
ax.scatter(‖train_data_x[support],‖1
train_data_x[support],‖train_data_y[support],‖1
train_data_y[support],‖c=train_data_tags[support],‖1
c=train_data_tags[support],‖cmap=plt.cm.Dark2,‖1
cmap=plt.cm.Dark2,‖)‖1
"if __name__ == ""__main__"":"‖test_cancer_data()‖1
test_cancer_data()‖test_demonstration()‖1
test_demonstration()‖plt.show()‖1
import numpy as np‖from numpy.linalg import norm‖1
def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:‖return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))‖1
def similarity_search(‖dataset: np.ndarray, value_array: np.ndarray‖1
dataset: np.ndarray, value_array: np.ndarray‖) -> list[list[list[float] | float]]:‖1
if dataset.ndim != value_array.ndim:‖msg = (‖1
msg = (‖"""Wrong input data's dimensions... """‖1
"""Wrong input data's dimensions... """‖"f""dataset : {dataset.ndim}, value_array : {value_array.ndim}"""‖1
"f""dataset : {dataset.ndim}, value_array : {value_array.ndim}"""‖)‖1
try:‖if dataset.shape[1] != value_array.shape[1]:‖1
if dataset.shape[1] != value_array.shape[1]:‖msg = (‖1
msg = (‖"""Wrong input data's shape... """‖1
"""Wrong input data's shape... """‖"f""dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}"""‖1
"f""dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}"""‖)‖1
raise ValueError(msg)‖except IndexError:‖1
except IndexError:‖if dataset.ndim != value_array.ndim:‖1
if dataset.ndim != value_array.ndim:‖"raise TypeError(""Wrong shape"")"‖1
if dataset.dtype != value_array.dtype:‖msg = (‖1
msg = (‖"""Input data have different datatype... """‖1
"""Input data have different datatype... """‖"f""dataset : {dataset.dtype}, value_array : {value_array.dtype}"""‖1
"f""dataset : {dataset.dtype}, value_array : {value_array.dtype}"""‖)‖1
for value in value_array:‖dist = euclidean(value, dataset[0])‖1
dist = euclidean(value, dataset[0])‖vector = dataset[0].tolist()‖1
for dataset_value in dataset[1:]:‖temp_dist = euclidean(value, dataset_value)‖1
if dist > temp_dist:‖dist = temp_dist‖1
dist = temp_dist‖vector = dataset_value.tolist()‖1
def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:‖return float(np.dot(input_a, input_b) / (norm(input_a) * norm(input_b)))‖1
import numpy as np‖from numpy import ndarray‖2
from numpy import ndarray‖from scipy.optimize import Bounds, LinearConstraint, minimize‖1
def norm_squared(vector: ndarray) -> float:‖return np.dot(vector, vector)‖1
self,‖*,‖1
*,‖regularization: float = np.inf,‖1
regularization: float = np.inf,‖"kernel: str = ""linear"","‖1
"kernel: str = ""linear"","‖gamma: float = 0.0,‖1
gamma: float = 0.0,‖) -> None:‖1
) -> None:‖self.regularization = regularization‖1
self.regularization = regularization‖self.gamma = gamma‖1
self.gamma = gamma‖"if kernel == ""linear"":"‖1
"if kernel == ""linear"":"‖self.kernel = self.__linear‖1
self.kernel = self.__linear‖"elif kernel == ""rbf"":"‖1
"elif kernel == ""rbf"":"‖if self.gamma == 0:‖1
if self.gamma == 0:‖"raise ValueError(""rbf kernel requires gamma"")"‖1
"raise ValueError(""rbf kernel requires gamma"")"‖if not isinstance(self.gamma, (float, int)):‖1
if not isinstance(self.gamma, (float, int)):‖"raise ValueError(""gamma must be float or int"")"‖1
"raise ValueError(""gamma must be float or int"")"‖if not self.gamma > 0:‖1
if not self.gamma > 0:‖"raise ValueError(""gamma must be > 0"")"‖1
"raise ValueError(""gamma must be > 0"")"‖self.kernel = self.__rbf‖1
else:‖"msg = f""Unknown kernel: {kernel}"""‖1
"msg = f""Unknown kernel: {kernel}"""‖raise ValueError(msg)‖1
def __linear(self, vector1: ndarray, vector2: ndarray) -> float:‖return np.dot(vector1, vector2)‖1
def __rbf(self, vector1: ndarray, vector2: ndarray) -> float:‖return np.exp(-(self.gamma * norm_squared(vector1 - vector2)))‖1
self.observations = observations‖self.classes = classes‖1
def to_minimize(candidate: ndarray) -> float:‖s = 0‖1
s = 0‖(n,) = np.shape(candidate)‖1
(n,) = np.shape(candidate)‖for i in range(n):‖1
for j in range(n):‖s += (‖1
s += (‖candidate[i]‖1
candidate[i]‖* candidate[j]‖1
* candidate[j]‖* classes[i]‖1
* classes[i]‖* classes[j]‖1
* classes[j]‖* self.kernel(observations[i], observations[j])‖1
* self.kernel(observations[i], observations[j])‖)‖1
)‖return 1 / 2 * s - sum(candidate)‖1
ly_contraint = LinearConstraint(classes, 0, 0)‖l_bounds = Bounds(0, self.regularization)‖1
l_star = minimize(‖to_minimize, np.ones(n), bounds=l_bounds, constraints=[ly_contraint]‖1
to_minimize, np.ones(n), bounds=l_bounds, constraints=[ly_contraint]‖).x‖1
).x‖self.optimum = l_star‖1
s = 0‖for i in range(n):‖1
for j in range(n):‖s += classes[i] - classes[i] * self.optimum[i] * self.kernel(‖1
s += classes[i] - classes[i] * self.optimum[i] * self.kernel(‖observations[i], observations[j]‖1
observations[i], observations[j]‖)‖1
)‖self.offset = s / n‖1
def predict(self, observation: ndarray) -> int:‖s = sum(‖1
s = sum(‖self.optimum[n]‖1
self.optimum[n]‖* self.classes[n]‖1
* self.classes[n]‖* self.kernel(self.observations[n], observation)‖1
* self.kernel(self.observations[n], observation)‖for n in range(len(self.classes))‖1
for n in range(len(self.classes))‖)‖1
)‖return 1 if s + self.offset >= 0 else -1‖1
import numpy as np‖from sklearn.datasets import fetch_california_housing‖1
from sklearn.datasets import fetch_california_housing‖from sklearn.metrics import mean_absolute_error, mean_squared_error‖1
from sklearn.metrics import mean_absolute_error, mean_squared_error‖from sklearn.model_selection import train_test_split‖1
from sklearn.model_selection import train_test_split‖from xgboost import XGBRegressor‖1
def xgboost(‖features: np.ndarray, target: np.ndarray, test_features: np.ndarray‖1
features: np.ndarray, target: np.ndarray, test_features: np.ndarray‖) -> np.ndarray:‖1
) -> np.ndarray:‖xgb = XGBRegressor(‖1
xgb = XGBRegressor(‖"verbosity=0, random_state=42, tree_method=""exact"", base_score=0.5"‖1
"verbosity=0, random_state=42, tree_method=""exact"", base_score=0.5"‖)‖1
)‖xgb.fit(features, target)‖1
predictions = xgb.predict(test_features)‖predictions = predictions.reshape(len(predictions), 1)‖1
predictions = predictions.reshape(len(predictions), 1)‖return predictions‖1
california = fetch_california_housing()‖data, target = data_handling(california)‖1
data, target = data_handling(california)‖x_train, x_test, y_train, y_test = train_test_split(‖1
x_train, x_test, y_train, y_test = train_test_split(‖data, target, test_size=0.25, random_state=1‖1
data, target, test_size=0.25, random_state=1‖)‖1
)‖predictions = xgboost(x_train, y_train, x_test)‖1
"print(f""Mean Absolute Error: {mean_absolute_error(y_test, predictions)}"")"‖"print(f""Mean Square Error: {mean_squared_error(y_test, predictions)}"")"‖1
doctest.testmod(verbose=True)‖main()‖2
import pandas as pd‖from sklearn.preprocessing import Normalizer‖1
from sklearn.preprocessing import Normalizer‖from sklearn.svm import SVR‖1
from sklearn.svm import SVR‖from statsmodels.tsa.statespace.sarimax import SARIMAX‖1
def linear_regression_prediction(‖train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list‖1
train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list‖) -> float:‖1
) -> float:‖x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])‖1
x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])‖y = np.array(train_usr)‖1
y = np.array(train_usr)‖beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)‖1
beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)‖return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])‖1
"simplefilter(""ignore"", UserWarning)"‖order = (1, 2, 1)‖1
order = (1, 2, 1)‖seasonal_order = (1, 1, 1, 7)‖1
seasonal_order = (1, 1, 1, 7)‖model = SARIMAX(‖1
model = SARIMAX(‖train_user, exog=train_match, order=order, seasonal_order=seasonal_order‖1
train_user, exog=train_match, order=order, seasonal_order=seasonal_order‖)‖1
)‖"model_fit = model.fit(disp=False, maxiter=600, method=""nm"")"‖1
"model_fit = model.fit(disp=False, maxiter=600, method=""nm"")"‖result = model_fit.predict(1, len(test_match), exog=[test_match])‖1
result = model_fit.predict(1, len(test_match), exog=[test_match])‖return float(result[0])‖1
def support_vector_regressor(x_train: list, x_test: list, train_user: list) -> float:‖"regressor = SVR(kernel=""rbf"", C=1, gamma=0.1, epsilon=0.1)"‖1
"regressor = SVR(kernel=""rbf"", C=1, gamma=0.1, epsilon=0.1)"‖regressor.fit(x_train, train_user)‖1
regressor.fit(x_train, train_user)‖y_pred = regressor.predict(x_test)‖1
y_pred = regressor.predict(x_test)‖return float(y_pred[0])‖1
def interquartile_range_checker(train_user: list) -> float:‖train_user.sort()‖1
train_user.sort()‖q1 = np.percentile(train_user, 25)‖1
q1 = np.percentile(train_user, 25)‖q3 = np.percentile(train_user, 75)‖1
q3 = np.percentile(train_user, 75)‖iqr = q3 - q1‖1
iqr = q3 - q1‖low_lim = q1 - (iqr * 0.1)‖1
low_lim = q1 - (iqr * 0.1)‖return float(low_lim)‖1
def data_safety_checker(list_vote: list, actual_result: float) -> bool:‖safe = 0‖1
safe = 0‖not_safe = 0‖1
if not isinstance(actual_result, float):‖"raise TypeError(""Actual result should be float. Value passed is a list"")"‖1
for i in list_vote:‖if i > actual_result:‖1
if i > actual_result:‖safe = not_safe + 1‖1
safe = not_safe + 1‖elif abs(abs(i) - abs(actual_result)) <= 0.1:‖1
elif abs(abs(i) - abs(actual_result)) <= 0.1:‖safe += 1‖1
safe += 1‖else:‖1
else:‖not_safe += 1‖1
not_safe += 1‖return safe > not_safe‖1
"if __name__ == ""__main__"":"‖"data_input_df = pd.read_csv(""ex_data.csv"")"‖1
total_date = normalize_df[:, 2].tolist()‖total_user = normalize_df[:, 0].tolist()‖1
total_user = normalize_df[:, 0].tolist()‖total_match = normalize_df[:, 1].tolist()‖1
x = normalize_df[:, [1, 2]].tolist()‖x_train = x[: len(x) - 1]‖1
x_train = x[: len(x) - 1]‖x_test = x[len(x) - 1 :]‖1
train_date = total_date[: len(total_date) - 1]‖train_user = total_user[: len(total_user) - 1]‖1
train_user = total_user[: len(total_user) - 1]‖train_match = total_match[: len(total_match) - 1]‖1
test_date = total_date[len(total_date) - 1 :]‖test_user = total_user[len(total_user) - 1 :]‖1
test_user = total_user[len(total_user) - 1 :]‖test_match = total_match[len(total_match) - 1 :]‖1
res_vote = [‖linear_regression_prediction(‖1
linear_regression_prediction(‖train_date, train_user, train_match, test_date, test_match‖1
train_date, train_user, train_match, test_date, test_match‖),‖1
),‖sarimax_predictor(train_user, train_match, test_match),‖1
sarimax_predictor(train_user, train_match, test_match),‖support_vector_regressor(x_train, x_test, train_user),‖1
support_vector_regressor(x_train, x_test, train_user),‖]‖1
"not_str = """" if data_safety_checker(res_vote, test_user[0]) else ""not """‖"print(f""Today's data is {not_str}safe."")"‖1
X = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]‖y = [0, 1, 0, 0]‖1
clf = MLPClassifier(‖"solver=""lbfgs"", alpha=1e-5, hidden_layer_sizes=(5, 2), random_state=1"‖1
"solver=""lbfgs"", alpha=1e-5, hidden_layer_sizes=(5, 2), random_state=1"‖)‖1
test = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0]]‖Y = clf.predict(test)‖1
def wrapper(y):‖return list(y)‖1
def surface_area_cube(side_length: float) -> float:‖if side_length < 0:‖1
if side_length < 0:‖"raise ValueError(""surface_area_cube() only accepts non-negative values"")"‖1
"raise ValueError(""surface_area_cube() only accepts non-negative values"")"‖return 6 * side_length**2‖1
def surface_area_cuboid(length: float, breadth: float, height: float) -> float:‖if length < 0 or breadth < 0 or height < 0:‖1
if length < 0 or breadth < 0 or height < 0:‖"raise ValueError(""surface_area_cuboid() only accepts non-negative values"")"‖1
"raise ValueError(""surface_area_cuboid() only accepts non-negative values"")"‖return 2 * ((length * breadth) + (breadth * height) + (length * height))‖1
def surface_area_sphere(radius: float) -> float:‖if radius < 0:‖1
if radius < 0:‖"raise ValueError(""surface_area_sphere() only accepts non-negative values"")"‖1
"raise ValueError(""surface_area_sphere() only accepts non-negative values"")"‖return 4 * pi * radius**2‖1
def surface_area_hemisphere(radius: float) -> float:‖if radius < 0:‖1
if radius < 0:‖"raise ValueError(""surface_area_hemisphere() only accepts non-negative values"")"‖1
"raise ValueError(""surface_area_hemisphere() only accepts non-negative values"")"‖return 3 * pi * radius**2‖1
def surface_area_cone(radius: float, height: float) -> float:‖if radius < 0 or height < 0:‖1
if radius < 0 or height < 0:‖"raise ValueError(""surface_area_cone() only accepts non-negative values"")"‖1
"raise ValueError(""surface_area_cone() only accepts non-negative values"")"‖return pi * radius * (radius + (height**2 + radius**2) ** 0.5)‖1
def surface_area_conical_frustum(‖radius_1: float, radius_2: float, height: float‖1
radius_1: float, radius_2: float, height: float‖) -> float:‖1
) -> float:‖if radius_1 < 0 or radius_2 < 0 or height < 0:‖1
if radius_1 < 0 or radius_2 < 0 or height < 0:‖raise ValueError(‖1
raise ValueError(‖"""surface_area_conical_frustum() only accepts non-negative values"""‖1
"""surface_area_conical_frustum() only accepts non-negative values"""‖)‖1
)‖slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5‖1
slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5‖return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)‖1
def surface_area_cylinder(radius: float, height: float) -> float:‖if radius < 0 or height < 0:‖1
if radius < 0 or height < 0:‖"raise ValueError(""surface_area_cylinder() only accepts non-negative values"")"‖1
"raise ValueError(""surface_area_cylinder() only accepts non-negative values"")"‖return 2 * pi * radius * (height + radius)‖1
def surface_area_torus(torus_radius: float, tube_radius: float) -> float:‖if torus_radius < 0 or tube_radius < 0:‖1
if torus_radius < 0 or tube_radius < 0:‖"raise ValueError(""surface_area_torus() only accepts non-negative values"")"‖1
"raise ValueError(""surface_area_torus() only accepts non-negative values"")"‖if torus_radius < tube_radius:‖1
if torus_radius < tube_radius:‖raise ValueError(‖1
raise ValueError(‖"""surface_area_torus() does not support spindle or self intersecting tori"""‖1
"""surface_area_torus() does not support spindle or self intersecting tori"""‖)‖1
)‖return 4 * pow(pi, 2) * torus_radius * tube_radius‖1
def area_rectangle(length: float, width: float) -> float:‖if length < 0 or width < 0:‖1
if length < 0 or width < 0:‖"raise ValueError(""area_rectangle() only accepts non-negative values"")"‖1
"raise ValueError(""area_rectangle() only accepts non-negative values"")"‖return length * width‖1
def area_square(side_length: float) -> float:‖if side_length < 0:‖1
if side_length < 0:‖"raise ValueError(""area_square() only accepts non-negative values"")"‖1
"raise ValueError(""area_square() only accepts non-negative values"")"‖return side_length**2‖1
def area_triangle(base: float, height: float) -> float:‖if base < 0 or height < 0:‖1
if base < 0 or height < 0:‖"raise ValueError(""area_triangle() only accepts non-negative values"")"‖1
"raise ValueError(""area_triangle() only accepts non-negative values"")"‖return (base * height) / 2‖1
def area_triangle_three_sides(side1: float, side2: float, side3: float) -> float:‖if side1 < 0 or side2 < 0 or side3 < 0:‖1
if side1 < 0 or side2 < 0 or side3 < 0:‖"raise ValueError(""area_triangle_three_sides() only accepts non-negative values"")"‖1
"raise ValueError(""area_triangle_three_sides() only accepts non-negative values"")"‖elif side1 + side2 < side3 or side1 + side3 < side2 or side2 + side3 < side1:‖1
elif side1 + side2 < side3 or side1 + side3 < side2 or side2 + side3 < side1:‖"raise ValueError(""Given three sides do not form a triangle"")"‖1
"raise ValueError(""Given three sides do not form a triangle"")"‖semi_perimeter = (side1 + side2 + side3) / 2‖1
semi_perimeter = (side1 + side2 + side3) / 2‖area = sqrt(‖1
area = sqrt(‖semi_perimeter‖1
semi_perimeter‖* (semi_perimeter - side1)‖1
* (semi_perimeter - side1)‖* (semi_perimeter - side2)‖1
* (semi_perimeter - side2)‖* (semi_perimeter - side3)‖1
* (semi_perimeter - side3)‖)‖1
)‖return area‖1
def area_parallelogram(base: float, height: float) -> float:‖if base < 0 or height < 0:‖1
if base < 0 or height < 0:‖"raise ValueError(""area_parallelogram() only accepts non-negative values"")"‖1
"raise ValueError(""area_parallelogram() only accepts non-negative values"")"‖return base * height‖1
def area_trapezium(base1: float, base2: float, height: float) -> float:‖if base1 < 0 or base2 < 0 or height < 0:‖1
if base1 < 0 or base2 < 0 or height < 0:‖"raise ValueError(""area_trapezium() only accepts non-negative values"")"‖1
"raise ValueError(""area_trapezium() only accepts non-negative values"")"‖return 1 / 2 * (base1 + base2) * height‖1
def area_circle(radius: float) -> float:‖if radius < 0:‖1
if radius < 0:‖"raise ValueError(""area_circle() only accepts non-negative values"")"‖1
"raise ValueError(""area_circle() only accepts non-negative values"")"‖return pi * radius**2‖1
def area_ellipse(radius_x: float, radius_y: float) -> float:‖if radius_x < 0 or radius_y < 0:‖1
if radius_x < 0 or radius_y < 0:‖"raise ValueError(""area_ellipse() only accepts non-negative values"")"‖1
"raise ValueError(""area_ellipse() only accepts non-negative values"")"‖return pi * radius_x * radius_y‖1
def area_rhombus(diagonal_1: float, diagonal_2: float) -> float:‖if diagonal_1 < 0 or diagonal_2 < 0:‖1
if diagonal_1 < 0 or diagonal_2 < 0:‖"raise ValueError(""area_rhombus() only accepts non-negative values"")"‖1
"raise ValueError(""area_rhombus() only accepts non-negative values"")"‖return 1 / 2 * diagonal_1 * diagonal_2‖1
def area_reg_polygon(sides: int, length: float) -> float:‖if not isinstance(sides, int) or sides < 3:‖1
if not isinstance(sides, int) or sides < 3:‖raise ValueError(‖1
raise ValueError(‖"""area_reg_polygon() only accepts integers greater than or \"‖1
"""area_reg_polygon() only accepts integers greater than or \"‖"equal to three as number of sides"""‖1
"equal to three as number of sides"""‖)‖1
)‖elif length < 0:‖1
elif length < 0:‖raise ValueError(‖1
raise ValueError(‖"""area_reg_polygon() only accepts non-negative values as \"‖1
"""area_reg_polygon() only accepts non-negative values as \"‖"length of a side"""‖1
"length of a side"""‖)‖1
)‖return (sides * length**2) / (4 * tan(pi / sides))‖1
return (sides * length**2) / (4 * tan(pi / sides))‖return (sides * length**2) / (4 * tan(pi / sides))‖1
"print(""[DEMO] Areas of various geometric shapes: \n"")"‖"print(f""Rectangle: {area_rectangle(10, 20) = }"")"‖1
"print(f""Rectangle: {area_rectangle(10, 20) = }"")"‖"print(f""Square: {area_square(10) = }"")"‖1
"print(f""Square: {area_square(10) = }"")"‖"print(f""Triangle: {area_triangle(10, 10) = }"")"‖1
"print(f""Triangle: {area_triangle(10, 10) = }"")"‖"print(f""Triangle: {area_triangle_three_sides(5, 12, 13) = }"")"‖1
"print(f""Triangle: {area_triangle_three_sides(5, 12, 13) = }"")"‖"print(f""Parallelogram: {area_parallelogram(10, 20) = }"")"‖1
"print(f""Parallelogram: {area_parallelogram(10, 20) = }"")"‖"print(f""Rhombus: {area_rhombus(10, 20) = }"")"‖1
"print(f""Rhombus: {area_rhombus(10, 20) = }"")"‖"print(f""Trapezium: {area_trapezium(10, 20, 30) = }"")"‖1
"print(f""Trapezium: {area_trapezium(10, 20, 30) = }"")"‖"print(f""Circle: {area_circle(20) = }"")"‖1
"print(f""Circle: {area_circle(20) = }"")"‖"print(f""Ellipse: {area_ellipse(10, 20) = }"")"‖1
"print(f""Ellipse: {area_ellipse(10, 20) = }"")"‖"print(""\nSurface Areas of various geometric shapes: \n"")"‖1
"print(""\nSurface Areas of various geometric shapes: \n"")"‖"print(f""Cube: {surface_area_cube(20) = }"")"‖1
"print(f""Cube: {surface_area_cube(20) = }"")"‖"print(f""Cuboid: {surface_area_cuboid(10, 20, 30) = }"")"‖1
"print(f""Cuboid: {surface_area_cuboid(10, 20, 30) = }"")"‖"print(f""Sphere: {surface_area_sphere(20) = }"")"‖1
"print(f""Sphere: {surface_area_sphere(20) = }"")"‖"print(f""Hemisphere: {surface_area_hemisphere(20) = }"")"‖1
"print(f""Hemisphere: {surface_area_hemisphere(20) = }"")"‖"print(f""Cone: {surface_area_cone(10, 20) = }"")"‖1
"print(f""Cone: {surface_area_cone(10, 20) = }"")"‖"print(f""Conical Frustum: {surface_area_conical_frustum(10, 20, 30) = }"")"‖1
"print(f""Conical Frustum: {surface_area_conical_frustum(10, 20, 30) = }"")"‖"print(f""Cylinder: {surface_area_cylinder(10, 20) = }"")"‖1
"print(f""Cylinder: {surface_area_cylinder(10, 20) = }"")"‖"print(f""Torus: {surface_area_torus(20, 10) = }"")"‖1
"print(f""Torus: {surface_area_torus(20, 10) = }"")"‖"print(f""Equilateral Triangle: {area_reg_polygon(3, 10) = }"")"‖1
"print(f""Equilateral Triangle: {area_reg_polygon(3, 10) = }"")"‖"print(f""Square: {area_reg_polygon(4, 10) = }"")"‖1
"print(f""Square: {area_reg_polygon(4, 10) = }"")"‖"print(f""Reqular Pentagon: {area_reg_polygon(5, 10) = }"")"‖1
class PolynomialRegression:‖"__slots__ = ""degree"", ""params"""‖1
def __init__(self, degree: int) -> None:‖if degree < 0:‖1
if degree < 0:‖"raise ValueError(""Polynomial degree must be non-negative"")"‖1
self.degree = degree‖self.params = None‖1
@staticmethod‖def _design_matrix(data: np.ndarray, degree: int) -> np.ndarray:‖1
def _design_matrix(data: np.ndarray, degree: int) -> np.ndarray:‖rows, *remaining = data.shape‖1
rows, *remaining = data.shape‖if remaining:‖1
if remaining:‖"raise ValueError(""Data must have dimensions N x 1"")"‖1
def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None:‖X = PolynomialRegression._design_matrix(x_train, self.degree)‖1
X = PolynomialRegression._design_matrix(x_train, self.degree)‖_, cols = X.shape‖1
_, cols = X.shape‖if np.linalg.matrix_rank(X) < cols:‖1
if np.linalg.matrix_rank(X) < cols:‖raise ArithmeticError(‖1
raise ArithmeticError(‖"""Design matrix is not full rank, can't compute coefficients"""‖1
"""Design matrix is not full rank, can't compute coefficients"""‖)‖1
def predict(self, data: np.ndarray) -> np.ndarray:‖if self.params is None:‖1
if self.params is None:‖"raise ArithmeticError(""Predictor hasn't been fit yet"")"‖1
def main() -> None:‖import seaborn as sns‖1
poly_reg = PolynomialRegression(degree=2)‖poly_reg.fit(mpg_data.weight, mpg_data.mpg)‖1
weight_sorted = np.sort(mpg_data.weight)‖predictions = poly_reg.predict(weight_sorted)‖1
"plt.scatter(mpg_data.weight, mpg_data.mpg, color=""gray"", alpha=0.5)"‖"plt.plot(weight_sorted, predictions, color=""red"", linewidth=3)"‖1
"plt.plot(weight_sorted, predictions, color=""red"", linewidth=3)"‖"plt.title(""Predicting Fuel Efficiency Using Polynomial Regression"")"‖1
"plt.title(""Predicting Fuel Efficiency Using Polynomial Regression"")"‖"plt.xlabel(""Weight (lbs)"")"‖1
"plt.xlabel(""Weight (lbs)"")"‖"plt.ylabel(""Fuel Efficiency (mpg)"")"‖1
"plt.ylabel(""Fuel Efficiency (mpg)"")"‖plt.show()‖1
from matplotlib import pyplot as plt‖from sklearn.datasets import load_iris‖1
from sklearn.datasets import load_iris‖from sklearn.metrics import ConfusionMatrixDisplay‖1
from sklearn.metrics import ConfusionMatrixDisplay‖from sklearn.model_selection import train_test_split‖1
from sklearn.model_selection import train_test_split‖from xgboost import XGBClassifier‖1
def xgboost(features: np.ndarray, target: np.ndarray) -> XGBClassifier:‖classifier = XGBClassifier()‖1
classifier = XGBClassifier()‖classifier.fit(features, target)‖1
classifier.fit(features, target)‖return classifier‖1
iris = load_iris()‖features, targets = data_handling(iris)‖1
features, targets = data_handling(iris)‖x_train, x_test, y_train, y_test = train_test_split(‖1
x_train, x_test, y_train, y_test = train_test_split(‖features, targets, test_size=0.25‖1
features, targets, test_size=0.25‖)‖1
ConfusionMatrixDisplay.from_estimator(‖xgboost_classifier,‖1
xgboost_classifier,‖x_test,‖1
x_test,‖y_test,‖1
y_test,‖display_labels=names,‖1
display_labels=names,‖"cmap=""Blues"","‖1
"cmap=""Blues"","‖"normalize=""true"","‖1
"normalize=""true"","‖)‖1
)‖"plt.title(""Normalized Confusion Matrix - IRIS Dataset"")"‖1
"plt.title(""Normalized Confusion Matrix - IRIS Dataset"")"‖plt.show()‖1
import pandas as pd‖from keras.layers import LSTM, Dense‖1
from keras.layers import LSTM, Dense‖from keras.models import Sequential‖1
from keras.models import Sequential‖from sklearn.preprocessing import MinMaxScaler‖1
"if __name__ == ""__main__"":"‖"sample_data = pd.read_csv(""sample_data.csv"", header=None)"‖1
"sample_data = pd.read_csv(""sample_data.csv"", header=None)"‖len_data = sample_data.shape[:1][0]‖1
actual_data = sample_data.iloc[:, 1:2]‖actual_data = actual_data.to_numpy().reshape(len_data, 1)‖1
actual_data = actual_data.to_numpy().reshape(len_data, 1)‖actual_data = MinMaxScaler().fit_transform(actual_data)‖1
actual_data = MinMaxScaler().fit_transform(actual_data)‖look_back = 10‖1
look_back = 10‖forward_days = 5‖1
forward_days = 5‖periods = 20‖1
periods = 20‖division = len_data - periods * look_back‖1
division = len_data - periods * look_back‖train_data = actual_data[:division]‖1
train_data = actual_data[:division]‖test_data = actual_data[division - look_back :]‖1
test_data = actual_data[division - look_back :]‖train_x, train_y = [], []‖1
train_x, train_y = [], []‖test_x, test_y = [], []‖1
for i in range(len(train_data) - forward_days - look_back + 1):‖train_x.append(train_data[i : i + look_back])‖1
train_x.append(train_data[i : i + look_back])‖train_y.append(train_data[i + look_back : i + look_back + forward_days])‖1
train_y.append(train_data[i + look_back : i + look_back + forward_days])‖for i in range(len(test_data) - forward_days - look_back + 1):‖1
for i in range(len(test_data) - forward_days - look_back + 1):‖test_x.append(test_data[i : i + look_back])‖1
test_x.append(test_data[i : i + look_back])‖test_y.append(test_data[i + look_back : i + look_back + forward_days])‖1
test_y.append(test_data[i + look_back : i + look_back + forward_days])‖x_train = np.array(train_x)‖1
x_train = np.array(train_x)‖x_test = np.array(test_x)‖1
x_test = np.array(test_x)‖y_train = np.array([list(i.ravel()) for i in train_y])‖1
y_train = np.array([list(i.ravel()) for i in train_y])‖y_test = np.array([list(i.ravel()) for i in test_y])‖1
model = Sequential()‖model.add(LSTM(128, input_shape=(look_back, 1), return_sequences=True))‖1
model.add(LSTM(128, input_shape=(look_back, 1), return_sequences=True))‖model.add(LSTM(64, input_shape=(128, 1)))‖1
model.add(LSTM(64, input_shape=(128, 1)))‖model.add(Dense(forward_days))‖1
model.add(Dense(forward_days))‖"model.compile(loss=""mean_squared_error"", optimizer=""adam"")"‖1
"model.compile(loss=""mean_squared_error"", optimizer=""adam"")"‖history = model.fit(‖1
history = model.fit(‖x_train, y_train, epochs=150, verbose=1, shuffle=True, batch_size=4‖1
x_train, y_train, epochs=150, verbose=1, shuffle=True, batch_size=4‖)‖1
)‖pred = model.predict(x_test)‖1
def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:‖if partitions <= 0:‖1
if partitions <= 0:‖"raise ValueError(""partitions must be a positive number!"")"‖1
"raise ValueError(""partitions must be a positive number!"")"‖if partitions > number_of_bytes:‖1
if partitions > number_of_bytes:‖"raise ValueError(""partitions can not > number_of_bytes!"")"‖1
"raise ValueError(""partitions can not > number_of_bytes!"")"‖bytes_per_partition = number_of_bytes // partitions‖1
bytes_per_partition = number_of_bytes // partitions‖allocation_list = []‖1
allocation_list = []‖for i in range(partitions):‖1
for i in range(partitions):‖start_bytes = i * bytes_per_partition + 1‖1
start_bytes = i * bytes_per_partition + 1‖end_bytes = (‖1
end_bytes = (‖number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition‖1
number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition‖)‖1
)‖"allocation_list.append(f""{start_bytes}-{end_bytes}"")"‖1
"allocation_list.append(f""{start_bytes}-{end_bytes}"")"‖return allocation_list‖1
import string‖from math import log10‖1
document_without_punctuation = document.translate(‖"str.maketrans("""", """", string.punctuation)"‖1
"str.maketrans("""", """", string.punctuation)"‖").replace(""\n"", """")"‖1
").replace(""\n"", """")"‖"tokenize_document = document_without_punctuation.split("" "")"‖1
"tokenize_document = document_without_punctuation.split("" "")"‖return len([word for word in tokenize_document if word.lower() == term.lower()])‖1
def document_frequency(term: str, corpus: str) -> tuple[int, int]:‖corpus_without_punctuation = corpus.lower().translate(‖1
corpus_without_punctuation = corpus.lower().translate(‖"str.maketrans("""", """", string.punctuation)"‖1
"str.maketrans("""", """", string.punctuation)"‖)‖1
)‖"docs = corpus_without_punctuation.split(""\n"")"‖1
"docs = corpus_without_punctuation.split(""\n"")"‖term = term.lower()‖1
term = term.lower()‖return (len([doc for doc in docs if term in doc]), len(docs))‖1
def inverse_document_frequency(df: int, n: int, smoothing=False) -> float:‖if smoothing:‖1
if smoothing:‖if n == 0:‖1
if n == 0:‖"raise ValueError(""log10(0) is undefined."")"‖1
"raise ValueError(""log10(0) is undefined."")"‖return round(1 + log10(n / (1 + df)), 3)‖1
if df == 0:‖"raise ZeroDivisionError(""df must be > 0"")"‖1
"raise ZeroDivisionError(""df must be > 0"")"‖elif n == 0:‖1
elif n == 0:‖"raise ValueError(""log10(0) is undefined."")"‖1
"raise ValueError(""log10(0) is undefined."")"‖return round(log10(n / df), 3)‖1
def tf_idf(tf: int, idf: int) -> float:‖return round(tf * idf, 3)‖1
def weight_matrix(point: np.ndarray, x_train: np.ndarray, tau: float) -> np.ndarray:‖m = len(x_train)‖1
m = len(x_train)‖weights = np.eye(m)‖1
weights = np.eye(m)‖for j in range(m):‖1
for j in range(m):‖diff = point - x_train[j]‖1
diff = point - x_train[j]‖weights[j, j] = np.exp(diff @ diff.T / (-2.0 * tau**2))‖1
def local_weight(‖point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float‖1
point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float‖) -> np.ndarray:‖1
) -> np.ndarray:‖weight_mat = weight_matrix(point, x_train, tau)‖1
weight_mat = weight_matrix(point, x_train, tau)‖weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (‖1
weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (‖x_train.T @ weight_mat @ y_train.T‖1
x_train.T @ weight_mat @ y_train.T‖)‖1
def local_weight_regression(‖x_train: np.ndarray, y_train: np.ndarray, tau: float‖1
x_train: np.ndarray, y_train: np.ndarray, tau: float‖) -> np.ndarray:‖1
) -> np.ndarray:‖y_pred = np.zeros(len(x_train))‖1
y_pred = np.zeros(len(x_train))‖for i, item in enumerate(x_train):‖1
for i, item in enumerate(x_train):‖y_pred[i] = np.dot(item, local_weight(item, x_train, y_train, tau)).item()‖1
def load_data(‖dataset_name: str, x_name: str, y_name: str‖1
dataset_name: str, x_name: str, y_name: str‖) -> tuple[np.ndarray, np.ndarray, np.ndarray]:‖1
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:‖import seaborn as sns‖1
data = sns.load_dataset(dataset_name)‖x_data = np.array(data[x_name])‖1
x_data = np.array(data[x_name])‖y_data = np.array(data[y_name])‖1
def plot_preds(‖x_train: np.ndarray,‖1
x_train: np.ndarray,‖preds: np.ndarray,‖1
preds: np.ndarray,‖x_data: np.ndarray,‖1
x_data: np.ndarray,‖y_data: np.ndarray,‖1
y_data: np.ndarray,‖x_name: str,‖1
x_name: str,‖y_name: str,‖1
y_name: str,‖) -> None:‖1
) -> None:‖x_train_sorted = np.sort(x_train, axis=0)‖1
x_train_sorted = np.sort(x_train, axis=0)‖"plt.scatter(x_data, y_data, color=""blue"")"‖1
"plt.scatter(x_data, y_data, color=""blue"")"‖plt.plot(‖1
plt.plot(‖x_train_sorted[:, 1],‖1
x_train_sorted[:, 1],‖preds[x_train[:, 1].argsort(0)],‖1
preds[x_train[:, 1].argsort(0)],‖"color=""yellow"","‖1
"color=""yellow"","‖linewidth=5,‖1
linewidth=5,‖)‖1
)‖"plt.title(""Local Weighted Regression"")"‖1
"plt.title(""Local Weighted Regression"")"‖plt.xlabel(x_name)‖1
plt.xlabel(x_name)‖plt.ylabel(y_name)‖1
plt.ylabel(y_name)‖plt.show()‖1
"training_data_x, total_bill, tip = load_data(""tips"", ""total_bill"", ""tip"")"‖predictions = local_weight_regression(training_data_x, tip, 5)‖1
predictions = local_weight_regression(training_data_x, tip, 5)‖"plot_preds(training_data_x, predictions, total_bill, tip, ""total_bill"", ""tip"")"‖1
sorted_list: list[int] = sorted(nums)‖length = len(sorted_list)‖1
length = len(sorted_list)‖mid_index = length >> 1‖1
mid_index = length >> 1‖return (‖1
return (‖(sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2‖1
(sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2‖if length % 2 == 0‖1
if length % 2 == 0‖else sorted_list[mid_index]‖1
else sorted_list[mid_index]‖)‖1
def main():‖import doctest‖2
def mae(predict, actual):‖predict = np.array(predict)‖1
predict = np.array(predict)‖actual = np.array(actual)‖5
difference = abs(predict - actual)‖score = difference.mean()‖1
def mse(predict, actual):‖predict = np.array(predict)‖1
difference = predict - actual‖square_diff = np.square(difference)‖2
score = square_diff.mean()‖return score‖1
def rmse(predict, actual):‖predict = np.array(predict)‖1
square_diff = np.square(difference)‖mean_square_diff = square_diff.mean()‖2
mean_square_diff = square_diff.mean()‖score = np.sqrt(mean_square_diff)‖1
score = np.sqrt(mean_square_diff)‖return score‖1
def rmsle(predict, actual):‖predict = np.array(predict)‖1
log_predict = np.log(predict + 1)‖log_actual = np.log(actual + 1)‖1
difference = log_predict - log_actual‖square_diff = np.square(difference)‖1
def mbd(predict, actual):‖predict = np.array(predict)‖1
difference = predict - actual‖numerator = np.sum(difference) / len(predict)‖1
numerator = np.sum(difference) / len(predict)‖denumerator = np.sum(actual) / len(predict)‖1
def manual_accuracy(predict, actual):‖return np.mean(np.array(actual) == np.array(predict))‖1
def add(first: int, second: int) -> int:‖while second != 0:‖1
while second != 0:‖c = first & second‖1
c = first & second‖first ^= second‖1
first ^= second‖second = c << 1‖1
second = c << 1‖return first‖1
"first = int(input(""Enter the first number: "").strip())"‖"second = int(input(""Enter the second number: "").strip())"‖1
"second = int(input(""Enter the second number: "").strip())"‖"print(f""{add(first, second) = }"")"‖1
def abs_val(num: float) -> float:‖return -num if num < 0 else num‖1
def abs_min(x: list[int]) -> int:‖if len(x) == 0:‖1
if len(x) == 0:‖"raise ValueError(""abs_min() arg is an empty sequence"")"‖1
"raise ValueError(""abs_min() arg is an empty sequence"")"‖j = x[0]‖1
j = x[0]‖for i in x:‖2
for i in x:‖if abs_val(i) < abs_val(j):‖1
if abs_val(i) < abs_val(j):‖j = i‖1
j = i‖return j‖2
def abs_max(x: list[int]) -> int:‖if len(x) == 0:‖1
if len(x) == 0:‖"raise ValueError(""abs_max() arg is an empty sequence"")"‖1
"raise ValueError(""abs_max() arg is an empty sequence"")"‖j = x[0]‖1
for i in x:‖if abs(i) > abs(j):‖1
if abs(i) > abs(j):‖j = i‖1
def abs_max_sort(x: list[int]) -> int:‖if len(x) == 0:‖1
if len(x) == 0:‖"raise ValueError(""abs_max_sort() arg is an empty sequence"")"‖1
"raise ValueError(""abs_max_sort() arg is an empty sequence"")"‖return sorted(x, key=abs)[-1]‖1
def test_abs_val():‖assert abs_val(0) == 0‖1
assert abs_val(0) == 0‖assert abs_val(34) == 34‖1
assert abs_val(34) == 34‖assert abs_val(-100000000000) == 100000000000‖1
a = [-3, -1, 2, -11]‖assert abs_max(a) == -11‖1
assert abs_max(a) == -11‖assert abs_max_sort(a) == -11‖1
assert abs_max_sort(a) == -11‖assert abs_min(a) == -1‖1
test_abs_val()‖print(abs_val(-34))‖1
def arc_length(angle: int, radius: int) -> float:‖return 2 * pi * radius * (angle / 360)‖1
"if __name__ == ""__main__"":"‖print(arc_length(90, 10))‖1
def trapezoidal_area(‖fnc: Callable[[float], float],‖2
fnc: Callable[[float], float],‖x_start: float,‖3
x_start: float,‖x_end: float,‖3
x_end: float,‖steps: int = 100,‖3
steps: int = 100,‖) -> float:‖3
) -> float:‖x1 = x_start‖2
x1 = x_start‖fx1 = fnc(x_start)‖3
fx1 = fnc(x_start)‖area = 0.0‖2
area = 0.0‖for _ in range(steps):‖1
x2 = (x_end - x_start) / steps + x1‖fx2 = fnc(x2)‖3
fx2 = fnc(x2)‖area += abs(fx2 + fx1) * (x2 - x1) / 2‖2
x1 = x2‖fx1 = fx2‖3
fx1 = fx2‖return area‖2
def f(x):‖return x**3 + x**2‖1
"print(""f(x) = x^3 + x^2"")"‖"print(""The area between the curve, x = -5, x = 5 and the x axis is:"")"‖1
"print(""The area between the curve, x = -5, x = 5 and the x axis is:"")"‖i = 10‖1
i = 10‖while i <= 100000:‖3
while i <= 100000:‖"print(f""with {i} steps: {trapezoidal_area(f, -5, 5, i)}"")"‖1
"print(f""with {i} steps: {trapezoidal_area(f, -5, 5, i)}"")"‖i *= 10‖1
def aliquot_sum(input_num: int) -> int:‖if not isinstance(input_num, int):‖1
if not isinstance(input_num, int):‖"raise ValueError(""Input must be an integer"")"‖1
"raise ValueError(""Input must be an integer"")"‖if input_num <= 0:‖1
if input_num <= 0:‖"raise ValueError(""Input must be positive"")"‖1
"raise ValueError(""Input must be positive"")"‖return sum(‖1
return sum(‖divisor for divisor in range(1, input_num // 2 + 1) if input_num % divisor == 0‖1
divisor for divisor in range(1, input_num // 2 + 1) if input_num % divisor == 0‖)‖1
def prime_factors(n: int) -> list:‖if n <= 0:‖1
if n <= 0:‖"raise ValueError(""Only positive integers have prime factors"")"‖1
"raise ValueError(""Only positive integers have prime factors"")"‖pf = []‖1
pf = []‖while n % 2 == 0:‖1
while n % 2 == 0:‖pf.append(2)‖1
pf.append(2)‖n = int(n / 2)‖1
n = int(n / 2)‖for i in range(3, int(math.sqrt(n)) + 1, 2):‖1
for i in range(3, int(math.sqrt(n)) + 1, 2):‖while n % i == 0:‖1
while n % i == 0:‖pf.append(i)‖1
pf.append(i)‖n = int(n / i)‖1
n = int(n / i)‖if n > 2:‖1
if n > 2:‖pf.append(n)‖1
pf.append(n)‖return pf‖1
def number_of_divisors(n: int) -> int:‖if n <= 0:‖1
if n <= 0:‖"raise ValueError(""Only positive numbers are accepted"")"‖3
"raise ValueError(""Only positive numbers are accepted"")"‖div = 1‖1
div = 1‖temp = 1‖1
temp = 1‖while n % 2 == 0:‖2
while n % 2 == 0:‖temp += 1‖2
temp += 1‖n = int(n / 2)‖2
n = int(n / 2)‖div *= temp‖1
div *= temp‖for i in range(3, int(math.sqrt(n)) + 1, 2):‖1
for i in range(3, int(math.sqrt(n)) + 1, 2):‖temp = 1‖2
temp = 1‖while n % i == 0:‖2
while n % i == 0:‖temp += 1‖2
temp += 1‖n = int(n / i)‖2
n = int(n / i)‖div *= temp‖1
div *= temp‖if n > 1:‖1
if n > 1:‖div *= 2‖1
div *= 2‖return div‖1
def sum_of_divisors(n: int) -> int:‖if n <= 0:‖1
"raise ValueError(""Only positive numbers are accepted"")"‖s = 1‖1
s = 1‖temp = 1‖1
n = int(n / 2)‖if temp > 1:‖1
if temp > 1:‖s *= (2**temp - 1) / (2 - 1)‖1
s *= (2**temp - 1) / (2 - 1)‖for i in range(3, int(math.sqrt(n)) + 1, 2):‖1
n = int(n / i)‖if temp > 1:‖1
if temp > 1:‖s *= (i**temp - 1) / (i - 1)‖1
s *= (i**temp - 1) / (i - 1)‖return int(s)‖1
def euler_phi(n: int) -> int:‖if n <= 0:‖1
"raise ValueError(""Only positive numbers are accepted"")"‖s = n‖1
s = n‖for x in set(prime_factors(n)):‖1
for x in set(prime_factors(n)):‖s *= (x - 1) / x‖1
s *= (x - 1) / x‖return int(s)‖1
def mode(input_list: list) -> list[Any]:‖if not input_list:‖1
if not input_list:‖return []‖1
return []‖result = [input_list.count(value) for value in input_list]‖1
result = [input_list.count(value) for value in input_list]‖y = max(result)‖1
def average_absolute_deviation(nums: list[int]) -> float:‖if not nums:‖1
if not nums:‖"raise ValueError(""List is empty"")"‖2
average = sum(nums) / len(nums)‖return sum(abs(x - average) for x in nums) / len(nums)‖1
if successes > trials:‖"raise ValueError(""""""successes must be lower or equal to trials"""""")"‖1
"raise ValueError(""""""successes must be lower or equal to trials"""""")"‖if trials < 0 or successes < 0:‖1
if trials < 0 or successes < 0:‖"raise ValueError(""the function is defined for non-negative integers"")"‖1
"raise ValueError(""the function is defined for non-negative integers"")"‖if not isinstance(successes, int) or not isinstance(trials, int):‖1
if not isinstance(successes, int) or not isinstance(trials, int):‖"raise ValueError(""the function is defined for non-negative integers"")"‖1
"raise ValueError(""the function is defined for non-negative integers"")"‖if not 0 < prob < 1:‖1
if not 0 < prob < 1:‖"raise ValueError(""prob has to be in range of 1 - 0"")"‖1
"raise ValueError(""prob has to be in range of 1 - 0"")"‖probability = (prob**successes) * ((1 - prob) ** (trials - successes))‖1
coefficient = float(factorial(trials))‖coefficient /= factorial(successes) * factorial(trials - successes)‖1
coefficient /= factorial(successes) * factorial(trials - successes)‖return probability * coefficient‖1
testmod()‖"print(""Probability of 2 successes out of 4 trails"")"‖1
"print(""Probability of 2 successes out of 4 trails"")"‖"print(""with probability of 0.75 is:"", end="" "")"‖1
"print(""with probability of 0.75 is:"", end="" "")"‖print(binomial_distribution(2, 4, 0.75))‖1
def binary_exp_recursive(base: float, exponent: int) -> float:‖if exponent < 0:‖1
if exponent < 0:‖"raise ValueError(""Exponent must be a non-negative integer"")"‖4
if exponent == 0:‖return 1‖2
if exponent % 2 == 1:‖return binary_exp_recursive(base, exponent - 1) * base‖1
b = binary_exp_recursive(base, exponent // 2)‖return b * b‖1
def binary_exp_iterative(base: float, exponent: int) -> float:‖if exponent < 0:‖1
res: int | float = 1‖while exponent > 0:‖2
while exponent > 0:‖if exponent & 1:‖2
if exponent & 1:‖res *= base‖1
base *= base‖exponent >>= 1‖2
def binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:‖if exponent < 0:‖1
"raise ValueError(""Exponent must be a non-negative integer"")"‖if modulus <= 0:‖2
if modulus <= 0:‖"raise ValueError(""Modulus must be a positive integer"")"‖2
if exponent % 2 == 1:‖return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus‖1
r = binary_exp_mod_recursive(base, exponent // 2, modulus)‖return (r * r) % modulus‖1
def binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:‖if exponent < 0:‖1
if exponent & 1:‖res = ((res % modulus) * (base % modulus)) % modulus‖1
"if __name__ == ""__main__"":"‖from timeit import timeit‖1
a = 1269380576‖b = 374‖1
b = 374‖c = 34‖1
runs = 100_000‖print(‖1
print(‖timeit(‖6
timeit(‖"f""binary_exp_recursive({a}, {b})"","‖1
"f""binary_exp_recursive({a}, {b})"","‖"setup=""from __main__ import binary_exp_recursive"","‖1
"setup=""from __main__ import binary_exp_recursive"","‖number=runs,‖1
number=runs,‖)‖4
timeit(‖"f""binary_exp_iterative({a}, {b})"","‖1
"f""binary_exp_iterative({a}, {b})"","‖"setup=""from __main__ import binary_exp_iterative"","‖1
"setup=""from __main__ import binary_exp_iterative"","‖number=runs,‖1
timeit(‖"f""binary_exp_mod_recursive({a}, {b}, {c})"","‖1
"f""binary_exp_mod_recursive({a}, {b}, {c})"","‖"setup=""from __main__ import binary_exp_mod_recursive"","‖1
"setup=""from __main__ import binary_exp_mod_recursive"","‖number=runs,‖1
timeit(‖"f""binary_exp_mod_iterative({a}, {b}, {c})"","‖1
"f""binary_exp_mod_iterative({a}, {b}, {c})"","‖"setup=""from __main__ import binary_exp_mod_iterative"","‖1
"setup=""from __main__ import binary_exp_mod_iterative"","‖number=runs,‖1
def decimal_to_negative_base_2(num: int) -> int:‖if num == 0:‖1
if num == 0:‖return 0‖1
return 0‖"ans = """""‖1
"ans = """""‖while num != 0:‖1
while num != 0:‖num, rem = divmod(num, -2)‖1
num, rem = divmod(num, -2)‖if rem < 0:‖1
if rem < 0:‖rem += 2‖1
rem += 2‖num += 1‖1
num += 1‖ans = str(rem) + ans‖1
ans = str(rem) + ans‖return int(ans)‖1
def bailey_borwein_plouffe(digit_position: int, precision: int = 1000) -> str:‖if (not isinstance(digit_position, int)) or (digit_position <= 0):‖1
if (not isinstance(digit_position, int)) or (digit_position <= 0):‖"raise ValueError(""Digit position must be a positive integer"")"‖1
"raise ValueError(""Digit position must be a positive integer"")"‖elif (not isinstance(precision, int)) or (precision < 0):‖1
elif (not isinstance(precision, int)) or (precision < 0):‖"raise ValueError(""Precision must be a nonnegative integer"")"‖1
sum_result = (‖4 * _subsum(digit_position, 1, precision)‖1
4 * _subsum(digit_position, 1, precision)‖- 2 * _subsum(digit_position, 4, precision)‖1
- 2 * _subsum(digit_position, 4, precision)‖- _subsum(digit_position, 5, precision)‖1
- _subsum(digit_position, 5, precision)‖- _subsum(digit_position, 6, precision)‖1
- _subsum(digit_position, 6, precision)‖)‖1
def _subsum(‖digit_pos_to_extract: int, denominator_addend: int, precision: int‖1
digit_pos_to_extract: int, denominator_addend: int, precision: int‖) -> float:‖1
total = 0.0‖for sum_index in range(digit_pos_to_extract + precision):‖1
for sum_index in range(digit_pos_to_extract + precision):‖denominator = 8 * sum_index + denominator_addend‖1
denominator = 8 * sum_index + denominator_addend‖if sum_index < digit_pos_to_extract:‖1
exponential_term = pow(‖16, digit_pos_to_extract - 1 - sum_index, denominator‖1
16, digit_pos_to_extract - 1 - sum_index, denominator‖)‖1
else:‖exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)‖1
exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)‖total += exponential_term / denominator‖1
total += exponential_term / denominator‖return total‖1
from decimal import Decimal, getcontext‖from math import ceil, factorial‖1
if not isinstance(precision, int):‖"raise TypeError(""Undefined for non-integers"")"‖1
"raise TypeError(""Undefined for non-integers"")"‖elif precision < 1:‖1
elif precision < 1:‖"raise ValueError(""Undefined for non-natural numbers"")"‖1
getcontext().prec = precision‖num_iterations = ceil(precision / 14)‖1
num_iterations = ceil(precision / 14)‖constant_term = 426880 * Decimal(10005).sqrt()‖1
constant_term = 426880 * Decimal(10005).sqrt()‖exponential_term = 1‖1
exponential_term = 1‖linear_term = 13591409‖1
linear_term = 13591409‖partial_sum = Decimal(linear_term)‖1
partial_sum = Decimal(linear_term)‖for k in range(1, num_iterations):‖1
for k in range(1, num_iterations):‖multinomial_term = factorial(6 * k) // (factorial(3 * k) * factorial(k) ** 3)‖1
multinomial_term = factorial(6 * k) // (factorial(3 * k) * factorial(k) ** 3)‖linear_term += 545140134‖1
linear_term += 545140134‖exponential_term *= -262537412640768000‖1
exponential_term *= -262537412640768000‖partial_sum += Decimal(multinomial_term * linear_term) / exponential_term‖1
partial_sum += Decimal(multinomial_term * linear_term) / exponential_term‖return str(constant_term / partial_sum)[:-1]‖1
"if __name__ == ""__main__"":"‖n = 50‖1
n = 50‖"print(f""The first {n} digits of pi is: {pi(n)}"")"‖1
def collatz_sequence(n: int) -> Generator[int]:‖if not isinstance(n, int) or n < 1:‖1
if not isinstance(n, int) or n < 1:‖"raise Exception(""Sequence only defined for positive integers"")"‖1
yield n‖while n != 1:‖1
while n != 1:‖if n % 2 == 0:‖1
if n % 2 == 0:‖n //= 2‖1
n //= 2‖else:‖1
else:‖n = 3 * n + 1‖1
n = 3 * n + 1‖yield n‖1
def main():‖"n = int(input(""Your number: ""))"‖1
"n = int(input(""Your number: ""))"‖sequence = tuple(collatz_sequence(n))‖1
sequence = tuple(collatz_sequence(n))‖print(sequence)‖1
print(sequence)‖"print(f""Collatz sequence from {n} took {len(sequence)} steps."")"‖1
def mean(nums: list) -> float:‖if not nums:‖1
"raise ValueError(""List is empty"")"‖return sum(nums) / len(nums)‖1
def extended_euclid(a: int, b: int) -> tuple[int, int]:‖if b == 0:‖2
if b == 0:‖return (1, 0)‖2
return (1, 0)‖(x, y) = extended_euclid(b, a % b)‖2
(x, y) = extended_euclid(b, a % b)‖k = a // b‖2
k = a // b‖return (y, x - k * y)‖2
def chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:‖(x, y) = extended_euclid(n1, n2)‖1
(x, y) = extended_euclid(n1, n2)‖m = n1 * n2‖1
m = n1 * n2‖n = r2 * x * n1 + r1 * y * n2‖2
n = r2 * x * n1 + r1 * y * n2‖return (n % m + m) % m‖2
def invert_modulo(a: int, n: int) -> int:‖(b, x) = extended_euclid(a, n)‖2
(b, x) = extended_euclid(a, n)‖if b < 0:‖2
if b < 0:‖b = (b % n + n) % n‖2
b = (b % n + n) % n‖return b‖2
def chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:‖x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)‖1
x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)‖m = n1 * n2‖1
"testmod(name=""chinese_remainder_theorem"", verbose=True)"‖"testmod(name=""chinese_remainder_theorem2"", verbose=True)"‖1
"testmod(name=""chinese_remainder_theorem2"", verbose=True)"‖"testmod(name=""invert_modulo"", verbose=True)"‖1
"testmod(name=""invert_modulo"", verbose=True)"‖"testmod(name=""extended_euclid"", verbose=True)"‖1
def binomial_coefficient(n: int, r: int) -> int:‖if n < 0 or r < 0:‖1
if n < 0 or r < 0:‖"raise ValueError(""n and r must be non-negative integers"")"‖1
"raise ValueError(""n and r must be non-negative integers"")"‖if 0 in (n, r):‖1
if 0 in (n, r):‖return 1‖1
return 1‖c = [0 for i in range(r + 1)]‖1
c[0] = 1‖for i in range(1, n + 1):‖1
j = min(i, r)‖while j > 0:‖1
while j > 0:‖c[j] += c[j - 1]‖1
c[j] += c[j - 1]‖j -= 1‖1
j -= 1‖return c[r]‖1
testmod()‖print(binomial_coefficient(n=10, r=5))‖1
def decimal_to_fraction(decimal: float | str) -> tuple[int, int]:‖try:‖1
try:‖decimal = float(decimal)‖1
decimal = float(decimal)‖except ValueError:‖1
except ValueError:‖"raise ValueError(""Please enter a valid number"")"‖1
"raise ValueError(""Please enter a valid number"")"‖fractional_part = decimal - int(decimal)‖1
fractional_part = decimal - int(decimal)‖if fractional_part == 0:‖1
if fractional_part == 0:‖return int(decimal), 1‖1
return int(decimal), 1‖else:‖1
else:‖"number_of_frac_digits = len(str(decimal).split(""."")[1])"‖1
"number_of_frac_digits = len(str(decimal).split(""."")[1])"‖numerator = int(decimal * (10**number_of_frac_digits))‖1
numerator = int(decimal * (10**number_of_frac_digits))‖denominator = 10**number_of_frac_digits‖1
denominator = 10**number_of_frac_digits‖divisor, dividend = denominator, numerator‖1
divisor, dividend = denominator, numerator‖while True:‖1
while True:‖remainder = dividend % divisor‖1
remainder = dividend % divisor‖if remainder == 0:‖1
if remainder == 0:‖break‖1
break‖dividend, divisor = divisor, remainder‖1
dividend, divisor = divisor, remainder‖numerator, denominator = numerator / divisor, denominator / divisor‖1
numerator, denominator = numerator / divisor, denominator / divisor‖return int(numerator), int(denominator)‖1
"if __name__ == ""__main__"":"‖"print(f""{decimal_to_fraction(2) = }"")"‖1
"print(f""{decimal_to_fraction(2) = }"")"‖"print(f""{decimal_to_fraction(89.0) = }"")"‖1
"print(f""{decimal_to_fraction(89.0) = }"")"‖"print(f""{decimal_to_fraction('67') = }"")"‖1
"print(f""{decimal_to_fraction('67') = }"")"‖"print(f""{decimal_to_fraction('45.0') = }"")"‖1
"print(f""{decimal_to_fraction('45.0') = }"")"‖"print(f""{decimal_to_fraction(1.5) = }"")"‖1
"print(f""{decimal_to_fraction(1.5) = }"")"‖"print(f""{decimal_to_fraction('6.25') = }"")"‖1
"print(f""{decimal_to_fraction('6.25') = }"")"‖"print(f""{decimal_to_fraction('78td') = }"")"‖1
from fractions import Fraction‖from math import floor‖1
def continued_fraction(num: Fraction) -> list[int]:‖numerator, denominator = num.as_integer_ratio()‖1
numerator, denominator = num.as_integer_ratio()‖continued_fraction_list: list[int] = []‖1
continued_fraction_list: list[int] = []‖while True:‖1
while True:‖integer_part = floor(numerator / denominator)‖1
integer_part = floor(numerator / denominator)‖continued_fraction_list.append(integer_part)‖1
continued_fraction_list.append(integer_part)‖numerator -= integer_part * denominator‖1
numerator -= integer_part * denominator‖if numerator == 0:‖1
if numerator == 0:‖break‖1
break‖numerator, denominator = denominator, numerator‖1
def binary_multiply(a: int, b: int) -> int:‖res = 0‖1
res = 0‖while b > 0:‖2
while b > 0:‖if b & 1:‖3
if b & 1:‖res += a‖1
a += a‖b >>= 1‖2
def binary_mod_multiply(a: int, b: int, modulus: int) -> int:‖res = 0‖1
if b & 1:‖res = ((res % modulus) + (a % modulus)) % modulus‖1
def check_polygon(nums: list[float]) -> bool:‖if len(nums) < 2:‖1
if len(nums) < 2:‖"raise ValueError(""Monogons and Digons are not polygons in the Euclidean space"")"‖1
"raise ValueError(""Monogons and Digons are not polygons in the Euclidean space"")"‖if any(i <= 0 for i in nums):‖1
if any(i <= 0 for i in nums):‖"raise ValueError(""All values must be greater than 0"")"‖1
"raise ValueError(""All values must be greater than 0"")"‖copy_nums = nums.copy()‖1
copy_nums = nums.copy()‖copy_nums.sort()‖1
copy_nums.sort()‖return copy_nums[-1] < sum(copy_nums[:-1])‖1
def chebyshev_distance(point_a: list[float], point_b: list[float]) -> float:‖if len(point_a) != len(point_b):‖1
if len(point_a) != len(point_b):‖"raise ValueError(""Both points must have the same dimension."")"‖2
import math‖from collections import Counter‖1
from collections import Counter‖from string import ascii_lowercase‖1
def calculate_prob(text: str) -> None:‖single_char_strings, two_char_strings = analyze_text(text)‖1
single_char_strings, two_char_strings = analyze_text(text)‖"my_alphas = list("" "" + ascii_lowercase)"‖1
for ch in my_alphas:‖if ch in single_char_strings:‖1
if ch in single_char_strings:‖my_str = single_char_strings[ch]‖1
my_str = single_char_strings[ch]‖prob = my_str / all_sum‖1
prob = my_str / all_sum‖my_fir_sum += prob * math.log2(prob)‖1
all_sum = sum(two_char_strings.values())‖my_sec_sum = 0‖1
for ch0 in my_alphas:‖for ch1 in my_alphas:‖1
for ch1 in my_alphas:‖sequence = ch0 + ch1‖1
sequence = ch0 + ch1‖if sequence in two_char_strings:‖1
if sequence in two_char_strings:‖my_str = two_char_strings[sequence]‖1
my_str = two_char_strings[sequence]‖prob = int(my_str) / all_sum‖1
prob = int(my_str) / all_sum‖my_sec_sum += prob * math.log2(prob)‖1
def analyze_text(text: str) -> tuple[dict, dict]:‖single_char_strings = Counter()‖1
single_char_strings = Counter()‖two_char_strings = Counter()‖1
two_char_strings = Counter()‖single_char_strings[text[-1]] += 1‖1
"two_char_strings["" "" + text[0]] += 1"‖for i in range(len(text) - 1):‖1
for i in range(len(text) - 1):‖single_char_strings[text[i]] += 1‖1
single_char_strings[text[i]] += 1‖two_char_strings[text[i : i + 2]] += 1‖1
two_char_strings[text[i : i + 2]] += 1‖return single_char_strings, two_char_strings‖1
if n < k or k < 0:‖"raise ValueError(""Please enter positive integers for n and k where n >= k"")"‖1
"raise ValueError(""Please enter positive integers for n and k where n >= k"")"‖res = 1‖1
res = 1‖for i in range(k):‖1
for i in range(k):‖res *= n - i‖1
res *= n - i‖res //= i + 1‖1
res //= i + 1‖return res‖1
print(‖"""The number of five-card hands possible from a standard"","‖1
"""The number of five-card hands possible from a standard"","‖"f""fifty-two card deck is: {combinations(52, 5)}\n"","‖1
"f""fifty-two card deck is: {combinations(52, 5)}\n"","‖)‖1
print(‖"""If a class of 40 students must be arranged into groups of"","‖1
"""If a class of 40 students must be arranged into groups of"","‖"f""4 for group projects, there are {combinations(40, 4)} ways"","‖1
"f""4 for group projects, there are {combinations(40, 4)} ways"","‖"""to arrange them.\n"","‖1
"""to arrange them.\n"","‖)‖1
print(‖"""If 10 teams are competing in a Formula One race, there"","‖1
"""If 10 teams are competing in a Formula One race, there"","‖"f""are {combinations(10, 3)} ways that first, second and"","‖1
"f""are {combinations(10, 3)} ways that first, second and"","‖"""third place can be awarded."","‖1
"""third place can be awarded."","‖)‖1
import typing‖from collections.abc import Iterable‖1
Vector = typing.Union[Iterable[float], Iterable[int], np.ndarray]‖VectorOut = typing.Union[np.float64, int, float]‖1
def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:‖return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))‖1
def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:‖return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)‖1
def benchmark() -> None:‖from timeit import timeit‖3
"print(""Without Numpy"")"‖print(‖1
timeit(‖"""euclidean_distance_no_np([1, 2, 3], [4, 5, 6])"","‖1
"""euclidean_distance_no_np([1, 2, 3], [4, 5, 6])"","‖number=10000,‖1
number=10000,‖globals=globals(),‖2
globals=globals(),‖)‖2
)‖"print(""With Numpy"")"‖1
"print(""With Numpy"")"‖print(‖1
timeit(‖"""euclidean_distance([1, 2, 3], [4, 5, 6])"","‖1
"""euclidean_distance([1, 2, 3], [4, 5, 6])"","‖number=10000,‖1
class Dual:‖def __init__(self, real, rank):‖1
def __init__(self, real, rank):‖self.real = real‖1
self.real = real‖if isinstance(rank, int):‖1
if isinstance(rank, int):‖self.duals = [1] * rank‖1
self.duals = [1] * rank‖else:‖1
else:‖self.duals = rank‖1
def __repr__(self):‖"s = ""+"".join(f""{dual}E{n}"" for n, dual in enumerate(self.duals, 1))"‖1
"s = ""+"".join(f""{dual}E{n}"" for n, dual in enumerate(self.duals, 1))"‖"return f""{self.real}+{s}"""‖1
def reduce(self):‖cur = self.duals.copy()‖1
cur = self.duals.copy()‖while cur[-1] == 0:‖1
while cur[-1] == 0:‖cur.pop(-1)‖1
cur.pop(-1)‖return Dual(self.real, cur)‖1
def __add__(self, other):‖if not isinstance(other, Dual):‖1
if not isinstance(other, Dual):‖return Dual(self.real + other, self.duals)‖1
return Dual(self.real + other, self.duals)‖s_dual = self.duals.copy()‖1
s_dual = self.duals.copy()‖o_dual = other.duals.copy()‖1
o_dual = other.duals.copy()‖if len(s_dual) > len(o_dual):‖1
if len(s_dual) > len(o_dual):‖o_dual.extend([1] * (len(s_dual) - len(o_dual)))‖1
o_dual.extend([1] * (len(s_dual) - len(o_dual)))‖elif len(s_dual) < len(o_dual):‖1
elif len(s_dual) < len(o_dual):‖s_dual.extend([1] * (len(o_dual) - len(s_dual)))‖1
s_dual.extend([1] * (len(o_dual) - len(s_dual)))‖new_duals = []‖1
new_duals = []‖for i in range(len(s_dual)):‖1
for i in range(len(s_dual)):‖new_duals.append(s_dual[i] + o_dual[i])‖1
new_duals.append(s_dual[i] + o_dual[i])‖return Dual(self.real + other.real, new_duals)‖1
def __sub__(self, other):‖return self + other * -1‖1
def __mul__(self, other):‖if not isinstance(other, Dual):‖1
if not isinstance(other, Dual):‖new_duals = []‖3
new_duals = []‖for i in self.duals:‖3
for i in self.duals:‖new_duals.append(i * other)‖1
new_duals.append(i * other)‖return Dual(self.real * other, new_duals)‖1
return Dual(self.real * other, new_duals)‖new_duals = [0] * (len(self.duals) + len(other.duals) + 1)‖1
new_duals = [0] * (len(self.duals) + len(other.duals) + 1)‖for i, item in enumerate(self.duals):‖1
for i, item in enumerate(self.duals):‖for j, jtem in enumerate(other.duals):‖1
for j, jtem in enumerate(other.duals):‖new_duals[i + j + 1] += item * jtem‖1
new_duals[i + j + 1] += item * jtem‖for k in range(len(self.duals)):‖1
for k in range(len(self.duals)):‖new_duals[k] += self.duals[k] * other.real‖1
new_duals[k] += self.duals[k] * other.real‖for index in range(len(other.duals)):‖1
for index in range(len(other.duals)):‖new_duals[index] += other.duals[index] * self.real‖1
new_duals[index] += other.duals[index] * self.real‖return Dual(self.real * other.real, new_duals)‖1
def __truediv__(self, other):‖if not isinstance(other, Dual):‖1
for i in self.duals:‖new_duals.append(i / other)‖1
new_duals.append(i / other)‖return Dual(self.real / other, new_duals)‖1
return Dual(self.real / other, new_duals)‖raise ValueError‖1
def __floordiv__(self, other):‖if not isinstance(other, Dual):‖1
for i in self.duals:‖new_duals.append(i // other)‖1
new_duals.append(i // other)‖return Dual(self.real // other, new_duals)‖1
return Dual(self.real // other, new_duals)‖raise ValueError‖1
def __pow__(self, n):‖if n < 0 or isinstance(n, float):‖1
if n < 0 or isinstance(n, float):‖"raise ValueError(""power must be a positive integer"")"‖1
"raise ValueError(""power must be a positive integer"")"‖if n == 0:‖1
if n == 0:‖return 1‖2
return 1‖if n == 1:‖1
if n == 1:‖return self‖1
return self‖x = self‖1
x = self‖for _ in range(n - 1):‖1
for _ in range(n - 1):‖x *= self‖1
x *= self‖return x‖1
def differentiate(func, position, order):‖if not callable(func):‖1
if not callable(func):‖"raise ValueError(""differentiate() requires a function as input for func"")"‖1
"raise ValueError(""differentiate() requires a function as input for func"")"‖if not isinstance(position, (float, int)):‖1
if not isinstance(position, (float, int)):‖"raise ValueError(""differentiate() requires a float as input for position"")"‖1
"raise ValueError(""differentiate() requires a float as input for position"")"‖if not isinstance(order, int):‖1
if not isinstance(order, int):‖"raise ValueError(""differentiate() requires an int as input for order"")"‖1
"raise ValueError(""differentiate() requires an int as input for order"")"‖d = Dual(position, 1)‖1
d = Dual(position, 1)‖result = func(d)‖1
result = func(d)‖if order == 0:‖1
if order == 0:‖return result.real‖1
return result.real‖return result.duals[order - 1] * factorial(order)‖1
def f(y):‖return y**2 * y**4‖1
def explicit_euler(‖ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float‖1
ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float‖) -> np.ndarray:‖2
) -> np.ndarray:‖n = int(np.ceil((x_end - x0) / step_size))‖2
n = int(np.ceil((x_end - x0) / step_size))‖y = np.zeros((n + 1,))‖2
y = np.zeros((n + 1,))‖y[0] = y0‖3
y[0] = y0‖x = x0‖3
for k in range(n):‖y[k + 1] = y[k] + step_size * ode_func(x, y[k])‖1
y[k + 1] = y[k] + step_size * ode_func(x, y[k])‖x += step_size‖1
def double_factorial_recursive(n: int) -> int:‖if not isinstance(n, int):‖1
if not isinstance(n, int):‖"raise ValueError(""double_factorial_recursive() only accepts integral values"")"‖1
"raise ValueError(""double_factorial_recursive() only accepts integral values"")"‖if n < 0:‖1
if n < 0:‖"raise ValueError(""double_factorial_recursive() not defined for negative values"")"‖1
"raise ValueError(""double_factorial_recursive() not defined for negative values"")"‖return 1 if n <= 1 else n * double_factorial_recursive(n - 2)‖1
def double_factorial_iterative(num: int) -> int:‖if not isinstance(num, int):‖1
if not isinstance(num, int):‖"raise ValueError(""double_factorial_iterative() only accepts integral values"")"‖1
"raise ValueError(""double_factorial_iterative() only accepts integral values"")"‖if num < 0:‖1
if num < 0:‖"raise ValueError(""double_factorial_iterative() not defined for negative values"")"‖1
"raise ValueError(""double_factorial_iterative() not defined for negative values"")"‖value = 1‖1
value = 1‖for i in range(num, 0, -2):‖1
for i in range(num, 0, -2):‖value *= i‖1
value *= i‖return value‖2
def ceil(x: float) -> int:‖return int(x) if x - int(x) <= 0 else int(x) + 1‖1
if edge <= 0 or not isinstance(edge, int):‖"raise ValueError(""Length must be a positive."")"‖2
"raise ValueError(""Length must be a positive."")"‖return 3 * ((25 + 10 * (5 ** (1 / 2))) ** (1 / 2)) * (edge**2)‖1
"raise ValueError(""Length must be a positive."")"‖return ((15 + (7 * (5 ** (1 / 2)))) / 4) * (edge**3)‖1
def decimal_isolate(number: float, digit_amount: int) -> float:‖if digit_amount > 0:‖1
if digit_amount > 0:‖return round(number - int(number), digit_amount)‖1
return round(number - int(number), digit_amount)‖return number - int(number)‖1
"if __name__ == ""__main__"":"‖print(decimal_isolate(1.53, 0))‖1
print(decimal_isolate(1.53, 0))‖print(decimal_isolate(35.345, 1))‖1
print(decimal_isolate(35.345, 1))‖print(decimal_isolate(35.345, 2))‖1
print(decimal_isolate(35.345, 2))‖print(decimal_isolate(35.345, 3))‖1
print(decimal_isolate(35.345, 3))‖print(decimal_isolate(-14.789, 3))‖1
print(decimal_isolate(-14.789, 3))‖print(decimal_isolate(0, 2))‖1
print(decimal_isolate(0, 2))‖print(decimal_isolate(-14.123, 1))‖1
print(decimal_isolate(-14.123, 1))‖print(decimal_isolate(-14.123, 2))‖1
print(decimal_isolate(-14.123, 2))‖print(decimal_isolate(-14.123, 3))‖1
def is_germain_prime(number: int) -> bool:‖if not isinstance(number, int) or number < 1:‖1
if not isinstance(number, int) or number < 1:‖"msg = f""Input value must be a positive integer. Input value: {number}"""‖2
"msg = f""Input value must be a positive integer. Input value: {number}"""‖raise TypeError(msg)‖2
def is_safe_prime(number: int) -> bool:‖if not isinstance(number, int) or number < 1:‖1
import functools‖from collections.abc import Iterator‖1
from collections.abc import Iterator‖from math import sqrt‖1
from math import sqrt‖from time import time‖1
def time_func(func, *args, **kwargs):‖start = time()‖1
start = time()‖output = func(*args, **kwargs)‖1
output = func(*args, **kwargs)‖end = time()‖1
end = time()‖if int(end - start) > 0:‖1
if int(end - start) > 0:‖"print(f""{func.__name__} runtime: {(end - start):0.4f} s"")"‖1
"print(f""{func.__name__} runtime: {(end - start):0.4f} s"")"‖else:‖1
else:‖"print(f""{func.__name__} runtime: {(end - start) * 1000:0.4f} ms"")"‖1
"print(f""{func.__name__} runtime: {(end - start) * 1000:0.4f} ms"")"‖return output‖1
def fib_iterative_yield(n: int) -> Iterator[int]:‖if n < 0:‖1
if n < 0:‖"raise ValueError(""n is negative"")"‖7
"raise ValueError(""n is negative"")"‖a, b = 0, 1‖1
a, b = 0, 1‖yield a‖1
yield a‖for _ in range(n):‖1
for _ in range(n):‖yield b‖1
yield b‖a, b = b, a + b‖1
def fib_iterative(n: int) -> list[int]:‖if n < 0:‖1
"raise ValueError(""n is negative"")"‖if n == 0:‖2
if n == 0:‖return [0]‖1
return [0]‖fib = [0, 1]‖1
fib = [0, 1]‖for _ in range(n - 1):‖1
for _ in range(n - 1):‖fib.append(fib[-1] + fib[-2])‖1
fib.append(fib[-1] + fib[-2])‖return fib‖1
def fib_recursive_term(i: int) -> int:‖if i < 0:‖2
if i < 0:‖"raise ValueError(""n is negative"")"‖2
"raise ValueError(""n is negative"")"‖if i < 2:‖2
if i < 2:‖return i‖2
return i‖return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)‖2
"raise ValueError(""n is negative"")"‖return [fib_recursive_term(i) for i in range(n + 1)]‖2
@functools.cache‖def fib_recursive_term(i: int) -> int:‖1
def fib_memoization(n: int) -> list[int]:‖if n < 0:‖1
def rec_fn_memoized(num: int) -> int:‖if num in cache:‖1
if num in cache:‖return cache[num]‖1
value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)‖cache[num] = value‖1
cache[num] = value‖return value‖1
def fib_binet(n: int) -> list[int]:‖if n < 0:‖1
"raise ValueError(""n is negative"")"‖if n >= 1475:‖1
if n >= 1475:‖"raise ValueError(""n is too large"")"‖1
"raise ValueError(""n is too large"")"‖sqrt_5 = sqrt(5)‖1
sqrt_5 = sqrt(5)‖phi = (1 + sqrt_5) / 2‖1
phi = (1 + sqrt_5) / 2‖return [round(phi**i / sqrt_5) for i in range(n + 1)]‖1
def matrix_pow_np(m: ndarray, power: int) -> ndarray:‖result = np.array([[1, 0], [0, 1]], dtype=int)‖1
result = np.array([[1, 0], [0, 1]], dtype=int)‖base = m‖1
base = m‖if power < 0:‖1
if power < 0:‖"raise ValueError(""power is negative"")"‖1
"raise ValueError(""power is negative"")"‖while power:‖1
while power:‖if power % 2 == 1:‖1
if power % 2 == 1:‖result = np.dot(result, base)‖1
result = np.dot(result, base)‖base = np.dot(base, base)‖1
base = np.dot(base, base)‖power //= 2‖1
power //= 2‖return result‖1
def fib_matrix_np(n: int) -> int:‖if n < 0:‖1
m = np.array([[1, 1], [1, 0]], dtype=int)‖result = matrix_pow_np(m, n - 1)‖1
result = matrix_pow_np(m, n - 1)‖return int(result[0, 0])‖1
num = 30‖time_func(fib_iterative_yield, num)‖1
time_func(fib_iterative_yield, num)‖time_func(fib_iterative, num)‖1
time_func(fib_iterative, num)‖time_func(fib_binet, num)‖1
time_func(fib_binet, num)‖time_func(fib_memoization, num)‖1
time_func(fib_memoization, num)‖time_func(fib_recursive_cached, num)‖1
time_func(fib_recursive_cached, num)‖time_func(fib_recursive, num)‖1
time_func(fib_recursive, num)‖time_func(fib_matrix_np, num)‖1
def totient(n: int) -> list:‖is_prime = [True for i in range(n + 1)]‖1
is_prime = [True for i in range(n + 1)]‖totients = [i - 1 for i in range(n + 1)]‖1
totients = [i - 1 for i in range(n + 1)]‖primes = []‖1
primes = []‖for i in range(2, n + 1):‖1
for i in range(2, n + 1):‖if is_prime[i]:‖1
if is_prime[i]:‖primes.append(i)‖1
primes.append(i)‖for j in range(len(primes)):‖1
for j in range(len(primes)):‖if i * primes[j] >= n:‖1
if i * primes[j] >= n:‖break‖1
break‖is_prime[i * primes[j]] = False‖1
if i % primes[j] == 0:‖totients[i * primes[j]] = totients[i] * primes[j]‖1
totients[i * primes[j]] = totients[i] * primes[j]‖break‖1
if abs(a) == 1:‖return a, 0‖1
return a, 0‖elif abs(b) == 1:‖1
elif abs(b) == 1:‖return 0, b‖1
old_remainder, remainder = a, b‖old_coeff_a, coeff_a = 1, 0‖1
old_coeff_a, coeff_a = 1, 0‖old_coeff_b, coeff_b = 0, 1‖1
while remainder != 0:‖quotient = old_remainder // remainder‖1
quotient = old_remainder // remainder‖old_remainder, remainder = remainder, old_remainder - quotient * remainder‖1
old_remainder, remainder = remainder, old_remainder - quotient * remainder‖old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a‖1
old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a‖old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b‖1
if a < 0:‖old_coeff_a = -old_coeff_a‖1
old_coeff_a = -old_coeff_a‖if b < 0:‖1
if b < 0:‖old_coeff_b = -old_coeff_b‖1
def main():‖if len(sys.argv) < 3:‖1
if len(sys.argv) < 3:‖"print(""2 integer arguments required"")"‖1
"print(""2 integer arguments required"")"‖return 1‖1
return 1‖a = int(sys.argv[1])‖1
a = int(sys.argv[1])‖b = int(sys.argv[2])‖1
b = int(sys.argv[2])‖print(extended_euclidean_algorithm(a, b))‖1
print(extended_euclidean_algorithm(a, b))‖return 0‖1
"if __name__ == ""__main__"":"‖raise SystemExit(main())‖1
def compute_geometric_mean(*args: int) -> float:‖product = 1‖1
product = 1‖for number in args:‖1
for number in args:‖if not isinstance(number, int) and not isinstance(number, float):‖1
if not isinstance(number, int) and not isinstance(number, float):‖"raise TypeError(""Not a Number"")"‖1
"raise TypeError(""Not a Number"")"‖product *= number‖1
if product < 0 and len(args) % 2 == 0:‖"raise ArithmeticError(""Cannot Compute Geometric Mean for these numbers."")"‖1
"raise ArithmeticError(""Cannot Compute Geometric Mean for these numbers."")"‖mean = abs(product) ** (1 / len(args))‖1
if product < 0:‖mean = -mean‖1
if possible_mean ** len(args) == product:‖mean = possible_mean‖1
mean = possible_mean‖return mean‖1
"testmod(name=""compute_geometric_mean"")"‖print(compute_geometric_mean(-3, -27))‖1
def exact_prime_factor_count(n: int) -> int:‖count = 0‖1
count = 0‖if n % 2 == 0:‖1
if n % 2 == 0:‖count += 1‖1
count += 1‖while n % 2 == 0:‖1
while n % 2 == 0:‖n = int(n / 2)‖1
while i <= int(math.sqrt(n)):‖if n % i == 0:‖1
if n % i == 0:‖count += 1‖1
count += 1‖while n % i == 0:‖1
while n % i == 0:‖n = int(n / i)‖1
n = int(n / i)‖i = i + 2‖1
if n > 2:‖count += 1‖1
"if __name__ == ""__main__"":"‖n = 51242183‖1
n = 51242183‖"print(f""The number of distinct prime factors is/are {exact_prime_factor_count(n)}"")"‖1
"print(f""The number of distinct prime factors is/are {exact_prime_factor_count(n)}"")"‖"print(f""The value of log(log(n)) is {math.log(math.log(n)):.4f}"")"‖1
def find_max_iterative(nums: list[int | float]) -> int | float:‖if len(nums) == 0:‖1
if len(nums) == 0:‖"raise ValueError(""find_max_iterative() arg is an empty sequence"")"‖1
"raise ValueError(""find_max_iterative() arg is an empty sequence"")"‖max_num = nums[0]‖1
max_num = nums[0]‖for x in nums:‖1
for x in nums:‖if x > max_num:‖1
if x > max_num:‖max_num = x‖1
max_num = x‖return max_num‖1
def find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:‖if len(nums) == 0:‖1
if len(nums) == 0:‖"raise ValueError(""find_max_recursive() arg is an empty sequence"")"‖1
"raise ValueError(""find_max_recursive() arg is an empty sequence"")"‖if (‖1
if (‖left >= len(nums)‖2
left >= len(nums)‖or left < -len(nums)‖2
or left < -len(nums)‖or right >= len(nums)‖2
or right >= len(nums)‖or right < -len(nums)‖2
or right < -len(nums)‖):‖2
):‖"raise IndexError(""list index out of range"")"‖2
"raise IndexError(""list index out of range"")"‖if left == right:‖2
if left == right:‖return nums[left]‖2
return nums[left]‖mid = (left + right) >> 1‖2
mid = (left + right) >> 1‖left_max = find_max_recursive(nums, left, mid)‖1
left_max = find_max_recursive(nums, left, mid)‖right_max = find_max_recursive(‖1
right_max = find_max_recursive(‖nums, mid + 1, right‖1
nums, mid + 1, right‖)‖2
def get_factors(‖number: int, factors: Counter | None = None, factor: int = 2‖1
number: int, factors: Counter | None = None, factor: int = 2‖) -> Counter:‖1
match number:‖case int(number) if number == 1:‖1
case int(number) if number == 1:‖return Counter({1: 1})‖1
return Counter({1: 1})‖case int(num) if number > 0:‖1
case int(num) if number > 0:‖number = num‖1
number = num‖case _:‖1
case _:‖"raise TypeError(""number must be integer and greater than zero"")"‖1
factors[factor] += 1‖return factors‖1
try:‖same_factors, *factors = map(get_factors, numbers)‖1
same_factors, *factors = map(get_factors, numbers)‖except TypeError as e:‖1
except TypeError as e:‖"raise Exception(""numbers must be integer and greater than zero"") from e"‖1
for factor in factors:‖same_factors &= factor‖1
for m in [factor**power for factor, power in same_factors.items()]:‖mult *= m‖1
mult *= m‖return mult‖1
"if __name__ == ""__main__"":"‖print(get_greatest_common_divisor(18, 45))‖1
def fast_inverse_sqrt(number: float) -> float:‖if number <= 0:‖1
if number <= 0:‖"raise ValueError(""Input must be a positive number."")"‖1
"raise ValueError(""Input must be a positive number."")"‖"i = struct.unpack("">i"", struct.pack("">f"", number))[0]"‖1
"i = struct.unpack("">i"", struct.pack("">f"", number))[0]"‖i = 0x5F3759DF - (i >> 1)‖1
i = 0x5F3759DF - (i >> 1)‖"y = struct.unpack("">f"", struct.pack("">i"", i))[0]"‖1
"y = struct.unpack("">f"", struct.pack("">i"", i))[0]"‖return y * (1.5 - 0.5 * number * y * y)‖1
for i in range(5, 101, 5):‖"print(f""{i:>3}: {(1 / sqrt(i)) - fast_inverse_sqrt(i):.5f}"")"‖1
def gaussian(x, mu: float = 0.0, sigma: float = 1.0) -> float:‖return 1 / sqrt(2 * pi * sigma**2) * exp(-((x - mu) ** 2) / (2 * sigma**2))‖1
def binary_exponentiation(a: int, n: float, mod: int) -> int:‖if n == 0:‖1
elif n % 2 == 1:‖return (binary_exponentiation(a, n - 1, mod) * a) % mod‖1
else:‖b = binary_exponentiation(a, n / 2, mod)‖1
b = binary_exponentiation(a, n / 2, mod)‖return (b * b) % mod‖1
a = 1000000000‖b = 10‖1
from doctest import testmod‖from math import sqrt‖1
def factors_of_a_number(num: int) -> list:‖facs: list[int] = []‖1
facs: list[int] = []‖if num < 1:‖1
if num < 1:‖return facs‖1
return facs‖facs.append(1)‖1
facs.append(1)‖if num == 1:‖1
if num == 1:‖return facs‖1
return facs‖facs.append(num)‖1
facs.append(num)‖for i in range(2, int(sqrt(num)) + 1):‖1
for i in range(2, int(sqrt(num)) + 1):‖if num % i == 0:‖1
if num % i == 0:‖facs.append(i)‖1
facs.append(i)‖d = num // i‖1
d = num // i‖if d != i:‖1
if d != i:‖facs.append(d)‖1
facs.append(d)‖facs.sort()‖1
facs.sort()‖return facs‖1
"if __name__ == ""__main__"":"‖"testmod(name=""factors_of_a_number"", verbose=True)"‖1
def floor(x: float) -> int:‖return int(x) if x - int(x) >= 0 else int(x) - 1‖1
def greatest_common_divisor(a: int, b: int) -> int:‖return abs(b) if a == 0 else greatest_common_divisor(b % a, a)‖1
def gcd_by_iterative(x: int, y: int) -> int:‖while y:‖1
while y:‖x, y = y, x % y‖1
x, y = y, x % y‖return abs(x)‖1
def main():‖try:‖1
try:‖"nums = input(""Enter two integers separated by comma (,): "").split("","")"‖1
"nums = input(""Enter two integers separated by comma (,): "").split("","")"‖num_1 = int(nums[0])‖1
num_1 = int(nums[0])‖num_2 = int(nums[1])‖1
num_2 = int(nums[1])‖print(‖1
print(‖"f""greatest_common_divisor({num_1}, {num_2}) = """‖1
"f""greatest_common_divisor({num_1}, {num_2}) = """‖"f""{greatest_common_divisor(num_1, num_2)}"""‖1
"f""{greatest_common_divisor(num_1, num_2)}"""‖)‖1
)‖"print(f""By iterative gcd({num_1}, {num_2}) = {gcd_by_iterative(num_1, num_2)}"")"‖1
"print(f""By iterative gcd({num_1}, {num_2}) = {gcd_by_iterative(num_1, num_2)}"")"‖except (IndexError, UnboundLocalError, ValueError):‖1
except (IndexError, UnboundLocalError, ValueError):‖"print(""Wrong input"")"‖1
def factorial(number: int) -> int:‖if number != int(number):‖1
if number != int(number):‖"raise ValueError(""factorial() only accepts integral values"")"‖1
"raise ValueError(""factorial() only accepts integral values"")"‖if number < 0:‖1
if number < 0:‖"raise ValueError(""factorial() not defined for negative values"")"‖1
"raise ValueError(""factorial() not defined for negative values"")"‖value = 1‖1
value = 1‖for i in range(1, number + 1):‖1
for i in range(1, number + 1):‖value *= i‖1
def factorial_recursive(n: int) -> int:‖if not isinstance(n, int):‖1
if not isinstance(n, int):‖"raise ValueError(""factorial() only accepts integral values"")"‖1
"raise ValueError(""factorial() only accepts integral values"")"‖if n < 0:‖1
"raise ValueError(""factorial() not defined for negative values"")"‖return 1 if n in {0, 1} else n * factorial(n - 1)‖1
"n = int(input(""Enter a positive integer: "").strip() or 0)"‖"print(f""factorial{n} is {factorial(n)}"")"‖1
def josephus_recursive(num_people: int, step_size: int) -> int:‖if (‖1
if (‖not isinstance(num_people, int)‖1
not isinstance(num_people, int)‖or not isinstance(step_size, int)‖1
or not isinstance(step_size, int)‖or num_people <= 0‖1
or num_people <= 0‖or step_size <= 0‖1
or step_size <= 0‖):‖1
):‖"raise ValueError(""num_people or step_size is not a positive integer."")"‖1
if num_people == 1:‖return 0‖1
def find_winner(num_people: int, step_size: int) -> int:‖return josephus_recursive(num_people, step_size) + 1‖1
def josephus_iterative(num_people: int, step_size: int) -> int:‖circle = list(range(1, num_people + 1))‖1
circle = list(range(1, num_people + 1))‖current = 0‖1
while len(circle) > 1:‖current = (current + step_size - 1) % len(circle)‖1
current = (current + step_size - 1) % len(circle)‖circle.pop(current)‖1
def is_ip_v4_address_valid(ip: str) -> bool:‖"octets = ip.split(""."")"‖1
"octets = ip.split(""."")"‖if len(octets) != 4:‖1
if len(octets) != 4:‖return False‖1
for octet in octets:‖if not octet.isdigit():‖1
if not octet.isdigit():‖return False‖1
number = int(octet)‖if len(str(number)) != len(octet):‖1
if len(str(number)) != len(octet):‖return False‖1
if not 0 <= number <= 255:‖return False‖1
"if __name__ == ""__main__"":"‖ip = input().strip()‖1
ip = input().strip()‖"valid_or_invalid = ""valid"" if is_ip_v4_address_valid(ip) else ""invalid"""‖1
"valid_or_invalid = ""valid"" if is_ip_v4_address_valid(ip) else ""invalid"""‖"print(f""{ip} is a {valid_or_invalid} IPv4 address."")"‖1
def find_min_iterative(nums: list[int | float]) -> int | float:‖if len(nums) == 0:‖1
if len(nums) == 0:‖"raise ValueError(""find_min_iterative() arg is an empty sequence"")"‖1
"raise ValueError(""find_min_iterative() arg is an empty sequence"")"‖min_num = nums[0]‖1
min_num = nums[0]‖for num in nums:‖1
for num in nums:‖min_num = min(min_num, num)‖1
min_num = min(min_num, num)‖return min_num‖1
def find_min_recursive(nums: list[int | float], left: int, right: int) -> int | float:‖if len(nums) == 0:‖1
if len(nums) == 0:‖"raise ValueError(""find_min_recursive() arg is an empty sequence"")"‖1
"raise ValueError(""find_min_recursive() arg is an empty sequence"")"‖if (‖1
mid = (left + right) >> 1‖left_min = find_min_recursive(nums, left, mid)‖1
left_min = find_min_recursive(nums, left, mid)‖right_min = find_min_recursive(‖1
right_min = find_min_recursive(‖nums, mid + 1, right‖1
import unittest‖from timeit import timeit‖1
def least_common_multiple_slow(first_num: int, second_num: int) -> int:‖max_num = first_num if first_num >= second_num else second_num‖1
max_num = first_num if first_num >= second_num else second_num‖common_mult = max_num‖1
common_mult = max_num‖while (common_mult % first_num > 0) or (common_mult % second_num > 0):‖1
while (common_mult % first_num > 0) or (common_mult % second_num > 0):‖common_mult += max_num‖1
common_mult += max_num‖return common_mult‖1
def least_common_multiple_fast(first_num: int, second_num: int) -> int:‖return first_num // greatest_common_divisor(first_num, second_num) * second_num‖1
def benchmark():‖setup = (‖1
setup = (‖"""from __main__ import least_common_multiple_slow, least_common_multiple_fast"""‖1
"""from __main__ import least_common_multiple_slow, least_common_multiple_fast"""‖)‖1
print(‖"""least_common_multiple_slow():"","‖1
"""least_common_multiple_slow():"","‖"timeit(""least_common_multiple_slow(1000, 999)"", setup=setup),"‖1
"timeit(""least_common_multiple_slow(1000, 999)"", setup=setup),"‖)‖1
print(‖"""least_common_multiple_fast():"","‖1
"""least_common_multiple_fast():"","‖"timeit(""least_common_multiple_fast(1000, 999)"", setup=setup),"‖1
"timeit(""least_common_multiple_fast(1000, 999)"", setup=setup),"‖)‖1
class TestLeastCommonMultiple(unittest.TestCase):‖test_inputs = (‖1
test_inputs = (‖(10, 20),‖1
(10, 20),‖(13, 15),‖1
(13, 15),‖(4, 31),‖1
(4, 31),‖(10, 42),‖1
(10, 42),‖(43, 34),‖1
(43, 34),‖(5, 12),‖1
(5, 12),‖(12, 25),‖1
(12, 25),‖(10, 25),‖1
(10, 25),‖(6, 9),‖1
(6, 9),‖)‖1
)‖expected_results = (20, 195, 124, 210, 1462, 60, 300, 50, 18)‖1
def test_lcm_function(self):‖for i, (first_num, second_num) in enumerate(self.test_inputs):‖1
for i, (first_num, second_num) in enumerate(self.test_inputs):‖slow_result = least_common_multiple_slow(first_num, second_num)‖1
slow_result = least_common_multiple_slow(first_num, second_num)‖fast_result = least_common_multiple_fast(first_num, second_num)‖1
fast_result = least_common_multiple_fast(first_num, second_num)‖with self.subTest(i=i):‖1
with self.subTest(i=i):‖assert slow_result == self.expected_results[i]‖1
assert slow_result == self.expected_results[i]‖assert fast_result == self.expected_results[i]‖1
"if __name__ == ""__main__"":"‖benchmark()‖1
benchmark()‖unittest.main()‖1
def is_square_free(factors: list[int]) -> bool:‖return len(set(factors)) == len(factors)‖1
def is_int_palindrome(num: int) -> bool:‖if num < 0:‖1
if num < 0:‖return False‖2
num_copy: int = num‖rev_num: int = 0‖1
rev_num: int = 0‖while num > 0:‖1
while num > 0:‖rev_num = rev_num * 10 + (num % 10)‖1
rev_num = rev_num * 10 + (num % 10)‖num //= 10‖1
from numpy import inf‖from scipy.integrate import quad‖1
def gamma_iterative(num: float) -> float:‖if num <= 0:‖1
if num <= 0:‖"raise ValueError(""math domain error"")"‖2
def integrand(x: float, z: float) -> float:‖return math.pow(x, z - 1) * math.exp(-x)‖1
def gamma_recursive(num: float) -> float:‖if num <= 0:‖1
"raise ValueError(""math domain error"")"‖if num > 171.5:‖1
if num > 171.5:‖"raise OverflowError(""math range error"")"‖1
"raise OverflowError(""math range error"")"‖elif num - int(num) not in (0, 0.5):‖1
elif num - int(num) not in (0, 0.5):‖"raise NotImplementedError(""num must be an integer or a half-integer"")"‖1
"raise NotImplementedError(""num must be an integer or a half-integer"")"‖elif num == 0.5:‖1
elif num == 0.5:‖return math.sqrt(math.pi)‖1
return math.sqrt(math.pi)‖else:‖1
else:‖return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)‖1
testmod()‖num = 1.0‖1
num = 1.0‖while num:‖1
while num:‖"num = float(input(""Gamma of: ""))"‖1
"num = float(input(""Gamma of: ""))"‖"print(f""gamma_iterative({num}) = {gamma_iterative(num)}"")"‖1
"print(f""gamma_iterative({num}) = {gamma_iterative(num)}"")"‖"print(f""gamma_recursive({num}) = {gamma_recursive(num)}"")"‖1
"print(f""gamma_recursive({num}) = {gamma_recursive(num)}"")"‖"print(""\nEnter 0 to exit..."")"‖1
def juggler_sequence(number: int) -> list[int]:‖if not isinstance(number, int):‖1
if not isinstance(number, int):‖"msg = f""Input value of [number={number}] must be an integer"""‖8
"msg = f""Input value of [number={number}] must be an integer"""‖raise TypeError(msg)‖8
raise TypeError(msg)‖if number < 1:‖3
if number < 1:‖"msg = f""Input value of [number={number}] must be a positive integer"""‖1
"msg = f""Input value of [number={number}] must be a positive integer"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖sequence = [number]‖1
sequence = [number]‖while number != 1:‖1
while number != 1:‖if number % 2 == 0:‖1
if number % 2 == 0:‖number = math.floor(math.sqrt(number))‖1
number = math.floor(math.sqrt(number))‖else:‖1
else:‖number = math.floor(‖1
number = math.floor(‖math.sqrt(number) * math.sqrt(number) * math.sqrt(number)‖1
math.sqrt(number) * math.sqrt(number) * math.sqrt(number)‖)‖1
)‖sequence.append(number)‖1
sequence.append(number)‖return sequence‖1
def max_sum_in_array(array: list[int], k: int) -> int:‖if len(array) < k or k < 0:‖1
if len(array) < k or k < 0:‖"raise ValueError(""Invalid Input"")"‖1
"raise ValueError(""Invalid Input"")"‖max_sum = current_sum = sum(array[:k])‖1
max_sum = current_sum = sum(array[:k])‖for i in range(len(array) - k):‖1
for i in range(len(array) - k):‖current_sum = current_sum - array[i] + array[i + k]‖1
current_sum = current_sum - array[i] + array[i + k]‖max_sum = max(max_sum, current_sum)‖1
max_sum = max(max_sum, current_sum)‖return max_sum‖1
from doctest import testmod‖from random import randint‖1
testmod()‖array = [randint(-1000, 1000) for i in range(100)]‖1
array = [randint(-1000, 1000) for i in range(100)]‖k = randint(0, 110)‖1
k = randint(0, 110)‖print(‖1
print(‖"f""The maximum sum of {k} consecutive elements is {max_sum_in_array(array, k)}"""‖1
"f""The maximum sum of {k} consecutive elements is {max_sum_in_array(array, k)}"""‖)‖1
def jaccard_similarity(‖set_a: set[str] | list[str] | tuple[str],‖1
set_a: set[str] | list[str] | tuple[str],‖set_b: set[str] | list[str] | tuple[str],‖1
set_b: set[str] | list[str] | tuple[str],‖alternative_union=False,‖1
alternative_union=False,‖):‖1
if isinstance(set_a, set) and isinstance(set_b, set):‖intersection_length = len(set_a.intersection(set_b))‖1
if alternative_union:‖union_length = len(set_a) + len(set_b)‖1
union_length = len(set_a) + len(set_b)‖else:‖1
else:‖union_length = len(set_a.union(set_b))‖1
elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):‖intersection = [element for element in set_a if element in set_b]‖1
if alternative_union:‖return len(intersection) / (len(set_a) + len(set_b))‖1
return len(intersection) / (len(set_a) + len(set_b))‖else:‖1
union = list(set_a) + [element for element in set_b if element not in set_a]‖return len(intersection) / len(union)‖1
return len(intersection) / len(union)‖raise ValueError(‖1
raise ValueError(‖"""Set a and b must either both be sets or be either a list or a tuple."""‖1
"""Set a and b must either both be sets or be either a list or a tuple."""‖)‖1
"if __name__ == ""__main__"":"‖"set_a = {""a"", ""b"", ""c"", ""d"", ""e""}"‖1
"set_a = {""a"", ""b"", ""c"", ""d"", ""e""}"‖"set_b = {""c"", ""d"", ""e"", ""f"", ""h"", ""i""}"‖1
"set_b = {""c"", ""d"", ""e"", ""f"", ""h"", ""i""}"‖print(jaccard_similarity(set_a, set_b))‖1
def res(x, y):‖if 0 not in (x, y):‖1
return y * math.log10(x)‖elif x == 0:‖1
elif x == 0:‖return 0‖1
return 0‖elif y == 0:‖1
elif y == 0:‖return 1‖1
return 1‖"raise AssertionError(""This should never happen"")"‖1
"prompt = ""Enter the base and the power separated by a comma: """‖"x1, y1 = map(int, input(prompt).split("",""))"‖1
"x1, y1 = map(int, input(prompt).split("",""))"‖"x2, y2 = map(int, input(prompt).split("",""))"‖1
res1 = res(x1, y1)‖res2 = res(x2, y2)‖1
if res1 > res2:‖"print(""Largest number is"", x1, ""^"", y1)"‖1
"print(""Largest number is"", x1, ""^"", y1)"‖elif res2 > res1:‖1
elif res2 > res1:‖"print(""Largest number is"", x2, ""^"", y2)"‖1
"print(""Largest number is"", x2, ""^"", y2)"‖else:‖1
else:‖"print(""Both are equal"")"‖1
def find_median(nums: list[int | float]) -> float:‖div, mod = divmod(len(nums), 2)‖1
div, mod = divmod(len(nums), 2)‖if mod:‖1
if mod:‖return nums[div]‖1
return nums[div]‖return (nums[div] + nums[(div) - 1]) / 2‖1
def interquartile_range(nums: list[int | float]) -> float:‖if not nums:‖1
if not nums:‖"raise ValueError(""The list is empty. Provide a non-empty list."")"‖1
"raise ValueError(""The list is empty. Provide a non-empty list."")"‖nums.sort()‖1
nums.sort()‖length = len(nums)‖1
length = len(nums)‖div, mod = divmod(length, 2)‖1
div, mod = divmod(length, 2)‖q1 = find_median(nums[:div])‖1
q1 = find_median(nums[:div])‖half_length = sum((div, mod))‖1
half_length = sum((div, mod))‖q3 = find_median(nums[half_length:length])‖1
q3 = find_median(nums[half_length:length])‖return q3 - q1‖1
def integer_square_root(num: int) -> int:‖if not isinstance(num, int) or num < 0:‖1
if not isinstance(num, int) or num < 0:‖"raise ValueError(""num must be non-negative integer"")"‖1
if num < 2:‖return num‖1
left_bound = 0‖right_bound = num // 2‖1
while left_bound <= right_bound:‖mid = left_bound + (right_bound - left_bound) // 2‖1
mid = left_bound + (right_bound - left_bound) // 2‖mid_squared = mid * mid‖1
mid_squared = mid * mid‖if mid_squared == num:‖1
if mid_squared == num:‖return mid‖1
if mid_squared < num:‖left_bound = mid + 1‖1
left_bound = mid + 1‖else:‖1
else:‖right_bound = mid - 1‖1
def karatsuba(a: int, b: int) -> int:‖if len(str(a)) == 1 or len(str(b)) == 1:‖1
if len(str(a)) == 1 or len(str(b)) == 1:‖return a * b‖1
m1 = max(len(str(a)), len(str(b)))‖m2 = m1 // 2‖1
a1, a2 = divmod(a, 10**m2)‖b1, b2 = divmod(b, 10**m2)‖1
x = karatsuba(a2, b2)‖y = karatsuba((a1 + a2), (b1 + b2))‖1
y = karatsuba((a1 + a2), (b1 + b2))‖z = karatsuba(a1, b1)‖1
def main():‖print(karatsuba(15463, 23489))‖1
_validate_point(point_a)‖_validate_point(point_b)‖2
_validate_point(point_b)‖if len(point_a) != len(point_b):‖2
if len(point_a) != len(point_b):‖"raise ValueError(""Both points must be in the same n-dimensional space"")"‖2
def _validate_point(point: list[float]) -> None:‖if point:‖1
if point:‖if isinstance(point, list):‖1
if isinstance(point, list):‖for item in point:‖1
for item in point:‖if not isinstance(item, (int, float)):‖1
if not isinstance(item, (int, float)):‖msg = (‖1
msg = (‖"""Expected a list of numbers as input, found """‖1
"""Expected a list of numbers as input, found """‖"f""{type(item).__name__}"""‖1
"f""{type(item).__name__}"""‖)‖1
raise TypeError(msg)‖else:‖2
else:‖"msg = f""Expected a list of numbers as input, found {type(point).__name__}"""‖1
"msg = f""Expected a list of numbers as input, found {type(point).__name__}"""‖raise TypeError(msg)‖1
else:‖"raise ValueError(""Missing an input"")"‖1
def euler_modified(‖ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float‖1
for k in range(n):‖y_get = y[k] + step_size * ode_func(x, y[k])‖1
y_get = y[k] + step_size * ode_func(x, y[k])‖y[k + 1] = y[k] + (‖1
y[k + 1] = y[k] + (‖(step_size / 2) * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))‖1
(step_size / 2) * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))‖)‖1
)‖x += step_size‖1
class Matrix:‖def __init__(self, arg):‖1
def __init__(self, arg):‖if isinstance(arg, list):‖1
if isinstance(arg, list):‖self.t = arg‖1
self.t = arg‖self.n = len(arg)‖1
self.n = len(arg)‖else:‖1
else:‖self.n = arg‖1
self.n = arg‖self.t = [[0 for _ in range(self.n)] for _ in range(self.n)]‖1
def __mul__(self, b):‖matrix = Matrix(self.n)‖1
matrix = Matrix(self.n)‖for i in range(self.n):‖1
for j in range(self.n):‖for k in range(self.n):‖1
for k in range(self.n):‖matrix.t[i][j] += self.t[i][k] * b.t[k][j]‖1
matrix.t[i][j] += self.t[i][k] * b.t[k][j]‖return matrix‖1
def modular_exponentiation(a, b):‖matrix = Matrix([[1, 0], [0, 1]])‖1
matrix = Matrix([[1, 0], [0, 1]])‖while b > 0:‖1
if b & 1:‖matrix *= a‖1
matrix *= a‖a *= a‖1
a *= a‖b >>= 1‖1
b >>= 1‖return matrix‖1
if n == 1:‖return f1‖2
return f1‖elif n == 2:‖2
elif n == 2:‖return f2‖2
return f2‖matrix = Matrix([[1, 1], [1, 0]])‖1
matrix = Matrix([[1, 1], [1, 0]])‖matrix = modular_exponentiation(matrix, n - 2)‖1
matrix = modular_exponentiation(matrix, n - 2)‖return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]‖1
while n > 0:‖f2, f1 = f1 + f2, f2‖1
f2, f1 = f1 + f2, f2‖n -= 1‖1
def matrix_exponentiation_time():‖from __main__ import fibonacci_with_matrix_exponentiation‖1
from __main__ import fibonacci_with_matrix_exponentiation‖"code = ""simple_fibonacci(randint(1,70000), 1, 1)"""‖1
"code = ""simple_fibonacci(randint(1,70000), 1, 1)"""‖exec_time = timeit.timeit(setup=setup, stmt=code, number=100)‖1
exec_time = timeit.timeit(setup=setup, stmt=code, number=100)‖print(‖1
print(‖"""Without matrix exponentiation the average execution time is "", exec_time / 100"‖1
"""Without matrix exponentiation the average execution time is "", exec_time / 100"‖)‖1
)‖return exec_time‖1
def main():‖matrix_exponentiation_time()‖1
matrix_exponentiation_time()‖simple_fibonacci_time()‖1
if not isinstance(theta, (int, float)):‖"raise ValueError(""maclaurin_sin() requires either an int or float for theta"")"‖1
if not isinstance(accuracy, int) or accuracy <= 0:‖"raise ValueError(""maclaurin_sin() requires a positive int for accuracy"")"‖1
theta = float(theta)‖div = theta // (2 * pi)‖2
div = theta // (2 * pi)‖theta -= 2 * div * pi‖2
theta -= 2 * div * pi‖return sum(‖1
return sum(‖(-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)‖1
(-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)‖)‖1
if not isinstance(theta, (int, float)):‖"raise ValueError(""maclaurin_cos() requires either an int or float for theta"")"‖1
if not isinstance(accuracy, int) or accuracy <= 0:‖"raise ValueError(""maclaurin_cos() requires a positive int for accuracy"")"‖1
theta -= 2 * div * pi‖return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))‖1
print(maclaurin_sin(10))‖print(maclaurin_sin(-10))‖1
print(maclaurin_sin(-10))‖print(maclaurin_sin(10, 15))‖1
print(maclaurin_sin(10, 15))‖print(maclaurin_sin(-10, 15))‖1
print(maclaurin_cos(5))‖print(maclaurin_cos(-5))‖1
print(maclaurin_cos(-5))‖print(maclaurin_cos(10, 15))‖1
print(maclaurin_cos(10, 15))‖print(maclaurin_cos(-10, 15))‖1
factorials = [1]‖for i in range(2, n):‖1
for i in range(2, n):‖factorials.append(factorials[-1] * i)‖1
factorials.append(factorials[-1] * i)‖"assert 0 <= k < factorials[-1] * n, ""k out of bounds"""‖1
permutation = []‖elements = list(range(n))‖1
while factorials:‖factorial = factorials.pop()‖1
factorial = factorials.pop()‖number, k = divmod(k, factorial)‖1
number, k = divmod(k, factorial)‖permutation.append(elements[number])‖1
permutation.append(elements[number])‖elements.remove(elements[number])‖1
elements.remove(elements[number])‖permutation.append(elements[0])‖1
from collections.abc import Callable‖from math import pi, sqrt‖1
from math import pi, sqrt‖from random import uniform‖1
from random import uniform‖from statistics import mean‖1
def is_in_circle(x: float, y: float) -> bool:‖distance_from_centre = sqrt((x**2) + (y**2))‖1
proportion = mean(‖int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))‖1
int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))‖for _ in range(iterations)‖1
for _ in range(iterations)‖)‖1
pi_estimate = proportion * 4‖"print(f""The estimated value of pi is {pi_estimate}"")"‖1
"print(f""The estimated value of pi is {pi_estimate}"")"‖"print(f""The numpy value of pi is {pi}"")"‖1
"print(f""The numpy value of pi is {pi}"")"‖"print(f""The total error is {abs(pi - pi_estimate)}"")"‖1
def area_under_curve_estimator(‖iterations: int,‖1
iterations: int,‖function_to_integrate: Callable[[float], float],‖1
function_to_integrate: Callable[[float], float],‖min_value: float = 0.0,‖1
min_value: float = 0.0,‖max_value: float = 1.0,‖1
max_value: float = 1.0,‖) -> float:‖1
return mean(‖function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)‖1
function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)‖) * (max_value - min_value)‖1
def area_under_line_estimator_check(‖iterations: int, min_value: float = 0.0, max_value: float = 1.0‖1
iterations: int, min_value: float = 0.0, max_value: float = 1.0‖) -> None:‖1
def identity_function(x: float) -> float:‖return x‖1
estimated_value = area_under_curve_estimator(‖iterations, identity_function, min_value, max_value‖1
iterations, identity_function, min_value, max_value‖)‖1
)‖expected_value = (max_value * max_value - min_value * min_value) / 2‖1
"print(""******************"")"‖"print(f""Estimating area under y=x where x varies from {min_value} to {max_value}"")"‖1
"print(f""Estimating area under y=x where x varies from {min_value} to {max_value}"")"‖"print(f""Estimated value is {estimated_value}"")"‖1
"print(f""Estimated value is {estimated_value}"")"‖"print(f""Expected value is {expected_value}"")"‖1
"print(f""Expected value is {expected_value}"")"‖"print(f""Total error is {abs(estimated_value - expected_value)}"")"‖1
"print(f""Total error is {abs(estimated_value - expected_value)}"")"‖"print(""******************"")"‖1
def function_to_integrate(x: float) -> float:‖return sqrt(4.0 - x * x)‖1
estimated_value = area_under_curve_estimator(‖iterations, function_to_integrate, 0.0, 2.0‖1
iterations, function_to_integrate, 0.0, 2.0‖)‖1
"print(""******************"")"‖"print(""Estimating pi using area_under_curve_estimator"")"‖1
"print(""Estimating pi using area_under_curve_estimator"")"‖"print(f""Estimated value is {estimated_value}"")"‖1
"print(f""Estimated value is {estimated_value}"")"‖"print(f""Expected value is {pi}"")"‖1
"print(f""Expected value is {pi}"")"‖"print(f""Total error is {abs(estimated_value - pi)}"")"‖1
"print(f""Total error is {abs(estimated_value - pi)}"")"‖"print(""******************"")"‖1
def liouville_lambda(number: int) -> int:‖if not isinstance(number, int):‖1
if number < 1:‖"raise ValueError(""Input must be a positive integer"")"‖2
"raise ValueError(""Input must be a positive integer"")"‖return -1 if len(prime_factors(number)) % 2 else 1‖1
import math‖from collections.abc import Callable‖2
def line_length(‖fnc: Callable[[float], float],‖1
fx1 = fnc(x_start)‖length = 0.0‖1
fx2 = fnc(x2)‖length += math.hypot(x2 - x1, fx2 - fx1)‖1
def f(x):‖return math.sin(10 * x)‖1
"print(""f(x) = sin(10 * x)"")"‖"print(""The length of the curve from x = -10 to x = 10 is:"")"‖1
"print(""The length of the curve from x = -10 to x = 10 is:"")"‖i = 10‖1
while i <= 100000:‖"print(f""With {i} steps: {line_length(f, -10, 10, i)}"")"‖1
"print(f""With {i} steps: {line_length(f, -10, 10, i)}"")"‖i *= 10‖1
if p < 2:‖"raise ValueError(""p should not be less than 2!"")"‖1
"raise ValueError(""p should not be less than 2!"")"‖elif p == 2:‖1
elif p == 2:‖return True‖1
s = 4‖m = (1 << p) - 1‖1
m = (1 << p) - 1‖for _ in range(p - 2):‖1
for _ in range(p - 2):‖s = ((s * s) - 2) % m‖1
s = ((s * s) - 2) % m‖return s == 0‖1
"if __name__ == ""__main__"":"‖print(lucas_lehmer_test(7))‖1
print(lucas_lehmer_test(7))‖print(lucas_lehmer_test(11))‖1
from maths.is_square_free import is_square_free‖from maths.prime_factors import prime_factors‖1
def mobius(n: int) -> int:‖factors = prime_factors(n)‖1
factors = prime_factors(n)‖if is_square_free(factors):‖1
if is_square_free(factors):‖return -1 if len(factors) % 2 else 1‖1
return -1 if len(factors) % 2 else 1‖return 0‖1
def joint_probability_distribution(‖x_values: list[int],‖1
x_values: list[int],‖y_values: list[int],‖2
y_values: list[int],‖x_probabilities: list[float],‖2
x_probabilities: list[float],‖y_probabilities: list[float],‖2
y_probabilities: list[float],‖) -> dict:‖1
) -> dict:‖return {‖1
return {‖(x, y): x_prob * y_prob‖1
(x, y): x_prob * y_prob‖for x, x_prob in zip(x_values, x_probabilities)‖1
for x, x_prob in zip(x_values, x_probabilities)‖for y, y_prob in zip(y_values, y_probabilities)‖1
for y, y_prob in zip(y_values, y_probabilities)‖}‖1
def expectation(values: list, probabilities: list) -> float:‖return sum(x * p for x, p in zip(values, probabilities))‖1
def variance(values: list[int], probabilities: list[float]) -> float:‖mean = expectation(values, probabilities)‖1
mean = expectation(values, probabilities)‖return sum((x - mean) ** 2 * p for x, p in zip(values, probabilities))‖1
def covariance(‖x_values: list[int],‖1
y_probabilities: list[float],‖) -> float:‖1
) -> float:‖mean_x = expectation(x_values, x_probabilities)‖1
mean_x = expectation(x_values, x_probabilities)‖mean_y = expectation(y_values, y_probabilities)‖1
mean_y = expectation(y_values, y_probabilities)‖return sum(‖1
return sum(‖(x - mean_x) * (y - mean_y) * px * py‖1
(x - mean_x) * (y - mean_y) * px * py‖for x, px in zip(x_values, x_probabilities)‖1
for x, px in zip(x_values, x_probabilities)‖for y, py in zip(y_values, y_probabilities)‖1
for y, py in zip(y_values, y_probabilities)‖)‖1
def standard_deviation(variance: float) -> float:‖return variance**0.5‖1
"x_vals = input(""Enter values of X separated by spaces: "").split()"‖"y_vals = input(""Enter values of Y separated by spaces: "").split()"‖1
x_values = [int(x) for x in x_vals]‖y_values = [int(y) for y in y_vals]‖1
"x_probs = input(""Enter probabilities for X separated by spaces: "").split()"‖"y_probs = input(""Enter probabilities for Y separated by spaces: "").split()"‖1
"y_probs = input(""Enter probabilities for Y separated by spaces: "").split()"‖assert len(x_values) == len(x_probs)‖1
assert len(x_values) == len(x_probs)‖assert len(y_values) == len(y_probs)‖1
x_probabilities = [float(p) for p in x_probs]‖y_probabilities = [float(p) for p in y_probs]‖1
jpd = joint_probability_distribution(‖x_values, y_values, x_probabilities, y_probabilities‖1
x_values, y_values, x_probabilities, y_probabilities‖)‖1
print(‖"""\n"".join("‖1
"""\n"".join("‖"f""P(X={x}, Y={y}) = {probability}"" for (x, y), probability in jpd.items()"‖1
"f""P(X={x}, Y={y}) = {probability}"" for (x, y), probability in jpd.items()"‖)‖1
)‖mean_xy = expectation(‖1
mean_xy = expectation(‖[x * y for x in x_values for y in y_values],‖1
[x * y for x in x_values for y in y_values],‖[px * py for px in x_probabilities for py in y_probabilities],‖1
[px * py for px in x_probabilities for py in y_probabilities],‖)‖1
)‖"print(f""x mean: {expectation(x_values, x_probabilities) = }"")"‖1
"print(f""x mean: {expectation(x_values, x_probabilities) = }"")"‖"print(f""y mean: {expectation(y_values, y_probabilities) = }"")"‖1
"print(f""y mean: {expectation(y_values, y_probabilities) = }"")"‖"print(f""xy mean: {mean_xy}"")"‖1
"print(f""xy mean: {mean_xy}"")"‖"print(f""x: {variance(x_values, x_probabilities) = }"")"‖1
"print(f""x: {variance(x_values, x_probabilities) = }"")"‖"print(f""y: {variance(y_values, y_probabilities) = }"")"‖1
"print(f""y: {variance(y_values, y_probabilities) = }"")"‖"print(f""{covariance(x_values, y_values, x_probabilities, y_probabilities) = }"")"‖1
"print(f""{covariance(x_values, y_values, x_probabilities, y_probabilities) = }"")"‖"print(f""x: {standard_deviation(variance(x_values, x_probabilities)) = }"")"‖1
"print(f""x: {standard_deviation(variance(x_values, x_probabilities)) = }"")"‖"print(f""y: {standard_deviation(variance(y_values, y_probabilities)) = }"")"‖1
def modular_division(a: int, b: int, n: int) -> int:‖assert n > 1‖1
assert n > 1‖assert a > 0‖1
assert a > 0‖assert greatest_common_divisor(a, n) == 1‖1
assert greatest_common_divisor(a, n) == 1‖(d, t, s) = extended_gcd(n, a)‖1
(d, t, s) = extended_gcd(n, a)‖x = (b * s) % n‖1
x = (b * s) % n‖return x‖2
def modular_division2(a: int, b: int, n: int) -> int:‖s = invert_modulo(a, n)‖1
s = invert_modulo(a, n)‖x = (b * s) % n‖1
def extended_gcd(a: int, b: int) -> tuple[int, int, int]:‖assert a >= 0‖1
def greatest_common_divisor(a: int, b: int) -> int:‖if a < b:‖1
if a < b:‖a, b = b, a‖1
while a % b != 0:‖a, b = b, a % b‖1
"testmod(name=""modular_division"", verbose=True)"‖"testmod(name=""modular_division2"", verbose=True)"‖1
"testmod(name=""modular_division2"", verbose=True)"‖"testmod(name=""invert_modulo"", verbose=True)"‖1
"testmod(name=""invert_modulo"", verbose=True)"‖"testmod(name=""extended_gcd"", verbose=True)"‖1
"testmod(name=""extended_gcd"", verbose=True)"‖"testmod(name=""extended_euclid"", verbose=True)"‖1
"testmod(name=""extended_euclid"", verbose=True)"‖"testmod(name=""greatest_common_divisor"", verbose=True)"‖1
class Point:‖def __init__(self, x: float, y: float) -> None:‖1
def __init__(self, x: float, y: float) -> None:‖self.x = x‖1
self.x = x‖self.y = y‖3
def is_in_unit_circle(self) -> bool:‖return (self.x**2 + self.y**2) <= 1‖1
@classmethod‖def random_unit_square(cls):‖1
def random_unit_square(cls):‖return cls(x=random.random(), y=random.random())‖1
def estimate_pi(number_of_simulations: int) -> float:‖if number_of_simulations < 1:‖1
if number_of_simulations < 1:‖"raise ValueError(""At least one simulation is necessary to estimate PI."")"‖1
number_in_unit_circle = 0‖for _ in range(number_of_simulations):‖1
for _ in range(number_of_simulations):‖random_point = Point.random_unit_square()‖1
if random_point.is_in_unit_circle():‖number_in_unit_circle += 1‖1
"prompt = ""Please enter the desired number of Monte Carlo simulations: """‖my_pi = estimate_pi(int(input(prompt).strip()))‖1
my_pi = estimate_pi(int(input(prompt).strip()))‖"print(f""An estimate of PI is {my_pi} with an error of {abs(my_pi - pi)}"")"‖1
def recursive_lucas_number(n_th_number: int) -> int:‖if not isinstance(n_th_number, int):‖1
if not isinstance(n_th_number, int):‖"raise TypeError(""recursive_lucas_number accepts only integer arguments."")"‖1
"raise TypeError(""recursive_lucas_number accepts only integer arguments."")"‖if n_th_number == 0:‖1
if n_th_number == 0:‖return 2‖1
return 2‖if n_th_number == 1:‖1
if n_th_number == 1:‖return 1‖1
return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(‖n_th_number - 2‖1
n_th_number - 2‖)‖1
def dynamic_lucas_number(n_th_number: int) -> int:‖if not isinstance(n_th_number, int):‖1
if not isinstance(n_th_number, int):‖"raise TypeError(""dynamic_lucas_number accepts only integer arguments."")"‖1
"raise TypeError(""dynamic_lucas_number accepts only integer arguments."")"‖a, b = 2, 1‖1
a, b = 2, 1‖for _ in range(n_th_number):‖1
for _ in range(n_th_number):‖a, b = b, a + b‖1
a, b = b, a + b‖return a‖1
testmod()‖"n = int(input(""Enter the number of terms in lucas series:\n"").strip())"‖1
"n = int(input(""Enter the number of terms in lucas series:\n"").strip())"‖"print(""Using recursive function to calculate lucas series:"")"‖1
"print(""Using recursive function to calculate lucas series:"")"‖"print("" "".join(str(recursive_lucas_number(i)) for i in range(n)))"‖1
"print("" "".join(str(recursive_lucas_number(i)) for i in range(n)))"‖"print(""\nUsing dynamic function to calculate lucas series:"")"‖1
"print(""\nUsing dynamic function to calculate lucas series:"")"‖"print("" "".join(str(dynamic_lucas_number(i)) for i in range(n)))"‖1
from itertools import compress, repeat‖from math import ceil, sqrt‖1
if num <= 2:‖return []‖1
return []‖if num == 3:‖1
if num == 3:‖return [2]‖1
for i in range(3, int(sqrt(num)) + 1, 2):‖if sieve[(i >> 1) - 1]:‖1
if sieve[(i >> 1) - 1]:‖i_squared = i**2‖1
i_squared = i**2‖sieve[(i_squared >> 1) - 1 :: i] = repeat(‖1
sieve[(i_squared >> 1) - 1 :: i] = repeat(‖0, ceil((num - i_squared) / (i << 1))‖1
0, ceil((num - i_squared) / (i << 1))‖)‖1
import math‖from timeit import timeit‖1
if not isinstance(n, int):‖"raise TypeError(""Input must be an integer"")"‖3
digits = 0‖n = abs(n)‖1
n = abs(n)‖while True:‖1
while True:‖n = n // 10‖1
n = n // 10‖digits += 1‖1
digits += 1‖if n == 0:‖1
if n == 0:‖break‖1
break‖return digits‖1
def benchmark() -> None:‖from collections.abc import Callable‖3
def benchmark_a_function(func: Callable, value: int) -> None:‖"call = f""{func.__name__}({value})"""‖3
"call = f""{func.__name__}({value})"""‖"timing = timeit(f""__main__.{call}"", setup=""import __main__"")"‖3
"timing = timeit(f""__main__.{call}"", setup=""import __main__"")"‖"print(f""{call}: {func(value)} -- {timing} seconds"")"‖1
for value in (262144, 1125899906842624, 1267650600228229401496703205376):‖for func in (num_digits, num_digits_fast, num_digits_faster):‖1
for func in (num_digits, num_digits_fast, num_digits_faster):‖benchmark_a_function(func, value)‖1
benchmark_a_function(func, value)‖print()‖3
import math‖import unittest‖1
if not isinstance(number, int) or not number >= 0:‖"raise ValueError(""is_prime() only accepts positive integers"")"‖1
return True‖elif number < 2 or number % 2 == 0 or number % 3 == 0:‖1
for i in range(5, int(math.sqrt(number) + 1), 6):‖if number % i == 0 or number % (i + 2) == 0:‖1
if number % i == 0 or number % (i + 2) == 0:‖return False‖1
class Test(unittest.TestCase):‖def test_primes(self):‖1
def test_primes(self):‖assert is_prime(2)‖1
assert is_prime(2)‖assert is_prime(3)‖1
assert is_prime(3)‖assert is_prime(5)‖1
assert is_prime(5)‖assert is_prime(7)‖1
assert is_prime(7)‖assert is_prime(11)‖1
assert is_prime(11)‖assert is_prime(13)‖1
assert is_prime(13)‖assert is_prime(17)‖1
assert is_prime(17)‖assert is_prime(19)‖1
assert is_prime(19)‖assert is_prime(23)‖1
assert is_prime(23)‖assert is_prime(29)‖1
def test_not_primes(self):‖with pytest.raises(ValueError):‖1
with pytest.raises(ValueError):‖is_prime(-19)‖1
is_prime(-19)‖assert not is_prime(0), (‖1
assert not is_prime(0), (‖"""Zero doesn't have any positive factors, primes must have exactly two."""‖1
"""Zero doesn't have any positive factors, primes must have exactly two."""‖)‖1
)‖assert not is_prime(1), (‖1
assert not is_prime(1), (‖"""One only has 1 positive factor, primes must have exactly two."""‖1
"""One only has 1 positive factor, primes must have exactly two."""‖)‖1
)‖assert not is_prime(2 * 2)‖1
assert not is_prime(2 * 2)‖assert not is_prime(2 * 3)‖1
assert not is_prime(2 * 3)‖assert not is_prime(3 * 3)‖1
assert not is_prime(3 * 3)‖assert not is_prime(3 * 5)‖1
assert not is_prime(3 * 5)‖assert not is_prime(3 * 5 * 7)‖1
q = 1‖r = 0‖1
r = 0‖t = 1‖1
t = 1‖k = 1‖1
k = 1‖n = 3‖1
n = 3‖m = 3‖1
decimal = limit‖counter = 0‖1
while counter != decimal + 1:‖if 4 * q + r - t < n * t:‖1
if 4 * q + r - t < n * t:‖result += str(n)‖1
result += str(n)‖if counter == 0:‖1
if counter == 0:‖"result += ""."""‖1
if decimal == counter:‖break‖1
counter += 1‖nr = 10 * (r - n * t)‖1
nr = 10 * (r - n * t)‖n = ((10 * (3 * q + r)) // t) - 10 * n‖1
n = ((10 * (3 * q + r)) // t) - 10 * n‖q *= 10‖1
q *= 10‖r = nr‖1
r = nr‖else:‖1
else:‖nr = (2 * q + r) * m‖1
nr = (2 * q + r) * m‖nn = (q * (7 * k) + 2 + (r * m)) // (t * m)‖1
nn = (q * (7 * k) + 2 + (r * m)) // (t * m)‖q *= k‖1
q *= k‖t *= m‖1
t *= m‖m += 2‖1
m += 2‖k += 1‖1
k += 1‖n = nn‖1
n = nn‖r = nr‖1
r = nr‖return result‖1
def main() -> None:‖"print(f""{calculate_pi(50) = }"")"‖1
"print(f""{calculate_pi(50) = }"")"‖import doctest‖1
if power < 0:‖return -1‖1
return -1‖base %= mod‖1
base %= mod‖result = 1‖1
while power > 0:‖if power & 1:‖1
if power & 1:‖result = (result * base) % mod‖1
result = (result * base) % mod‖power = power >> 1‖1
power = power >> 1‖base = (base * base) % mod‖1
def main():‖print(modular_exponential(3, 200, 13))‖1
import math‖from collections.abc import Generator‖1
def slow_primes(max_n: int) -> Generator[int]:‖numbers: Generator = (i for i in range(1, (max_n + 1)))‖1
numbers: Generator = (i for i in range(1, (max_n + 1)))‖for i in (n for n in numbers if n > 1):‖2
for i in (n for n in numbers if n > 1):‖for j in range(2, i):‖1
for j in range(2, i):‖if (i % j) == 0:‖1
if (i % j) == 0:‖break‖3
else:‖yield i‖3
def primes(max_n: int) -> Generator[int]:‖numbers: Generator = (i for i in range(1, (max_n + 1)))‖1
bound = int(math.sqrt(i)) + 1‖for j in range(2, bound):‖1
for j in range(2, bound):‖if (i % j) == 0:‖1
def fast_primes(max_n: int) -> Generator[int]:‖numbers: Generator = (i for i in range(1, (max_n + 1), 2))‖1
if max_n > 2:‖yield 2‖1
yield 2‖for i in (n for n in numbers if n > 1):‖1
for i in (n for n in numbers if n > 1):‖bound = int(math.sqrt(i)) + 1‖1
bound = int(math.sqrt(i)) + 1‖for j in range(3, bound, 2):‖1
def benchmark():‖from timeit import timeit‖1
"setup = ""from __main__ import slow_primes, primes, fast_primes"""‖"print(timeit(""slow_primes(1_000_000_000_000)"", setup=setup, number=1_000_000))"‖1
"print(timeit(""slow_primes(1_000_000_000_000)"", setup=setup, number=1_000_000))"‖"print(timeit(""primes(1_000_000_000_000)"", setup=setup, number=1_000_000))"‖1
"print(timeit(""primes(1_000_000_000_000)"", setup=setup, number=1_000_000))"‖"print(timeit(""fast_primes(1_000_000_000_000)"", setup=setup, number=1_000_000))"‖1
"if __name__ == ""__main__"":"‖"number = int(input(""Calculate primes up to:\n>> "").strip())"‖1
"number = int(input(""Calculate primes up to:\n>> "").strip())"‖for ret in primes(number):‖1
for ret in primes(number):‖print(ret)‖1
print(ret)‖benchmark()‖1
def perfect(number: int) -> bool:‖if not isinstance(number, int):‖2
if not isinstance(number, int):‖"raise ValueError(""number must be an integer"")"‖2
"raise ValueError(""number must be an integer"")"‖if number <= 0:‖2
if number <= 0:‖return False‖2
return False‖return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number‖2
testmod()‖"print(""Program to check whether a number is a Perfect number or not..."")"‖2
"print(""Program to check whether a number is a Perfect number or not..."")"‖try:‖2
try:‖"number = int(input(""Enter a positive integer: "").strip())"‖2
"number = int(input(""Enter a positive integer: "").strip())"‖except ValueError:‖2
except ValueError:‖"msg = ""number must be an integer"""‖2
"msg = ""number must be an integer"""‖raise ValueError(msg)‖1
if not isinstance(num, int):‖"raise ValueError(""multiplicative_persistence() only accepts integral values"")"‖1
"raise ValueError(""multiplicative_persistence() only accepts integral values"")"‖if num < 0:‖1
if num < 0:‖"raise ValueError(""multiplicative_persistence() does not accept negative values"")"‖1
steps = 0‖num_string = str(num)‖2
while len(num_string) != 1:‖numbers = [int(i) for i in num_string]‖2
total = 1‖for i in range(len(numbers)):‖1
for i in range(len(numbers)):‖total *= numbers[i]‖1
steps += 1‖return steps‖2
if not isinstance(num, int):‖"raise ValueError(""additive_persistence() only accepts integral values"")"‖1
"raise ValueError(""additive_persistence() only accepts integral values"")"‖if num < 0:‖1
if num < 0:‖"raise ValueError(""additive_persistence() does not accept negative values"")"‖1
total = 0‖for i in range(len(numbers)):‖1
for i in range(len(numbers)):‖total += numbers[i]‖1
def minkowski_distance(‖point_a: list[float],‖1
point_a: list[float],‖point_b: list[float],‖1
point_b: list[float],‖order: int,‖1
order: int,‖) -> float:‖1
) -> float:‖if order < 1:‖1
if order < 1:‖"raise ValueError(""The order must be greater than or equal to 1."")"‖1
def perfect_square(num: int) -> bool:‖return math.sqrt(num) * math.sqrt(num) == num‖1
def perfect_square_binary_search(n: int) -> bool:‖left = 0‖1
left = 0‖right = n‖2
right = n‖while left <= right:‖2
while left <= right:‖mid = (left + right) // 2‖1
mid = (left + right) // 2‖if mid**2 == n:‖1
if mid**2 == n:‖return True‖1
return True‖elif mid**2 > n:‖1
elif mid**2 > n:‖right = mid - 1‖1
right = mid - 1‖else:‖1
else:‖left = mid + 1‖1
left = mid + 1‖return False‖1
class Dice:‖NUM_SIDES = 6‖1
def __init__(self):‖self.sides = list(range(1, Dice.NUM_SIDES + 1))‖1
def roll(self):‖return random.choice(self.sides)‖1
def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:‖dices = [Dice() for i in range(num_dice)]‖1
dices = [Dice() for i in range(num_dice)]‖count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)‖1
count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)‖for _ in range(num_throws):‖1
for _ in range(num_throws):‖count_of_sum[sum(dice.roll() for dice in dices)] += 1‖1
count_of_sum[sum(dice.roll() for dice in dices)] += 1‖probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]‖1
probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]‖return probability[num_dice:]‖1
def perfect_cube(n: int) -> bool:‖val = n ** (1 / 3)‖1
val = n ** (1 / 3)‖return (val * val * val) == n‖1
def perfect_cube_binary_search(n: int) -> bool:‖if not isinstance(n, int):‖1
if not isinstance(n, int):‖"raise TypeError(""perfect_cube_binary_search() only accepts integers"")"‖1
"raise TypeError(""perfect_cube_binary_search() only accepts integers"")"‖if n < 0:‖1
if n < 0:‖n = -n‖1
n = -n‖left = 0‖1
while left <= right:‖mid = left + (right - left) // 2‖1
mid = left + (right - left) // 2‖if mid * mid * mid == n:‖1
if mid * mid * mid == n:‖return True‖1
return True‖elif mid * mid * mid < n:‖1
elif mid * mid * mid < n:‖left = mid + 1‖1
left = mid + 1‖else:‖2
else:‖right = mid - 1‖2
right = mid - 1‖return False‖1
class Point:‖def __init__(self, x, y, z):‖1
def __init__(self, x, y, z):‖self.x = x‖1
self.y = y‖self.z = z‖1
def __repr__(self) -> str:‖"return f""Point({self.x}, {self.y}, {self.z})"""‖1
def distance(a: Point, b: Point) -> float:‖return math.sqrt(abs((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2))‖1
if a == 0:‖"raise ValueError(""Coefficient 'a' must not be zero."")"‖1
"raise ValueError(""Coefficient 'a' must not be zero."")"‖delta = b * b - 4 * a * c‖1
root_1 = (-b + sqrt(delta)) / (2 * a)‖root_2 = (-b - sqrt(delta)) / (2 * a)‖1
return (‖root_1.real if not root_1.imag else root_1,‖1
root_1.real if not root_1.imag else root_1,‖root_2.real if not root_2.imag else root_2,‖1
root_2.real if not root_2.imag else root_2,‖)‖1
def main():‖solution1, solution2 = quadratic_roots(a=5, b=6, c=1)‖1
solution1, solution2 = quadratic_roots(a=5, b=6, c=1)‖"print(f""The solutions are: {solution1} and {solution2}"")"‖1
def multiplication_table(number: int, number_of_terms: int) -> str:‖"return ""\n"".join("‖1
"return ""\n"".join("‖"f""{number} * {i} = {number * i}"" for i in range(1, number_of_terms + 1)"‖1
"f""{number} * {i} = {number * i}"" for i in range(1, number_of_terms + 1)"‖)‖1
"if __name__ == ""__main__"":"‖print(multiplication_table(number=5, number_of_terms=10))‖1
if n <= 0 or isinstance(n, float):‖"msg = f""Number {n} must instead be a positive integer"""‖1
"msg = f""Number {n} must instead be a positive integer"""‖raise ValueError(msg)‖2
in_prime = []‖start = 2‖1
start = 2‖end = int(math.sqrt(n))‖1
end = int(math.sqrt(n))‖temp = [True] * (end + 1)‖1
temp = [True] * (end + 1)‖prime = []‖1
while start <= end:‖if temp[start] is True:‖1
if temp[start] is True:‖in_prime.append(start)‖1
in_prime.append(start)‖for i in range(start * start, end + 1, start):‖1
for i in range(start * start, end + 1, start):‖temp[i] = False‖1
temp[i] = False‖start += 1‖1
start += 1‖prime += in_prime‖1
low = end + 1‖high = min(2 * end, n)‖1
while low <= n:‖temp = [True] * (high - low + 1)‖1
temp = [True] * (high - low + 1)‖for each in in_prime:‖1
for each in in_prime:‖t = math.floor(low / each) * each‖1
t = math.floor(low / each) * each‖if t < low:‖1
if t < low:‖t += each‖1
for j in range(t, high + 1, each):‖temp[j - low] = False‖1
for j in range(len(temp)):‖if temp[j] is True:‖1
if temp[j] is True:‖prime.append(j + low)‖1
low = high + 1‖high = min(high + end, n)‖1
Vector3d = tuple[float, float, float]‖Point3d = tuple[float, float, float]‖1
def create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:‖x = end_point2[0] - end_point1[0]‖1
x = end_point2[0] - end_point1[0]‖y = end_point2[1] - end_point1[1]‖1
y = end_point2[1] - end_point1[1]‖z = end_point2[2] - end_point1[2]‖1
z = end_point2[2] - end_point1[2]‖return (x, y, z)‖1
def get_3d_vectors_cross(ab: Vector3d, ac: Vector3d) -> Vector3d:‖x = ab[1] * ac[2] - ab[2] * ac[1]‖1
x = ab[1] * ac[2] - ab[2] * ac[1]‖y = (ab[0] * ac[2] - ab[2] * ac[0]) * -1‖1
y = (ab[0] * ac[2] - ab[2] * ac[0]) * -1‖z = ab[0] * ac[1] - ab[1] * ac[0]‖1
z = ab[0] * ac[1] - ab[1] * ac[0]‖return (x, y, z)‖1
def is_zero_vector(vector: Vector3d, accuracy: int) -> bool:‖return tuple(round(x, accuracy) for x in vector) == (0, 0, 0)‖1
def are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:‖ab = create_vector(a, b)‖1
ab = create_vector(a, b)‖ac = create_vector(a, c)‖1
ac = create_vector(a, c)‖return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)‖1
def evaluate_poly(poly: Sequence[float], x: float) -> float:‖return sum(c * (x**i) for i, c in enumerate(poly))‖1
def horner(poly: Sequence[float], x: float) -> float:‖result = 0.0‖1
result = 0.0‖for coeff in reversed(poly):‖1
for coeff in reversed(poly):‖result = result * x + coeff‖1
result = result * x + coeff‖return result‖1
"if __name__ == ""__main__"":"‖poly = (0.0, 0.0, 5.0, 9.3, 7.0)‖1
poly = (0.0, 0.0, 5.0, 9.3, 7.0)‖x = 10.0‖1
x = 10.0‖print(evaluate_poly(poly, x))‖1
print(evaluate_poly(poly, x))‖print(horner(poly, x))‖1
def power(base: int, exponent: int) -> float:‖return base * power(base, (exponent - 1)) if exponent else 1‖1
testmod()‖"print(""Raise base to the power of exponent using recursion..."")"‖1
"print(""Raise base to the power of exponent using recursion..."")"‖"base = int(input(""Enter the base: "").strip())"‖1
"base = int(input(""Enter the base: "").strip())"‖"exponent = int(input(""Enter the exponent: "").strip())"‖1
"exponent = int(input(""Enter the exponent: "").strip())"‖result = power(base, abs(exponent))‖1
result = power(base, abs(exponent))‖if exponent < 0:‖1
if exponent < 0:‖result = 1 / result‖1
result = 1 / result‖"print(f""{base} to the power of {exponent} is {result}"")"‖1
def sigmoid(vector: np.ndarray) -> np.ndarray:‖return 1 / (1 + np.exp(-vector))‖3
import mpmath‖import numpy as np‖1
self.polyA = list(poly_a or [0])[:]‖self.polyB = list(poly_b or [0])[:]‖1
while self.polyA[-1] == 0:‖self.polyA.pop()‖1
self.polyA.pop()‖self.len_A = len(self.polyA)‖1
while self.polyB[-1] == 0:‖self.polyB.pop()‖1
self.polyB.pop()‖self.len_B = len(self.polyB)‖1
self.c_max_length = int(‖2 ** np.ceil(np.log2(len(self.polyA) + len(self.polyB) - 1))‖1
2 ** np.ceil(np.log2(len(self.polyA) + len(self.polyB) - 1))‖)‖1
while len(self.polyA) < self.c_max_length:‖self.polyA.append(0)‖1
self.polyA.append(0)‖while len(self.polyB) < self.c_max_length:‖1
while len(self.polyB) < self.c_max_length:‖self.polyB.append(0)‖1
def __dft(self, which):‖"dft = [[x] for x in self.polyA] if which == ""A"" else [[x] for x in self.polyB]"‖1
if len(dft) <= 1:‖return dft[0]‖1
return dft[0]‖next_ncol = self.c_max_length // 2‖1
next_ncol = self.c_max_length // 2‖while next_ncol > 0:‖1
while next_ncol > 0:‖new_dft = [[] for i in range(next_ncol)]‖1
new_dft = [[] for i in range(next_ncol)]‖root = self.root**next_ncol‖1
current_root = 1‖for j in range(self.c_max_length // (next_ncol * 2)):‖2
for j in range(self.c_max_length // (next_ncol * 2)):‖for i in range(next_ncol):‖2
for i in range(next_ncol):‖new_dft[i].append(dft[i][j] + current_root * dft[i + next_ncol][j])‖1
new_dft[i].append(dft[i][j] + current_root * dft[i + next_ncol][j])‖current_root *= root‖1
for i in range(next_ncol):‖new_dft[i].append(dft[i][j] - current_root * dft[i + next_ncol][j])‖1
new_dft[i].append(dft[i][j] - current_root * dft[i + next_ncol][j])‖current_root *= root‖1
dft = new_dft‖next_ncol = next_ncol // 2‖1
next_ncol = next_ncol // 2‖return dft[0]‖1
def __multiply(self):‖"dft_a = self.__dft(""A"")"‖1
"dft_a = self.__dft(""A"")"‖"dft_b = self.__dft(""B"")"‖1
"dft_b = self.__dft(""B"")"‖inverce_c = [[dft_a[i] * dft_b[i] for i in range(self.c_max_length)]]‖1
inverce_c = [[dft_a[i] * dft_b[i] for i in range(self.c_max_length)]]‖del dft_a‖1
del dft_a‖del dft_b‖1
if len(inverce_c[0]) <= 1:‖return inverce_c[0]‖1
next_ncol = 2‖while next_ncol <= self.c_max_length:‖1
while next_ncol <= self.c_max_length:‖new_inverse_c = [[] for i in range(next_ncol)]‖1
new_inverse_c = [[] for i in range(next_ncol)]‖root = self.root ** (next_ncol // 2)‖1
root = self.root ** (next_ncol // 2)‖current_root = 1‖1
for j in range(self.c_max_length // next_ncol):‖for i in range(next_ncol // 2):‖1
new_inverse_c[i].append(‖(‖1
(‖inverce_c[i][j]‖2
inverce_c[i][j]‖+ inverce_c[i][j + self.c_max_length // next_ncol]‖1
+ inverce_c[i][j + self.c_max_length // next_ncol]‖)‖1
)‖/ 2‖1
/ 2‖)‖1
new_inverse_c[i + next_ncol // 2].append(‖(‖1
inverce_c[i][j]‖- inverce_c[i][j + self.c_max_length // next_ncol]‖1
- inverce_c[i][j + self.c_max_length // next_ncol]‖)‖1
)‖/ (2 * current_root)‖1
/ (2 * current_root)‖)‖1
)‖current_root *= root‖1
inverce_c = new_inverse_c‖next_ncol *= 2‖1
while inverce_c[-1] == 0:‖inverce_c.pop()‖1
inverce_c.pop()‖return inverce_c‖1
def __str__(self):‖"a = ""A = "" + "" + "".join("‖1
"a = ""A = "" + "" + "".join("‖"f""{coef}*x^{i}"" for coef, i in enumerate(self.polyA[: self.len_A])"‖1
"f""{coef}*x^{i}"" for coef, i in enumerate(self.polyA[: self.len_A])"‖)‖1
)‖"b = ""B = "" + "" + "".join("‖1
"b = ""B = "" + "" + "".join("‖"f""{coef}*x^{i}"" for coef, i in enumerate(self.polyB[: self.len_B])"‖1
"f""{coef}*x^{i}"" for coef, i in enumerate(self.polyB[: self.len_B])"‖)‖1
)‖"c = ""A*B = "" + "" + "".join("‖1
"c = ""A*B = "" + "" + "".join("‖"f""{coef}*x^{i}"" for coef, i in enumerate(self.product)"‖1
"f""{coef}*x^{i}"" for coef, i in enumerate(self.product)"‖)‖1
duplicate_set = current_set.copy()‖for row_index, row in enumerate(duplicate_set):‖1
for row_index, row in enumerate(duplicate_set):‖magnitude = row[0]‖1
magnitude = row[0]‖for column_index, column in enumerate(row):‖1
for column_index, column in enumerate(row):‖if magnitude == 0:‖1
if magnitude == 0:‖current_set[row_index][column_index] = column‖1
current_set[row_index][column_index] = column‖continue‖1
continue‖current_set[row_index][column_index] = column / magnitude‖1
first_row = current_set[0]‖final_set = [first_row]‖1
final_set = [first_row]‖current_set = current_set[1::]‖1
current_set = current_set[1::]‖for row in current_set:‖1
for row in current_set:‖temp_row = []‖1
if row[0] == 0:‖final_set.append(row)‖1
final_set.append(row)‖continue‖1
continue‖for column_index in range(len(row)):‖1
for column_index in range(len(row)):‖temp_row.append(first_row[column_index] - row[column_index])‖1
temp_row.append(first_row[column_index] - row[column_index])‖final_set.append(temp_row)‖1
if len(final_set[0]) != 3:‖current_first_row = final_set[0]‖1
current_first_row = final_set[0]‖current_first_column = []‖1
current_first_column = []‖next_iteration = []‖1
next_iteration = []‖for row in final_set[1::]:‖1
for row in final_set[1::]:‖current_first_column.append(row[0])‖1
current_first_column.append(row[0])‖next_iteration.append(row[1::])‖1
next_iteration.append(row[1::])‖resultant = simplify(next_iteration)‖1
resultant = simplify(next_iteration)‖for i in range(len(resultant)):‖1
for i in range(len(resultant)):‖resultant[i].insert(0, current_first_column[i])‖1
resultant[i].insert(0, current_first_column[i])‖resultant.insert(0, current_first_row)‖1
resultant.insert(0, current_first_row)‖final_set = resultant‖1
final_set = resultant‖return final_set‖1
def solve_simultaneous(equations: list[list]) -> list:‖if len(equations) == 0:‖1
if len(equations) == 0:‖"raise IndexError(""solve_simultaneous() requires n lists of length n+1"")"‖1
"raise IndexError(""solve_simultaneous() requires n lists of length n+1"")"‖_length = len(equations) + 1‖1
_length = len(equations) + 1‖if any(len(item) != _length for item in equations):‖1
if any(len(item) != _length for item in equations):‖"raise IndexError(""solve_simultaneous() requires n lists of length n+1"")"‖1
"raise IndexError(""solve_simultaneous() requires n lists of length n+1"")"‖for row in equations:‖1
for row in equations:‖if any(not isinstance(column, (int, float)) for column in row):‖1
if any(not isinstance(column, (int, float)) for column in row):‖"raise ValueError(""solve_simultaneous() requires lists of integers"")"‖1
"raise ValueError(""solve_simultaneous() requires lists of integers"")"‖if len(equations) == 1:‖1
if len(equations) == 1:‖return [equations[0][-1] / equations[0][0]]‖1
return [equations[0][-1] / equations[0][0]]‖data_set = equations.copy()‖1
data_set = equations.copy()‖if any(0 in row for row in data_set):‖1
if any(0 in row for row in data_set):‖temp_data = data_set.copy()‖1
temp_data = data_set.copy()‖full_row = []‖1
full_row = []‖for row_index, row in enumerate(temp_data):‖1
for row_index, row in enumerate(temp_data):‖if 0 not in row:‖1
if 0 not in row:‖full_row = data_set.pop(row_index)‖1
full_row = data_set.pop(row_index)‖break‖1
break‖if not full_row:‖1
if not full_row:‖"raise ValueError(""solve_simultaneous() requires at least 1 full equation"")"‖1
"raise ValueError(""solve_simultaneous() requires at least 1 full equation"")"‖data_set.insert(0, full_row)‖1
data_set.insert(0, full_row)‖useable_form = data_set.copy()‖1
useable_form = data_set.copy()‖simplified = simplify(useable_form)‖1
simplified = simplify(useable_form)‖simplified = simplified[::-1]‖1
simplified = simplified[::-1]‖solutions: list = []‖1
solutions: list = []‖for row in simplified:‖1
for row in simplified:‖current_solution = row[-1]‖1
current_solution = row[-1]‖if not solutions:‖1
if not solutions:‖if row[-2] == 0:‖1
if row[-2] == 0:‖solutions.append(0)‖1
solutions.append(0)‖continue‖2
continue‖solutions.append(current_solution / row[-2])‖1
solutions.append(current_solution / row[-2])‖continue‖1
continue‖temp_row = row.copy()[: len(row) - 1 :]‖1
temp_row = row.copy()[: len(row) - 1 :]‖while temp_row[0] == 0:‖1
while temp_row[0] == 0:‖temp_row.pop(0)‖1
temp_row.pop(0)‖if len(temp_row) == 0:‖1
if len(temp_row) == 0:‖solutions.append(0)‖1
continue‖temp_row = temp_row[1::]‖1
temp_row = temp_row[1::]‖temp_row = temp_row[::-1]‖1
temp_row = temp_row[::-1]‖for column_index, column in enumerate(temp_row):‖1
for column_index, column in enumerate(temp_row):‖current_solution -= column * solutions[column_index]‖1
current_solution -= column * solutions[column_index]‖solutions.append(current_solution)‖1
solutions.append(current_solution)‖final = []‖1
final = []‖for item in solutions:‖1
for item in solutions:‖final.append(float(round(item, 5)))‖1
final.append(float(round(item, 5)))‖return final[::-1]‖1
doctest.testmod()‖eq = [‖1
eq = [‖[2, 1, 1, 1, 1, 4],‖1
[2, 1, 1, 1, 1, 4],‖[1, 2, 1, 1, 1, 5],‖1
[1, 2, 1, 1, 1, 5],‖[1, 1, 2, 1, 1, 6],‖1
[1, 1, 2, 1, 1, 6],‖[1, 1, 1, 2, 1, 7],‖1
[1, 1, 1, 2, 1, 7],‖[1, 1, 1, 1, 2, 8],‖1
[1, 1, 1, 1, 2, 8],‖]‖1
]‖print(solve_simultaneous(eq))‖1
print(solve_simultaneous(eq))‖print(solve_simultaneous([[4, 2]]))‖1
def sock_merchant(colors: list[int]) -> int:‖return sum(socks_by_color // 2 for socks_by_color in Counter(colors).values())‖1
"colors = [int(x) for x in input(""Enter socks by color :"").rstrip().split()]"‖"print(f""sock_merchant({colors}) = {sock_merchant(colors)}"")"‖1
if not isinstance(num, int):‖"raise TypeError(""only integers accepted as input"")"‖1
"raise TypeError(""only integers accepted as input"")"‖else:‖1
else:‖num_str = str(abs(num))‖1
num_str = str(abs(num))‖num_transpositions = [list(num_str) for char in range(len(num_str))]‖1
num_transpositions = [list(num_str) for char in range(len(num_str))]‖for index in range(len(num_str)):‖1
for index in range(len(num_str)):‖num_transpositions[index].pop(index)‖1
num_transpositions[index].pop(index)‖return max(‖1
return max(‖"int("""".join(list(transposition))) for transposition in num_transpositions"‖1
"int("""".join(list(transposition))) for transposition in num_transpositions"‖)‖1
if number <= 1:‖status = False‖1
if number % divisor == 0:‖status = False‖1
status = False‖break‖1
for i in range(len(begin_list)):‖for j in range(i + 1, len(begin_list)):‖1
for j in range(i + 1, len(begin_list)):‖if (begin_list[i] != 0) and (begin_list[j] % begin_list[i] == 0):‖1
if (begin_list[i] != 0) and (begin_list[j] % begin_list[i] == 0):‖begin_list[j] = 0‖1
for number in range(2, n + 1):‖if is_prime(number):‖1
if is_prime(number):‖ans.append(number)‖1
if number in {0, 1}:‖ans.append(number)‖1
elif not is_prime(number):‖while quotient != 1:‖1
while quotient != 1:‖if is_prime(factor) and (quotient % factor == 0):‖1
if is_prime(factor) and (quotient % factor == 0):‖ans.append(factor)‖1
ans.append(factor)‖quotient /= factor‖1
quotient /= factor‖else:‖1
else:‖factor += 1‖1
else:‖ans.append(number)‖1
assert isinstance(number, int) and (number >= 0), (‖"""'number' must been an int and >= 0"""‖2
"""'number' must been an int and >= 0"""‖)‖2
"assert isinstance(number, int), ""'number' must been an int"""‖"assert isinstance(number % 2 == 0, bool), ""compare must been from type bool"""‖1
"assert isinstance(number, int), ""'number' must been an int"""‖"assert isinstance(number % 2 != 0, bool), ""compare must been from type bool"""‖1
assert isinstance(number, int) and (number > 2) and is_even(number), (‖"""'number' must been an int, even and > 2"""‖1
"""'number' must been an int, even and > 2"""‖)‖1
prime_numbers = get_prime_numbers(number)‖len_pn = len(prime_numbers)‖1
i = 0‖j = None‖1
while i < len_pn and loop:‖j = i + 1‖1
while j < len_pn and loop:‖if prime_numbers[i] + prime_numbers[j] == number:‖1
if prime_numbers[i] + prime_numbers[j] == number:‖loop = False‖1
loop = False‖ans.append(prime_numbers[i])‖1
ans.append(prime_numbers[i])‖ans.append(prime_numbers[j])‖1
assert (‖isinstance(ans, list)‖2
isinstance(ans, list)‖and (len(ans) == 2)‖1
and (len(ans) == 2)‖and (ans[0] + ans[1] == number)‖1
and (ans[0] + ans[1] == number)‖and is_prime(ans[0])‖1
and is_prime(ans[0])‖and is_prime(ans[1])‖1
and is_prime(ans[1])‖"), ""'ans' must contains two primes. And sum of elements must been eq 'number'"""‖1
assert (‖isinstance(number1, int)‖1
isinstance(number1, int)‖and isinstance(number2, int)‖1
and isinstance(number2, int)‖and (number1 >= 1)‖1
and (number1 >= 1)‖and (number2 >= 1)‖1
and (number2 >= 1)‖"), ""'number1' and 'number2' must been positive integer."""‖1
prime_fac_1 = prime_factorization(number1)‖prime_fac_2 = prime_factorization(number2)‖1
elif number1 == 1 or number2 == 1:‖prime_fac_1 = []‖1
prime_fac_1 = []‖prime_fac_2 = []‖1
prime_fac_2 = []‖ans = max(number1, number2)‖1
count1 = 0‖count2 = 0‖1
for n in prime_fac_1:‖if n not in done:‖1
if n not in done:‖if n in prime_fac_2:‖1
if n in prime_fac_2:‖count1 = prime_fac_1.count(n)‖1
count1 = prime_fac_1.count(n)‖count2 = prime_fac_2.count(n)‖1
for _ in range(max(count1, count2)):‖ans *= n‖1
else:‖count1 = prime_fac_1.count(n)‖1
for _ in range(count1):‖ans *= n‖1
for n in prime_fac_2:‖if n not in done:‖1
if n not in done:‖count2 = prime_fac_2.count(n)‖1
for _ in range(count2):‖ans *= n‖1
assert isinstance(ans, int) and (ans >= 0), (‖"""'ans' must been from type int and positive"""‖1
"""'ans' must been from type int and positive"""‖)‖1
index = 0‖ans = 2‖1
while index < n:‖index += 1‖1
while not is_prime(ans):‖ans += 1‖1
assert isinstance(ans, int) and is_prime(ans), (‖"""'ans' must been a prime number and from type int"""‖1
"""'ans' must been a prime number and from type int"""‖)‖1
assert (‖is_prime(p_number_1) and is_prime(p_number_2) and (p_number_1 < p_number_2)‖1
is_prime(p_number_1) and is_prime(p_number_2) and (p_number_1 < p_number_2)‖"), ""The arguments must been prime numbers and 'pNumber1' < 'pNumber2'"""‖1
while not is_prime(number):‖number += 1‖2
while number < p_number_2:‖ans.append(number)‖1
isinstance(ans, list)‖and ans[0] != p_number_1‖1
and ans[0] != p_number_1‖and ans[len(ans) - 1] != p_number_2‖1
and ans[len(ans) - 1] != p_number_2‖"), ""'ans' must been a list without the arguments"""‖1
for divisor in range(1, n + 1):‖if n % divisor == 0:‖1
if n % divisor == 0:‖ans.append(divisor)‖1
assert isinstance(number, int) and (number > 1), (‖"""'number' must been an int and >= 1"""‖1
"""'number' must been an int and >= 1"""‖)‖1
assert (‖isinstance(divisors, list)‖1
isinstance(divisors, list)‖and (divisors[0] == 1)‖1
and (divisors[0] == 1)‖and (divisors[len(divisors) - 1] == number)‖1
and (divisors[len(divisors) - 1] == number)‖"), ""Error in help-function getDivisiors(...)"""‖1
assert (‖isinstance(numerator, int)‖1
isinstance(numerator, int)‖and isinstance(denominator, int)‖1
and isinstance(denominator, int)‖and (denominator != 0)‖1
and (denominator != 0)‖"), ""The arguments must been from type int and 'denominator' != 0"""‖1
assert (‖isinstance(gcd_of_fraction, int)‖1
isinstance(gcd_of_fraction, int)‖and (numerator % gcd_of_fraction == 0)‖1
and (numerator % gcd_of_fraction == 0)‖and (denominator % gcd_of_fraction == 0)‖1
and (denominator % gcd_of_fraction == 0)‖"), ""Error in function gcd_by_iterative(...,...)"""‖1
def factorial(n):‖return 1 if n == 1 else n * factorial(n - 1)‖1
tmp = 0‖fib1 = 1‖1
fib1 = 1‖ans = 1‖1
for _ in range(n - 1):‖tmp = ans‖1
tmp = ans‖ans += fib1‖1
ans += fib1‖fib1 = tmp‖1
def pollard_rho(‖num: int,‖1
num: int,‖seed: int = 2,‖1
seed: int = 2,‖step: int = 1,‖1
step: int = 1,‖attempts: int = 3,‖1
attempts: int = 3,‖) -> int | None:‖1
if num < 2:‖"raise ValueError(""The input value cannot be less than 2"")"‖1
if num > 2 and num % 2 == 0:‖return 2‖1
def rand_fn(value: int, step: int, modulus: int) -> int:‖return (pow(value, 2) + step) % modulus‖1
tortoise = seed‖hare = seed‖1
tortoise = rand_fn(tortoise, step, num)‖hare = rand_fn(hare, step, num)‖1
hare = rand_fn(hare, step, num)‖hare = rand_fn(hare, step, num)‖1
"if __name__ == ""__main__"":"‖import argparse‖1
parser.add_argument(‖"""num"","‖1
"""num"","‖type=int,‖1
type=int,‖"help=""The value to find a divisor of"","‖1
"help=""The value to find a divisor of"","‖)‖1
parser.add_argument(‖"""--attempts"","‖1
"""--attempts"","‖type=int,‖1
type=int,‖default=3,‖1
default=3,‖"help=""The number of attempts before giving up"","‖1
"help=""The number of attempts before giving up"","‖)‖1
)‖args = parser.parse_args()‖3
divisor = pollard_rho(args.num, attempts=args.attempts)‖if divisor is None:‖1
if divisor is None:‖"print(f""{args.num} is probably prime"")"‖1
"print(f""{args.num} is probably prime"")"‖else:‖1
else:‖quotient = args.num // divisor‖1
quotient = args.num // divisor‖"print(f""{args.num} = {divisor} * {quotient}"")"‖1
def sin(‖angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10‖1
angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10‖) -> float:‖1
result = angle_in_radians‖a = 3‖1
a = 3‖b = -1‖1
for _ in range(accuracy):‖result += (b * (angle_in_radians**a)) / factorial(a)‖1
b = -b‖a += 2‖1
def prime_factors(n: int) -> list[int]:‖i = 2‖1
i = 2‖factors = []‖1
factors = []‖while i * i <= n:‖1
while i * i <= n:‖if n % i:‖1
if n % i:‖i += 1‖1
i += 1‖else:‖2
else:‖n //= i‖1
n //= i‖factors.append(i)‖1
factors.append(i)‖if n > 1:‖1
if n > 1:‖factors.append(n)‖1
factors.append(n)‖return factors‖1
if num <= 0:‖"raise ValueError(""Input must be a positive integer"")"‖1
p = 2‖while p * p <= num:‖1
while p * p <= num:‖if primes[p]:‖1
if primes[p]:‖for i in range(p * p, num + 1, p):‖1
for i in range(p * p, num + 1, p):‖primes[i] = False‖1
primes[i] = False‖p += 1‖1
"user_num = int(input(""Enter a positive integer: "").strip())"‖print(prime_sieve_eratosthenes(user_num))‖1
def signum(num: float) -> int:‖if num < 0:‖1
if num < 0:‖return -1‖1
return -1‖return 1 if num else 0‖1
def test_signum() -> None:‖assert signum(5) == 1‖1
assert signum(5) == 1‖assert signum(-5) == -1‖1
assert signum(-5) == -1‖assert signum(0) == 0‖1
assert signum(0) == 0‖assert signum(10.5) == 1‖1
assert signum(10.5) == 1‖assert signum(-10.5) == -1‖1
assert signum(-10.5) == -1‖assert signum(1e-6) == 1‖1
assert signum(1e-6) == 1‖assert signum(-1e-6) == -1‖1
assert signum(-1e-6) == -1‖assert signum(123456789) == 1‖1
assert signum(123456789) == 1‖assert signum(-123456789) == -1‖1
"if __name__ == ""__main__"":"‖print(signum(12))‖1
print(signum(12))‖print(signum(-12))‖1
print(signum(-12))‖print(signum(0))‖1
if num <= 0:‖"msg = f""{num}: Invalid input, please enter a positive integer."""‖1
"msg = f""{num}: Invalid input, please enter a positive integer."""‖raise ValueError(msg)‖1
sieve = [True] * (num + 1)‖prime = []‖1
prime = []‖start = 2‖1
start = 2‖end = int(math.sqrt(num))‖1
if sieve[start] is True:‖prime.append(start)‖1
for i in range(start * start, num + 1, start):‖if sieve[i] is True:‖1
if sieve[i] is True:‖sieve[i] = False‖1
for j in range(end + 1, num + 1):‖if sieve[j] is True:‖1
if sieve[j] is True:‖prime.append(j)‖1
"if __name__ == ""__main__"":"‖"print(prime_sieve(int(input(""Enter a positive integer: "").strip())))"‖1
def sum_of_harmonic_progression(‖first_term: float, common_difference: float, number_of_terms: int‖1
first_term: float, common_difference: float, number_of_terms: int‖) -> float:‖1
) -> float:‖arithmetic_progression = [1 / first_term]‖1
arithmetic_progression = [1 / first_term]‖first_term = 1 / first_term‖1
first_term = 1 / first_term‖for _ in range(number_of_terms - 1):‖1
for _ in range(number_of_terms - 1):‖first_term += common_difference‖1
first_term += common_difference‖arithmetic_progression.append(first_term)‖1
arithmetic_progression.append(first_term)‖harmonic_series = [1 / step for step in arithmetic_progression]‖1
harmonic_series = [1 / step for step in arithmetic_progression]‖return sum(harmonic_series)‖1
doctest.testmod()‖print(sum_of_harmonic_progression(1 / 2, 2, 2))‖1
"if __name__ == ""__main__"":"‖print(softmax((0,)))‖1
def assign_ranks(data: Sequence[float]) -> list[int]:‖ranked_data = sorted((value, index) for index, value in enumerate(data))‖1
ranked_data = sorted((value, index) for index, value in enumerate(data))‖ranks = [0] * len(data)‖1
for position, (_, index) in enumerate(ranked_data):‖ranks[index] = position + 1‖1
def calculate_spearman_rank_correlation(‖variable_1: Sequence[float], variable_2: Sequence[float]‖1
variable_1: Sequence[float], variable_2: Sequence[float]‖) -> float:‖1
) -> float:‖n = len(variable_1)‖1
n = len(variable_1)‖rank_var1 = assign_ranks(variable_1)‖1
rank_var1 = assign_ranks(variable_1)‖rank_var2 = assign_ranks(variable_2)‖1
print(‖"f""{calculate_spearman_rank_correlation([1, 2, 3, 4, 5], [2, 4, 6, 8, 10]) = }"""‖1
"f""{calculate_spearman_rank_correlation([1, 2, 3, 4, 5], [2, 4, 6, 8, 10]) = }"""‖)‖1
def qr_householder(a: np.ndarray):‖m, n = a.shape‖1
m, n = a.shape‖t = min(m, n)‖1
t = min(m, n)‖q = np.eye(m)‖1
q = np.eye(m)‖r = a.copy()‖1
e1 = np.zeros_like(x)‖e1[0] = 1.0‖1
v = x + np.sign(x[0]) * alpha * e1‖v /= np.linalg.norm(v)‖1
q = q @ q_k.T‖r = q_k @ r‖1
if random_a in (0, 1):‖return random_a‖1
random_a %= number‖t = 1‖1
while random_a != 0:‖while random_a % 2 == 0:‖1
while random_a % 2 == 0:‖random_a //= 2‖1
random_a //= 2‖r = number % 8‖1
r = number % 8‖if r in (3, 5):‖1
if r in (3, 5):‖t = -t‖1
if random_a % 4 == number % 4 == 3:‖t = -t‖1
if number <= 1:‖return False‖1
return False‖if number <= 3:‖1
if number <= 3:‖return True‖1
for _ in range(iterations):‖a = random.randint(2, number - 2)‖1
a = random.randint(2, number - 2)‖x = jacobi_symbol(a, number)‖1
x = jacobi_symbol(a, number)‖y = pow(a, (number - 1) // 2, number)‖1
if x == 0 or y != x % number:‖return False‖1
def sylvester(number: int) -> int:‖"assert isinstance(number, int), f""The input value of [n={number}] is not an integer"""‖1
if number == 1:‖return 2‖1
return 2‖elif number < 1:‖1
elif number < 1:‖"msg = f""The input value of [n={number}] has to be > 0"""‖1
"msg = f""The input value of [n={number}] has to be > 0"""‖raise ValueError(msg)‖1
else:‖num = sylvester(number - 1)‖1
num = sylvester(number - 1)‖lower = num - 1‖1
lower = num - 1‖upper = num‖1
upper = num‖return lower * upper + 1‖1
"if __name__ == ""__main__"":"‖"print(f""The 8th number in Sylvester's sequence: {sylvester(8)}"")"‖1
def two_sum(nums: list[int], target: int) -> list[int]:‖chk_map: dict[int, int] = {}‖1
chk_map: dict[int, int] = {}‖for index, val in enumerate(nums):‖1
for index, val in enumerate(nums):‖compl = target - val‖1
compl = target - val‖if compl in chk_map:‖1
if compl in chk_map:‖return [chk_map[compl], index]‖1
return [chk_map[compl], index]‖chk_map[val] = index‖1
chk_map[val] = index‖return []‖1
doctest.testmod()‖"print(f""{two_sum([2, 7, 11, 15], 9) = }"")"‖1
from itertools import permutations‖from random import randint‖1
from random import randint‖from timeit import repeat‖1
def make_dataset() -> tuple[list[int], int]:‖arr = [randint(-1000, 1000) for i in range(10)]‖1
arr = [randint(-1000, 1000) for i in range(10)]‖r = randint(-5000, 5000)‖1
r = randint(-5000, 5000)‖return (arr, r)‖1
def triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:‖for triplet in permutations(arr, 3):‖1
for triplet in permutations(arr, 3):‖if sum(triplet) == target:‖1
if sum(triplet) == target:‖return tuple(sorted(triplet))‖1
return tuple(sorted(triplet))‖return (0, 0, 0)‖1
def triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:‖arr.sort()‖1
arr.sort()‖n = len(arr)‖1
n = len(arr)‖for i in range(n - 1):‖1
for i in range(n - 1):‖left, right = i + 1, n - 1‖1
left, right = i + 1, n - 1‖while left < right:‖1
while left < right:‖if arr[i] + arr[left] + arr[right] == target:‖1
if arr[i] + arr[left] + arr[right] == target:‖return (arr[i], arr[left], arr[right])‖1
return (arr[i], arr[left], arr[right])‖elif arr[i] + arr[left] + arr[right] < target:‖1
elif arr[i] + arr[left] + arr[right] < target:‖left += 1‖1
left += 1‖elif arr[i] + arr[left] + arr[right] > target:‖1
elif arr[i] + arr[left] + arr[right] > target:‖right -= 1‖1
right -= 1‖return (0, 0, 0)‖1
def trapezoidal_rule(boundary, steps):‖h = (boundary[1] - boundary[0]) / steps‖1
h = (boundary[1] - boundary[0]) / steps‖a = boundary[0]‖2
a = boundary[0]‖b = boundary[1]‖2
b = boundary[1]‖x_i = make_points(a, b, h)‖2
x_i = make_points(a, b, h)‖y = 0.0‖2
y = 0.0‖y += (h / 2.0) * f(a)‖1
y += (h / 2.0) * f(a)‖for i in x_i:‖1
for i in x_i:‖y += h * f(i)‖1
y += h * f(i)‖y += (h / 2.0) * f(b)‖1
y += (h / 2.0) * f(b)‖return y‖1
def make_points(a, b, h):‖x = a + h‖2
x = a + h‖while x <= (b - h):‖1
while x <= (b - h):‖yield x‖1
yield x‖x += h‖1
def f(x):‖return x**2‖1
def main():‖a = 0.0‖2
a = 0.0‖b = 1.0‖2
b = 1.0‖steps = 10.0‖2
steps = 10.0‖boundary = [a, b]‖2
boundary = [a, b]‖y = trapezoidal_rule(boundary, steps)‖1
y = trapezoidal_rule(boundary, steps)‖"print(f""y = {y}"")"‖1
def three_sum(nums: list[int]) -> list[list[int]]:‖nums.sort()‖1
nums.sort()‖ans = []‖1
ans = []‖for i in range(len(nums) - 2):‖1
for i in range(len(nums) - 2):‖if i == 0 or (nums[i] != nums[i - 1]):‖1
if i == 0 or (nums[i] != nums[i - 1]):‖low, high, c = i + 1, len(nums) - 1, 0 - nums[i]‖1
low, high, c = i + 1, len(nums) - 1, 0 - nums[i]‖while low < high:‖1
while low < high:‖if nums[low] + nums[high] == c:‖1
if nums[low] + nums[high] == c:‖ans.append([nums[i], nums[low], nums[high]])‖1
while low < high and nums[low] == nums[low + 1]:‖low += 1‖1
low += 1‖while low < high and nums[high] == nums[high - 1]:‖1
while low < high and nums[high] == nums[high - 1]:‖high -= 1‖1
low += 1‖high -= 1‖1
high -= 1‖elif nums[low] + nums[high] < c:‖1
elif nums[low] + nums[high] < c:‖low += 1‖1
low += 1‖else:‖1
else:‖high -= 1‖1
high -= 1‖return ans‖1
def twin_prime(number: int) -> int:‖if not isinstance(number, int):‖1
raise TypeError(msg)‖if is_prime(number) and is_prime(number + 2):‖1
if is_prime(number) and is_prime(number + 2):‖return number + 2‖1
return number + 2‖else:‖1
else:‖return -1‖2
from collections.abc import Callable‖from dataclasses import dataclass‖1
@dataclass‖class AdamsBashforth:‖1
func: Callable[[float, float], float]‖x_initials: list[float]‖1
x_initials: list[float]‖y_initials: list[float]‖1
y_initials: list[float]‖step_size: float‖1
step_size: float‖x_final: float‖1
def __post_init__(self) -> None:‖if self.x_initials[-1] >= self.x_final:‖1
if self.x_initials[-1] >= self.x_final:‖raise ValueError(‖1
raise ValueError(‖"""The final value of x must be greater than the initial values of x."""‖1
"""The final value of x must be greater than the initial values of x."""‖)‖1
if self.step_size <= 0:‖"raise ValueError(""Step size must be positive."")"‖1
if not all(‖round(x1 - x0, 10) == self.step_size‖1
round(x1 - x0, 10) == self.step_size‖for x0, x1 in zip(self.x_initials, self.x_initials[1:])‖1
for x0, x1 in zip(self.x_initials, self.x_initials[1:])‖):‖1
):‖"raise ValueError(""x-values must be equally spaced according to step size."")"‖1
if len(self.x_initials) != 2 or len(self.y_initials) != 2:‖"raise ValueError(""Insufficient initial points information."")"‖1
x_0, x_1 = self.x_initials[:2]‖y_0, y_1 = self.y_initials[:2]‖1
n = int((self.x_final - x_1) / self.step_size)‖y = np.zeros(n + 2)‖1
y = np.zeros(n + 2)‖y[0] = y_0‖1
y[0] = y_0‖y[1] = y_1‖4
for i in range(n):‖y[i + 2] = y[i + 1] + (self.step_size / 2) * (‖1
y[i + 2] = y[i + 1] + (self.step_size / 2) * (‖3 * self.func(x_1, y[i + 1]) - self.func(x_0, y[i])‖1
3 * self.func(x_1, y[i + 1]) - self.func(x_0, y[i])‖)‖1
)‖x_0 = x_1‖4
x_0 = x_1‖x_1 += self.step_size‖1
def step_3(self) -> np.ndarray:‖if len(self.x_initials) != 3 or len(self.y_initials) != 3:‖1
if len(self.x_initials) != 3 or len(self.y_initials) != 3:‖"raise ValueError(""Insufficient initial points information."")"‖1
x_0, x_1, x_2 = self.x_initials[:3]‖y_0, y_1, y_2 = self.y_initials[:3]‖1
n = int((self.x_final - x_2) / self.step_size)‖y = np.zeros(n + 4)‖1
y = np.zeros(n + 4)‖y[0] = y_0‖2
y[1] = y_1‖y[2] = y_2‖3
for i in range(n + 1):‖y[i + 3] = y[i + 2] + (self.step_size / 12) * (‖1
y[i + 3] = y[i + 2] + (self.step_size / 12) * (‖23 * self.func(x_2, y[i + 2])‖1
23 * self.func(x_2, y[i + 2])‖- 16 * self.func(x_1, y[i + 1])‖1
- 16 * self.func(x_1, y[i + 1])‖+ 5 * self.func(x_0, y[i])‖1
+ 5 * self.func(x_0, y[i])‖)‖1
x_0 = x_1‖x_1 = x_2‖3
x_1 = x_2‖x_2 += self.step_size‖1
if len(self.x_initials) != 4 or len(self.y_initials) != 4:‖"raise ValueError(""Insufficient initial points information."")"‖1
x_0, x_1, x_2, x_3 = self.x_initials[:4]‖y_0, y_1, y_2, y_3 = self.y_initials[:4]‖1
n = int((self.x_final - x_3) / self.step_size)‖y = np.zeros(n + 4)‖1
y[2] = y_2‖y[3] = y_3‖2
for i in range(n):‖y[i + 4] = y[i + 3] + (self.step_size / 24) * (‖1
y[i + 4] = y[i + 3] + (self.step_size / 24) * (‖55 * self.func(x_3, y[i + 3])‖1
55 * self.func(x_3, y[i + 3])‖- 59 * self.func(x_2, y[i + 2])‖1
- 59 * self.func(x_2, y[i + 2])‖+ 37 * self.func(x_1, y[i + 1])‖1
+ 37 * self.func(x_1, y[i + 1])‖- 9 * self.func(x_0, y[i])‖1
- 9 * self.func(x_0, y[i])‖)‖1
x_1 = x_2‖x_2 = x_3‖2
x_2 = x_3‖x_3 += self.step_size‖1
if len(self.x_initials) != 5 or len(self.y_initials) != 5:‖"raise ValueError(""Insufficient initial points information."")"‖1
x_0, x_1, x_2, x_3, x_4 = self.x_initials[:5]‖y_0, y_1, y_2, y_3, y_4 = self.y_initials[:5]‖1
n = int((self.x_final - x_4) / self.step_size)‖y = np.zeros(n + 6)‖1
y = np.zeros(n + 6)‖y[0] = y_0‖1
y[3] = y_3‖y[4] = y_4‖1
for i in range(n + 1):‖y[i + 5] = y[i + 4] + (self.step_size / 720) * (‖1
y[i + 5] = y[i + 4] + (self.step_size / 720) * (‖1901 * self.func(x_4, y[i + 4])‖1
1901 * self.func(x_4, y[i + 4])‖- 2774 * self.func(x_3, y[i + 3])‖1
- 2774 * self.func(x_3, y[i + 3])‖- 2616 * self.func(x_2, y[i + 2])‖1
- 2616 * self.func(x_2, y[i + 2])‖- 1274 * self.func(x_1, y[i + 1])‖1
- 1274 * self.func(x_1, y[i + 1])‖+ 251 * self.func(x_0, y[i])‖1
+ 251 * self.func(x_0, y[i])‖)‖1
x_2 = x_3‖x_3 = x_4‖1
x_3 = x_4‖x_4 += self.step_size‖1
def sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:‖total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)‖1
def main():‖print(sum_of_series(1, 1, 10))‖1
def sum_of_geometric_progression(‖first_term: int, common_ratio: int, num_of_terms: int‖1
first_term: int, common_ratio: int, num_of_terms: int‖) -> float:‖1
) -> float:‖if common_ratio == 1:‖1
if side_length < 0:‖"raise ValueError(""vol_cube() only accepts non-negative values"")"‖1
"raise ValueError(""vol_cube() only accepts non-negative values"")"‖return pow(side_length, 3)‖1
if height < 0 or radius < 0:‖"raise ValueError(""vol_spherical_cap() only accepts non-negative values"")"‖1
def vol_spheres_intersect(‖radius_1: float, radius_2: float, centers_distance: float‖1
radius_1: float, radius_2: float, centers_distance: float‖) -> float:‖2
if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:‖"raise ValueError(""vol_spheres_intersect() only accepts non-negative values"")"‖1
"raise ValueError(""vol_spheres_intersect() only accepts non-negative values"")"‖if centers_distance == 0:‖1
if centers_distance == 0:‖return vol_sphere(min(radius_1, radius_2))‖1
h1 = (‖(radius_1 - radius_2 + centers_distance)‖1
(radius_1 - radius_2 + centers_distance)‖* (radius_1 + radius_2 - centers_distance)‖1
* (radius_1 + radius_2 - centers_distance)‖/ (2 * centers_distance)‖1
/ (2 * centers_distance)‖)‖2
)‖h2 = (‖1
h2 = (‖(radius_2 - radius_1 + centers_distance)‖1
(radius_2 - radius_1 + centers_distance)‖* (radius_2 + radius_1 - centers_distance)‖1
* (radius_2 + radius_1 - centers_distance)‖/ (2 * centers_distance)‖1
def vol_spheres_union(‖radius_1: float, radius_2: float, centers_distance: float‖1
if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:‖raise ValueError(‖1
raise ValueError(‖"""vol_spheres_union() only accepts non-negative values, non-zero radius"""‖1
"""vol_spheres_union() only accepts non-negative values, non-zero radius"""‖)‖1
if centers_distance == 0:‖return vol_sphere(max(radius_1, radius_2))‖1
return (‖vol_sphere(radius_1)‖1
vol_sphere(radius_1)‖+ vol_sphere(radius_2)‖1
+ vol_sphere(radius_2)‖- vol_spheres_intersect(radius_1, radius_2, centers_distance)‖1
- vol_spheres_intersect(radius_1, radius_2, centers_distance)‖)‖1
if width < 0 or height < 0 or length < 0:‖"raise ValueError(""vol_cuboid() only accepts non-negative values"")"‖1
"raise ValueError(""vol_cuboid() only accepts non-negative values"")"‖return float(width * height * length)‖1
if height < 0 or area_of_base < 0:‖"raise ValueError(""vol_cone() only accepts non-negative values"")"‖1
"raise ValueError(""vol_cone() only accepts non-negative values"")"‖return area_of_base * height / 3.0‖1
if height < 0 or radius < 0:‖"raise ValueError(""vol_right_circ_cone() only accepts non-negative values"")"‖1
"raise ValueError(""vol_right_circ_cone() only accepts non-negative values"")"‖return pi * pow(radius, 2) * height / 3.0‖1
if height < 0 or area_of_base < 0:‖"raise ValueError(""vol_prism() only accepts non-negative values"")"‖1
"raise ValueError(""vol_prism() only accepts non-negative values"")"‖return float(area_of_base * height)‖1
if height < 0 or area_of_base < 0:‖"raise ValueError(""vol_pyramid() only accepts non-negative values"")"‖1
"raise ValueError(""vol_pyramid() only accepts non-negative values"")"‖return area_of_base * height / 3.0‖1
if radius < 0:‖"raise ValueError(""vol_sphere() only accepts non-negative values"")"‖1
if radius < 0:‖"raise ValueError(""vol_hemisphere() only accepts non-negative values"")"‖1
if height < 0 or radius < 0:‖"raise ValueError(""vol_circular_cylinder() only accepts non-negative values"")"‖1
def vol_hollow_circular_cylinder(‖inner_radius: float, outer_radius: float, height: float‖1
inner_radius: float, outer_radius: float, height: float‖) -> float:‖1
if inner_radius < 0 or outer_radius < 0 or height < 0:‖raise ValueError(‖1
raise ValueError(‖"""vol_hollow_circular_cylinder() only accepts non-negative values"""‖1
"""vol_hollow_circular_cylinder() only accepts non-negative values"""‖)‖1
)‖if outer_radius <= inner_radius:‖1
if outer_radius <= inner_radius:‖"raise ValueError(""outer_radius must be greater than inner_radius"")"‖1
"raise ValueError(""outer_radius must be greater than inner_radius"")"‖return pi * (pow(outer_radius, 2) - pow(inner_radius, 2)) * height‖1
if radius_1 < 0 or radius_2 < 0 or height < 0:‖"raise ValueError(""vol_conical_frustum() only accepts non-negative values"")"‖1
"raise ValueError(""vol_conical_frustum() only accepts non-negative values"")"‖return (‖1
return (‖1‖2
1‖/ 3‖2
/ 3‖* pi‖1
* pi‖* height‖1
* height‖* (pow(radius_1, 2) + pow(radius_2, 2) + radius_1 * radius_2)‖1
* (pow(radius_1, 2) + pow(radius_2, 2) + radius_1 * radius_2)‖)‖1
if torus_radius < 0 or tube_radius < 0:‖"raise ValueError(""vol_torus() only accepts non-negative values"")"‖1
"raise ValueError(""vol_torus() only accepts non-negative values"")"‖return 2 * pow(pi, 2) * torus_radius * pow(tube_radius, 2)‖1
if tri_side < 0:‖"raise ValueError(""vol_icosahedron() only accepts non-negative values"")"‖1
"raise ValueError(""vol_icosahedron() only accepts non-negative values"")"‖return tri_side**3 * (3 + 5**0.5) * 5 / 12‖1
"print(""Volumes:"")"‖"print(f""Cube: {vol_cube(2) = }"")"‖1
"print(f""Cube: {vol_cube(2) = }"")"‖"print(f""Cuboid: {vol_cuboid(2, 2, 2) = }"")"‖1
"print(f""Cuboid: {vol_cuboid(2, 2, 2) = }"")"‖"print(f""Cone: {vol_cone(2, 2) = }"")"‖1
"print(f""Cone: {vol_cone(2, 2) = }"")"‖"print(f""Right Circular Cone: {vol_right_circ_cone(2, 2) = }"")"‖1
"print(f""Right Circular Cone: {vol_right_circ_cone(2, 2) = }"")"‖"print(f""Prism: {vol_prism(2, 2) = }"")"‖1
"print(f""Prism: {vol_prism(2, 2) = }"")"‖"print(f""Pyramid: {vol_pyramid(2, 2) = }"")"‖1
"print(f""Pyramid: {vol_pyramid(2, 2) = }"")"‖"print(f""Sphere: {vol_sphere(2) = }"")"‖1
"print(f""Sphere: {vol_sphere(2) = }"")"‖"print(f""Hemisphere: {vol_hemisphere(2) = }"")"‖1
"print(f""Hemisphere: {vol_hemisphere(2) = }"")"‖"print(f""Circular Cylinder: {vol_circular_cylinder(2, 2) = }"")"‖1
"print(f""Circular Cylinder: {vol_circular_cylinder(2, 2) = }"")"‖"print(f""Torus: {vol_torus(2, 2) = }"")"‖1
"print(f""Torus: {vol_torus(2, 2) = }"")"‖"print(f""Conical Frustum: {vol_conical_frustum(2, 2, 4) = }"")"‖1
"print(f""Conical Frustum: {vol_conical_frustum(2, 2, 4) = }"")"‖"print(f""Spherical cap: {vol_spherical_cap(1, 2) = }"")"‖1
"print(f""Spherical cap: {vol_spherical_cap(1, 2) = }"")"‖"print(f""Spheres intersetion: {vol_spheres_intersect(2, 2, 1) = }"")"‖1
"print(f""Spheres intersetion: {vol_spheres_intersect(2, 2, 1) = }"")"‖"print(f""Spheres union: {vol_spheres_union(2, 2, 1) = }"")"‖1
"print(f""Spheres union: {vol_spheres_union(2, 2, 1) = }"")"‖print(‖1
print(‖"f""Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }"""‖1
"f""Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }"""‖)‖1
)‖"print(f""Icosahedron: {vol_icosahedron(2.5) = }"")"‖1
def two_pointer(nums: list[int], target: int) -> list[int]:‖i = 0‖1
i = 0‖j = len(nums) - 1‖1
while i < j:‖if nums[i] + nums[j] == target:‖1
if nums[i] + nums[j] == target:‖return [i, j]‖1
return [i, j]‖elif nums[i] + nums[j] < target:‖1
elif nums[i] + nums[j] < target:‖i = i + 1‖1
i = i + 1‖else:‖1
else:‖j = j - 1‖1
doctest.testmod()‖"print(f""{two_pointer([2, 7, 11, 15], 9) = }"")"‖1
def sumset(set_a: set, set_b: set) -> set:‖"assert isinstance(set_a, set), f""The input value of [set_a={set_a}] is not a set"""‖1
"assert isinstance(set_a, set), f""The input value of [set_a={set_a}] is not a set"""‖"assert isinstance(set_b, set), f""The input value of [set_b={set_b}] is not a set"""‖1
def sum_of_digits(n: int) -> int:‖n = abs(n)‖1
n = abs(n)‖res = 0‖1
res = 0‖while n > 0:‖1
while n > 0:‖res += n % 10‖1
res += n % 10‖n //= 10‖1
n //= 10‖return res‖1
def sum_of_digits_recursion(n: int) -> int:‖n = abs(n)‖1
n = abs(n)‖return n if n < 10 else n % 10 + sum_of_digits(n // 10)‖1
def sum_of_digits_compact(n: int) -> int:‖return sum(int(c) for c in str(abs(n)))‖1
from collections.abc import Callable‖from timeit import timeit‖2
"timing = timeit(f""__main__.{call}"", setup=""import __main__"")"‖"print(f""{call:56} = {func(value)} -- {timing:.4f} seconds"")"‖1
for value in (262144, 1125899906842624, 1267650600228229401496703205376):‖for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):‖1
for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):‖benchmark_a_function(func, value)‖1
def equation(x: float) -> float:‖return 10 - x * x‖1
if equation(a) * equation(b) >= 0:‖"raise ValueError(""Wrong space!"")"‖1
c = a‖while (b - a) >= 0.01:‖1
if equation(c) == 0.0:‖break‖1
if equation(c) * equation(a) < 0:‖b = c‖1
b = c‖else:‖1
else:‖a = c‖1
a = c‖return c‖1
print(bisection(-2, 5))‖print(bisection(0, 6))‖1
if denominator < 0:‖"raise ValueError(""The Denominator Cannot be less than 0"")"‖1
"raise ValueError(""The Denominator Cannot be less than 0"")"‖elif isinstance(denominator, float):‖1
elif isinstance(denominator, float):‖"raise ValueError(""The Denominator must be an integer"")"‖1
"raise ValueError(""The Denominator must be an integer"")"‖return [‖1
return [‖"f""{numerator}/{denominator}"""‖1
"f""{numerator}/{denominator}"""‖for numerator in range(1, denominator)‖1
for numerator in range(1, denominator)‖if gcd(numerator, denominator) == 1‖1
if gcd(numerator, denominator) == 1‖]‖1
import argparse‖import datetime‖1
def zeller(date_input: str) -> str:‖days = {‖1
days = {‖"""0"": ""Sunday"","‖1
"""0"": ""Sunday"","‖"""1"": ""Monday"","‖1
"""1"": ""Monday"","‖"""2"": ""Tuesday"","‖1
"""2"": ""Tuesday"","‖"""3"": ""Wednesday"","‖1
"""3"": ""Wednesday"","‖"""4"": ""Thursday"","‖1
"""4"": ""Thursday"","‖"""5"": ""Friday"","‖1
"""5"": ""Friday"","‖"""6"": ""Saturday"","‖1
"""6"": ""Saturday"","‖}‖1
if not 0 < len(date_input) < 11:‖"raise ValueError(""Must be 10 characters long"")"‖1
if not 0 < m < 13:‖"raise ValueError(""Month must be between 1 - 12"")"‖1
"if sep_1 not in [""-"", ""/""]:"‖"raise ValueError(""Date separator must be '-' or '/'"")"‖1
if not 0 < d < 32:‖"raise ValueError(""Date must be between 1 - 31"")"‖1
"if sep_2 not in [""-"", ""/""]:"‖"raise ValueError(""Date separator must be '-' or '/'"")"‖1
if not 45 < y < 8500:‖raise ValueError(‖1
raise ValueError(‖"""Year out of range. There has to be some sort of limit...right?"""‖1
"""Year out of range. There has to be some sort of limit...right?"""‖)‖1
if m <= 2:‖y = y - 1‖1
y = y - 1‖m = m + 12‖1
c: int = int(str(y)[:2])‖k: int = int(str(y)[2:])‖1
k: int = int(str(y)[2:])‖t: int = int(2.6 * m - 5.39)‖1
t: int = int(2.6 * m - 5.39)‖u: int = int(c / 4)‖1
u: int = int(c / 4)‖v: int = int(k / 4)‖1
v: int = int(k / 4)‖x: int = int(d + k)‖1
x: int = int(d + k)‖z: int = int(t + u + v + x)‖1
z: int = int(t + u + v + x)‖w: int = int(z - (2 * c))‖1
w: int = int(z - (2 * c))‖f: int = round(w % 7)‖1
if f != convert_datetime_days[dt_ck.weekday()]:‖"raise AssertionError(""The date was evaluated incorrectly. Contact developer."")"‖1
"response: str = f""Your date {date_input}, is a {days[str(f)]}!"""‖return response‖1
doctest.testmod()‖parser = argparse.ArgumentParser(‖1
parser = argparse.ArgumentParser(‖description=(‖1
description=(‖"""Find out what day of the week nearly any date is or was. Enter """‖1
"""Find out what day of the week nearly any date is or was. Enter """‖"""date as a string in the mm-dd-yyyy or mm/dd/yyyy format"""‖1
"""date as a string in the mm-dd-yyyy or mm/dd/yyyy format"""‖)‖1
parser.add_argument(‖"""date_input"", type=str, help=""Date as a string (mm-dd-yyyy or mm/dd/yyyy)"""‖1
"""date_input"", type=str, help=""Date as a string (mm-dd-yyyy or mm/dd/yyyy)"""‖)‖1
args = parser.parse_args()‖zeller(args.date_input)‖1
def intersection(function: Callable[[float], float], x0: float, x1: float) -> float:‖x_n: float = x0‖1
x_n: float = x0‖x_n1: float = x1‖1
x_n1: float = x1‖while True:‖1
while True:‖if x_n == x_n1 or function(x_n1) == function(x_n):‖1
if x_n == x_n1 or function(x_n1) == function(x_n):‖"raise ZeroDivisionError(""float division by zero, could not find root"")"‖1
"raise ZeroDivisionError(""float division by zero, could not find root"")"‖x_n2: float = x_n1 - (‖1
x_n2: float = x_n1 - (‖function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))‖1
function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))‖)‖1
)‖if abs(x_n2 - x_n1) < 10**-5:‖1
if abs(x_n2 - x_n1) < 10**-5:‖return x_n2‖1
return x_n2‖x_n = x_n1‖1
x_n = x_n1‖x_n1 = x_n2‖1
def f(x: float) -> float:‖return math.pow(x, 3) - (2 * x) - 5‖1
"if __name__ == ""__main__"":"‖print(intersection(f, 3, 3.5))‖1
def f(x: float) -> float:‖return x * x‖1
def simpson_integration(function, a: float, b: float, precision: int = 4) -> float:‖assert callable(function), (‖1
assert callable(function), (‖"f""the function(object) passed should be callable your input : {function}"""‖1
"f""the function(object) passed should be callable your input : {function}"""‖)‖1
)‖"assert isinstance(a, (float, int)), f""a should be float or integer your input : {a}"""‖1
"assert isinstance(a, (float, int)), f""a should be float or integer your input : {a}"""‖assert isinstance(function(a), (float, int)), (‖1
assert isinstance(function(a), (float, int)), (‖"""the function should return integer or float return type of your function, """‖1
"""the function should return integer or float return type of your function, """‖"f""{type(a)}"""‖1
"f""{type(a)}"""‖)‖1
)‖"assert isinstance(b, (float, int)), f""b should be float or integer your input : {b}"""‖1
"assert isinstance(b, (float, int)), f""b should be float or integer your input : {b}"""‖assert isinstance(precision, int) and precision > 0, (‖1
assert isinstance(precision, int) and precision > 0, (‖"f""precision should be positive integer your input : {precision}"""‖1
"f""precision should be positive integer your input : {precision}"""‖)‖1
h = (b - a) / N_STEPS‖result = function(a) + function(b)‖1
for i in range(1, N_STEPS):‖a1 = a + h * i‖1
a1 = a + h * i‖result += function(a1) * (4 if i % 2 else 2)‖1
result *= h / 3‖return round(result, precision)‖1
def runge_kutta(f, y0, x0, h, x_end):‖n = int(np.ceil((x_end - x0) / h))‖1
n = int(np.ceil((x_end - x0) / h))‖y = np.zeros((n + 1,))‖1
for k in range(n):‖k1 = f(x, y[k])‖1
k1 = f(x, y[k])‖k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)‖1
k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)‖k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)‖1
k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)‖k4 = f(x + h, y[k] + h * k3)‖1
k4 = f(x + h, y[k] + h * k3)‖y[k + 1] = y[k] + (1 / 6) * h * (k1 + 2 * k2 + 2 * k3 + k4)‖1
y[k + 1] = y[k] + (1 / 6) * h * (k1 + 2 * k2 + 2 * k3 + k4)‖x += h‖1
def calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:‖return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x‖1
def newton_raphson(‖f: RealFunc,‖1
f: RealFunc,‖x0: float = 0,‖1
x0: float = 0,‖max_iter: int = 100,‖1
max_iter: int = 100,‖step: float = 1e-6,‖1
step: float = 1e-6,‖max_error: float = 1e-6,‖1
max_error: float = 1e-6,‖log_steps: bool = False,‖1
log_steps: bool = False,‖) -> tuple[float, float, list[float]]:‖1
def f_derivative(x: float) -> float:‖return calc_derivative(f, x, step)‖1
a = x0‖steps = []‖1
steps = []‖for _ in range(max_iter):‖1
for _ in range(max_iter):‖if log_steps:‖1
if log_steps:‖steps.append(a)‖1
error = abs(f(a))‖if error < max_error:‖1
if error < max_error:‖return a, error, steps‖1
if f_derivative(a) == 0:‖"raise ZeroDivisionError(""No converging solution found, zero derivative"")"‖1
"raise ZeroDivisionError(""No converging solution found, zero derivative"")"‖a -= f(a) / f_derivative(a)‖1
a -= f(a) / f_derivative(a)‖"raise ArithmeticError(""No converging solution found, iteration limit reached"")"‖1
import doctest‖from math import exp, tanh‖1
def func(x: float) -> float:‖return tanh(x) ** 2 - exp(3 * x)‖1
solution, err, steps = newton_raphson(‖func, x0=10, max_iter=100, step=1e-6, log_steps=True‖1
func, x0=10, max_iter=100, step=1e-6, log_steps=True‖)‖1
)‖"print(f""{solution=}, {err=}"")"‖1
"print(f""{solution=}, {err=}"")"‖"print(""\n"".join(str(x) for x in steps))"‖1
def ucal(u: float, p: int) -> float:‖temp = u‖1
temp = u‖for i in range(1, p):‖1
for i in range(1, p):‖temp = temp * (u - i)‖1
temp = temp * (u - i)‖return temp‖1
def main() -> None:‖"n = int(input(""enter the numbers of values: ""))"‖1
"n = int(input(""enter the numbers of values: ""))"‖y: list[list[float]] = []‖1
y: list[list[float]] = []‖for _ in range(n):‖1
for _ in range(n):‖y.append([])‖1
y.append([])‖for i in range(n):‖1
for j in range(n):‖y[i].append(j)‖1
y[i].append(j)‖y[i][j] = 0‖1
"print(""enter the values of parameters in a list: "")"‖x = list(map(int, input().split()))‖1
"print(""enter the values of corresponding parameters: "")"‖for i in range(n):‖1
for i in range(n):‖y[i][0] = float(input())‖1
"value = int(input(""enter the value to interpolate: ""))"‖u = (value - x[0]) / (x[1] - x[0])‖1
for i in range(1, n):‖for j in range(n - i):‖1
for j in range(n - i):‖y[j][i] = y[j + 1][i - 1] - y[j][i - 1]‖1
summ = y[0][0]‖for i in range(1, n):‖1
for i in range(1, n):‖summ += (ucal(u, i) * y[0][i]) / math.factorial(i)‖1
def f(x: float) -> float:‖return 8 * x - 2 * exp(-x)‖1
def secant_method(lower_bound: float, upper_bound: float, repeats: int) -> float:‖x0 = lower_bound‖1
x0 = lower_bound‖x1 = upper_bound‖1
x1 = upper_bound‖for _ in range(repeats):‖1
for _ in range(repeats):‖x0, x1 = x1, x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0))‖1
x0, x1 = x1, x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0))‖return x1‖1
"if __name__ == ""__main__"":"‖"print(f""Example: {secant_method(1, 3, 2)}"")"‖1
def neville_interpolate(x_points: list, y_points: list, x0: int) -> list:‖n = len(x_points)‖1
n = len(x_points)‖q = [[0] * n for i in range(n)]‖1
q = [[0] * n for i in range(n)]‖for i in range(n):‖1
for i in range(n):‖q[i][1] = y_points[i]‖1
for i in range(2, n):‖for j in range(i, n):‖1
for j in range(i, n):‖q[j][i] = (‖1
q[j][i] = (‖(x0 - x_points[j - i + 1]) * q[j][i - 1]‖1
(x0 - x_points[j - i + 1]) * q[j][i - 1]‖- (x0 - x_points[j]) * q[j - 1][i - 1]‖1
- (x0 - x_points[j]) * q[j - 1][i - 1]‖) / (x_points[j] - x_points[j - i + 1])‖1
def f(x):‖return x**3‖1
"print(""f(x) = x^3"")"‖"print(""The area between the curve, x = -10, x = 10 and the x axis is:"")"‖1
"print(""The area between the curve, x = -10, x = 10 and the x axis is:"")"‖i = 10‖1
while i <= 100000:‖area = trapezoidal_area(f, -5, 5, i)‖1
area = trapezoidal_area(f, -5, 5, i)‖"print(f""with {i} steps: {area}"")"‖1
"print(f""with {i} steps: {area}"")"‖i *= 10‖1
def bisection(function: Callable[[float], float], a: float, b: float) -> float:‖start: float = a‖1
start: float = a‖end: float = b‖1
end: float = b‖if function(a) == 0:‖1
if function(a) == 0:‖return a‖1
return a‖elif function(b) == 0:‖1
elif function(b) == 0:‖return b‖1
return b‖elif (‖1
elif (‖function(a) * function(b) > 0‖1
function(a) * function(b) > 0‖):‖1
"raise ValueError(""could not find root in given interval."")"‖else:‖1
else:‖mid: float = start + (end - start) / 2.0‖1
mid: float = start + (end - start) / 2.0‖while abs(start - mid) > 10**-7:‖1
while abs(start - mid) > 10**-7:‖if function(mid) == 0:‖1
if function(mid) == 0:‖return mid‖1
return mid‖elif function(mid) * function(start) < 0:‖1
elif function(mid) * function(start) < 0:‖end = mid‖1
end = mid‖else:‖1
else:‖start = mid‖1
start = mid‖mid = start + (end - start) / 2.0‖1
mid = start + (end - start) / 2.0‖return mid‖1
def f(x: float) -> float:‖return x**3 - 2 * x - 5‖1
"if __name__ == ""__main__"":"‖print(bisection(f, 1, 1000))‖1
class Polynomial:‖def __init__(self, degree: int, coefficients: MutableSequence[float]) -> None:‖1
def __init__(self, degree: int, coefficients: MutableSequence[float]) -> None:‖if len(coefficients) != degree + 1:‖1
if len(coefficients) != degree + 1:‖raise ValueError(‖1
raise ValueError(‖"""The number of coefficients should be equal to the degree + 1."""‖1
"""The number of coefficients should be equal to the degree + 1."""‖)‖1
self.coefficients: list[float] = list(coefficients)‖self.degree = degree‖1
if self.degree > polynomial_2.degree:‖coefficients = self.coefficients[:]‖1
coefficients = self.coefficients[:]‖for i in range(polynomial_2.degree + 1):‖1
for i in range(polynomial_2.degree + 1):‖coefficients[i] += polynomial_2.coefficients[i]‖1
coefficients[i] += polynomial_2.coefficients[i]‖return Polynomial(self.degree, coefficients)‖1
return Polynomial(self.degree, coefficients)‖else:‖1
else:‖coefficients = polynomial_2.coefficients[:]‖1
coefficients = polynomial_2.coefficients[:]‖for i in range(self.degree + 1):‖1
for i in range(self.degree + 1):‖coefficients[i] += self.coefficients[i]‖1
coefficients[i] += self.coefficients[i]‖return Polynomial(polynomial_2.degree, coefficients)‖1
def __sub__(self, polynomial_2: Polynomial) -> Polynomial:‖return self + polynomial_2 * Polynomial(0, [-1])‖1
def __neg__(self) -> Polynomial:‖return Polynomial(self.degree, [-c for c in self.coefficients])‖1
def __mul__(self, polynomial_2: Polynomial) -> Polynomial:‖coefficients: list[float] = [0] * (self.degree + polynomial_2.degree + 1)‖1
coefficients: list[float] = [0] * (self.degree + polynomial_2.degree + 1)‖for i in range(self.degree + 1):‖1
for i in range(self.degree + 1):‖for j in range(polynomial_2.degree + 1):‖1
for j in range(polynomial_2.degree + 1):‖coefficients[i + j] += (‖1
coefficients[i + j] += (‖self.coefficients[i] * polynomial_2.coefficients[j]‖1
self.coefficients[i] * polynomial_2.coefficients[j]‖)‖1
def evaluate(self, substitution: float) -> float:‖result: int | float = 0‖1
result: int | float = 0‖for i in range(self.degree + 1):‖1
for i in range(self.degree + 1):‖result += self.coefficients[i] * (substitution**i)‖1
result += self.coefficients[i] * (substitution**i)‖return result‖1
def __str__(self) -> str:‖"polynomial = """""‖1
"polynomial = """""‖for i in range(self.degree, -1, -1):‖1
for i in range(self.degree, -1, -1):‖if self.coefficients[i] == 0:‖1
if self.coefficients[i] == 0:‖continue‖1
continue‖elif self.coefficients[i] > 0:‖1
elif self.coefficients[i] > 0:‖if polynomial:‖1
if polynomial:‖"polynomial += "" + """‖1
"polynomial += "" + """‖else:‖1
else:‖"polynomial += "" - """‖1
if i == 0:‖polynomial += str(abs(self.coefficients[i]))‖1
polynomial += str(abs(self.coefficients[i]))‖elif i == 1:‖1
elif i == 1:‖"polynomial += str(abs(self.coefficients[i])) + ""x"""‖1
"polynomial += str(abs(self.coefficients[i])) + ""x"""‖else:‖1
else:‖"polynomial += str(abs(self.coefficients[i])) + ""x^"" + str(i)"‖1
def __repr__(self) -> str:‖return self.__str__()‖1
def derivative(self) -> Polynomial:‖coefficients: list[float] = [0] * self.degree‖1
coefficients: list[float] = [0] * self.degree‖for i in range(self.degree):‖1
for i in range(self.degree):‖coefficients[i] = self.coefficients[i + 1] * (i + 1)‖1
coefficients[i] = self.coefficients[i + 1] * (i + 1)‖return Polynomial(self.degree - 1, coefficients)‖1
def integral(self, constant: float = 0) -> Polynomial:‖coefficients: list[float] = [0] * (self.degree + 2)‖1
coefficients: list[float] = [0] * (self.degree + 2)‖coefficients[0] = constant‖1
coefficients[0] = constant‖for i in range(self.degree + 1):‖1
for i in range(self.degree + 1):‖coefficients[i + 1] = self.coefficients[i] / (i + 1)‖1
coefficients[i + 1] = self.coefficients[i] / (i + 1)‖return Polynomial(self.degree + 1, coefficients)‖1
def __eq__(self, polynomial_2: object) -> bool:‖if not isinstance(polynomial_2, Polynomial):‖1
if not isinstance(polynomial_2, Polynomial):‖return False‖1
if self.degree != polynomial_2.degree:‖return False‖1
for i in range(self.degree + 1):‖if self.coefficients[i] != polynomial_2.coefficients[i]:‖1
if self.coefficients[i] != polynomial_2.coefficients[i]:‖return False‖1
def __ne__(self, polynomial_2: object) -> bool:‖return not self.__eq__(polynomial_2)‖1
from collections.abc import Callable‖from math import sqrt‖1
def runge_kutta_gills(‖func: Callable[[float, float], float],‖1
func: Callable[[float, float], float],‖x_initial: float,‖1
x_initial: float,‖y_initial: float,‖2
y_initial: float,‖step_size: float,‖2
step_size: float,‖x_final: float,‖2
x_final: float,‖) -> np.ndarray:‖2
) -> np.ndarray:‖if x_initial >= x_final:‖2
if x_initial >= x_final:‖raise ValueError(‖2
raise ValueError(‖"""The final value of x must be greater than initial value of x."""‖2
"""The final value of x must be greater than initial value of x."""‖)‖2
if step_size <= 0:‖"raise ValueError(""Step size must be positive."")"‖2
n = int((x_final - x_initial) / step_size)‖y = np.zeros(n + 1)‖1
y = np.zeros(n + 1)‖y[0] = y_initial‖1
y[0] = y_initial‖for i in range(n):‖1
for i in range(n):‖k1 = step_size * func(x_initial, y[i])‖1
k1 = step_size * func(x_initial, y[i])‖k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)‖1
k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)‖k3 = step_size * func(‖1
k3 = step_size * func(‖x_initial + step_size / 2,‖1
x_initial + step_size / 2,‖y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,‖1
y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,‖)‖1
)‖k4 = step_size * func(‖2
k4 = step_size * func(‖x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3‖1
x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3‖)‖1
y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6‖x_initial += step_size‖1
x_initial += step_size‖return y‖1
def fx(x: float, a: float) -> float:‖return math.pow(x, 2) - a‖1
def fx_derivative(x: float) -> float:‖return 2 * x‖1
def get_initial_point(a: float) -> float:‖start = 2.0‖1
while start <= a:‖start = math.pow(start, 2)‖1
def square_root_iterative(‖a: float, max_iter: int = 9999, tolerance: float = 1e-14‖1
a: float, max_iter: int = 9999, tolerance: float = 1e-14‖) -> float:‖1
if a < 0:‖"raise ValueError(""math domain error"")"‖1
for _ in range(max_iter):‖prev_value = value‖1
prev_value = value‖value = value - fx(value, a) / fx_derivative(value)‖1
value = value - fx(value, a) / fx_derivative(value)‖if abs(prev_value - value) < tolerance:‖1
if abs(prev_value - value) < tolerance:‖return value‖1
if steps <= 0:‖"raise ZeroDivisionError(""Number of steps must be greater than zero"")"‖1
y = 0.0‖y += (h / 3.0) * f(a)‖1
y += (h / 3.0) * f(a)‖cnt = 2‖1
cnt = 2‖for i in x_i:‖1
for i in x_i:‖y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)‖1
y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)‖cnt += 1‖1
cnt += 1‖y += (h / 3.0) * f(b)‖1
y += (h / 3.0) * f(b)‖return y‖1
x = a + h‖while x < (b - h):‖1
while x < (b - h):‖yield x‖1
yield x‖x = x + h‖1
def f(x):‖y = (x - 0) * (x - 0)‖1
y = (x - 0) * (x - 0)‖return y‖1
boundary = [a, b]‖y = method_2(boundary, steps)‖1
y = method_2(boundary, steps)‖"print(f""y = {y}"")"‖1
if length <= 0 or not isinstance(length, int):‖"raise ValueError(""Length must be a positive integer."")"‖1
"raise ValueError(""Length must be a positive integer."")"‖return [n * (2 * n - 1) for n in range(length)]‖1
"if __name__ == ""__main__"":"‖print(hexagonal_numbers(length=5))‖1
print(hexagonal_numbers(length=5))‖print(hexagonal_numbers(length=10))‖1
def is_harmonic_series(series: list) -> bool:‖if not isinstance(series, list):‖1
if not isinstance(series, list):‖"raise ValueError(""Input series is not valid, valid series - [1, 2/3, 2]"")"‖1
"raise ValueError(""Input series is not valid, valid series - [1, 2/3, 2]"")"‖if len(series) == 0:‖1
if len(series) == 0:‖"raise ValueError(""Input list must be a non empty list"")"‖6
"raise ValueError(""Input list must be a non empty list"")"‖if len(series) == 1 and series[0] != 0:‖1
if len(series) == 1 and series[0] != 0:‖return True‖1
return True‖rec_series = []‖1
rec_series = []‖series_len = len(series)‖1
series_len = len(series)‖for i in range(series_len):‖1
for i in range(series_len):‖if series[i] == 0:‖1
if series[i] == 0:‖"raise ValueError(""Input series cannot have 0 as an element"")"‖1
"raise ValueError(""Input series cannot have 0 as an element"")"‖rec_series.append(1 / series[i])‖1
rec_series.append(1 / series[i])‖common_diff = rec_series[1] - rec_series[0]‖1
common_diff = rec_series[1] - rec_series[0]‖for index in range(2, series_len):‖1
for index in range(2, series_len):‖if rec_series[index] - rec_series[index - 1] != common_diff:‖1
if rec_series[index] - rec_series[index - 1] != common_diff:‖return False‖1
def harmonic_mean(series: list) -> float:‖if not isinstance(series, list):‖1
if not isinstance(series, list):‖"raise ValueError(""Input series is not valid, valid series - [2, 4, 6]"")"‖3
"raise ValueError(""Input series is not valid, valid series - [2, 4, 6]"")"‖if len(series) == 0:‖3
"raise ValueError(""Input list must be a non empty list"")"‖answer = 0‖2
answer = 0‖for val in series:‖2
for val in series:‖answer += 1 / val‖1
answer += 1 / val‖return len(series) / answer‖1
if y == 0:‖return 1‖1
return 1‖temp = power(x, y // 2, mod) % mod‖1
temp = power(x, y // 2, mod) % mod‖temp = (temp * temp) % mod‖1
temp = (temp * temp) % mod‖if y % 2 == 1:‖1
if y % 2 == 1:‖temp = (temp * x) % mod‖1
temp = (temp * x) % mod‖return temp‖1
if n <= 0 or not isinstance(n, int):‖"msg = f""Number {n} must instead be a positive integer"""‖1
return all(‖power(b, n - 1, n) == 1‖1
power(b, n - 1, n) == 1‖for b in range(2, n)‖1
for b in range(2, n)‖if greatest_common_divisor(b, n) == 1‖1
if greatest_common_divisor(b, n) == 1‖)‖1
"number = int(input(""Enter number: "").strip())"‖if is_carmichael_number(number):‖1
if is_carmichael_number(number):‖"print(f""{number} is a Carmichael Number."")"‖1
"print(f""{number} is a Carmichael Number."")"‖else:‖1
else:‖"print(f""{number} is not a Carmichael Number."")"‖1
def p_series(nth_term: float | str, power: float | str) -> list[str]:‖"if nth_term == """":"‖1
"if nth_term == """":"‖"return [""""]"‖1
"return [""""]"‖nth_term = int(nth_term)‖1
nth_term = int(nth_term)‖power = int(power)‖1
power = int(power)‖series: list[str] = []‖1
series: list[str] = []‖for temp in range(int(nth_term)):‖1
for temp in range(int(nth_term)):‖"series.append(f""1 / {pow(temp + 1, int(power))}"" if series else ""1"")"‖1
"series.append(f""1 / {pow(temp + 1, int(power))}"" if series else ""1"")"‖return series‖1
"nth_term = int(input(""Enter the last number (nth term) of the P-Series""))"‖"power = int(input(""Enter the power for  P-Series""))"‖1
"power = int(input(""Enter the power for  P-Series""))"‖"print(""Formula of P-Series => 1+1/2^p+1/3^p ..... 1/n^p"")"‖1
"print(""Formula of P-Series => 1+1/2^p+1/3^p ..... 1/n^p"")"‖print(p_series(nth_term, power))‖1
def harmonic_series(n_term: str) -> list:‖"if n_term == """":"‖1
"if n_term == """":"‖return []‖1
return []‖series: list = []‖1
series: list = []‖for temp in range(int(n_term)):‖1
for temp in range(int(n_term)):‖"series.append(f""1/{temp + 1}"" if series else ""1"")"‖1
"series.append(f""1/{temp + 1}"" if series else ""1"")"‖return series‖1
"if __name__ == ""__main__"":"‖"nth_term = input(""Enter the last number (nth term) of the Harmonic Series"")"‖1
"nth_term = input(""Enter the last number (nth term) of the Harmonic Series"")"‖"print(""Formula of Harmonic Series => 1+1/2+1/3 ..... 1/n"")"‖1
"print(""Formula of Harmonic Series => 1+1/2+1/3 ..... 1/n"")"‖print(harmonic_series(nth_term))‖1
if number < 1:‖"msg = f""Input value of [number={number}] must be > 0"""‖2
"msg = f""Input value of [number={number}] must be > 0"""‖raise ValueError(msg)‖2
for i in range(1, number):‖current_number *= 4 * i - 2‖1
current_number *= 4 * i - 2‖current_number //= i + 1‖1
def is_geometric_series(series: list) -> bool:‖if not isinstance(series, list):‖1
if not isinstance(series, list):‖"raise ValueError(""Input series is not valid, valid series - [2, 4, 8]"")"‖2
"raise ValueError(""Input series is not valid, valid series - [2, 4, 8]"")"‖if len(series) == 0:‖2
"raise ValueError(""Input list must be a non empty list"")"‖if len(series) == 1:‖2
if len(series) == 1:‖return True‖2
return True‖try:‖1
try:‖common_ratio = series[1] / series[0]‖1
common_ratio = series[1] / series[0]‖for index in range(len(series) - 1):‖1
for index in range(len(series) - 1):‖if series[index + 1] / series[index] != common_ratio:‖1
if series[index + 1] / series[index] != common_ratio:‖return False‖1
return False‖except ZeroDivisionError:‖1
except ZeroDivisionError:‖return False‖1
def geometric_mean(series: list) -> float:‖if not isinstance(series, list):‖1
"raise ValueError(""Input list must be a non empty list"")"‖answer = 1‖1
answer = 1‖for value in series:‖1
for value in series:‖answer *= value‖1
answer *= value‖return pow(answer, 1 / len(series))‖1
def bell_numbers(max_set_length: int) -> list[int]:‖if max_set_length < 0:‖1
if max_set_length < 0:‖"raise ValueError(""max_set_length must be non-negative"")"‖1
bell = [0] * (max_set_length + 1)‖bell[0] = 1‖1
for i in range(1, max_set_length + 1):‖for j in range(i):‖1
for j in range(i):‖bell[i] += _binomial_coefficient(i - 1, j) * bell[j]‖1
def _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:‖if elements_to_choose in {0, total_elements}:‖1
if elements_to_choose in {0, total_elements}:‖return 1‖1
coefficient = 1‖for i in range(elements_to_choose):‖1
for i in range(elements_to_choose):‖coefficient *= total_elements - i‖1
coefficient *= total_elements - i‖coefficient //= i + 1‖1
def runge_kutta_fehlberg_45(‖func: Callable,‖1
func: Callable,‖x_initial: float,‖1
n = int((x_final - x_initial) / step_size)‖y = np.zeros(‖1
y = np.zeros(‖(n + 1),‖1
(n + 1),‖)‖1
)‖x = np.zeros(n + 1)‖1
x = np.zeros(n + 1)‖y[0] = y_initial‖1
y[0] = y_initial‖x[0] = x_initial‖1
x[0] = x_initial‖for i in range(n):‖1
for i in range(n):‖k1 = step_size * func(x[i], y[i])‖1
k1 = step_size * func(x[i], y[i])‖k2 = step_size * func(x[i] + step_size / 4, y[i] + k1 / 4)‖1
k2 = step_size * func(x[i] + step_size / 4, y[i] + k1 / 4)‖k3 = step_size * func(‖1
k3 = step_size * func(‖x[i] + (3 / 8) * step_size, y[i] + (3 / 32) * k1 + (9 / 32) * k2‖1
x[i] + (3 / 8) * step_size, y[i] + (3 / 32) * k1 + (9 / 32) * k2‖)‖1
k4 = step_size * func(‖x[i] + (12 / 13) * step_size,‖1
x[i] + (12 / 13) * step_size,‖y[i] + (1932 / 2197) * k1 - (7200 / 2197) * k2 + (7296 / 2197) * k3,‖1
y[i] + (1932 / 2197) * k1 - (7200 / 2197) * k2 + (7296 / 2197) * k3,‖)‖1
)‖k5 = step_size * func(‖1
k5 = step_size * func(‖x[i] + step_size,‖1
x[i] + step_size,‖y[i] + (439 / 216) * k1 - 8 * k2 + (3680 / 513) * k3 - (845 / 4104) * k4,‖1
y[i] + (439 / 216) * k1 - 8 * k2 + (3680 / 513) * k3 - (845 / 4104) * k4,‖)‖1
)‖k6 = step_size * func(‖1
k6 = step_size * func(‖x[i] + step_size / 2,‖1
x[i] + step_size / 2,‖y[i]‖1
y[i]‖- (8 / 27) * k1‖1
- (8 / 27) * k1‖+ 2 * k2‖1
+ 2 * k2‖- (3544 / 2565) * k3‖1
- (3544 / 2565) * k3‖+ (1859 / 4104) * k4‖1
+ (1859 / 4104) * k4‖- (11 / 40) * k5,‖1
- (11 / 40) * k5,‖)‖1
)‖y[i + 1] = (‖1
y[i + 1] = (‖y[i]‖1
y[i]‖+ (16 / 135) * k1‖1
+ (16 / 135) * k1‖+ (6656 / 12825) * k3‖1
+ (6656 / 12825) * k3‖+ (28561 / 56430) * k4‖1
+ (28561 / 56430) * k4‖- (9 / 50) * k5‖1
- (9 / 50) * k5‖+ (2 / 55) * k6‖1
+ (2 / 55) * k6‖)‖1
)‖x[i + 1] = step_size + x[i]‖1
x[i + 1] = step_size + x[i]‖return y‖1
fact_sum = 0‖duplicate = number‖1
duplicate = number‖while duplicate > 0:‖1
while duplicate > 0:‖duplicate, digit = divmod(duplicate, 10)‖1
duplicate, digit = divmod(duplicate, 10)‖fact_sum += factorial(digit)‖1
fact_sum += factorial(digit)‖return fact_sum == number‖1
"if __name__ == ""__main__"":"‖"print(""Program to check whether a number is a Krisnamurthy Number or not."")"‖1
"print(""Program to check whether a number is a Krisnamurthy Number or not."")"‖"number = int(input(""Enter number: "").strip())"‖1
"number = int(input(""Enter number: "").strip())"‖print(‖1
print(‖"f""{number} is {'' if krishnamurthy(number) else 'not '}a Krishnamurthy Number."""‖1
"f""{number} is {'' if krishnamurthy(number) else 'not '}a Krishnamurthy Number."""‖)‖1
def is_arithmetic_series(series: list) -> bool:‖if not isinstance(series, list):‖1
return True‖common_diff = series[1] - series[0]‖1
common_diff = series[1] - series[0]‖for index in range(len(series) - 1):‖1
for index in range(len(series) - 1):‖if series[index + 1] - series[index] != common_diff:‖1
if series[index + 1] - series[index] != common_diff:‖return False‖1
def arithmetic_mean(series: list) -> float:‖if not isinstance(series, list):‖1
for val in series:‖answer += val‖1
answer += val‖return answer / len(series)‖1
def is_automorphic_number(number: int) -> bool:‖if not isinstance(number, int):‖1
raise TypeError(msg)‖if number < 0:‖1
if number < 0:‖return False‖1
return False‖number_square = number * number‖1
number_square = number * number‖while number > 0:‖1
while number > 0:‖if number % 10 != number_square % 10:‖1
if number % 10 != number_square % 10:‖return False‖1
return False‖number //= 10‖1
number //= 10‖number_square //= 10‖1
number_square //= 10‖return True‖1
if base < 2 or base > 36:‖"raise ValueError(""'base' must be between 2 and 36 inclusive"")"‖4
"digits = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"""‖"result = """""‖1
if number < 0:‖"raise ValueError(""number must be a positive integer"")"‖1
while number > 0:‖number, remainder = divmod(number, base)‖1
number, remainder = divmod(number, base)‖result = digits[remainder] + result‖1
"if result == """":"‖"result = ""0"""‖1
num_str = int_to_base(num, base)‖res = sum(int(char, base) for char in num_str)‖1
res = sum(int(char, base) for char in num_str)‖res_str = int_to_base(res, base)‖1
res_str = int_to_base(res, base)‖return res_str‖1
if limit < 0:‖return []‖1
numbers = [‖int_to_base(i, base)‖1
int_to_base(i, base)‖for i in range(1, limit)‖1
for i in range(1, limit)‖if i % int(sum_of_digits(i, base), base) == 0‖1
if i % int(sum_of_digits(i, base), base) == 0‖]‖1
n = int_to_base(num, base)‖d = sum_of_digits(num, base)‖1
d = sum_of_digits(num, base)‖return int(n, base) % int(d, base) == 0‖1
def geometric_series(‖nth_term: float,‖1
nth_term: float,‖start_term_a: float,‖1
start_term_a: float,‖common_ratio_r: float,‖1
common_ratio_r: float,‖) -> list[float]:‖1
) -> list[float]:‖if not all((nth_term, start_term_a, common_ratio_r)):‖1
if not all((nth_term, start_term_a, common_ratio_r)):‖return []‖1
return []‖series: list[float] = []‖1
series: list[float] = []‖power = 1‖1
power = 1‖multiple = common_ratio_r‖1
multiple = common_ratio_r‖for _ in range(int(nth_term)):‖1
for _ in range(int(nth_term)):‖if not series:‖1
if not series:‖series.append(start_term_a)‖1
series.append(start_term_a)‖else:‖1
else:‖power += 1‖1
power += 1‖series.append(float(start_term_a * multiple))‖1
series.append(float(start_term_a * multiple))‖multiple = pow(float(common_ratio_r), power)‖1
multiple = pow(float(common_ratio_r), power)‖return series‖1
"nth_term = float(input(""Enter the last number (n term) of the Geometric Series""))"‖"start_term_a = float(input(""Enter the starting term (a) of the Geometric Series""))"‖1
"start_term_a = float(input(""Enter the starting term (a) of the Geometric Series""))"‖common_ratio_r = float(‖1
common_ratio_r = float(‖"input(""Enter the common ratio between two terms (r) of the Geometric Series"")"‖1
"input(""Enter the common ratio between two terms (r) of the Geometric Series"")"‖)‖1
)‖"print(""Formula of Geometric Series => a + ar + ar^2 ... +ar^n"")"‖1
"print(""Formula of Geometric Series => a + ar + ar^2 ... +ar^n"")"‖print(geometric_series(nth_term, start_term_a, common_ratio_r))‖1
def polygonal_num(num: int, sides: int) -> int:‖if num < 0 or sides < 3:‖1
if num < 0 or sides < 3:‖"raise ValueError(""Invalid input: num must be >= 0 and sides must be >= 3."")"‖1
PASSING = (1, 153, 370, 371, 1634, 24678051, 115132219018763992565095597973971522401)‖"FAILING: tuple = (-153, -1, 0, 1.2, 200, ""A"", [], {}, None)"‖1
def armstrong_number(n: int) -> bool:‖if not isinstance(n, int) or n < 1:‖1
if not isinstance(n, int) or n < 1:‖return False‖3
total = 0‖number_of_digits = 0‖1
number_of_digits = 0‖temp = n‖1
temp = n‖while temp > 0:‖2
while temp > 0:‖rem = temp % 10‖1
rem = temp % 10‖total += rem**number_of_digits‖1
total += rem**number_of_digits‖temp //= 10‖1
temp //= 10‖return n == total‖1
def pluperfect_number(n: int) -> bool:‖if not isinstance(n, int) or n < 1:‖1
digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]‖digit_total = 0‖1
digit_total = 0‖total = 0‖1
total = 0‖temp = n‖1
while temp > 0:‖temp, rem = divmod(temp, 10)‖1
temp, rem = divmod(temp, 10)‖digit_histogram[rem] += 1‖1
digit_histogram[rem] += 1‖digit_total += 1‖1
for cnt, i in zip(digit_histogram, range(len(digit_histogram))):‖total += cnt * i**digit_total‖1
def narcissistic_number(n: int) -> bool:‖if not isinstance(n, int) or n < 1:‖1
return False‖expo = len(str(n))‖1
def main():‖"num = int(input(""Enter an integer to see if it is an Armstrong number: "").strip())"‖1
"num = int(input(""Enter an integer to see if it is an Armstrong number: "").strip())"‖"print(f""{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number."")"‖1
"print(f""{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number."")"‖"print(f""{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number."")"‖1
"print(f""{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number."")"‖"print(f""{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number."")"‖1
raise ValueError(msg)‖elif number == 1:‖1
elif number == 1:‖return 3‖1
return 3‖elif number == 2:‖1
elif number == 2:‖return 5‖1
return 5‖else:‖1
else:‖block_index = int(math.log(number // 3, 2)) + 2‖1
proth_list = [3, 5]‖proth_index = 2‖1
proth_index = 2‖increment = 3‖1
increment = 3‖for block in range(1, block_index):‖1
for block in range(1, block_index):‖for _ in range(increment):‖1
for _ in range(increment):‖proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])‖1
proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])‖proth_index += 1‖1
proth_index += 1‖increment *= 2‖1
for number in range(11):‖value = 0‖1
value = 0‖try:‖1
try:‖value = proth(number)‖1
value = proth(number)‖except ValueError:‖1
except ValueError:‖"print(f""ValueError: there is no {number}th Proth number"")"‖1
"print(f""ValueError: there is no {number}th Proth number"")"‖continue‖1
def generate_large_matrix() -> list[list[int]]:‖return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]‖1
grid = generate_large_matrix()‖test_grids = (‖1
test_grids = (‖[[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]],‖1
[[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]],‖[[3, 2], [1, 0]],‖1
[[3, 2], [1, 0]],‖[[7, 7, 6]],‖1
[[7, 7, 6]],‖[[7, 7, 6], [-1, -2, -3]],‖1
[[7, 7, 6], [-1, -2, -3]],‖grid,‖1
grid,‖)‖1
def validate_grid(grid: list[list[int]]) -> None:‖assert all(row == sorted(row, reverse=True) for row in grid)‖1
assert all(row == sorted(row, reverse=True) for row in grid)‖assert all(list(col) == sorted(col, reverse=True) for col in zip(*grid))‖1
def find_negative_index(array: list[int]) -> int:‖left = 0‖1
left = 0‖right = len(array) - 1‖1
if not array or array[0] < 0:‖return 0‖1
while right + 1 > left:‖mid = (left + right) // 2‖1
mid = (left + right) // 2‖num = array[mid]‖1
if num < 0 and array[mid - 1] >= 0:‖return mid‖1
if num >= 0:‖left = mid + 1‖1
def count_negatives_binary_search(grid: list[list[int]]) -> int:‖total = 0‖1
total = 0‖bound = len(grid[0])‖1
for i in range(len(grid)):‖bound = find_negative_index(grid[i][:bound])‖1
bound = find_negative_index(grid[i][:bound])‖total += bound‖1
total += bound‖return (len(grid) * len(grid[0])) - total‖1
def count_negatives_brute_force(grid: list[list[int]]) -> int:‖return len([number for row in grid for number in row if number < 0])‖1
def count_negatives_brute_force_with_break(grid: list[list[int]]) -> int:‖total = 0‖1
total = 0‖for row in grid:‖1
for row in grid:‖for i, number in enumerate(row):‖1
for i, number in enumerate(row):‖if number < 0:‖1
if number < 0:‖total += len(row) - i‖1
total += len(row) - i‖break‖1
break‖return total‖1
"print(""Running benchmarks"")"‖setup = (‖1
setup = (‖"""from __main__ import count_negatives_binary_search, """‖1
"""from __main__ import count_negatives_binary_search, """‖"""count_negatives_brute_force, count_negatives_brute_force_with_break, grid"""‖1
"""count_negatives_brute_force, count_negatives_brute_force_with_break, grid"""‖)‖1
)‖for func in (‖1
for func in (‖"""count_negatives_binary_search"","‖1
"""count_negatives_binary_search"","‖"""count_negatives_brute_force_with_break"","‖1
"""count_negatives_brute_force_with_break"","‖"""count_negatives_brute_force"","‖1
"""count_negatives_brute_force"","‖):‖1
):‖"time = timeit(f""{func}(grid=grid)"", setup=setup, number=500)"‖1
"time = timeit(f""{func}(grid=grid)"", setup=setup, number=500)"‖"print(f""{func}() took {time:0.4f} seconds"")"‖1
def ugly_numbers(n: int) -> int:‖ugly_nums = [1]‖1
i2, i3, i5 = 0, 0, 0‖next_2 = ugly_nums[i2] * 2‖1
next_2 = ugly_nums[i2] * 2‖next_3 = ugly_nums[i3] * 3‖1
next_3 = ugly_nums[i3] * 3‖next_5 = ugly_nums[i5] * 5‖1
for _ in range(1, n):‖next_num = min(next_2, next_3, next_5)‖1
next_num = min(next_2, next_3, next_5)‖ugly_nums.append(next_num)‖1
ugly_nums.append(next_num)‖if next_num == next_2:‖1
if next_num == next_2:‖i2 += 1‖1
i2 += 1‖next_2 = ugly_nums[i2] * 2‖1
next_2 = ugly_nums[i2] * 2‖if next_num == next_3:‖1
if next_num == next_3:‖i3 += 1‖1
i3 += 1‖next_3 = ugly_nums[i3] * 3‖1
next_3 = ugly_nums[i3] * 3‖if next_num == next_5:‖1
if next_num == next_5:‖i5 += 1‖1
i5 += 1‖next_5 = ugly_nums[i5] * 5‖1
next_5 = ugly_nums[i5] * 5‖return ugly_nums[-1]‖1
testmod(verbose=True)‖"print(f""{ugly_numbers(200) = }"")"‖1
def hamming(n_element: int) -> list:‖n_element = int(n_element)‖1
n_element = int(n_element)‖if n_element < 1:‖1
if n_element < 1:‖"my_error = ValueError(""n_element should be a positive number"")"‖1
"my_error = ValueError(""n_element should be a positive number"")"‖raise my_error‖1
hamming_list = [1]‖i, j, k = (0, 0, 0)‖1
i, j, k = (0, 0, 0)‖index = 1‖1
index = 1‖while index < n_element:‖1
while index < n_element:‖while hamming_list[i] * 2 <= hamming_list[-1]:‖1
while hamming_list[i] * 2 <= hamming_list[-1]:‖i += 1‖1
i += 1‖while hamming_list[j] * 3 <= hamming_list[-1]:‖1
while hamming_list[j] * 3 <= hamming_list[-1]:‖j += 1‖1
j += 1‖while hamming_list[k] * 5 <= hamming_list[-1]:‖1
while hamming_list[k] * 5 <= hamming_list[-1]:‖k += 1‖1
k += 1‖hamming_list.append(‖1
hamming_list.append(‖min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)‖1
min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)‖)‖1
)‖index += 1‖1
index += 1‖return hamming_list‖1
"if __name__ == ""__main__"":"‖"n = input(""Enter the last number (nth term) of the Hamming Number Series: "")"‖1
"n = input(""Enter the last number (nth term) of the Hamming Number Series: "")"‖"print(""Formula of Hamming Number Series => 2^i * 3^j * 5^k"")"‖1
"print(""Formula of Hamming Number Series => 2^i * 3^j * 5^k"")"‖hamming_numbers = hamming(int(n))‖1
hamming_numbers = hamming(int(n))‖"print(""-----------------------------------------------------"")"‖1
"print(""-----------------------------------------------------"")"‖"print(f""The list with nth numbers is: {hamming_numbers}"")"‖1
"print(f""The list with nth numbers is: {hamming_numbers}"")"‖"print(""-----------------------------------------------------"")"‖1
def triangular_number(position: int) -> int:‖if position < 0:‖1
if position < 0:‖"raise ValueError(""param `position` must be non-negative"")"‖1
def is_happy_number(number: int) -> bool:‖if not isinstance(number, int) or number <= 0:‖1
if not isinstance(number, int) or number <= 0:‖"msg = f""{number=} must be a positive integer"""‖1
"msg = f""{number=} must be a positive integer"""‖raise ValueError(msg)‖1
seen = set()‖while number != 1 and number not in seen:‖1
while number != 1 and number not in seen:‖seen.add(number)‖1
seen.add(number)‖number = sum(int(digit) ** 2 for digit in str(number))‖1
number = sum(int(digit) ** 2 for digit in str(number))‖return number == 1‖1
r = int((lower_bound + upper_bound) // 2)‖if array[r] == value:‖1
if array[r] == value:‖return r‖1
return r‖if lower_bound >= upper_bound:‖1
if lower_bound >= upper_bound:‖return -1‖1
return -1‖if array[r] < value:‖1
if array[r] < value:‖return binary_search(array, r + 1, upper_bound, value)‖1
return binary_search(array, r + 1, upper_bound, value)‖else:‖1
else:‖return binary_search(array, lower_bound, r - 1, value)‖1
def mat_bin_search(value: int, matrix: list) -> list:‖index = 0‖1
index = 0‖if matrix[index][0] == value:‖1
if matrix[index][0] == value:‖return [index, 0]‖1
return [index, 0]‖while index < len(matrix) and matrix[index][0] < value:‖1
while index < len(matrix) and matrix[index][0] < value:‖r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)‖1
r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)‖if r != -1:‖1
if r != -1:‖return [index, r]‖1
return [index, r]‖index += 1‖1
index += 1‖return [-1, -1]‖1
values = [1]‖for i in range(2, int(sqrt(number)) + 1, 1):‖1
for i in range(2, int(sqrt(number)) + 1, 1):‖if number % i == 0:‖1
if number % i == 0:‖values.append(i)‖1
values.append(i)‖if int(number // i) != i:‖1
if int(number // i) != i:‖values.append(int(number // i))‖1
values.append(int(number // i))‖return sorted(values)‖1
def abundant(n: int) -> bool:‖return sum(factors(n)) > n‖1
def semi_perfect(number: int) -> bool:‖values = factors(number)‖1
values = factors(number)‖r = len(values)‖1
r = len(values)‖subset = [[0 for i in range(number + 1)] for j in range(r + 1)]‖1
subset = [[0 for i in range(number + 1)] for j in range(r + 1)]‖for i in range(r + 1):‖1
for i in range(r + 1):‖subset[i][0] = True‖1
for i in range(1, number + 1):‖subset[0][i] = False‖1
for i in range(1, r + 1):‖for j in range(1, number + 1):‖1
for j in range(1, number + 1):‖if j < values[i - 1]:‖1
if j < values[i - 1]:‖subset[i][j] = subset[i - 1][j]‖1
subset[i][j] = subset[i - 1][j]‖else:‖1
else:‖subset[i][j] = subset[i - 1][j] or subset[i - 1][j - values[i - 1]]‖1
def weird(number: int) -> bool:‖return abundant(number) and not semi_perfect(number)‖1
doctest.testmod(verbose=True)‖for number in (69, 70, 71):‖1
for number in (69, 70, 71):‖"print(f""{number} is {'' if weird(number) else 'not '}weird."")"‖1
if not len(equation1) == len(equation2) == 3:‖"raise ValueError(""Please enter a valid equation."")"‖1
"raise ValueError(""Please enter a valid equation."")"‖if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:‖1
if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:‖"raise ValueError(""Both a & b of two equations can't be zero."")"‖1
a1, b1, c1 = equation1‖a2, b2, c2 = equation2‖1
determinant = a1 * b2 - a2 * b1‖determinant_x = c1 * b2 - c2 * b1‖1
determinant_x = c1 * b2 - c2 * b1‖determinant_y = a1 * c2 - a2 * c1‖1
if determinant == 0:‖if determinant_x == determinant_y == 0:‖1
if determinant_x == determinant_y == 0:‖"raise ValueError(""Infinite solutions. (Consistent system)"")"‖1
"raise ValueError(""Infinite solutions. (Consistent system)"")"‖else:‖1
else:‖"raise ValueError(""No solution. (Inconsistent system)"")"‖1
"raise ValueError(""No solution. (Inconsistent system)"")"‖elif determinant_x == determinant_y == 0:‖1
return (0.0, 0.0)‖else:‖1
else:‖x = determinant_x / determinant‖1
x = determinant_x / determinant‖y = determinant_y / determinant‖1
def depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:‖row_length, col_length = len(grid), len(grid[0])‖1
row_length, col_length = len(grid), len(grid[0])‖if (‖1
if (‖min(row, col) < 0‖1
min(row, col) < 0‖or row == row_length‖1
or row == row_length‖or col == col_length‖1
or col == col_length‖or (row, col) in visit‖1
or (row, col) in visit‖or grid[row][col] == 1‖1
or grid[row][col] == 1‖):‖1
return 0‖if row == row_length - 1 and col == col_length - 1:‖1
if row == row_length - 1 and col == col_length - 1:‖return 1‖1
count = 0‖count += depth_first_search(grid, row + 1, col, visit)‖1
count += depth_first_search(grid, row + 1, col, visit)‖count += depth_first_search(grid, row - 1, col, visit)‖1
count += depth_first_search(grid, row - 1, col, visit)‖count += depth_first_search(grid, row, col + 1, visit)‖1
count += depth_first_search(grid, row, col + 1, visit)‖count += depth_first_search(grid, row, col - 1, visit)‖1
visit.remove((row, col))‖return count‖1
def hexagonal(number: int) -> int:‖if not isinstance(number, int):‖1
"raise ValueError(""Input must be a positive integer"")"‖return number * (2 * number - 1)‖1
class Matrix:‖def __init__(self, row: int, col: int, graph: list[list[bool]]) -> None:‖1
def __init__(self, row: int, col: int, graph: list[list[bool]]) -> None:‖self.ROW = row‖1
self.ROW = row‖self.COL = col‖1
self.COL = col‖self.graph = graph‖1
def is_safe(self, i: int, j: int, visited: list[list[bool]]) -> bool:‖return (‖1
return (‖0 <= i < self.ROW‖1
0 <= i < self.ROW‖and 0 <= j < self.COL‖1
and 0 <= j < self.COL‖and not visited[i][j]‖1
and not visited[i][j]‖and self.graph[i][j]‖1
and self.graph[i][j]‖)‖1
row_nbr = [-1, -1, -1, 0, 0, 1, 1, 1]‖col_nbr = [-1, 0, 1, -1, 1, -1, 0, 1]‖1
col_nbr = [-1, 0, 1, -1, 1, -1, 0, 1]‖visited[i][j] = True‖1
visited[i][j] = True‖for k in range(8):‖1
for k in range(8):‖if self.is_safe(i + row_nbr[k], j + col_nbr[k], visited):‖1
if self.is_safe(i + row_nbr[k], j + col_nbr[k], visited):‖self.diffs(i + row_nbr[k], j + col_nbr[k], visited)‖1
def count_islands(self) -> int:‖visited = [[False for j in range(self.COL)] for i in range(self.ROW)]‖1
visited = [[False for j in range(self.COL)] for i in range(self.ROW)]‖count = 0‖1
count = 0‖for i in range(self.ROW):‖1
for i in range(self.ROW):‖for j in range(self.COL):‖1
for j in range(self.COL):‖if visited[i][j] is False and self.graph[i][j] == 1:‖1
if visited[i][j] is False and self.graph[i][j] == 1:‖self.diffs(i, j, visited)‖1
self.diffs(i, j, visited)‖count += 1‖1
def array_equalization(vector: list[int], step_size: int) -> int:‖if step_size <= 0:‖1
if step_size <= 0:‖"raise ValueError(""Step size must be positive and non-zero."")"‖1
"raise ValueError(""Step size must be positive and non-zero."")"‖if not isinstance(step_size, int):‖1
if not isinstance(step_size, int):‖"raise ValueError(""Step size must be an integer."")"‖1
unique_elements = set(vector)‖min_updates = maxsize‖1
for element in unique_elements:‖elem_index = 0‖1
elem_index = 0‖updates = 0‖1
updates = 0‖while elem_index < len(vector):‖1
while elem_index < len(vector):‖if vector[elem_index] != element:‖1
if vector[elem_index] != element:‖updates += 1‖1
updates += 1‖elem_index += step_size‖1
elem_index += step_size‖else:‖1
else:‖elem_index += 1‖1
elem_index += 1‖min_updates = min(min_updates, updates)‖1
def is_pronic(number: int) -> bool:‖if not isinstance(number, int):‖1
raise TypeError(msg)‖if number < 0 or number % 2 == 1:‖1
if number < 0 or number % 2 == 1:‖return False‖1
return False‖number_sqrt = int(number**0.5)‖1
number_sqrt = int(number**0.5)‖return number == number_sqrt * (number_sqrt + 1)‖1
matrix_1_to_4 = [‖[1, 2],‖1
[1, 2],‖[3, 4],‖1
[3, 4],‖]‖1
matrix_5_to_8 = [‖[5, 6],‖1
[5, 6],‖[7, 8],‖2
[7, 8],‖]‖1
matrix_5_to_9_high = [‖[5, 6],‖1
[7, 8],‖[9],‖1
[9],‖]‖1
matrix_5_to_9_wide = [‖[5, 6],‖1
[5, 6],‖[7, 8, 9],‖1
[7, 8, 9],‖]‖1
matrix_count_up = [‖[1, 2, 3, 4],‖1
[1, 2, 3, 4],‖[5, 6, 7, 8],‖1
[5, 6, 7, 8],‖[9, 10, 11, 12],‖1
[9, 10, 11, 12],‖[13, 14, 15, 16],‖1
[13, 14, 15, 16],‖]‖1
matrix_unordered = [‖[5, 8, 1, 2],‖1
[5, 8, 1, 2],‖[6, 7, 3, 0],‖1
[6, 7, 3, 0],‖[4, 5, 9, 1],‖1
[4, 5, 9, 1],‖[2, 6, 10, 14],‖1
[2, 6, 10, 14],‖]‖1
]‖matrices = (‖1
matrices = (‖matrix_1_to_4,‖1
matrix_1_to_4,‖matrix_5_to_8,‖1
matrix_5_to_8,‖matrix_5_to_9_high,‖1
matrix_5_to_9_high,‖matrix_5_to_9_wide,‖1
matrix_5_to_9_wide,‖matrix_count_up,‖1
matrix_count_up,‖matrix_unordered,‖1
matrix_unordered,‖)‖1
def is_square(matrix: Matrix) -> bool:‖len_matrix = len(matrix)‖1
len_matrix = len(matrix)‖return all(len(row) == len_matrix for row in matrix)‖1
def matrix_multiply(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:‖return [‖1
return [‖[sum(a * b for a, b in zip(row, col)) for col in zip(*matrix_b)]‖1
[sum(a * b for a, b in zip(row, col)) for col in zip(*matrix_b)]‖for row in matrix_a‖1
for row in matrix_a‖]‖1
def matrix_multiply_recursive(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:‖if not matrix_a or not matrix_b:‖1
if not matrix_a or not matrix_b:‖return []‖1
return []‖if not all(‖1
if not all(‖(len(matrix_a) == len(matrix_b), is_square(matrix_a), is_square(matrix_b))‖1
(len(matrix_a) == len(matrix_b), is_square(matrix_a), is_square(matrix_b))‖):‖1
):‖"raise ValueError(""Invalid matrix dimensions"")"‖1
def multiply(‖i_loop: int,‖1
i_loop: int,‖j_loop: int,‖1
j_loop: int,‖k_loop: int,‖1
k_loop: int,‖matrix_a: Matrix,‖1
matrix_a: Matrix,‖matrix_b: Matrix,‖1
matrix_b: Matrix,‖result: Matrix,‖1
result: Matrix,‖) -> None:‖1
) -> None:‖if i_loop >= len(matrix_a):‖1
if i_loop >= len(matrix_a):‖return‖1
return‖if j_loop >= len(matrix_b[0]):‖1
if j_loop >= len(matrix_b[0]):‖return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)‖1
return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)‖if k_loop >= len(matrix_b):‖1
if k_loop >= len(matrix_b):‖return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)‖1
return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)‖result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]‖1
result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]‖return multiply(i_loop, j_loop, k_loop + 1, matrix_a, matrix_b, result)‖1
multiply(0, 0, 0, matrix_a, matrix_b, result)‖return result‖1
failure_count, test_count = testmod()‖if not failure_count:‖1
if not failure_count:‖matrix_a = matrices[0]‖1
matrix_a = matrices[0]‖for matrix_b in matrices[1:]:‖1
for matrix_b in matrices[1:]:‖"print(""Multiplying:"")"‖1
"print(""Multiplying:"")"‖for row in matrix_a:‖1
for row in matrix_a:‖print(row)‖1
print(row)‖"print(""By:"")"‖1
"print(""By:"")"‖for row in matrix_b:‖1
for row in matrix_b:‖print(row)‖1
print(row)‖"print(""Result:"")"‖1
"print(""Result:"")"‖try:‖1
try:‖result = matrix_multiply_recursive(matrix_a, matrix_b)‖1
result = matrix_multiply_recursive(matrix_a, matrix_b)‖for row in result:‖1
for row in result:‖print(row)‖1
print(row)‖assert result == matrix_multiply(matrix_a, matrix_b)‖1
assert result == matrix_multiply(matrix_a, matrix_b)‖except ValueError as e:‖1
except ValueError as e:‖"print(f""{e!r}"")"‖1
"print(f""{e!r}"")"‖print()‖1
print()‖matrix_a = matrix_b‖1
"print(""Benchmark:"")"‖from functools import partial‖1
from functools import partial‖from timeit import timeit‖1
mytimeit = partial(timeit, globals=globals(), number=100_000)‖"for func in (""matrix_multiply"", ""matrix_multiply_recursive""):"‖1
"for func in (""matrix_multiply"", ""matrix_multiply_recursive""):"‖"print(f""{func:>25}(): {mytimeit(f'{func}(matrix_count_up, matrix_unordered)')}"")"‖1
determinant = float(‖d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1])‖1
d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1])‖)‖1
)‖if determinant == 0:‖2
if determinant == 0:‖"raise ValueError(""This matrix has no inverse."")"‖2
swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]‖swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]‖1
swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]‖swapped_matrix[1][0], swapped_matrix[0][1] = -matrix[1][0], -matrix[0][1]‖1
return [‖[(float(d(n)) / determinant) or 0.0 for n in row] for row in swapped_matrix‖1
[(float(d(n)) / determinant) or 0.0 for n in row] for row in swapped_matrix‖]‖1
]‖elif (‖1
elif (‖len(matrix) == 3‖1
len(matrix) == 3‖and len(matrix[0]) == 3‖1
and len(matrix[0]) == 3‖and len(matrix[1]) == 3‖1
and len(matrix[1]) == 3‖and len(matrix[2]) == 3‖1
and len(matrix[2]) == 3‖):‖1
determinant = float(‖(‖1
(‖(d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]))‖1
(d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]))‖+ (d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]))‖1
+ (d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]))‖+ (d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]))‖1
+ (d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]))‖)‖1
)‖- (‖1
- (‖(d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]))‖1
(d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]))‖+ (d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]))‖1
+ (d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]))‖+ (d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1]))‖1
+ (d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1]))‖)‖1
cofactor_matrix = [‖[d(0.0), d(0.0), d(0.0)],‖1
[d(0.0), d(0.0), d(0.0)],‖[d(0.0), d(0.0), d(0.0)],‖2
[d(0.0), d(0.0), d(0.0)],‖]‖1
]‖cofactor_matrix[0][0] = (d(matrix[1][1]) * d(matrix[2][2])) - (‖1
cofactor_matrix[0][0] = (d(matrix[1][1]) * d(matrix[2][2])) - (‖d(matrix[1][2]) * d(matrix[2][1])‖1
d(matrix[1][2]) * d(matrix[2][1])‖)‖1
)‖cofactor_matrix[0][1] = -(‖1
cofactor_matrix[0][1] = -(‖(d(matrix[1][0]) * d(matrix[2][2])) - (d(matrix[1][2]) * d(matrix[2][0]))‖1
(d(matrix[1][0]) * d(matrix[2][2])) - (d(matrix[1][2]) * d(matrix[2][0]))‖)‖1
)‖cofactor_matrix[0][2] = (d(matrix[1][0]) * d(matrix[2][1])) - (‖1
cofactor_matrix[0][2] = (d(matrix[1][0]) * d(matrix[2][1])) - (‖d(matrix[1][1]) * d(matrix[2][0])‖1
d(matrix[1][1]) * d(matrix[2][0])‖)‖1
)‖cofactor_matrix[1][0] = -(‖1
cofactor_matrix[1][0] = -(‖(d(matrix[0][1]) * d(matrix[2][2])) - (d(matrix[0][2]) * d(matrix[2][1]))‖1
(d(matrix[0][1]) * d(matrix[2][2])) - (d(matrix[0][2]) * d(matrix[2][1]))‖)‖1
)‖cofactor_matrix[1][1] = (d(matrix[0][0]) * d(matrix[2][2])) - (‖1
cofactor_matrix[1][1] = (d(matrix[0][0]) * d(matrix[2][2])) - (‖d(matrix[0][2]) * d(matrix[2][0])‖1
d(matrix[0][2]) * d(matrix[2][0])‖)‖1
)‖cofactor_matrix[1][2] = -(‖1
cofactor_matrix[1][2] = -(‖(d(matrix[0][0]) * d(matrix[2][1])) - (d(matrix[0][1]) * d(matrix[2][0]))‖1
(d(matrix[0][0]) * d(matrix[2][1])) - (d(matrix[0][1]) * d(matrix[2][0]))‖)‖1
)‖cofactor_matrix[2][0] = (d(matrix[0][1]) * d(matrix[1][2])) - (‖1
cofactor_matrix[2][0] = (d(matrix[0][1]) * d(matrix[1][2])) - (‖d(matrix[0][2]) * d(matrix[1][1])‖1
d(matrix[0][2]) * d(matrix[1][1])‖)‖1
)‖cofactor_matrix[2][1] = -(‖1
cofactor_matrix[2][1] = -(‖(d(matrix[0][0]) * d(matrix[1][2])) - (d(matrix[0][2]) * d(matrix[1][0]))‖1
(d(matrix[0][0]) * d(matrix[1][2])) - (d(matrix[0][2]) * d(matrix[1][0]))‖)‖1
)‖cofactor_matrix[2][2] = (d(matrix[0][0]) * d(matrix[1][1])) - (‖1
cofactor_matrix[2][2] = (d(matrix[0][0]) * d(matrix[1][1])) - (‖d(matrix[0][1]) * d(matrix[1][0])‖1
d(matrix[0][1]) * d(matrix[1][0])‖)‖1
adjoint_matrix = array(cofactor_matrix)‖for i in range(3):‖1
for j in range(3):‖adjoint_matrix[i][j] = cofactor_matrix[j][i]‖1
inverse_matrix = array(cofactor_matrix)‖for i in range(3):‖1
for j in range(3):‖inverse_matrix[i][j] /= d(determinant)‖1
return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]‖"raise ValueError(""Please provide a matrix of size 2x2 or 3x3."")"‖1
def add(*matrix_s: list[list[int]]) -> list[list[int]]:‖if all(_check_not_integer(m) for m in matrix_s):‖1
if all(_check_not_integer(m) for m in matrix_s):‖for i in matrix_s[1:]:‖1
for i in matrix_s[1:]:‖_verify_matrix_sizes(matrix_s[0], i)‖1
_verify_matrix_sizes(matrix_s[0], i)‖return [[sum(t) for t in zip(*m)] for m in zip(*matrix_s)]‖1
return [[sum(t) for t in zip(*m)] for m in zip(*matrix_s)]‖"raise TypeError(""Expected a matrix, got int/list instead"")"‖1
def subtract(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:‖if (‖1
if (‖_check_not_integer(matrix_a)‖1
_check_not_integer(matrix_a)‖and _check_not_integer(matrix_b)‖1
and _check_not_integer(matrix_b)‖and _verify_matrix_sizes(matrix_a, matrix_b)‖1
and _verify_matrix_sizes(matrix_a, matrix_b)‖):‖1
):‖return [[i - j for i, j in zip(*m)] for m in zip(matrix_a, matrix_b)]‖1
return [[i - j for i, j in zip(*m)] for m in zip(matrix_a, matrix_b)]‖"raise TypeError(""Expected a matrix, got int/list instead"")"‖1
def scalar_multiply(matrix: list[list[int]], n: float) -> list[list[float]]:‖return [[x * n for x in row] for row in matrix]‖1
def multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:‖if _check_not_integer(matrix_a) and _check_not_integer(matrix_b):‖1
if _check_not_integer(matrix_a) and _check_not_integer(matrix_b):‖rows, cols = _verify_matrix_sizes(matrix_a, matrix_b)‖1
if cols[0] != rows[1]:‖msg = (‖1
msg = (‖"""Cannot multiply matrix of dimensions """‖1
"""Cannot multiply matrix of dimensions """‖"f""({rows[0]},{cols[0]}) and ({rows[1]},{cols[1]})"""‖1
"f""({rows[0]},{cols[0]}) and ({rows[1]},{cols[1]})"""‖)‖1
raise ValueError(msg)‖return [‖1
return [‖[sum(m * n for m, n in zip(i, j)) for j in zip(*matrix_b)] for i in matrix_a‖1
[sum(m * n for m, n in zip(i, j)) for j in zip(*matrix_b)] for i in matrix_a‖]‖1
def identity(n: int) -> list[list[int]]:‖n = int(n)‖1
n = int(n)‖return [[int(row == column) for column in range(n)] for row in range(n)]‖1
def transpose(‖matrix: list[list[int]], return_map: bool = True‖1
matrix: list[list[int]], return_map: bool = True‖) -> list[list[int]] | map[list[int]]:‖1
) -> list[list[int]] | map[list[int]]:‖if _check_not_integer(matrix):‖1
if _check_not_integer(matrix):‖if return_map:‖1
if return_map:‖return map(list, zip(*matrix))‖1
return map(list, zip(*matrix))‖else:‖1
else:‖return list(map(list, zip(*matrix)))‖1
return list(map(list, zip(*matrix)))‖"raise TypeError(""Expected a matrix, got int/list instead"")"‖1
def minor(matrix: list[list[int]], row: int, column: int) -> list[list[int]]:‖minor = matrix[:row] + matrix[row + 1 :]‖1
minor = matrix[:row] + matrix[row + 1 :]‖return [row[:column] + row[column + 1 :] for row in minor]‖1
def determinant(matrix: list[list[int]]) -> Any:‖if len(matrix) == 1:‖1
if len(matrix) == 1:‖return matrix[0][0]‖1
return sum(‖x * determinant(minor(matrix, 0, i)) * (-1) ** i‖1
x * determinant(minor(matrix, 0, i)) * (-1) ** i‖for i, x in enumerate(matrix[0])‖1
for i, x in enumerate(matrix[0])‖)‖1
det = determinant(matrix)‖if det == 0:‖1
if det == 0:‖return None‖1
matrix_minor = [‖[determinant(minor(matrix, i, j)) for j in range(len(matrix))]‖1
[determinant(minor(matrix, i, j)) for j in range(len(matrix))]‖for i in range(len(matrix))‖1
for i in range(len(matrix))‖]‖1
cofactors = [‖[x * (-1) ** (row + col) for col, x in enumerate(matrix_minor[row])]‖1
[x * (-1) ** (row + col) for col, x in enumerate(matrix_minor[row])]‖for row in range(len(matrix))‖1
for row in range(len(matrix))‖]‖1
]‖adjugate = list(transpose(cofactors))‖1
adjugate = list(transpose(cofactors))‖return scalar_multiply(adjugate, 1 / det)‖1
def _check_not_integer(matrix: list[list[int]]) -> bool:‖return not isinstance(matrix, int) and not isinstance(matrix[0], int)‖1
def _shape(matrix: list[list[int]]) -> tuple[int, int]:‖return len(matrix), len(matrix[0])‖1
def _verify_matrix_sizes(‖matrix_a: list[list[int]], matrix_b: list[list[int]]‖1
matrix_a: list[list[int]], matrix_b: list[list[int]]‖) -> tuple[tuple[int, int], tuple[int, int]]:‖1
) -> tuple[tuple[int, int], tuple[int, int]]:‖shape = _shape(matrix_a) + _shape(matrix_b)‖1
shape = _shape(matrix_a) + _shape(matrix_b)‖if shape[0] != shape[3] or shape[1] != shape[2]:‖1
if shape[0] != shape[3] or shape[1] != shape[2]:‖msg = (‖1
msg = (‖"""operands could not be broadcast together with shape """‖1
"""operands could not be broadcast together with shape """‖"f""({shape[0], shape[1]}), ({shape[2], shape[3]})"""‖1
"f""({shape[0], shape[1]}), ({shape[2], shape[3]})"""‖)‖1
raise ValueError(msg)‖return (shape[0], shape[2]), (shape[1], shape[3])‖1
def main() -> None:‖matrix_a = [[12, 10], [3, 9]]‖1
matrix_a = [[12, 10], [3, 9]]‖matrix_b = [[3, 4], [7, 4]]‖1
matrix_b = [[3, 4], [7, 4]]‖matrix_c = [[11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34], [41, 42, 43, 44]]‖1
matrix_c = [[11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34], [41, 42, 43, 44]]‖matrix_d = [[3, 0, 2], [2, 0, -2], [0, 1, 1]]‖1
matrix_d = [[3, 0, 2], [2, 0, -2], [0, 1, 1]]‖"print(f""Add Operation, {add(matrix_a, matrix_b) = } \n"")"‖1
"print(f""Add Operation, {add(matrix_a, matrix_b) = } \n"")"‖"print(f""Multiply Operation, {multiply(matrix_a, matrix_b) = } \n"")"‖1
"print(f""Multiply Operation, {multiply(matrix_a, matrix_b) = } \n"")"‖"print(f""Identity: {identity(5)}\n"")"‖1
"print(f""Identity: {identity(5)}\n"")"‖"print(f""Minor of {matrix_c} = {minor(matrix_c, 1, 2)} \n"")"‖1
"print(f""Minor of {matrix_c} = {minor(matrix_c, 1, 2)} \n"")"‖"print(f""Determinant of {matrix_b} = {determinant(matrix_b)} \n"")"‖1
"print(f""Determinant of {matrix_b} = {determinant(matrix_b)} \n"")"‖"print(f""Inverse of {matrix_d} = {inverse(matrix_d)}\n"")"‖1
def validate_matrix_size(size: int) -> None:‖if not isinstance(size, int) or size <= 0:‖1
if not isinstance(size, int) or size <= 0:‖"raise ValueError(""Matrix size must be a positive integer."")"‖1
def validate_matrix_content(matrix: list[str], size: int) -> None:‖print(matrix)‖1
print(matrix)‖if len(matrix) != size:‖1
if len(matrix) != size:‖"raise ValueError(""The matrix dont match with size."")"‖1
"raise ValueError(""The matrix dont match with size."")"‖for row in matrix:‖1
for row in matrix:‖if len(row) != size:‖1
if len(row) != size:‖"msg = f""Each row in the matrix must have exactly {size} characters."""‖1
"msg = f""Each row in the matrix must have exactly {size} characters."""‖raise ValueError(msg)‖1
raise ValueError(msg)‖if not all(char.isalnum() for char in row):‖1
if not all(char.isalnum() for char in row):‖"raise ValueError(""Matrix rows can only contain letters and numbers."")"‖1
def validate_moves(moves: list[tuple[int, int]], size: int) -> None:‖for move in moves:‖1
for move in moves:‖x, y = move‖1
x, y = move‖if not (0 <= x < size and 0 <= y < size):‖1
if not (0 <= x < size and 0 <= y < size):‖"raise ValueError(""Move is out of bounds for a matrix."")"‖1
def parse_moves(input_str: str) -> list[tuple[int, int]]:‖moves = []‖1
moves = []‖"for pair in input_str.split("",""):"‖1
"for pair in input_str.split("",""):"‖parts = pair.strip().split()‖1
parts = pair.strip().split()‖if len(parts) != 2:‖1
if len(parts) != 2:‖"raise ValueError(""Each move must have exactly two numbers."")"‖1
"raise ValueError(""Each move must have exactly two numbers."")"‖x, y = map(int, parts)‖1
x, y = map(int, parts)‖moves.append((x, y))‖1
moves.append((x, y))‖return moves‖1
def find_repeat(‖matrix_g: list[list[str]], row: int, column: int, size: int‖1
matrix_g: list[list[str]], row: int, column: int, size: int‖) -> set[tuple[int, int]]:‖1
column = size - 1 - column‖visited = set()‖1
visited = set()‖repeated = set()‖1
def dfs(row_n: int, column_n: int) -> None:‖if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:‖1
if row_n < 0 or row_n >= size or column_n < 0 or column_n >= size:‖return‖1
return‖if (row_n, column_n) in visited:‖1
if (row_n, column_n) in visited:‖return‖1
return‖visited.add((row_n, column_n))‖1
visited.add((row_n, column_n))‖if matrix_g[row_n][column_n] == color:‖1
if matrix_g[row_n][column_n] == color:‖repeated.add((row_n, column_n))‖1
repeated.add((row_n, column_n))‖dfs(row_n - 1, column_n)‖1
dfs(row_n - 1, column_n)‖dfs(row_n + 1, column_n)‖1
dfs(row_n + 1, column_n)‖dfs(row_n, column_n - 1)‖1
dfs(row_n, column_n - 1)‖dfs(row_n, column_n + 1)‖1
def increment_score(count: int) -> int:‖return int(count * (count + 1) / 2)‖1
for row in range(size):‖"if matrix_g[row][column] != ""-"":"‖1
"if matrix_g[row][column] != ""-"":"‖new_list.append(matrix_g[row][column])‖1
new_list.append(matrix_g[row][column])‖else:‖1
else:‖new_list.insert(0, matrix_g[row][column])‖1
new_list.insert(0, matrix_g[row][column])‖for row in range(size):‖1
for row in range(size):‖matrix_g[row][column] = new_list[row]‖1
matrix_g[row][column] = new_list[row]‖return matrix_g‖1
for column in range(size - 1, -1, -1):‖"if all(matrix_g[row][column] == ""-"" for row in range(size)):"‖1
"if all(matrix_g[row][column] == ""-"" for row in range(size)):"‖empty_columns.append(column)‖1
for column in empty_columns:‖for col in range(column + 1, size):‖1
for col in range(column + 1, size):‖for row in range(size):‖1
for row in range(size):‖matrix_g[row][col - 1] = matrix_g[row][col]‖1
matrix_g[row][col - 1] = matrix_g[row][col]‖for row in range(size):‖1
for row in range(size):‖"matrix_g[row][-1] = ""-"""‖1
def play(‖matrix_g: list[list[str]], pos_x: int, pos_y: int, size: int‖1
matrix_g: list[list[str]], pos_x: int, pos_y: int, size: int‖) -> tuple[list[list[str]], int]:‖1
if len(same_colors) != 0:‖for pos in same_colors:‖1
for pos in same_colors:‖"matrix_g[pos[0]][pos[1]] = ""-"""‖1
"matrix_g[pos[0]][pos[1]] = ""-"""‖for column in range(size):‖1
for column in range(size):‖matrix_g = move_x(matrix_g, column, size)‖1
game_matrix = [list(row) for row in matrix]‖total_score = 0‖1
for move in moves:‖pos_x, pos_y = move‖1
pos_x, pos_y = move‖game_matrix, score = play(game_matrix, pos_x, pos_y, size)‖1
game_matrix, score = play(game_matrix, pos_x, pos_y, size)‖total_score += score‖1
doctest.testmod(verbose=True)‖try:‖1
try:‖"size = int(input(""Enter the size of the matrix: ""))"‖1
"size = int(input(""Enter the size of the matrix: ""))"‖validate_matrix_size(size)‖1
validate_matrix_size(size)‖"print(f""Enter the {size} rows of the matrix:"")"‖1
"print(f""Enter the {size} rows of the matrix:"")"‖"matrix = [input(f""Row {i + 1}: "") for i in range(size)]"‖1
"matrix = [input(f""Row {i + 1}: "") for i in range(size)]"‖validate_matrix_content(matrix, size)‖1
validate_matrix_content(matrix, size)‖"moves_input = input(""Enter the moves (e.g., '0 0, 1 1'): "")"‖1
"moves_input = input(""Enter the moves (e.g., '0 0, 1 1'): "")"‖moves = parse_moves(moves_input)‖1
moves = parse_moves(moves_input)‖validate_moves(moves, size)‖1
validate_moves(moves, size)‖score = process_game(size, matrix, moves)‖1
score = process_game(size, matrix, moves)‖"print(f""Total score: {score}"")"‖1
"print(f""Total score: {score}"")"‖except ValueError as e:‖1
except ValueError as e:‖"print(f""{e}"")"‖1
"msg = ""number must be an integer"""‖print(msg)‖1
print(msg)‖raise ValueError(msg)‖1
def search_in_a_sorted_matrix(mat: list[list[int]], m: int, n: int, key: float) -> None:‖i, j = m - 1, 0‖1
i, j = m - 1, 0‖while i >= 0 and j < n:‖1
while i >= 0 and j < n:‖if key == mat[i][j]:‖1
if key == mat[i][j]:‖"print(f""Key {key} found at row- {i + 1} column- {j + 1}"")"‖1
"print(f""Key {key} found at row- {i + 1} column- {j + 1}"")"‖return‖1
return‖if key < mat[i][j]:‖1
if key < mat[i][j]:‖i -= 1‖1
else:‖j += 1‖1
j += 1‖"print(f""Key {key} not found"")"‖1
def main() -> None:‖mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]‖1
mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]‖"x = int(input(""Enter the element to be searched:""))"‖1
"x = int(input(""Enter the element to be searched:""))"‖print(mat)‖1
print(mat)‖search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), x)‖1
def make_matrix(row_size: int = 4) -> list[list[int]]:‖row_size = abs(row_size) or 4‖1
row_size = abs(row_size) or 4‖return [[1 + x + y * row_size for x in range(row_size)] for y in range(row_size)]‖1
def transpose(matrix: list[list[int]]) -> list[list[int]]:‖matrix[:] = [list(x) for x in zip(*matrix)]‖1
matrix[:] = [list(x) for x in zip(*matrix)]‖return matrix‖1
def reverse_row(matrix: list[list[int]]) -> list[list[int]]:‖matrix[:] = matrix[::-1]‖1
matrix[:] = matrix[::-1]‖return matrix‖1
def reverse_column(matrix: list[list[int]]) -> list[list[int]]:‖matrix[:] = [x[::-1] for x in matrix]‖1
matrix[:] = [x[::-1] for x in matrix]‖return matrix‖1
def print_matrix(matrix: list[list[int]]) -> None:‖for i in matrix:‖1
for i in matrix:‖print(*i)‖1
"if __name__ == ""__main__"":"‖matrix = make_matrix()‖1
matrix = make_matrix()‖"print(""\norigin:\n"")"‖3
"print(""\norigin:\n"")"‖print_matrix(matrix)‖3
print_matrix(matrix)‖"print(""\nrotate 90 counterclockwise:\n"")"‖1
"print(""\nrotate 90 counterclockwise:\n"")"‖print_matrix(rotate_90(matrix))‖1
print_matrix(matrix)‖"print(""\nrotate 180:\n"")"‖1
"print(""\nrotate 180:\n"")"‖print_matrix(rotate_180(matrix))‖1
print_matrix(matrix)‖"print(""\nrotate 270 counterclockwise:\n"")"‖1
"print(""\nrotate 270 counterclockwise:\n"")"‖print_matrix(rotate_270(matrix))‖1
matrix = [‖[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],‖1
[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],‖[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],‖1
[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],‖[0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],‖1
[0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],‖[0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],‖1
[0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],‖[0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],‖1
[0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],‖[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],‖1
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],‖[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],‖1
[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],‖[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],‖1
[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],‖]‖1
def is_safe(row: int, col: int, rows: int, cols: int) -> bool:‖return 0 <= row < rows and 0 <= col < cols‖1
def depth_first_search(row: int, col: int, seen: set, mat: list[list[int]]) -> int:‖rows = len(mat)‖1
rows = len(mat)‖cols = len(mat[0])‖1
cols = len(mat[0])‖if is_safe(row, col, rows, cols) and (row, col) not in seen and mat[row][col] == 1:‖1
if is_safe(row, col, rows, cols) and (row, col) not in seen and mat[row][col] == 1:‖seen.add((row, col))‖1
seen.add((row, col))‖return (‖1
1‖+ depth_first_search(row + 1, col, seen, mat)‖1
+ depth_first_search(row + 1, col, seen, mat)‖+ depth_first_search(row - 1, col, seen, mat)‖1
+ depth_first_search(row - 1, col, seen, mat)‖+ depth_first_search(row, col + 1, seen, mat)‖1
+ depth_first_search(row, col + 1, seen, mat)‖+ depth_first_search(row, col - 1, seen, mat)‖1
+ depth_first_search(row, col - 1, seen, mat)‖)‖1
else:‖return 0‖3
def find_max_area(mat: list[list[int]]) -> int:‖seen: set = set()‖1
max_area = 0‖for row, line in enumerate(mat):‖1
for row, line in enumerate(mat):‖for col, item in enumerate(line):‖1
for col, item in enumerate(line):‖if item == 1 and (row, col) not in seen:‖1
max_area = max(max_area, depth_first_search(row, col, seen, mat))‖return max_area‖1
test_graph = [‖[0, 16, 13, 0, 0, 0],‖1
[0, 16, 13, 0, 0, 0],‖[0, 0, 10, 12, 0, 0],‖2
[0, 0, 10, 12, 0, 0],‖[0, 4, 0, 0, 14, 0],‖2
[0, 4, 0, 0, 14, 0],‖[0, 0, 9, 0, 0, 20],‖2
[0, 0, 9, 0, 0, 20],‖[0, 0, 0, 7, 0, 4],‖2
[0, 0, 0, 7, 0, 4],‖[0, 0, 0, 0, 0, 0],‖2
[0, 0, 0, 0, 0, 0],‖]‖2
visited = [False] * len(graph)‖queue = [s]‖1
queue = [s]‖visited[s] = True‖1
while queue:‖u = queue.pop(0)‖2
u = queue.pop(0)‖for ind in range(len(graph[u])):‖1
for ind in range(len(graph[u])):‖if visited[ind] is False and graph[u][ind] > 0:‖1
if visited[ind] is False and graph[u][ind] > 0:‖queue.append(ind)‖1
queue.append(ind)‖visited[ind] = True‖2
visited[ind] = True‖parent[ind] = u‖1
def mincut(graph, source, sink):‖parent = [-1] * (len(graph))‖1
parent = [-1] * (len(graph))‖max_flow = 0‖2
max_flow = 0‖res = []‖1
res = []‖temp = [i[:] for i in graph]‖1
temp = [i[:] for i in graph]‖while bfs(graph, source, sink, parent):‖1
while bfs(graph, source, sink, parent):‖"path_flow = float(""Inf"")"‖1
"path_flow = float(""Inf"")"‖s = sink‖1
path_flow = min(path_flow, graph[parent[s]][s])‖s = parent[s]‖2
max_flow += path_flow‖v = sink‖2
while v != source:‖u = parent[v]‖2
u = parent[v]‖graph[u][v] -= path_flow‖2
graph[u][v] -= path_flow‖graph[v][u] += path_flow‖2
graph[v][u] += path_flow‖v = parent[v]‖2
for i in range(len(graph)):‖for j in range(len(graph[0])):‖1
for j in range(len(graph[0])):‖if graph[i][j] == 0 and temp[i][j] > 0:‖1
if graph[i][j] == 0 and temp[i][j] > 0:‖res.append((i, j))‖1
"if __name__ == ""__main__"":"‖print(mincut(test_graph, source=0, sink=5))‖1
def print_pascal_triangle(num_rows: int) -> None:‖triangle = generate_pascal_triangle(num_rows)‖1
triangle = generate_pascal_triangle(num_rows)‖for row_idx in range(num_rows):‖1
for _ in range(num_rows - row_idx - 1):‖"print(end="" "")"‖1
for col_idx in range(row_idx + 1):‖if col_idx != row_idx:‖1
if col_idx != row_idx:‖"print(triangle[row_idx][col_idx], end="" "")"‖1
"print(triangle[row_idx][col_idx], end="" "")"‖else:‖1
else:‖"print(triangle[row_idx][col_idx], end="""")"‖1
"print(triangle[row_idx][col_idx], end="""")"‖print()‖1
if not isinstance(num_rows, int):‖"raise TypeError(""The input value of 'num_rows' should be 'int'"")"‖2
if num_rows == 0:‖return []‖2
return []‖elif num_rows < 0:‖2
elif num_rows < 0:‖raise ValueError(‖2
raise ValueError(‖"""The input value of 'num_rows' should be greater than or equal to 0"""‖2
"""The input value of 'num_rows' should be greater than or equal to 0"""‖)‖2
triangle: list[list[int]] = []‖for current_row_idx in range(num_rows):‖1
for current_row_idx in range(num_rows):‖current_row = populate_current_row(triangle, current_row_idx)‖1
current_row = populate_current_row(triangle, current_row_idx)‖triangle.append(current_row)‖1
triangle.append(current_row)‖return triangle‖1
def populate_current_row(triangle: list[list[int]], current_row_idx: int) -> list[int]:‖current_row = [-1] * (current_row_idx + 1)‖1
current_row[0], current_row[-1] = 1, 1‖for current_col_idx in range(1, current_row_idx):‖1
for current_col_idx in range(1, current_row_idx):‖calculate_current_element(‖1
calculate_current_element(‖triangle, current_row, current_row_idx, current_col_idx‖1
triangle, current_row, current_row_idx, current_col_idx‖)‖1
)‖return current_row‖1
def calculate_current_element(‖triangle: list[list[int]],‖1
triangle: list[list[int]],‖current_row: list[int],‖1
current_row: list[int],‖current_row_idx: int,‖1
current_row_idx: int,‖current_col_idx: int,‖1
current_col_idx: int,‖) -> None:‖1
) -> None:‖above_to_left_elt = triangle[current_row_idx - 1][current_col_idx - 1]‖1
above_to_left_elt = triangle[current_row_idx - 1][current_col_idx - 1]‖above_to_right_elt = triangle[current_row_idx - 1][current_col_idx]‖1
above_to_right_elt = triangle[current_row_idx - 1][current_col_idx]‖current_row[current_col_idx] = above_to_left_elt + above_to_right_elt‖1
for row_index in range(1, num_rows):‖temp_row = [0] + result[-1] + [0]‖1
temp_row = [0] + result[-1] + [0]‖row_length = row_index + 1‖1
distinct_elements = sum(divmod(row_length, 2))‖row_first_half = [‖1
row_first_half = [‖temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)‖1
temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)‖]‖1
]‖row_second_half = row_first_half[: (row_index + 1) // 2]‖1
row_second_half = row_first_half[: (row_index + 1) // 2]‖row_second_half.reverse()‖1
row_second_half.reverse()‖row = row_first_half + row_second_half‖1
row = row_first_half + row_second_half‖result.append(row)‖1
for value in range(15):‖for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):‖1
for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):‖benchmark_a_function(func, value)‖1
matrix = [list(row) for row in matrix]‖if matrix and isinstance(matrix, list):‖1
if matrix and isinstance(matrix, list):‖if isinstance(matrix[0], list):‖1
if isinstance(matrix[0], list):‖prev_len = 0‖1
prev_len = 0‖for row in matrix:‖1
for row in matrix:‖if prev_len == 0:‖1
if prev_len == 0:‖prev_len = len(row)‖1
prev_len = len(row)‖result = True‖1
result = True‖else:‖2
else:‖result = prev_len == len(row)‖1
result = prev_len == len(row)‖else:‖1
else:‖result = True‖1
else:‖result = False‖1
def spiral_print_clockwise(a: list[list[int]]) -> None:‖if check_matrix(a) and len(a) > 0:‖1
if check_matrix(a) and len(a) > 0:‖a = [list(row) for row in a]‖1
a = [list(row) for row in a]‖mat_row = len(a)‖1
mat_row = len(a)‖if isinstance(a[0], list):‖1
if isinstance(a[0], list):‖mat_col = len(a[0])‖1
mat_col = len(a[0])‖else:‖1
else:‖for dat in a:‖1
for dat in a:‖print(dat)‖1
print(dat)‖return‖1
for i in range(mat_col):‖print(a[0][i])‖1
for i in range(1, mat_row):‖print(a[i][mat_col - 1])‖1
if mat_row > 1:‖for i in range(mat_col - 2, -1, -1):‖1
for i in range(mat_col - 2, -1, -1):‖print(a[mat_row - 1][i])‖1
for i in range(mat_row - 2, 0, -1):‖print(a[i][0])‖1
print(a[i][0])‖remain_mat = [row[1 : mat_col - 1] for row in a[1 : mat_row - 1]]‖1
remain_mat = [row[1 : mat_col - 1] for row in a[1 : mat_row - 1]]‖if len(remain_mat) > 0:‖1
if len(remain_mat) > 0:‖spiral_print_clockwise(remain_mat)‖1
spiral_print_clockwise(remain_mat)‖else:‖1
else:‖return‖1
else:‖"print(""Not a valid matrix"")"‖1
"print(""Not a valid matrix"")"‖return‖1
def spiral_traversal(matrix: list[list]) -> list[int]:‖if matrix:‖1
if matrix:‖return list(matrix.pop(0)) + spiral_traversal(‖1
return list(matrix.pop(0)) + spiral_traversal(‖[list(row) for row in zip(*matrix)][::-1]‖1
[list(row) for row in zip(*matrix)][::-1]‖)‖1
else:‖return []‖2
a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]‖spiral_print_clockwise(a)‖1
def largest_square_area_in_matrix_top_down_approch(‖rows: int, cols: int, mat: list[list[int]]‖1
rows: int, cols: int, mat: list[list[int]]‖) -> int:‖4
if row >= rows or col >= cols:‖return 0‖2
right = update_area_of_max_square(row, col + 1)‖diagonal = update_area_of_max_square(row + 1, col + 1)‖1
diagonal = update_area_of_max_square(row + 1, col + 1)‖down = update_area_of_max_square(row + 1, col)‖1
if mat[row][col]:‖sub_problem_sol = 1 + min([right, diagonal, down])‖2
sub_problem_sol = 1 + min([right, diagonal, down])‖largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)‖2
largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)‖return sub_problem_sol‖1
return sub_problem_sol‖else:‖2
largest_square_area = [0]‖update_area_of_max_square(0, 0)‖1
update_area_of_max_square(0, 0)‖return largest_square_area[0]‖1
def largest_square_area_in_matrix_top_down_approch_with_dp(‖rows: int, cols: int, mat: list[list[int]]‖1
def update_area_of_max_square_using_dp_array(‖row: int, col: int, dp_array: list[list[int]]‖1
row: int, col: int, dp_array: list[list[int]]‖) -> int:‖1
) -> int:‖if row >= rows or col >= cols:‖1
return 0‖if dp_array[row][col] != -1:‖1
if dp_array[row][col] != -1:‖return dp_array[row][col]‖1
right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)‖diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)‖1
diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)‖down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)‖1
largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)‖dp_array[row][col] = sub_problem_sol‖1
dp_array[row][col] = sub_problem_sol‖return sub_problem_sol‖1
largest_square_area = [0]‖dp_array = [[-1] * cols for _ in range(rows)]‖1
dp_array = [[-1] * cols for _ in range(rows)]‖update_area_of_max_square_using_dp_array(0, 0, dp_array)‖1
def largest_square_area_in_matrix_bottom_up(‖rows: int, cols: int, mat: list[list[int]]‖1
) -> int:‖dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]‖1
dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]‖largest_square_area = 0‖1
largest_square_area = 0‖for row in range(rows - 1, -1, -1):‖2
for row in range(rows - 1, -1, -1):‖for col in range(cols - 1, -1, -1):‖2
for col in range(cols - 1, -1, -1):‖right = dp_array[row][col + 1]‖1
right = dp_array[row][col + 1]‖diagonal = dp_array[row + 1][col + 1]‖1
diagonal = dp_array[row + 1][col + 1]‖bottom = dp_array[row + 1][col]‖1
if mat[row][col] == 1:‖dp_array[row][col] = 1 + min(right, diagonal, bottom)‖1
dp_array[row][col] = 1 + min(right, diagonal, bottom)‖largest_square_area = max(dp_array[row][col], largest_square_area)‖1
largest_square_area = max(dp_array[row][col], largest_square_area)‖else:‖1
else:‖dp_array[row][col] = 0‖1
def largest_square_area_in_matrix_bottom_up_space_optimization(‖rows: int, cols: int, mat: list[list[int]]‖1
) -> int:‖current_row = [0] * (cols + 1)‖1
current_row = [0] * (cols + 1)‖next_row = [0] * (cols + 1)‖1
next_row = [0] * (cols + 1)‖largest_square_area = 0‖1
for col in range(cols - 1, -1, -1):‖right = current_row[col + 1]‖1
right = current_row[col + 1]‖diagonal = next_row[col + 1]‖1
diagonal = next_row[col + 1]‖bottom = next_row[col]‖1
if mat[row][col] == 1:‖current_row[col] = 1 + min(right, diagonal, bottom)‖1
current_row[col] = 1 + min(right, diagonal, bottom)‖largest_square_area = max(current_row[col], largest_square_area)‖1
largest_square_area = max(current_row[col], largest_square_area)‖else:‖1
else:‖current_row[col] = 0‖1
current_row[col] = 0‖next_row = current_row‖1
doctest.testmod()‖print(largest_square_area_in_matrix_bottom_up(2, 2, [[1, 1], [1, 1]]))‖1
graph = [‖[0, 16, 13, 0, 0, 0],‖1
def breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:‖visited = [False] * len(graph)‖1
visited = [False] * len(graph)‖queue = []‖1
queue.append(source)‖visited[source] = True‖1
for ind, node in enumerate(graph[u]):‖if visited[ind] is False and node > 0:‖1
if visited[ind] is False and node > 0:‖queue.append(ind)‖1
visited[ind] = True‖parents[ind] = u‖1
parents[ind] = u‖return visited[sink]‖1
while breadth_first_search(graph, source, sink, parent):‖path_flow = int(1e9)‖1
path_flow = int(1e9)‖s = sink‖1
testmod()‖"print(f""{ford_fulkerson(graph, source=0, sink=5) = }"")"‖1
mat_a = [[12, 10], [3, 9]]‖mat_b = [[3, 4], [7, 4]]‖1
mat_b = [[3, 4], [7, 4]]‖mat_c = [[3, 0, 2], [2, 0, -2], [0, 1, 1]]‖1
mat_c = [[3, 0, 2], [2, 0, -2], [0, 1, 1]]‖mat_d = [[3, 0, -2], [2, 0, 2], [0, 1, 1]]‖1
mat_d = [[3, 0, -2], [2, 0, 2], [0, 1, 1]]‖mat_e = [[3, 0, 2], [2, 0, -2], [0, 1, 1], [2, 0, -2]]‖1
mat_e = [[3, 0, 2], [2, 0, -2], [0, 1, 1], [2, 0, -2]]‖mat_f = [1]‖1
mat_f = [1]‖mat_h = [2]‖1
logger = logging.getLogger()‖logger.level = logging.DEBUG‖1
logger.level = logging.DEBUG‖stream_handler = logging.StreamHandler(sys.stdout)‖1
stream_handler = logging.StreamHandler(sys.stdout)‖logger.addHandler(stream_handler)‖1
@pytest.mark.mat_ops‖@pytest.mark.parametrize(‖3
@pytest.mark.parametrize(‖"(""mat1"", ""mat2""), [(mat_a, mat_b), (mat_c, mat_d), (mat_d, mat_e), (mat_f, mat_h)]"‖3
"(""mat1"", ""mat2""), [(mat_a, mat_b), (mat_c, mat_d), (mat_d, mat_e), (mat_f, mat_h)]"‖)‖3
)‖def test_addition(mat1, mat2):‖1
def test_addition(mat1, mat2):‖if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):‖1
if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):‖"logger.info(f""\n\t{test_addition.__name__} returned integer"")"‖1
"logger.info(f""\n\t{test_addition.__name__} returned integer"")"‖with pytest.raises(TypeError):‖1
with pytest.raises(TypeError):‖matop.add(mat1, mat2)‖2
matop.add(mat1, mat2)‖elif (np.array(mat1)).shape == (np.array(mat2)).shape:‖2
elif (np.array(mat1)).shape == (np.array(mat2)).shape:‖"logger.info(f""\n\t{test_addition.__name__} with same matrix dims"")"‖1
"logger.info(f""\n\t{test_addition.__name__} with same matrix dims"")"‖act = (np.array(mat1) + np.array(mat2)).tolist()‖1
act = (np.array(mat1) + np.array(mat2)).tolist()‖theo = matop.add(mat1, mat2)‖1
theo = matop.add(mat1, mat2)‖assert theo == act‖1
assert theo == act‖else:‖3
else:‖"logger.info(f""\n\t{test_addition.__name__} with different matrix dims"")"‖1
"logger.info(f""\n\t{test_addition.__name__} with different matrix dims"")"‖with pytest.raises(ValueError):‖1
with pytest.raises(ValueError):‖matop.add(mat1, mat2)‖1
)‖def test_subtraction(mat1, mat2):‖1
def test_subtraction(mat1, mat2):‖if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):‖1
if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):‖"logger.info(f""\n\t{test_subtraction.__name__} returned integer"")"‖1
"logger.info(f""\n\t{test_subtraction.__name__} returned integer"")"‖with pytest.raises(TypeError):‖1
with pytest.raises(TypeError):‖matop.subtract(mat1, mat2)‖1
matop.subtract(mat1, mat2)‖elif (np.array(mat1)).shape == (np.array(mat2)).shape:‖1
elif (np.array(mat1)).shape == (np.array(mat2)).shape:‖"logger.info(f""\n\t{test_subtraction.__name__} with same matrix dims"")"‖1
"logger.info(f""\n\t{test_subtraction.__name__} with same matrix dims"")"‖act = (np.array(mat1) - np.array(mat2)).tolist()‖1
act = (np.array(mat1) - np.array(mat2)).tolist()‖theo = matop.subtract(mat1, mat2)‖1
theo = matop.subtract(mat1, mat2)‖assert theo == act‖1
else:‖"logger.info(f""\n\t{test_subtraction.__name__} with different matrix dims"")"‖1
"logger.info(f""\n\t{test_subtraction.__name__} with different matrix dims"")"‖with pytest.raises(ValueError):‖1
with pytest.raises(ValueError):‖assert matop.subtract(mat1, mat2)‖2
)‖def test_multiplication(mat1, mat2):‖1
def test_multiplication(mat1, mat2):‖if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):‖1
if (np.array(mat1)).shape < (2, 2) or (np.array(mat2)).shape < (2, 2):‖"logger.info(f""\n\t{test_multiplication.__name__} returned integer"")"‖1
"logger.info(f""\n\t{test_multiplication.__name__} returned integer"")"‖with pytest.raises(TypeError):‖1
elif (np.array(mat1)).shape == (np.array(mat2)).shape:‖"logger.info(f""\n\t{test_multiplication.__name__} meets dim requirements"")"‖1
"logger.info(f""\n\t{test_multiplication.__name__} meets dim requirements"")"‖act = (np.matmul(mat1, mat2)).tolist()‖1
act = (np.matmul(mat1, mat2)).tolist()‖theo = matop.multiply(mat1, mat2)‖1
theo = matop.multiply(mat1, mat2)‖assert theo == act‖1
else:‖logger.info(‖1
logger.info(‖"f""\n\t{test_multiplication.__name__} does not meet dim requirements"""‖1
"f""\n\t{test_multiplication.__name__} does not meet dim requirements"""‖)‖1
)‖with pytest.raises(ValueError):‖1
@pytest.mark.mat_ops‖def test_scalar_multiply():‖1
def test_scalar_multiply():‖act = (3.5 * np.array(mat_a)).tolist()‖1
act = (3.5 * np.array(mat_a)).tolist()‖theo = matop.scalar_multiply(mat_a, 3.5)‖1
theo = matop.scalar_multiply(mat_a, 3.5)‖assert theo == act‖1
@pytest.mark.mat_ops‖def test_identity():‖1
def test_identity():‖act = (np.identity(5)).tolist()‖1
act = (np.identity(5)).tolist()‖theo = matop.identity(5)‖1
theo = matop.identity(5)‖assert theo == act‖1
@pytest.mark.mat_ops‖"@pytest.mark.parametrize(""mat"", [mat_a, mat_b, mat_c, mat_d, mat_e, mat_f])"‖1
"@pytest.mark.parametrize(""mat"", [mat_a, mat_b, mat_c, mat_d, mat_e, mat_f])"‖def test_transpose(mat):‖1
def test_transpose(mat):‖if (np.array(mat)).shape < (2, 2):‖1
if (np.array(mat)).shape < (2, 2):‖"logger.info(f""\n\t{test_transpose.__name__} returned integer"")"‖1
"logger.info(f""\n\t{test_transpose.__name__} returned integer"")"‖with pytest.raises(TypeError):‖1
with pytest.raises(TypeError):‖matop.transpose(mat)‖1
matop.transpose(mat)‖else:‖1
else:‖act = (np.transpose(mat)).tolist()‖1
act = (np.transpose(mat)).tolist()‖theo = matop.transpose(mat, return_map=False)‖1
theo = matop.transpose(mat, return_map=False)‖assert theo == act‖1
self.row, self.column = row, column‖self.array = [[default_value for _ in range(column)] for _ in range(row)]‖1
max_element_length = 0‖for row_vector in self.array:‖1
for row_vector in self.array:‖for obj in row_vector:‖1
for obj in row_vector:‖max_element_length = max(max_element_length, len(str(obj)))‖1
max_element_length = max(max_element_length, len(str(obj)))‖"string_format_identifier = f""%{max_element_length}s"""‖1
def single_line(row_vector: list[float]) -> str:‖nonlocal string_format_identifier‖1
nonlocal string_format_identifier‖"line = ""["""‖1
"line = ""["""‖"line += "", "".join(string_format_identifier % (obj,) for obj in row_vector)"‖1
"line += "", "".join(string_format_identifier % (obj,) for obj in row_vector)"‖"line += ""]"""‖1
"line += ""]"""‖return line‖1
"s += ""\n"".join(single_line(row_vector) for row_vector in self.array)"‖return s‖1
def __repr__(self) -> str:‖return str(self)‖1
def validate_indices(self, loc: tuple[int, int]) -> bool:‖if not (isinstance(loc, (list, tuple)) and len(loc) == 2):‖1
if not (isinstance(loc, (list, tuple)) and len(loc) == 2):‖return False‖1
return False‖elif not (0 <= loc[0] < self.row and 0 <= loc[1] < self.column):‖1
elif not (0 <= loc[0] < self.row and 0 <= loc[1] < self.column):‖return False‖1
def __getitem__(self, loc: tuple[int, int]) -> Any:‖assert self.validate_indices(loc)‖1
assert self.validate_indices(loc)‖return self.array[loc[0]][loc[1]]‖1
def __setitem__(self, loc: tuple[int, int], value: float) -> None:‖assert self.validate_indices(loc)‖1
assert self.validate_indices(loc)‖self.array[loc[0]][loc[1]] = value‖1
assert isinstance(another, Matrix)‖assert self.row == another.row‖1
assert self.row == another.row‖assert self.column == another.column‖1
result = Matrix(self.row, self.column)‖for r in range(self.row):‖3
for r in range(self.row):‖for c in range(self.column):‖4
for c in range(self.column):‖result[r, c] = self[r, c] + another[r, c]‖1
result[r, c] = self[r, c] + another[r, c]‖return result‖1
for c in range(self.column):‖result[r, c] = -self[r, c]‖1
result[r, c] = -self[r, c]‖return result‖1
def __sub__(self, another: Matrix) -> Matrix:‖return self + (-another)‖1
if isinstance(another, (int, float)):‖result = Matrix(self.row, self.column)‖1
for c in range(self.column):‖result[r, c] = self[r, c] * another‖1
result[r, c] = self[r, c] * another‖return result‖1
return result‖elif isinstance(another, Matrix):‖1
elif isinstance(another, Matrix):‖assert self.column == another.row‖1
assert self.column == another.row‖result = Matrix(self.row, another.column)‖1
result = Matrix(self.row, another.column)‖for r in range(self.row):‖1
for r in range(self.row):‖for c in range(another.column):‖1
for c in range(another.column):‖for i in range(self.column):‖1
for i in range(self.column):‖result[r, c] += self[r, i] * another[i, c]‖1
result[r, c] += self[r, i] * another[i, c]‖return result‖1
return result‖else:‖1
else:‖"msg = f""Unsupported type given for another ({type(another)})"""‖1
"msg = f""Unsupported type given for another ({type(another)})"""‖raise TypeError(msg)‖1
result = Matrix(self.column, self.row)‖for r in range(self.row):‖1
for c in range(self.column):‖result[c, r] = self[r, c]‖1
result[c, r] = self[r, c]‖return result‖1
assert isinstance(u, Matrix)‖assert isinstance(v, Matrix)‖1
assert isinstance(v, Matrix)‖assert self.row == self.column == u.row == v.row‖1
assert self.row == self.column == u.row == v.row‖assert u.column == v.column == 1‖1
v_t = v.transpose()‖numerator_factor = (v_t * self * u)[0, 0] + 1‖1
numerator_factor = (v_t * self * u)[0, 0] + 1‖if numerator_factor == 0:‖1
if numerator_factor == 0:‖return None‖1
return None‖return self - ((self * u) * (v_t * self) * (1.0 / numerator_factor))‖1
ainv = Matrix(3, 3, 0)‖for i in range(3):‖1
for i in range(3):‖ainv[i, i] = 1‖1
ainv[i, i] = 1‖"print(f""a^(-1) is {ainv}"")"‖1
u = Matrix(3, 1, 0)‖u[0, 0], u[1, 0], u[2, 0] = 1, 2, -3‖1
u[0, 0], u[1, 0], u[2, 0] = 1, 2, -3‖v = Matrix(3, 1, 0)‖1
v = Matrix(3, 1, 0)‖v[0, 0], v[1, 0], v[2, 0] = 4, -2, 5‖1
v[0, 0], v[1, 0], v[2, 0] = 4, -2, 5‖"print(f""u is {u}"")"‖1
"print(f""u is {u}"")"‖"print(f""v is {v}"")"‖1
"print(f""v is {v}"")"‖"print(f""uv^T is {u * v.transpose()}"")"‖1
def test2() -> None:‖import doctest‖1
def __init__(self, rows: list[list[int]]):‖error = TypeError(‖1
error = TypeError(‖"""Matrices must be formed from a list of zero or more lists containing at """‖1
"""Matrices must be formed from a list of zero or more lists containing at """‖"""least one and the same number of values, each of which must be of type """‖1
"""least one and the same number of values, each of which must be of type """‖"""int or float."""‖1
"""int or float."""‖)‖1
)‖if len(rows) != 0:‖1
if len(rows) != 0:‖cols = len(rows[0])‖1
cols = len(rows[0])‖if cols == 0:‖1
if cols == 0:‖raise error‖1
raise error‖for row in rows:‖1
for row in rows:‖if len(row) != cols:‖1
if len(row) != cols:‖raise error‖1
raise error‖for value in row:‖1
for value in row:‖if not isinstance(value, (int, float)):‖2
if not isinstance(value, (int, float)):‖raise error‖1
raise error‖self.rows = rows‖1
self.rows = rows‖else:‖1
else:‖self.rows = []‖1
def columns(self) -> list[list[int]]:‖return [[row[i] for row in self.rows] for i in range(len(self.rows[0]))]‖1
@property‖def num_rows(self) -> int:‖1
def num_rows(self) -> int:‖return len(self.rows)‖1
@property‖def num_columns(self) -> int:‖1
def num_columns(self) -> int:‖return len(self.rows[0])‖1
@property‖def order(self) -> tuple[int, int]:‖1
def order(self) -> tuple[int, int]:‖return self.num_rows, self.num_columns‖1
@property‖def is_square(self) -> bool:‖1
def is_square(self) -> bool:‖return self.order[0] == self.order[1]‖1
def identity(self) -> Matrix:‖values = [‖1
values = [‖[0 if column_num != row_num else 1 for column_num in range(self.num_rows)]‖1
[0 if column_num != row_num else 1 for column_num in range(self.num_rows)]‖for row_num in range(self.num_rows)‖1
for row_num in range(self.num_rows)‖]‖1
]‖return Matrix(values)‖2
def determinant(self) -> int:‖if not self.is_square:‖1
if not self.is_square:‖return 0‖1
return 0‖if self.order == (0, 0):‖1
if self.order == (0, 0):‖return 1‖1
return 1‖if self.order == (1, 1):‖1
if self.order == (1, 1):‖return int(self.rows[0][0])‖1
return int(self.rows[0][0])‖if self.order == (2, 2):‖1
if self.order == (2, 2):‖return int(‖1
return int(‖(self.rows[0][0] * self.rows[1][1])‖1
(self.rows[0][0] * self.rows[1][1])‖- (self.rows[0][1] * self.rows[1][0])‖1
- (self.rows[0][1] * self.rows[1][0])‖)‖1
else:‖return sum(‖1
return sum(‖self.rows[0][column] * self.cofactors().rows[0][column]‖1
self.rows[0][column] * self.cofactors().rows[0][column]‖for column in range(self.num_columns)‖1
for column in range(self.num_columns)‖)‖1
def is_invertable(self) -> bool:‖return bool(self.determinant())‖1
def get_minor(self, row: int, column: int) -> int:‖values = [‖1
values = [‖[‖1
[‖self.rows[other_row][other_column]‖1
self.rows[other_row][other_column]‖for other_column in range(self.num_columns)‖1
for other_column in range(self.num_columns)‖if other_column != column‖1
if other_column != column‖]‖1
]‖for other_row in range(self.num_rows)‖1
for other_row in range(self.num_rows)‖if other_row != row‖1
if other_row != row‖]‖1
]‖return Matrix(values).determinant()‖1
def get_cofactor(self, row: int, column: int) -> int:‖if (row + column) % 2 == 0:‖1
if (row + column) % 2 == 0:‖return self.get_minor(row, column)‖1
return self.get_minor(row, column)‖return -1 * self.get_minor(row, column)‖1
def minors(self) -> Matrix:‖return Matrix(‖1
return Matrix(‖[‖5
[‖[self.get_minor(row, column) for column in range(self.num_columns)]‖1
[self.get_minor(row, column) for column in range(self.num_columns)]‖for row in range(self.num_rows)‖1
for row in range(self.num_rows)‖]‖2
def cofactors(self) -> Matrix:‖return Matrix(‖1
[‖[‖1
[‖self.minors().rows[row][column]‖1
self.minors().rows[row][column]‖if (row + column) % 2 == 0‖1
if (row + column) % 2 == 0‖else self.minors().rows[row][column] * -1‖1
else self.minors().rows[row][column] * -1‖for column in range(self.minors().num_columns)‖1
for column in range(self.minors().num_columns)‖]‖1
]‖for row in range(self.minors().num_rows)‖1
for row in range(self.minors().num_rows)‖]‖1
def adjugate(self) -> Matrix:‖values = [‖1
values = [‖[self.cofactors().rows[column][row] for column in range(self.num_columns)]‖1
[self.cofactors().rows[column][row] for column in range(self.num_columns)]‖for row in range(self.num_rows)‖1
def inverse(self) -> Matrix:‖determinant = self.determinant()‖1
determinant = self.determinant()‖if not determinant:‖1
if not determinant:‖"raise TypeError(""Only matrices with a non-zero determinant have an inverse"")"‖1
"raise TypeError(""Only matrices with a non-zero determinant have an inverse"")"‖return self.adjugate() * (1 / determinant)‖1
def __repr__(self) -> str:‖return str(self.rows)‖1
def __str__(self) -> str:‖if self.num_rows == 0:‖1
if self.num_rows == 0:‖"return ""[]"""‖1
"return ""[]"""‖if self.num_rows == 1:‖1
if self.num_rows == 1:‖"return ""[["" + "". "".join(str(self.rows[0])) + ""]]"""‖1
"return ""[["" + "". "".join(str(self.rows[0])) + ""]]"""‖return (‖1
return (‖"""["""‖1
"""["""‖"+ ""\n "".join("‖1
"+ ""\n "".join("‖[‖1
[‖"""["" + "". "".join([str(value) for value in row]) + "".]"""‖1
"""["" + "". "".join([str(value) for value in row]) + "".]"""‖for row in self.rows‖1
for row in self.rows‖]‖2
)‖"+ ""]"""‖1
"+ ""]"""‖)‖1
def add_row(self, row: list[int], position: int | None = None) -> None:‖"type_error = TypeError(""Row must be a list containing all ints and/or floats"")"‖1
"type_error = TypeError(""Row must be a list containing all ints and/or floats"")"‖if not isinstance(row, list):‖1
if not isinstance(row, list):‖raise type_error‖1
raise type_error‖for value in row:‖1
if not isinstance(value, (int, float)):‖raise type_error‖2
raise type_error‖if len(row) != self.num_columns:‖1
if len(row) != self.num_columns:‖raise ValueError(‖1
raise ValueError(‖"""Row must be equal in length to the other rows in the matrix"""‖1
"""Row must be equal in length to the other rows in the matrix"""‖)‖1
)‖if position is None:‖2
if position is None:‖self.rows.append(row)‖1
self.rows.append(row)‖else:‖1
else:‖self.rows = self.rows[0:position] + [row] + self.rows[position:]‖1
def add_column(self, column: list[int], position: int | None = None) -> None:‖type_error = TypeError(‖1
type_error = TypeError(‖"""Column must be a list containing all ints and/or floats"""‖1
"""Column must be a list containing all ints and/or floats"""‖)‖1
)‖if not isinstance(column, list):‖1
if not isinstance(column, list):‖raise type_error‖1
raise type_error‖for value in column:‖1
for value in column:‖if not isinstance(value, (int, float)):‖1
raise type_error‖if len(column) != self.num_rows:‖1
if len(column) != self.num_rows:‖raise ValueError(‖1
raise ValueError(‖"""Column must be equal in length to the other columns in the matrix"""‖1
"""Column must be equal in length to the other columns in the matrix"""‖)‖1
if position is None:‖self.rows = [self.rows[i] + [column[i]] for i in range(self.num_rows)]‖1
self.rows = [self.rows[i] + [column[i]] for i in range(self.num_rows)]‖else:‖1
else:‖self.rows = [‖1
self.rows = [‖self.rows[i][0:position] + [column[i]] + self.rows[i][position:]‖1
self.rows[i][0:position] + [column[i]] + self.rows[i][position:]‖for i in range(self.num_rows)‖1
for i in range(self.num_rows)‖]‖3
def __eq__(self, other: object) -> bool:‖if not isinstance(other, Matrix):‖1
if not isinstance(other, Matrix):‖return NotImplemented‖1
return NotImplemented‖return self.rows == other.rows‖1
def __ne__(self, other: object) -> bool:‖return not self == other‖1
def __neg__(self) -> Matrix:‖return self * -1‖1
def __add__(self, other: Matrix) -> Matrix:‖if self.order != other.order:‖1
if self.order != other.order:‖"raise ValueError(""Addition requires matrices of the same order"")"‖1
"raise ValueError(""Addition requires matrices of the same order"")"‖return Matrix(‖1
[‖[self.rows[i][j] + other.rows[i][j] for j in range(self.num_columns)]‖1
[self.rows[i][j] + other.rows[i][j] for j in range(self.num_columns)]‖for i in range(self.num_rows)‖1
def __sub__(self, other: Matrix) -> Matrix:‖if self.order != other.order:‖1
if self.order != other.order:‖"raise ValueError(""Subtraction requires matrices of the same order"")"‖1
"raise ValueError(""Subtraction requires matrices of the same order"")"‖return Matrix(‖1
[‖[self.rows[i][j] - other.rows[i][j] for j in range(self.num_columns)]‖1
[self.rows[i][j] - other.rows[i][j] for j in range(self.num_columns)]‖for i in range(self.num_rows)‖1
def __mul__(self, other: Matrix | float) -> Matrix:‖if isinstance(other, (int, float)):‖1
if isinstance(other, (int, float)):‖return Matrix(‖1
return Matrix(‖[[int(element * other) for element in row] for row in self.rows]‖1
[[int(element * other) for element in row] for row in self.rows]‖)‖1
)‖elif isinstance(other, Matrix):‖1
elif isinstance(other, Matrix):‖if self.num_columns != other.num_rows:‖1
if self.num_columns != other.num_rows:‖raise ValueError(‖1
raise ValueError(‖"""The number of columns in the first matrix must """‖1
"""The number of columns in the first matrix must """‖"""be equal to the number of rows in the second"""‖1
"""be equal to the number of rows in the second"""‖)‖1
)‖return Matrix(‖1
[‖[Matrix.dot_product(row, column) for column in other.columns()]‖1
[Matrix.dot_product(row, column) for column in other.columns()]‖for row in self.rows‖1
else:‖raise TypeError(‖1
raise TypeError(‖"""A Matrix can only be multiplied by an int, float, or another matrix"""‖1
"""A Matrix can only be multiplied by an int, float, or another matrix"""‖)‖1
def __pow__(self, other: int) -> Matrix:‖if not isinstance(other, int):‖1
if not isinstance(other, int):‖"raise TypeError(""A Matrix can only be raised to the power of an int"")"‖1
"raise TypeError(""A Matrix can only be raised to the power of an int"")"‖if not self.is_square:‖1
if not self.is_square:‖"raise ValueError(""Only square matrices can be raised to a power"")"‖1
"raise ValueError(""Only square matrices can be raised to a power"")"‖if other == 0:‖1
if other == 0:‖return self.identity()‖1
return self.identity()‖if other < 0:‖1
if other < 0:‖if self.is_invertable():‖1
if self.is_invertable():‖return self.inverse() ** (-other)‖1
return self.inverse() ** (-other)‖raise ValueError(‖1
raise ValueError(‖"""Only invertable matrices can be raised to a negative power"""‖1
"""Only invertable matrices can be raised to a negative power"""‖)‖1
)‖result = self‖1
result = self‖for _ in range(other - 1):‖1
for _ in range(other - 1):‖result *= self‖1
result *= self‖return result‖1
@classmethod‖def dot_product(cls, row: list[int], column: list[int]) -> int:‖1
def dot_product(cls, row: list[int], column: list[int]) -> int:‖return sum(row[i] * column[i] for i in range(len(row)))‖1
NUM_SQUARES = 9‖"EMPTY_CELL = ""."""‖1
def is_valid_sudoku_board(sudoku_board: list[list[str]]) -> bool:‖if len(sudoku_board) != NUM_SQUARES or (‖1
if len(sudoku_board) != NUM_SQUARES or (‖any(len(row) != NUM_SQUARES for row in sudoku_board)‖1
any(len(row) != NUM_SQUARES for row in sudoku_board)‖):‖1
):‖"error_message = f""Sudoku boards must be {NUM_SQUARES}x{NUM_SQUARES} squares."""‖1
"error_message = f""Sudoku boards must be {NUM_SQUARES}x{NUM_SQUARES} squares."""‖raise ValueError(error_message)‖1
row_values: defaultdict[int, set[str]] = defaultdict(set)‖col_values: defaultdict[int, set[str]] = defaultdict(set)‖1
col_values: defaultdict[int, set[str]] = defaultdict(set)‖box_values: defaultdict[tuple[int, int], set[str]] = defaultdict(set)‖1
for row in range(NUM_SQUARES):‖for col in range(NUM_SQUARES):‖1
for col in range(NUM_SQUARES):‖value = sudoku_board[row][col]‖1
if value == EMPTY_CELL:‖continue‖1
if (‖value in row_values[row]‖1
value in row_values[row]‖or value in col_values[col]‖1
or value in col_values[col]‖or value in box_values[box]‖1
or value in box_values[box]‖):‖1
row_values[row].add(value)‖col_values[col].add(value)‖1
col_values[col].add(value)‖box_values[box].add(value)‖1
testmod()‖"print(timeit(""is_valid_sudoku_board(valid_board)"", globals=globals()))"‖1
"print(timeit(""is_valid_sudoku_board(valid_board)"", globals=globals()))"‖"print(timeit(""is_valid_sudoku_board(invalid_board)"", globals=globals()))"‖1
class CNN:‖def __init__(‖1
def __init__(‖self, conv1_get, size_p1, bp_num1, bp_num2, bp_num3, rate_w=0.2, rate_t=0.2‖1
self, conv1_get, size_p1, bp_num1, bp_num2, bp_num3, rate_w=0.2, rate_t=0.2‖):‖1
):‖self.num_bp1 = bp_num1‖1
self.num_bp1 = bp_num1‖self.num_bp2 = bp_num2‖1
self.num_bp2 = bp_num2‖self.num_bp3 = bp_num3‖1
self.num_bp3 = bp_num3‖self.conv1 = conv1_get[:2]‖1
self.conv1 = conv1_get[:2]‖self.step_conv1 = conv1_get[2]‖1
self.step_conv1 = conv1_get[2]‖self.size_pooling1 = size_p1‖1
self.size_pooling1 = size_p1‖self.rate_weight = rate_w‖1
self.rate_weight = rate_w‖self.rate_thre = rate_t‖1
self.rate_thre = rate_t‖rng = np.random.default_rng()‖1
rng = np.random.default_rng()‖self.w_conv1 = [‖1
self.w_conv1 = [‖np.asmatrix(-1 * rng.random((self.conv1[0], self.conv1[0])) + 0.5)‖1
np.asmatrix(-1 * rng.random((self.conv1[0], self.conv1[0])) + 0.5)‖for i in range(self.conv1[1])‖1
for i in range(self.conv1[1])‖]‖1
]‖self.wkj = np.asmatrix(-1 * rng.random((self.num_bp3, self.num_bp2)) + 0.5)‖1
self.wkj = np.asmatrix(-1 * rng.random((self.num_bp3, self.num_bp2)) + 0.5)‖self.vji = np.asmatrix(-1 * rng.random((self.num_bp2, self.num_bp1)) + 0.5)‖1
self.vji = np.asmatrix(-1 * rng.random((self.num_bp2, self.num_bp1)) + 0.5)‖self.thre_conv1 = -2 * rng.random(self.conv1[1]) + 1‖1
self.thre_conv1 = -2 * rng.random(self.conv1[1]) + 1‖self.thre_bp2 = -2 * rng.random(self.num_bp2) + 1‖1
self.thre_bp2 = -2 * rng.random(self.num_bp2) + 1‖self.thre_bp3 = -2 * rng.random(self.num_bp3) + 1‖1
model_dic = {‖"""num_bp1"": self.num_bp1,"‖1
"""num_bp1"": self.num_bp1,"‖"""num_bp2"": self.num_bp2,"‖1
"""num_bp2"": self.num_bp2,"‖"""num_bp3"": self.num_bp3,"‖1
"""num_bp3"": self.num_bp3,"‖"""conv1"": self.conv1,"‖1
"""conv1"": self.conv1,"‖"""step_conv1"": self.step_conv1,"‖1
"""step_conv1"": self.step_conv1,"‖"""size_pooling1"": self.size_pooling1,"‖1
"""size_pooling1"": self.size_pooling1,"‖"""rate_weight"": self.rate_weight,"‖1
"""rate_weight"": self.rate_weight,"‖"""rate_thre"": self.rate_thre,"‖1
"""rate_thre"": self.rate_thre,"‖"""w_conv1"": self.w_conv1,"‖1
"""w_conv1"": self.w_conv1,"‖"""wkj"": self.wkj,"‖1
"""wkj"": self.wkj,"‖"""vji"": self.vji,"‖1
"""vji"": self.vji,"‖"""thre_conv1"": self.thre_conv1,"‖1
"""thre_conv1"": self.thre_conv1,"‖"""thre_bp2"": self.thre_bp2,"‖1
"""thre_bp2"": self.thre_bp2,"‖"""thre_bp3"": self.thre_bp3,"‖1
"""thre_bp3"": self.thre_bp3,"‖}‖1
}‖"with open(save_path, ""wb"") as f:"‖1
"with open(save_path, ""wb"") as f:"‖pickle.dump(model_dic, f)‖1
@classmethod‖def read_model(cls, model_path):‖1
"with open(model_path, ""rb"") as f:"‖model_dic = pickle.load(f)‖1
"conv_get = model_dic.get(""conv1"")"‖"conv_get.append(model_dic.get(""step_conv1""))"‖1
"conv_get.append(model_dic.get(""step_conv1""))"‖"size_p1 = model_dic.get(""size_pooling1"")"‖1
"size_p1 = model_dic.get(""size_pooling1"")"‖"bp1 = model_dic.get(""num_bp1"")"‖1
"bp1 = model_dic.get(""num_bp1"")"‖"bp2 = model_dic.get(""num_bp2"")"‖1
"bp2 = model_dic.get(""num_bp2"")"‖"bp3 = model_dic.get(""num_bp3"")"‖1
"bp3 = model_dic.get(""num_bp3"")"‖"r_w = model_dic.get(""rate_weight"")"‖1
"r_w = model_dic.get(""rate_weight"")"‖"r_t = model_dic.get(""rate_thre"")"‖1
"conv_ins.w_conv1 = model_dic.get(""w_conv1"")"‖"conv_ins.wkj = model_dic.get(""wkj"")"‖1
"conv_ins.wkj = model_dic.get(""wkj"")"‖"conv_ins.vji = model_dic.get(""vji"")"‖1
"conv_ins.vji = model_dic.get(""vji"")"‖"conv_ins.thre_conv1 = model_dic.get(""thre_conv1"")"‖1
"conv_ins.thre_conv1 = model_dic.get(""thre_conv1"")"‖"conv_ins.thre_bp2 = model_dic.get(""thre_bp2"")"‖1
"conv_ins.thre_bp2 = model_dic.get(""thre_bp2"")"‖"conv_ins.thre_bp3 = model_dic.get(""thre_bp3"")"‖1
"conv_ins.thre_bp3 = model_dic.get(""thre_bp3"")"‖return conv_ins‖1
def sig(self, x):‖return 1 / (1 + np.exp(-1 * x))‖1
def do_round(self, x):‖return round(x, 3)‖1
size_conv = convs[0]‖num_conv = convs[1]‖1
num_conv = convs[1]‖size_data = np.shape(data)[0]‖1
data_focus = []‖for i_focus in range(0, size_data - size_conv + 1, conv_step):‖1
for i_focus in range(0, size_data - size_conv + 1, conv_step):‖for j_focus in range(0, size_data - size_conv + 1, conv_step):‖1
for j_focus in range(0, size_data - size_conv + 1, conv_step):‖focus = data[‖1
focus = data[‖i_focus : i_focus + size_conv, j_focus : j_focus + size_conv‖1
i_focus : i_focus + size_conv, j_focus : j_focus + size_conv‖]‖1
]‖data_focus.append(focus)‖1
data_featuremap = []‖size_feature_map = int((size_data - size_conv) / conv_step + 1)‖1
size_feature_map = int((size_data - size_conv) / conv_step + 1)‖for i_map in range(num_conv):‖1
for i_map in range(num_conv):‖featuremap = []‖1
featuremap = []‖for i_focus in range(len(data_focus)):‖1
for i_focus in range(len(data_focus)):‖net_focus = (‖1
net_focus = (‖np.sum(np.multiply(data_focus[i_focus], w_convs[i_map]))‖1
np.sum(np.multiply(data_focus[i_focus], w_convs[i_map]))‖- thre_convs[i_map]‖1
- thre_convs[i_map]‖)‖1
)‖featuremap.append(self.sig(net_focus))‖1
featuremap.append(self.sig(net_focus))‖featuremap = np.asmatrix(featuremap).reshape(‖1
featuremap = np.asmatrix(featuremap).reshape(‖size_feature_map, size_feature_map‖1
size_feature_map, size_feature_map‖)‖1
)‖data_featuremap.append(featuremap)‖1
focus1_list = []‖for each_focus in data_focus:‖1
for each_focus in data_focus:‖focus1_list.extend(self.Expand_Mat(each_focus))‖1
focus1_list.extend(self.Expand_Mat(each_focus))‖focus_list = np.asarray(focus1_list)‖1
focus_list = np.asarray(focus1_list)‖return focus_list, data_featuremap‖1
size_map = len(featuremaps[0])‖size_pooled = int(size_map / size_pooling)‖1
size_pooled = int(size_map / size_pooling)‖featuremap_pooled = []‖1
featuremap_pooled = []‖for i_map in range(len(featuremaps)):‖1
for i_map in range(len(featuremaps)):‖feature_map = featuremaps[i_map]‖1
feature_map = featuremaps[i_map]‖map_pooled = []‖1
map_pooled = []‖for i_focus in range(0, size_map, size_pooling):‖1
for i_focus in range(0, size_map, size_pooling):‖for j_focus in range(0, size_map, size_pooling):‖1
for j_focus in range(0, size_map, size_pooling):‖focus = feature_map[‖1
focus = feature_map[‖i_focus : i_focus + size_pooling,‖1
i_focus : i_focus + size_pooling,‖j_focus : j_focus + size_pooling,‖1
j_focus : j_focus + size_pooling,‖]‖1
]‖"if pooling_type == ""average_pool"":"‖1
map_pooled.append(np.average(focus))‖"elif pooling_type == ""max_pooling"":"‖1
map_pooled.append(np.max(focus))‖map_pooled = np.asmatrix(map_pooled).reshape(size_pooled, size_pooled)‖1
map_pooled = np.asmatrix(map_pooled).reshape(size_pooled, size_pooled)‖featuremap_pooled.append(map_pooled)‖1
featuremap_pooled.append(map_pooled)‖return featuremap_pooled‖1
data_expanded = []‖for i in range(len(data)):‖1
for i in range(len(data)):‖shapes = np.shape(data[i])‖1
shapes = np.shape(data[i])‖data_listed = data[i].reshape(1, shapes[0] * shapes[1])‖1
data_listed = data[i].reshape(1, shapes[0] * shapes[1])‖data_listed = data_listed.getA().tolist()[0]‖1
data_listed = data_listed.getA().tolist()[0]‖data_expanded.extend(data_listed)‖1
data_expanded.extend(data_listed)‖data_expanded = np.asarray(data_expanded)‖1
data_expanded = np.asarray(data_expanded)‖return data_expanded‖1
data_mat = np.asarray(data_mat)‖shapes = np.shape(data_mat)‖1
shapes = np.shape(data_mat)‖data_expanded = data_mat.reshape(1, shapes[0] * shapes[1])‖1
data_expanded = data_mat.reshape(1, shapes[0] * shapes[1])‖return data_expanded‖1
def _calculate_gradient_from_pool(‖self, out_map, pd_pool, num_map, size_map, size_pooling‖1
self, out_map, pd_pool, num_map, size_map, size_pooling‖):‖1
):‖pd_all = []‖1
pd_all = []‖i_pool = 0‖1
i_pool = 0‖for i_map in range(num_map):‖1
for i_map in range(num_map):‖pd_conv1 = np.ones((size_map, size_map))‖1
pd_conv1 = np.ones((size_map, size_map))‖for i in range(0, size_map, size_pooling):‖1
for i in range(0, size_map, size_pooling):‖for j in range(0, size_map, size_pooling):‖1
for j in range(0, size_map, size_pooling):‖pd_conv1[i : i + size_pooling, j : j + size_pooling] = pd_pool[‖1
pd_conv1[i : i + size_pooling, j : j + size_pooling] = pd_pool[‖i_pool‖1
i_pool‖]‖1
]‖i_pool = i_pool + 1‖1
i_pool = i_pool + 1‖pd_conv2 = np.multiply(‖1
pd_conv2 = np.multiply(‖pd_conv1, np.multiply(out_map[i_map], (1 - out_map[i_map]))‖1
pd_conv1, np.multiply(out_map[i_map], (1 - out_map[i_map]))‖)‖1
)‖pd_all.append(pd_conv2)‖1
pd_all.append(pd_conv2)‖return pd_all‖1
def train(‖self, patterns, datas_train, datas_teach, n_repeat, error_accuracy, draw_e=bool‖1
self, patterns, datas_train, datas_teach, n_repeat, error_accuracy, draw_e=bool‖):‖1
"print(""----------------------Start Training-------------------------"")"‖"print(("" - - Shape: Train_Data  "", np.shape(datas_train)))"‖1
"print(("" - - Shape: Train_Data  "", np.shape(datas_train)))"‖"print(("" - - Shape: Teach_Data  "", np.shape(datas_teach)))"‖1
"print(("" - - Shape: Teach_Data  "", np.shape(datas_teach)))"‖rp = 0‖1
rp = 0‖all_mse = []‖1
all_mse = []‖mse = 10000‖1
mse = 10000‖while rp < n_repeat and mse >= error_accuracy:‖1
while rp < n_repeat and mse >= error_accuracy:‖error_count = 0‖1
error_count = 0‖"print(f""-------------Learning Time {rp}--------------"")"‖1
"print(f""-------------Learning Time {rp}--------------"")"‖for p in range(len(datas_train)):‖1
data_train = np.asmatrix(datas_train[p])‖data_teach = np.asarray(datas_teach[p])‖1
data_teach = np.asarray(datas_teach[p])‖data_focus1, data_conved1 = self.convolute(‖1
data_focus1, data_conved1 = self.convolute(‖data_train,‖1
data_train,‖self.conv1,‖1
self.conv1,‖self.w_conv1,‖3
self.w_conv1,‖self.thre_conv1,‖3
self.thre_conv1,‖conv_step=self.step_conv1,‖3
conv_step=self.step_conv1,‖)‖3
)‖data_pooled1 = self.pooling(data_conved1, self.size_pooling1)‖3
data_pooled1 = self.pooling(data_conved1, self.size_pooling1)‖shape_featuremap1 = np.shape(data_conved1)‖1
shape_featuremap1 = np.shape(data_conved1)‖data_bp_input = self._expand(data_pooled1)‖1
data_bp_input = self._expand(data_pooled1)‖bp_out1 = data_bp_input‖1
bp_net_j = np.dot(bp_out1, self.vji.T) - self.thre_bp2‖bp_out2 = self.sig(bp_net_j)‖1
bp_out2 = self.sig(bp_net_j)‖bp_net_k = np.dot(bp_out2, self.wkj.T) - self.thre_bp3‖1
bp_net_k = np.dot(bp_out2, self.wkj.T) - self.thre_bp3‖bp_out3 = self.sig(bp_net_k)‖1
pd_k_all = np.multiply(‖(data_teach - bp_out3), np.multiply(bp_out3, (1 - bp_out3))‖1
(data_teach - bp_out3), np.multiply(bp_out3, (1 - bp_out3))‖)‖1
)‖pd_j_all = np.multiply(‖1
pd_j_all = np.multiply(‖np.dot(pd_k_all, self.wkj), np.multiply(bp_out2, (1 - bp_out2))‖1
np.dot(pd_k_all, self.wkj), np.multiply(bp_out2, (1 - bp_out2))‖)‖1
)‖pd_i_all = np.dot(pd_j_all, self.vji)‖1
pd_conv1_pooled = pd_i_all / (self.size_pooling1 * self.size_pooling1)‖pd_conv1_pooled = pd_conv1_pooled.T.getA().tolist()‖1
pd_conv1_pooled = pd_conv1_pooled.T.getA().tolist()‖pd_conv1_all = self._calculate_gradient_from_pool(‖1
pd_conv1_all = self._calculate_gradient_from_pool(‖data_conved1,‖1
data_conved1,‖pd_conv1_pooled,‖1
pd_conv1_pooled,‖shape_featuremap1[0],‖1
shape_featuremap1[0],‖shape_featuremap1[1],‖1
shape_featuremap1[1],‖self.size_pooling1,‖1
self.size_pooling1,‖)‖1
for k_conv in range(self.conv1[1]):‖pd_conv_list = self._expand_mat(pd_conv1_all[k_conv])‖1
pd_conv_list = self._expand_mat(pd_conv1_all[k_conv])‖delta_w = self.rate_weight * np.dot(pd_conv_list, data_focus1)‖1
self.w_conv1[k_conv] = self.w_conv1[k_conv] + delta_w.reshape(‖(self.conv1[0], self.conv1[0])‖1
(self.conv1[0], self.conv1[0])‖)‖1
self.thre_conv1[k_conv] = (‖self.thre_conv1[k_conv]‖1
self.thre_conv1[k_conv]‖- np.sum(pd_conv1_all[k_conv]) * self.rate_thre‖1
- np.sum(pd_conv1_all[k_conv]) * self.rate_thre‖)‖1
self.wkj = self.wkj + pd_k_all.T * bp_out2 * self.rate_weight‖self.vji = self.vji + pd_j_all.T * bp_out1 * self.rate_weight‖1
self.vji = self.vji + pd_j_all.T * bp_out1 * self.rate_weight‖self.thre_bp3 = self.thre_bp3 - pd_k_all * self.rate_thre‖1
self.thre_bp3 = self.thre_bp3 - pd_k_all * self.rate_thre‖self.thre_bp2 = self.thre_bp2 - pd_j_all * self.rate_thre‖1
errors = np.sum(abs(data_teach - bp_out3))‖error_count += errors‖1
rp = rp + 1‖mse = error_count / patterns‖1
mse = error_count / patterns‖all_mse.append(mse)‖1
def draw_error():‖yplot = [error_accuracy for i in range(int(n_repeat * 1.2))]‖1
yplot = [error_accuracy for i in range(int(n_repeat * 1.2))]‖"plt.plot(all_mse, ""+-"")"‖1
"plt.plot(all_mse, ""+-"")"‖"plt.plot(yplot, ""r--"")"‖1
"plt.plot(yplot, ""r--"")"‖"plt.xlabel(""Learning Times"")"‖1
"plt.xlabel(""Learning Times"")"‖"plt.ylabel(""All_mse"")"‖1
"plt.ylabel(""All_mse"")"‖plt.grid(True, alpha=0.5)‖1
plt.grid(True, alpha=0.5)‖plt.show()‖1
"print(""------------------Training Complete---------------------"")"‖"print(("" - - Training epoch: "", rp, f""     - - Mse: {mse:.6f}""))"‖1
"print(("" - - Training epoch: "", rp, f""     - - Mse: {mse:.6f}""))"‖if draw_e:‖1
if draw_e:‖draw_error()‖1
draw_error()‖return mse‖1
produce_out = []‖"print(""-------------------Start Testing-------------------------"")"‖1
"print(""-------------------Start Testing-------------------------"")"‖"print(("" - - Shape: Test_Data  "", np.shape(datas_test)))"‖1
"print(("" - - Shape: Test_Data  "", np.shape(datas_test)))"‖for p in range(len(datas_test)):‖1
for p in range(len(datas_test)):‖data_test = np.asmatrix(datas_test[p])‖1
data_test = np.asmatrix(datas_test[p])‖data_focus1, data_conved1 = self.convolute(‖1
data_focus1, data_conved1 = self.convolute(‖data_test,‖2
data_test,‖self.conv1,‖2
data_pooled1 = self.pooling(data_conved1, self.size_pooling1)‖data_bp_input = self._expand(data_pooled1)‖1
bp_out1 = data_bp_input‖bp_net_j = bp_out1 * self.vji.T - self.thre_bp2‖1
bp_net_j = bp_out1 * self.vji.T - self.thre_bp2‖bp_out2 = self.sig(bp_net_j)‖1
bp_out2 = self.sig(bp_net_j)‖bp_net_k = bp_out2 * self.wkj.T - self.thre_bp3‖1
bp_net_k = bp_out2 * self.wkj.T - self.thre_bp3‖bp_out3 = self.sig(bp_net_k)‖1
bp_out3 = self.sig(bp_net_k)‖produce_out.extend(bp_out3.getA().tolist())‖1
produce_out.extend(bp_out3.getA().tolist())‖res = [list(map(self.do_round, each)) for each in produce_out]‖1
res = [list(map(self.do_round, each)) for each in produce_out]‖return np.asarray(res)‖1
data_test = np.asmatrix(data)‖data_focus1, data_conved1 = self.convolute(‖1
def leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:‖return np.where(vector > 0, vector, alpha * vector)‖1
def multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:‖matrix_c = []‖1
matrix_c = []‖n = len(matrix_a)‖1
n = len(matrix_a)‖for i in range(n):‖1
for i in range(n):‖list_1 = []‖1
list_1 = []‖for j in range(n):‖1
for j in range(n):‖val = 0‖1
val = 0‖for k in range(n):‖1
for k in range(n):‖val = val + matrix_a[i][k] * matrix_b[k][j]‖1
val = val + matrix_a[i][k] * matrix_b[k][j]‖list_1.append(val)‖1
list_1.append(val)‖matrix_c.append(list_1)‖1
matrix_c.append(list_1)‖return matrix_c‖1
def identity(n: int) -> list[list[int]]:‖return [[int(row == column) for column in range(n)] for row in range(n)]‖1
def nth_fibonacci_matrix(n: int) -> int:‖if n <= 1:‖1
if n <= 1:‖return n‖2
return n‖res_matrix = identity(2)‖1
res_matrix = identity(2)‖fibonacci_matrix = [[1, 1], [1, 0]]‖1
fibonacci_matrix = [[1, 1], [1, 0]]‖n = n - 1‖1
n = n - 1‖while n > 0:‖1
while n > 0:‖if n % 2 == 1:‖1
if n % 2 == 1:‖res_matrix = multiply(res_matrix, fibonacci_matrix)‖1
res_matrix = multiply(res_matrix, fibonacci_matrix)‖fibonacci_matrix = multiply(fibonacci_matrix, fibonacci_matrix)‖1
fibonacci_matrix = multiply(fibonacci_matrix, fibonacci_matrix)‖n = int(n / 2)‖1
n = int(n / 2)‖return res_matrix[0][0]‖1
def nth_fibonacci_bruteforce(n: int) -> int:‖if n <= 1:‖1
return n‖fib0 = 0‖1
fib0 = 0‖fib1 = 1‖1
fib1 = 1‖for _ in range(2, n + 1):‖1
for _ in range(2, n + 1):‖fib0, fib1 = fib1, fib0 + fib1‖1
fib0, fib1 = fib1, fib0 + fib1‖return fib1‖1
def main() -> None:‖"for ordinal in ""0th 1st 2nd 3rd 10th 100th 1000th"".split():"‖1
"for ordinal in ""0th 1st 2nd 3rd 10th 100th 1000th"".split():"‖"n = int("""".join(c for c in ordinal if c in ""0123456789""))"‖1
"n = int("""".join(c for c in ordinal if c in ""0123456789""))"‖print(‖1
print(‖"f""{ordinal} fibonacci number using matrix exponentiation is """‖1
"f""{ordinal} fibonacci number using matrix exponentiation is """‖"f""{nth_fibonacci_matrix(n)} and using bruteforce is """‖1
"f""{nth_fibonacci_matrix(n)} and using bruteforce is """‖"f""{nth_fibonacci_bruteforce(n)}\n"""‖1
"f""{nth_fibonacci_bruteforce(n)}\n"""‖)‖1
def gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:‖return vector * sigmoid(1.702 * vector)‖1
import gzip‖import os‖1
import os‖import typing‖1
import typing‖import urllib‖1
import numpy as np‖from tensorflow.python.framework import dtypes, random_seed‖1
from tensorflow.python.framework import dtypes, random_seed‖from tensorflow.python.platform import gfile‖1
from tensorflow.python.platform import gfile‖from tensorflow.python.util.deprecation import deprecated‖1
class _Datasets(typing.NamedTuple):‖"train: ""_DataSet"""‖1
"train: ""_DataSet"""‖"validation: ""_DataSet"""‖1
"validation: ""_DataSet"""‖"test: ""_DataSet"""‖1
def _read32(bytestream):‖"dt = np.dtype(np.uint32).newbyteorder("">"")"‖1
"dt = np.dtype(np.uint32).newbyteorder("">"")"‖return np.frombuffer(bytestream.read(4), dtype=dt)[0]‖1
"@deprecated(None, ""Please use tf.data to implement this functionality."")"‖def _extract_images(f):‖1
def _extract_images(f):‖"print(""Extracting"", f.name)"‖1
"print(""Extracting"", f.name)"‖with gzip.GzipFile(fileobj=f) as bytestream:‖2
with gzip.GzipFile(fileobj=f) as bytestream:‖magic = _read32(bytestream)‖2
magic = _read32(bytestream)‖if magic != 2051:‖1
if magic != 2051:‖"msg = f""Invalid magic number {magic} in MNIST image file: {f.name}"""‖1
"msg = f""Invalid magic number {magic} in MNIST image file: {f.name}"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖num_images = _read32(bytestream)‖1
num_images = _read32(bytestream)‖rows = _read32(bytestream)‖1
rows = _read32(bytestream)‖cols = _read32(bytestream)‖1
cols = _read32(bytestream)‖buf = bytestream.read(rows * cols * num_images)‖1
buf = bytestream.read(rows * cols * num_images)‖data = np.frombuffer(buf, dtype=np.uint8)‖1
data = np.frombuffer(buf, dtype=np.uint8)‖data = data.reshape(num_images, rows, cols, 1)‖1
data = data.reshape(num_images, rows, cols, 1)‖return data‖1
"@deprecated(None, ""Please use tf.one_hot on tensors."")"‖def _dense_to_one_hot(labels_dense, num_classes):‖1
def _dense_to_one_hot(labels_dense, num_classes):‖num_labels = labels_dense.shape[0]‖1
num_labels = labels_dense.shape[0]‖index_offset = np.arange(num_labels) * num_classes‖1
index_offset = np.arange(num_labels) * num_classes‖labels_one_hot = np.zeros((num_labels, num_classes))‖1
labels_one_hot = np.zeros((num_labels, num_classes))‖labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1‖1
labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1‖return labels_one_hot‖1
"@deprecated(None, ""Please use tf.data to implement this functionality."")"‖def _extract_labels(f, one_hot=False, num_classes=10):‖1
def _extract_labels(f, one_hot=False, num_classes=10):‖"print(""Extracting"", f.name)"‖1
magic = _read32(bytestream)‖if magic != 2049:‖1
if magic != 2049:‖"msg = f""Invalid magic number {magic} in MNIST label file: {f.name}"""‖1
"msg = f""Invalid magic number {magic} in MNIST label file: {f.name}"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖num_items = _read32(bytestream)‖1
num_items = _read32(bytestream)‖buf = bytestream.read(num_items)‖1
buf = bytestream.read(num_items)‖labels = np.frombuffer(buf, dtype=np.uint8)‖1
labels = np.frombuffer(buf, dtype=np.uint8)‖if one_hot:‖1
if one_hot:‖return _dense_to_one_hot(labels, num_classes)‖1
return _dense_to_one_hot(labels, num_classes)‖return labels‖1
@deprecated(‖None,‖1
None,‖"""Please use alternatives such as official/mnist/_DataSet.py"""‖1
"""Please use alternatives such as official/mnist/_DataSet.py"""‖""" from tensorflow/models."","‖1
""" from tensorflow/models."","‖)‖1
)‖def __init__(‖1
self,‖images,‖1
images,‖labels,‖1
labels,‖fake_data=False,‖1
fake_data=False,‖one_hot=False,‖2
one_hot=False,‖dtype=dtypes.float32,‖2
dtype=dtypes.float32,‖reshape=True,‖2
reshape=True,‖seed=None,‖1
seed=None,‖):‖1
):‖seed1, seed2 = random_seed.get_seed(seed)‖1
self._rng = np.random.default_rng(seed1 if seed is None else seed2)‖dtype = dtypes.as_dtype(dtype).base_dtype‖1
dtype = dtypes.as_dtype(dtype).base_dtype‖if dtype not in (dtypes.uint8, dtypes.float32):‖1
if dtype not in (dtypes.uint8, dtypes.float32):‖"msg = f""Invalid image dtype {dtype!r}, expected uint8 or float32"""‖1
"msg = f""Invalid image dtype {dtype!r}, expected uint8 or float32"""‖raise TypeError(msg)‖1
raise TypeError(msg)‖if fake_data:‖1
if fake_data:‖self._num_examples = 10000‖1
self._num_examples = 10000‖self.one_hot = one_hot‖1
self.one_hot = one_hot‖else:‖1
else:‖assert images.shape[0] == labels.shape[0], (‖1
assert images.shape[0] == labels.shape[0], (‖"f""images.shape: {images.shape} labels.shape: {labels.shape}"""‖1
"f""images.shape: {images.shape} labels.shape: {labels.shape}"""‖)‖1
)‖self._num_examples = images.shape[0]‖1
if reshape:‖assert images.shape[3] == 1‖1
assert images.shape[3] == 1‖images = images.reshape(‖1
images = images.reshape(‖images.shape[0], images.shape[1] * images.shape[2]‖1
images.shape[0], images.shape[1] * images.shape[2]‖)‖1
)‖if dtype == dtypes.float32:‖1
images = images.astype(np.float32)‖images = np.multiply(images, 1.0 / 255.0)‖1
images = np.multiply(images, 1.0 / 255.0)‖self._images = images‖1
self._images = images‖self._labels = labels‖1
self._labels = labels‖self._epochs_completed = 0‖1
self._epochs_completed = 0‖self._index_in_epoch = 0‖1
@property‖def images(self):‖1
def images(self):‖return self._images‖1
@property‖def labels(self):‖1
def labels(self):‖return self._labels‖1
@property‖def num_examples(self):‖1
def num_examples(self):‖return self._num_examples‖1
@property‖def epochs_completed(self):‖1
def epochs_completed(self):‖return self._epochs_completed‖1
def next_batch(self, batch_size, fake_data=False, shuffle=True):‖if fake_data:‖1
if fake_data:‖fake_image = [1] * 784‖1
fake_image = [1] * 784‖fake_label = [1] + [0] * 9 if self.one_hot else 0‖1
fake_label = [1] + [0] * 9 if self.one_hot else 0‖return (‖1
return (‖[fake_image for _ in range(batch_size)],‖1
[fake_image for _ in range(batch_size)],‖[fake_label for _ in range(batch_size)],‖1
[fake_label for _ in range(batch_size)],‖)‖1
)‖start = self._index_in_epoch‖1
if self._epochs_completed == 0 and start == 0 and shuffle:‖perm0 = np.arange(self._num_examples)‖1
perm0 = np.arange(self._num_examples)‖self._rng.shuffle(perm0)‖1
self._rng.shuffle(perm0)‖self._images = self.images[perm0]‖1
self._images = self.images[perm0]‖self._labels = self.labels[perm0]‖1
rest_num_examples = self._num_examples - start‖images_rest_part = self._images[start : self._num_examples]‖1
images_rest_part = self._images[start : self._num_examples]‖labels_rest_part = self._labels[start : self._num_examples]‖1
if shuffle:‖perm = np.arange(self._num_examples)‖1
perm = np.arange(self._num_examples)‖self._rng.shuffle(perm)‖1
self._rng.shuffle(perm)‖self._images = self.images[perm]‖1
self._images = self.images[perm]‖self._labels = self.labels[perm]‖1
start = 0‖self._index_in_epoch = batch_size - rest_num_examples‖1
self._index_in_epoch = batch_size - rest_num_examples‖end = self._index_in_epoch‖1
end = self._index_in_epoch‖images_new_part = self._images[start:end]‖1
images_new_part = self._images[start:end]‖labels_new_part = self._labels[start:end]‖1
labels_new_part = self._labels[start:end]‖return (‖1
return (‖np.concatenate((images_rest_part, images_new_part), axis=0),‖1
np.concatenate((images_rest_part, images_new_part), axis=0),‖np.concatenate((labels_rest_part, labels_new_part), axis=0),‖1
np.concatenate((labels_rest_part, labels_new_part), axis=0),‖)‖1
else:‖self._index_in_epoch += batch_size‖1
self._index_in_epoch += batch_size‖end = self._index_in_epoch‖1
end = self._index_in_epoch‖return self._images[start:end], self._labels[start:end]‖1
"@deprecated(None, ""Please write your own downloading logic."")"‖def _maybe_download(filename, work_directory, source_url):‖1
def _maybe_download(filename, work_directory, source_url):‖if not gfile.Exists(work_directory):‖1
if not gfile.Exists(work_directory):‖gfile.MakeDirs(work_directory)‖1
gfile.MakeDirs(work_directory)‖filepath = os.path.join(work_directory, filename)‖1
filepath = os.path.join(work_directory, filename)‖if not gfile.Exists(filepath):‖1
if not gfile.Exists(filepath):‖urllib.request.urlretrieve(source_url, filepath)‖1
urllib.request.urlretrieve(source_url, filepath)‖with gfile.GFile(filepath) as f:‖1
with gfile.GFile(filepath) as f:‖size = f.size()‖1
size = f.size()‖"print(""Successfully downloaded"", filename, size, ""bytes."")"‖1
"print(""Successfully downloaded"", filename, size, ""bytes."")"‖return filepath‖1
"@deprecated(None, ""Please use alternatives such as: tensorflow_datasets.load('mnist')"")"‖def read_data_sets(‖1
def read_data_sets(‖train_dir,‖1
train_dir,‖fake_data=False,‖1
reshape=True,‖validation_size=5000,‖1
validation_size=5000,‖seed=None,‖1
seed=None,‖source_url=DEFAULT_SOURCE_URL,‖1
source_url=DEFAULT_SOURCE_URL,‖):‖1
):‖if fake_data:‖1
def fake():‖return _DataSet(‖1
return _DataSet(‖[], [], fake_data=True, one_hot=one_hot, dtype=dtype, seed=seed‖1
[], [], fake_data=True, one_hot=one_hot, dtype=dtype, seed=seed‖)‖1
train = fake()‖validation = fake()‖1
validation = fake()‖test = fake()‖1
test = fake()‖return _Datasets(train=train, validation=validation, test=test)‖1
if not source_url:‖source_url = DEFAULT_SOURCE_URL‖1
"train_images_file = ""train-images-idx3-ubyte.gz"""‖"train_labels_file = ""train-labels-idx1-ubyte.gz"""‖1
"train_labels_file = ""train-labels-idx1-ubyte.gz"""‖"test_images_file = ""t10k-images-idx3-ubyte.gz"""‖1
"test_images_file = ""t10k-images-idx3-ubyte.gz"""‖"test_labels_file = ""t10k-labels-idx1-ubyte.gz"""‖1
local_file = _maybe_download(‖train_images_file, train_dir, source_url + train_images_file‖1
train_images_file, train_dir, source_url + train_images_file‖)‖1
)‖"with gfile.Open(local_file, ""rb"") as f:"‖4
"with gfile.Open(local_file, ""rb"") as f:"‖train_images = _extract_images(f)‖1
local_file = _maybe_download(‖train_labels_file, train_dir, source_url + train_labels_file‖1
train_labels_file, train_dir, source_url + train_labels_file‖)‖1
"with gfile.Open(local_file, ""rb"") as f:"‖train_labels = _extract_labels(f, one_hot=one_hot)‖1
local_file = _maybe_download(‖test_images_file, train_dir, source_url + test_images_file‖1
test_images_file, train_dir, source_url + test_images_file‖)‖1
"with gfile.Open(local_file, ""rb"") as f:"‖test_images = _extract_images(f)‖1
local_file = _maybe_download(‖test_labels_file, train_dir, source_url + test_labels_file‖1
test_labels_file, train_dir, source_url + test_labels_file‖)‖1
"with gfile.Open(local_file, ""rb"") as f:"‖test_labels = _extract_labels(f, one_hot=one_hot)‖1
if not 0 <= validation_size <= len(train_images):‖msg = (‖1
msg = (‖"""Validation size should be between 0 and """‖1
"""Validation size should be between 0 and """‖"f""{len(train_images)}. Received: {validation_size}."""‖1
"f""{len(train_images)}. Received: {validation_size}."""‖)‖1
validation_images = train_images[:validation_size]‖validation_labels = train_labels[:validation_size]‖1
validation_labels = train_labels[:validation_size]‖train_images = train_images[validation_size:]‖1
train_images = train_images[validation_size:]‖train_labels = train_labels[validation_size:]‖1
train = _DataSet(train_images, train_labels, **options)‖validation = _DataSet(validation_images, validation_labels, **options)‖1
validation = _DataSet(validation_images, validation_labels, **options)‖test = _DataSet(test_images, test_labels, **options)‖1
def sigmoid(x: np.ndarray) -> np.ndarray:‖return 1 / (1 + np.exp(-x))‖1
def __init__(‖self, units, activation=None, learning_rate=None, is_input_layer=False‖1
self, units, activation=None, learning_rate=None, is_input_layer=False‖):‖1
):‖self.units = units‖1
self.units = units‖self.weight = None‖1
self.weight = None‖self.bias = None‖1
self.bias = None‖self.activation = activation‖1
self.activation = activation‖if learning_rate is None:‖1
if learning_rate is None:‖learning_rate = 0.3‖1
learning_rate = 0.3‖self.learn_rate = learning_rate‖1
self.learn_rate = learning_rate‖self.is_input_layer = is_input_layer‖1
def initializer(self, back_units):‖rng = np.random.default_rng()‖1
rng = np.random.default_rng()‖self.weight = np.asmatrix(rng.normal(0, 0.5, (self.units, back_units)))‖1
self.weight = np.asmatrix(rng.normal(0, 0.5, (self.units, back_units)))‖self.bias = np.asmatrix(rng.normal(0, 0.5, self.units)).T‖1
self.bias = np.asmatrix(rng.normal(0, 0.5, self.units)).T‖if self.activation is None:‖1
if self.activation is None:‖self.activation = sigmoid‖1
if self.activation == sigmoid:‖gradient_mat = np.dot(self.output, (1 - self.output).T)‖1
gradient_mat = np.dot(self.output, (1 - self.output).T)‖gradient_activation = np.diag(np.diag(gradient_mat))‖1
gradient_activation = np.diag(np.diag(gradient_mat))‖else:‖1
else:‖gradient_activation = 1‖1
gradient_activation = 1‖return gradient_activation‖1
def forward_propagation(self, xdata):‖self.xdata = xdata‖1
self.xdata = xdata‖if self.is_input_layer:‖1
self.wx_plus_b = xdata‖self.output = xdata‖1
self.output = xdata‖return xdata‖1
return xdata‖else:‖1
else:‖self.wx_plus_b = np.dot(self.weight, self.xdata) - self.bias‖1
self.wx_plus_b = np.dot(self.weight, self.xdata) - self.bias‖self.output = self.activation(self.wx_plus_b)‖1
self.output = self.activation(self.wx_plus_b)‖return self.output‖1
def back_propagation(self, gradient):‖gradient_activation = self.cal_gradient()‖1
gradient_activation = self.cal_gradient()‖gradient = np.asmatrix(np.dot(gradient.T, gradient_activation))‖1
self._gradient_weight = np.asmatrix(self.xdata)‖self._gradient_bias = -1‖1
self._gradient_bias = -1‖self._gradient_x = self.weight‖1
self.gradient_weight = np.dot(gradient.T, self._gradient_weight.T)‖self.gradient_bias = gradient * self._gradient_bias‖1
self.gradient_bias = gradient * self._gradient_bias‖self.gradient = np.dot(gradient, self._gradient_x).T‖1
self.weight = self.weight - self.learn_rate * self.gradient_weight‖self.bias = self.bias - self.learn_rate * self.gradient_bias.T‖1
def __init__(self):‖self.layers = []‖1
self.layers = []‖self.train_mse = []‖1
self.train_mse = []‖self.fig_loss = plt.figure()‖1
self.fig_loss = plt.figure()‖self.ax_loss = self.fig_loss.add_subplot(1, 1, 1)‖1
def add_layer(self, layer):‖self.layers.append(layer)‖1
def build(self):‖for i, layer in enumerate(self.layers[:]):‖1
for i, layer in enumerate(self.layers[:]):‖if i < 1:‖1
if i < 1:‖layer.is_input_layer = True‖1
layer.is_input_layer = True‖else:‖1
else:‖layer.initializer(self.layers[i - 1].units)‖1
def summary(self):‖for i, layer in enumerate(self.layers[:]):‖1
for i, layer in enumerate(self.layers[:]):‖"print(f""------- layer {i} -------"")"‖1
"print(f""------- layer {i} -------"")"‖"print(""weight.shape "", np.shape(layer.weight))"‖1
"print(""weight.shape "", np.shape(layer.weight))"‖"print(""bias.shape "", np.shape(layer.bias))"‖1
def train(self, xdata, ydata, train_round, accuracy):‖self.train_round = train_round‖1
self.train_round = train_round‖self.accuracy = accuracy‖1
x_shape = np.shape(xdata)‖for _ in range(train_round):‖1
for _ in range(train_round):‖all_loss = 0‖1
all_loss = 0‖for row in range(x_shape[0]):‖1
for row in range(x_shape[0]):‖_xdata = np.asmatrix(xdata[row, :]).T‖1
_xdata = np.asmatrix(xdata[row, :]).T‖_ydata = np.asmatrix(ydata[row, :]).T‖1
for layer in self.layers:‖_xdata = layer.forward_propagation(_xdata)‖1
loss, gradient = self.cal_loss(_ydata, _xdata)‖all_loss = all_loss + loss‖1
for layer in self.layers[:0:-1]:‖gradient = layer.back_propagation(gradient)‖1
mse = all_loss / x_shape[0]‖self.train_mse.append(mse)‖1
if mse < self.accuracy:‖"print(""----达到精度----"")"‖1
"print(""----达到精度----"")"‖return mse‖1
return mse‖return None‖1
def cal_loss(self, ydata, ydata_):‖self.loss = np.sum(np.power((ydata - ydata_), 2))‖1
self.loss = np.sum(np.power((ydata - ydata_), 2))‖self.loss_gradient = 2 * (ydata_ - ydata)‖1
def plot_loss(self):‖if self.ax_loss.lines:‖1
if self.ax_loss.lines:‖self.ax_loss.lines.remove(self.ax_loss.lines[0])‖1
self.ax_loss.lines.remove(self.ax_loss.lines[0])‖"self.ax_loss.plot(self.train_mse, ""r-"")"‖1
"self.ax_loss.plot(self.train_mse, ""r-"")"‖plt.ion()‖1
plt.ion()‖"plt.xlabel(""step"")"‖1
"plt.xlabel(""step"")"‖"plt.ylabel(""loss"")"‖1
"plt.ylabel(""loss"")"‖plt.show()‖1
plt.show()‖plt.pause(0.1)‖1
def example():‖rng = np.random.default_rng()‖1
rng = np.random.default_rng()‖x = rng.normal(size=(10, 10))‖1
x = rng.normal(size=(10, 10))‖y = np.asarray(‖1
y = np.asarray(‖[‖1
[‖[0.8, 0.4],‖1
[0.8, 0.4],‖[0.4, 0.3],‖1
[0.4, 0.3],‖[0.34, 0.45],‖1
[0.34, 0.45],‖[0.67, 0.32],‖1
[0.67, 0.32],‖[0.88, 0.67],‖1
[0.88, 0.67],‖[0.78, 0.77],‖1
[0.78, 0.77],‖[0.55, 0.66],‖1
[0.55, 0.66],‖[0.55, 0.43],‖1
[0.55, 0.43],‖[0.54, 0.1],‖1
[0.54, 0.1],‖[0.1, 0.5],‖1
[0.1, 0.5],‖]‖1
)‖model = BPNN()‖1
model = BPNN()‖for i in (10, 20, 30, 2):‖1
for i in (10, 20, 30, 2):‖model.add_layer(DenseLayer(i))‖1
model.add_layer(DenseLayer(i))‖model.build()‖1
model.build()‖model.summary()‖1
model.summary()‖model.train(xdata=x, ydata=y, train_round=100, accuracy=0.01)‖1
"if __name__ == ""__main__"":"‖example()‖2
"if __name__ == ""__main__"":"‖print(np.array(relu([-1, 0, 5])))‖1
def softplus(vector: np.ndarray) -> np.ndarray:‖return np.log(1 + np.exp(vector))‖1
def exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:‖return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))‖1
def sigmoid_function(value: float, deriv: bool = False) -> float:‖if deriv:‖1
if deriv:‖return value * (1 - value)‖1
return value * (1 - value)‖return 1 / (1 + math.exp(-value))‖1
"expected = int(input(""Expected value: ""))"‖"number_propagations = int(input(""Number of propagations: ""))"‖1
"number_propagations = int(input(""Number of propagations: ""))"‖print(forward_propagation(expected, number_propagations))‖1
def mish(vector: np.ndarray) -> np.ndarray:‖return vector * np.tanh(softplus(vector))‖1
n = len(finish)‖"print(""The following activities are selected:"")"‖1
i = 0‖"print(i, end="","")"‖1
if start[j] >= finish[i]:‖"print(j, end="","")"‖1
"print(j, end="","")"‖i = j‖1
start = [1, 3, 0, 5, 8, 5]‖finish = [2, 4, 6, 7, 9, 9]‖1
finish = [2, 4, 6, 7, 9, 9]‖print_max_activities(start, finish)‖1
def scaled_exponential_linear_unit(‖vector: np.ndarray, alpha: float = 1.6732, lambda_: float = 1.0507‖1
vector: np.ndarray, alpha: float = 1.6732, lambda_: float = 1.0507‖) -> np.ndarray:‖1
) -> np.ndarray:‖return lambda_ * np.where(vector > 0, vector, alpha * (np.exp(vector) - 1))‖1
test_claim_vector = [8, 5, 9, 7]‖test_allocated_res_table = [‖1
test_allocated_res_table = [‖[2, 0, 1, 1],‖1
[2, 0, 1, 1],‖[0, 1, 2, 1],‖1
[0, 1, 2, 1],‖[4, 0, 0, 3],‖1
[4, 0, 0, 3],‖[0, 2, 1, 0],‖1
[0, 2, 1, 0],‖[1, 0, 3, 0],‖1
[1, 0, 3, 0],‖]‖1
]‖test_maximum_claim_table = [‖1
test_maximum_claim_table = [‖[3, 2, 1, 4],‖1
[3, 2, 1, 4],‖[0, 2, 5, 2],‖1
[0, 2, 5, 2],‖[5, 1, 0, 5],‖1
[5, 1, 0, 5],‖[1, 5, 3, 0],‖1
[1, 5, 3, 0],‖[3, 0, 3, 3],‖1
[3, 0, 3, 3],‖]‖1
class BankersAlgorithm:‖def __init__(‖1
self,‖claim_vector: list[int],‖1
claim_vector: list[int],‖allocated_resources_table: list[list[int]],‖1
allocated_resources_table: list[list[int]],‖maximum_claim_table: list[list[int]],‖1
maximum_claim_table: list[list[int]],‖) -> None:‖1
) -> None:‖self.__claim_vector = claim_vector‖1
self.__claim_vector = claim_vector‖self.__allocated_resources_table = allocated_resources_table‖1
self.__allocated_resources_table = allocated_resources_table‖self.__maximum_claim_table = maximum_claim_table‖1
def __processes_resource_summation(self) -> list[int]:‖return [‖1
return [‖sum(p_item[i] for p_item in self.__allocated_resources_table)‖1
sum(p_item[i] for p_item in self.__allocated_resources_table)‖for i in range(len(self.__allocated_resources_table[0]))‖1
for i in range(len(self.__allocated_resources_table[0]))‖]‖1
def __available_resources(self) -> list[int]:‖return np.array(self.__claim_vector) - np.array(‖1
return np.array(self.__claim_vector) - np.array(‖self.__processes_resource_summation()‖1
self.__processes_resource_summation()‖)‖1
def __need(self) -> list[list[int]]:‖return [‖1
return [‖list(np.array(self.__maximum_claim_table[i]) - np.array(allocated_resource))‖1
list(np.array(self.__maximum_claim_table[i]) - np.array(allocated_resource))‖for i, allocated_resource in enumerate(self.__allocated_resources_table)‖1
for i, allocated_resource in enumerate(self.__allocated_resources_table)‖]‖1
def __need_index_manager(self) -> dict[int, list[int]]:‖return {self.__need().index(i): i for i in self.__need()}‖1
def main(self, **kwargs) -> None:‖need_list = self.__need()‖1
need_list = self.__need()‖alloc_resources_table = self.__allocated_resources_table‖1
alloc_resources_table = self.__allocated_resources_table‖available_resources = self.__available_resources()‖1
available_resources = self.__available_resources()‖need_index_manager = self.__need_index_manager()‖1
need_index_manager = self.__need_index_manager()‖for kw, val in kwargs.items():‖1
for kw, val in kwargs.items():‖if kw and val is True:‖1
if kw and val is True:‖self.__pretty_data()‖1
self.__pretty_data()‖"print(""_"" * 50 + ""\n"")"‖1
"print(""_"" * 50 + ""\n"")"‖while need_list:‖1
while need_list:‖safe = False‖1
safe = False‖for each_need in need_list:‖1
for each_need in need_list:‖execution = True‖1
execution = True‖for index, need in enumerate(each_need):‖1
for index, need in enumerate(each_need):‖if need > available_resources[index]:‖1
if need > available_resources[index]:‖execution = False‖1
execution = False‖break‖1
break‖if execution:‖1
if execution:‖safe = True‖1
for original_need_index, need_clone in need_index_manager.items():‖if each_need == need_clone:‖1
if each_need == need_clone:‖process_number = original_need_index‖1
process_number = original_need_index‖"print(f""Process {process_number + 1} is executing."")"‖1
available_resources = np.array(available_resources) + np.array(‖alloc_resources_table[process_number]‖1
alloc_resources_table[process_number]‖)‖1
print(‖"""Updated available resource stack for processes: """‖1
"""Updated available resource stack for processes: """‖"+ "" "".join([str(x) for x in available_resources])"‖1
"+ "" "".join([str(x) for x in available_resources])"‖)‖1
)‖break‖1
break‖if safe:‖1
if safe:‖"print(""The process is in a safe state.\n"")"‖1
"print(""The process is in a safe state.\n"")"‖else:‖1
else:‖"print(""System in unsafe state. Aborting...\n"")"‖1
"print(""System in unsafe state. Aborting...\n"")"‖break‖1
def __pretty_data(self):‖"print("" "" * 9 + ""Allocated Resource Table"")"‖1
"print("" "" * 9 + ""Allocated Resource Table"")"‖for item in self.__allocated_resources_table:‖1
for item in self.__allocated_resources_table:‖print(‖1
print(‖"f""P{self.__allocated_resources_table.index(item) + 1}"""‖1
"f""P{self.__allocated_resources_table.index(item) + 1}"""‖"+ "" "".join(f""{it:>8}"" for it in item)"‖1
"+ "" "".join(f""{it:>8}"" for it in item)"‖"+ ""\n"""‖2
"+ ""\n"""‖)‖2
)‖"print("" "" * 9 + ""System Resource Table"")"‖1
"print("" "" * 9 + ""System Resource Table"")"‖for item in self.__maximum_claim_table:‖1
for item in self.__maximum_claim_table:‖print(‖1
print(‖"f""P{self.__maximum_claim_table.index(item) + 1}"""‖1
"f""P{self.__maximum_claim_table.index(item) + 1}"""‖"+ "" "".join(f""{it:>8}"" for it in item)"‖1
print(‖"""Current Usage by Active Processes: """‖1
"""Current Usage by Active Processes: """‖"+ "" "".join(str(x) for x in self.__claim_vector)"‖1
"+ "" "".join(str(x) for x in self.__claim_vector)"‖)‖1
print(‖"""Initial Available Resources:       """‖1
"""Initial Available Resources:       """‖"+ "" "".join(str(x) for x in self.__available_resources())"‖1
"+ "" "".join(str(x) for x in self.__available_resources())"‖)‖1
def fisher_yates_shuffle(data: list) -> list[Any]:‖for _ in range(len(data)):‖1
for _ in range(len(data)):‖a = random.randint(0, len(data) - 1)‖1
a = random.randint(0, len(data) - 1)‖b = random.randint(0, len(data) - 1)‖1
b = random.randint(0, len(data) - 1)‖data[a], data[b] = data[b], data[a]‖1
data[a], data[b] = data[b], data[a]‖return data‖1
"if __name__ == ""__main__"":"‖integers = [0, 1, 2, 3, 4, 5, 6, 7]‖1
integers = [0, 1, 2, 3, 4, 5, 6, 7]‖"strings = [""python"", ""says"", ""hello"", ""!""]"‖1
"strings = [""python"", ""says"", ""hello"", ""!""]"‖"print(""Fisher-Yates Shuffle:"")"‖1
"print(""Fisher-Yates Shuffle:"")"‖"print(""List"", integers, strings)"‖1
"print(""List"", integers, strings)"‖"print(""FY Shuffle"", fisher_yates_shuffle(integers), fisher_yates_shuffle(strings))"‖1
class TwoHiddenLayerNeuralNetwork:‖def __init__(self, input_array: np.ndarray, output_array: np.ndarray) -> None:‖1
rng = np.random.default_rng()‖self.input_layer_and_first_hidden_layer_weights = rng.random(‖1
self.input_layer_and_first_hidden_layer_weights = rng.random(‖(self.input_array.shape[1], 4)‖1
(self.input_array.shape[1], 4)‖)‖1
self.layer_between_input_and_first_hidden_layer = sigmoid(‖np.dot(self.input_array, self.input_layer_and_first_hidden_layer_weights)‖1
np.dot(self.input_array, self.input_layer_and_first_hidden_layer_weights)‖)‖1
self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(‖np.dot(‖2
np.dot(‖self.layer_between_input_and_first_hidden_layer,‖2
self.layer_between_input_and_first_hidden_layer,‖self.first_hidden_layer_and_second_hidden_layer_weights,‖2
self.first_hidden_layer_and_second_hidden_layer_weights,‖)‖2
self.layer_between_second_hidden_layer_and_output = sigmoid(‖np.dot(‖2
np.dot(‖self.layer_between_first_hidden_layer_and_second_hidden_layer,‖2
self.layer_between_first_hidden_layer_and_second_hidden_layer,‖self.second_hidden_layer_and_output_layer_weights,‖2
self.second_hidden_layer_and_output_layer_weights,‖)‖2
updated_second_hidden_layer_and_output_layer_weights = np.dot(‖self.layer_between_first_hidden_layer_and_second_hidden_layer.T,‖1
self.layer_between_first_hidden_layer_and_second_hidden_layer.T,‖2‖1
2‖* (self.output_array - self.predicted_output)‖3
* (self.output_array - self.predicted_output)‖* sigmoid_derivative(self.predicted_output),‖3
* sigmoid_derivative(self.predicted_output),‖)‖1
)‖updated_first_hidden_layer_and_second_hidden_layer_weights = np.dot(‖1
updated_first_hidden_layer_and_second_hidden_layer_weights = np.dot(‖self.layer_between_input_and_first_hidden_layer.T,‖1
self.layer_between_input_and_first_hidden_layer.T,‖np.dot(‖1
np.dot(‖2‖2
* sigmoid_derivative(self.predicted_output),‖self.second_hidden_layer_and_output_layer_weights.T,‖2
self.second_hidden_layer_and_output_layer_weights.T,‖)‖2
)‖* sigmoid_derivative(‖2
* sigmoid_derivative(‖self.layer_between_first_hidden_layer_and_second_hidden_layer‖2
self.layer_between_first_hidden_layer_and_second_hidden_layer‖),‖2
),‖)‖5
)‖updated_input_layer_and_first_hidden_layer_weights = np.dot(‖1
updated_input_layer_and_first_hidden_layer_weights = np.dot(‖self.input_array.T,‖1
self.input_array.T,‖np.dot(‖1
np.dot(‖np.dot(‖1
),‖self.first_hidden_layer_and_second_hidden_layer_weights.T,‖1
self.first_hidden_layer_and_second_hidden_layer_weights.T,‖)‖1
)‖* sigmoid_derivative(self.layer_between_input_and_first_hidden_layer),‖1
* sigmoid_derivative(self.layer_between_input_and_first_hidden_layer),‖)‖1
self.input_layer_and_first_hidden_layer_weights += (‖updated_input_layer_and_first_hidden_layer_weights‖1
updated_input_layer_and_first_hidden_layer_weights‖)‖1
)‖self.first_hidden_layer_and_second_hidden_layer_weights += (‖1
self.first_hidden_layer_and_second_hidden_layer_weights += (‖updated_first_hidden_layer_and_second_hidden_layer_weights‖1
updated_first_hidden_layer_and_second_hidden_layer_weights‖)‖1
)‖self.second_hidden_layer_and_output_layer_weights += (‖1
self.second_hidden_layer_and_output_layer_weights += (‖updated_second_hidden_layer_and_output_layer_weights‖1
updated_second_hidden_layer_and_output_layer_weights‖)‖1
def train(self, output: np.ndarray, iterations: int, give_loss: bool) -> None:‖for iteration in range(1, iterations + 1):‖1
for iteration in range(1, iterations + 1):‖self.output = self.feedforward()‖1
self.output = self.feedforward()‖self.back_propagation()‖1
self.back_propagation()‖if give_loss:‖1
if give_loss:‖loss = np.mean(np.square(output - self.feedforward()))‖1
loss = np.mean(np.square(output - self.feedforward()))‖"print(f""Iteration {iteration} Loss: {loss}"")"‖1
self.layer_between_input_and_first_hidden_layer = sigmoid(‖np.dot(self.array, self.input_layer_and_first_hidden_layer_weights)‖1
np.dot(self.array, self.input_layer_and_first_hidden_layer_weights)‖)‖1
def sigmoid(value: np.ndarray) -> np.ndarray:‖return 1 / (1 + np.exp(-value))‖1
def sigmoid_derivative(value: np.ndarray) -> np.ndarray:‖return (value) * (1 - (value))‖1
test_input = np.array(‖(‖1
(‖[0, 0, 0],‖1
[0, 0, 0],‖[0, 0, 1],‖1
[0, 0, 1],‖[0, 1, 0],‖1
[0, 1, 0],‖[0, 1, 1],‖1
[0, 1, 1],‖[1, 0, 0],‖1
[1, 0, 0],‖[1, 0, 1],‖1
[1, 0, 1],‖[1, 1, 0],‖1
[1, 1, 0],‖[1, 1, 1],‖1
[1, 1, 1],‖),‖1
),‖dtype=np.float64,‖1
dtype=np.float64,‖)‖1
neural_network = TwoHiddenLayerNeuralNetwork(‖input_array=test_input, output_array=output‖1
input_array=test_input, output_array=output‖)‖1
def squareplus(vector: np.ndarray, beta: float) -> np.ndarray:‖return (vector + np.sqrt(vector**2 + beta)) / 2‖1
import math‖from datetime import UTC, datetime, timedelta‖1
def gauss_easter(year: int) -> datetime:‖metonic_cycle = year % 19‖1
metonic_cycle = year % 19‖julian_leap_year = year % 4‖1
julian_leap_year = year % 4‖non_leap_year = year % 7‖1
non_leap_year = year % 7‖leap_day_inhibits = math.floor(year / 100)‖1
leap_day_inhibits = math.floor(year / 100)‖lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)‖1
lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)‖leap_day_reinstall_number = leap_day_inhibits / 4‖1
leap_day_reinstall_number = leap_day_inhibits / 4‖secular_moon_shift = (‖1
secular_moon_shift = (‖15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number‖1
15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number‖) % 30‖1
) % 30‖century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7‖1
days_from_phm_to_sunday = (‖2 * julian_leap_year‖1
2 * julian_leap_year‖+ 4 * non_leap_year‖1
+ 4 * non_leap_year‖+ 6 * days_to_add‖1
+ 6 * days_to_add‖+ century_starting_point‖1
+ century_starting_point‖) % 7‖1
if days_to_add == 29 and days_from_phm_to_sunday == 6:‖return datetime(year, 4, 19, tzinfo=UTC)‖1
return datetime(year, 4, 19, tzinfo=UTC)‖elif days_to_add == 28 and days_from_phm_to_sunday == 6:‖1
elif days_to_add == 28 and days_from_phm_to_sunday == 6:‖return datetime(year, 4, 18, tzinfo=UTC)‖1
return datetime(year, 4, 18, tzinfo=UTC)‖else:‖1
else:‖return datetime(year, 3, 22, tzinfo=UTC) + timedelta(‖1
return datetime(year, 3, 22, tzinfo=UTC) + timedelta(‖days=int(days_to_add + days_from_phm_to_sunday)‖1
days=int(days_to_add + days_from_phm_to_sunday)‖)‖1
"if __name__ == ""__main__"":"‖for year in (1994, 2000, 2010, 2021, 2023, 2032, 2100):‖1
for year in (1994, 2000, 2010, 2021, 2023, 2032, 2100):‖"tense = ""will be"" if year > datetime.now(tz=UTC).year else ""was"""‖1
"tense = ""will be"" if year > datetime.now(tz=UTC).year else ""was"""‖"print(f""Easter in {year} {tense} {gauss_easter(year)}"")"‖1
from collections import deque‖from enum import Enum‖1
from enum import Enum‖from math import atan2, degrees‖1
from math import atan2, degrees‖from sys import maxsize‖1
class Direction(Enum):‖left = 1‖1
left = 1‖straight = 2‖1
straight = 2‖right = 3‖1
def __repr__(self):‖"return f""{self.__class__.__name__}.{self.name}"""‖1
x, y = point‖return degrees(atan2(y - miny, x - minx))‖1
def check_direction(‖starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]‖1
starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]‖) -> Direction:‖1
) -> Direction:‖x0, y0 = starting‖1
x0, y0 = starting‖x1, y1 = via‖1
x1, y1 = via‖x2, y2 = target‖1
x2, y2 = target‖via_angle = degrees(atan2(y1 - y0, x1 - x0))‖1
via_angle = degrees(atan2(y1 - y0, x1 - x0))‖via_angle %= 360‖1
via_angle %= 360‖target_angle = degrees(atan2(y2 - y0, x2 - x0))‖1
target_angle = degrees(atan2(y2 - y0, x2 - x0))‖target_angle %= 360‖1
if target_angle > via_angle:‖return Direction.left‖1
return Direction.left‖elif target_angle == via_angle:‖1
elif target_angle == via_angle:‖return Direction.straight‖1
return Direction.straight‖else:‖1
else:‖return Direction.right‖1
"raise ValueError(""graham_scan: argument must contain more than 3 points."")"‖if len(points) == 3:‖1
if len(points) == 3:‖return points‖1
minidx = 0‖miny, minx = maxsize, maxsize‖1
miny, minx = maxsize, maxsize‖for i, point in enumerate(points):‖1
for i, point in enumerate(points):‖x = point[0]‖1
x = point[0]‖y = point[1]‖1
y = point[1]‖if y < miny:‖1
if y < miny:‖miny = y‖1
miny = y‖minx = x‖1
minx = x‖minidx = i‖2
minidx = i‖if y == miny and x < minx:‖1
if y == miny and x < minx:‖minx = x‖1
stack: deque[tuple[int, int]] = deque()‖stack.append(sorted_points[0])‖1
stack.append(sorted_points[0])‖stack.append(sorted_points[1])‖1
stack.append(sorted_points[1])‖stack.append(sorted_points[2])‖1
for i in range(3, len(sorted_points)):‖while True:‖1
while True:‖starting = stack[-2]‖1
starting = stack[-2]‖via = stack[-1]‖1
via = stack[-1]‖target = sorted_points[i]‖1
target = sorted_points[i]‖next_direction = check_direction(starting, via, target)‖1
if next_direction == Direction.left:‖current_direction = Direction.left‖1
current_direction = Direction.left‖break‖1
break‖if next_direction == Direction.straight:‖1
if next_direction == Direction.straight:‖if current_direction == Direction.left:‖1
break‖elif current_direction == Direction.right:‖1
stack.pop()‖if next_direction == Direction.right:‖1
if next_direction == Direction.right:‖stack.pop()‖1
stack.pop()‖stack.append(sorted_points[i])‖1
stack.append(sorted_points[i])‖return list(stack)‖1
def soboleva_modified_hyperbolic_tangent(‖vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float‖1
vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float‖) -> np.ndarray:‖1
numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)‖denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)‖1
def sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:‖return vector * sigmoid(vector)‖1
def swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:‖return vector * sigmoid(trainable_parameter * vector)‖1
class Things:‖def __init__(self, name, value, weight):‖1
def __init__(self, name, value, weight):‖self.name = name‖1
self.name = name‖self.value = value‖1
self.value = value‖self.weight = weight‖1
def __repr__(self):‖"return f""{self.__class__.__name__}({self.name}, {self.value}, {self.weight})"""‖1
def get_value(self):‖return self.value‖1
def get_name(self):‖return self.name‖1
def get_weight(self):‖return self.weight‖1
def value_weight(self):‖return self.value / self.weight‖1
def build_menu(name, value, weight):‖menu = []‖1
menu = []‖for i in range(len(value)):‖1
for i in range(len(value)):‖menu.append(Things(name[i], value[i], weight[i]))‖1
menu.append(Things(name[i], value[i], weight[i]))‖return menu‖1
def greedy(item, max_cost, key_func):‖items_copy = sorted(item, key=key_func, reverse=True)‖1
items_copy = sorted(item, key=key_func, reverse=True)‖result = []‖1
result = []‖total_value, total_cost = 0.0, 0.0‖1
total_value, total_cost = 0.0, 0.0‖for i in range(len(items_copy)):‖1
for i in range(len(items_copy)):‖if (total_cost + items_copy[i].get_weight()) <= max_cost:‖1
if (total_cost + items_copy[i].get_weight()) <= max_cost:‖result.append(items_copy[i])‖1
result.append(items_copy[i])‖total_cost += items_copy[i].get_weight()‖1
total_cost += items_copy[i].get_weight()‖total_value += items_copy[i].get_value()‖1
total_value += items_copy[i].get_value()‖return (result, total_value)‖1
def test_greedy():‖pass‖1
def majority_vote(votes: list[int], votes_needed_to_win: int) -> list[int]:‖majority_candidate_counter: Counter[int] = Counter()‖1
majority_candidate_counter: Counter[int] = Counter()‖for vote in votes:‖1
for vote in votes:‖majority_candidate_counter[vote] += 1‖1
majority_candidate_counter[vote] += 1‖if len(majority_candidate_counter) == votes_needed_to_win:‖1
if len(majority_candidate_counter) == votes_needed_to_win:‖majority_candidate_counter -= Counter(set(majority_candidate_counter))‖1
majority_candidate_counter -= Counter(set(majority_candidate_counter))‖majority_candidate_counter = Counter(‖1
majority_candidate_counter = Counter(‖vote for vote in votes if vote in majority_candidate_counter‖1
vote for vote in votes if vote in majority_candidate_counter‖)‖1
)‖return [‖1
return [‖vote‖1
vote‖for vote in majority_candidate_counter‖1
for vote in majority_candidate_counter‖if majority_candidate_counter[vote] > len(votes) / votes_needed_to_win‖1
if majority_candidate_counter[vote] > len(votes) / votes_needed_to_win‖]‖1
from collections.abc import Callable‖from typing import Generic, TypeVar‖2
"T = TypeVar(""T"")"‖"U = TypeVar(""U"")"‖2
def __init__(self, key: T | None, val: U | None):‖self.key = key‖2
self.key = key‖self.val = val‖2
self.val = val‖self.freq: int = 0‖1
self.freq: int = 0‖self.next: DoubleLinkedListNode[T, U] | None = None‖1
self.next: DoubleLinkedListNode[T, U] | None = None‖self.prev: DoubleLinkedListNode[T, U] | None = None‖2
def __repr__(self) -> str:‖return (‖2
return (‖"f""Node: key: {self.key}, val: {self.val}, freq: {self.freq}, """‖1
"f""Node: key: {self.key}, val: {self.val}, freq: {self.freq}, """‖"f""has next: {self.next is not None}, has prev: {self.prev is not None}"""‖1
"f""has next: {self.next is not None}, has prev: {self.prev is not None}"""‖)‖1
def __init__(self) -> None:‖self.head: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)‖2
self.head: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)‖self.rear: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)‖2
self.rear: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)‖self.head.next, self.rear.prev = self.rear, self.head‖2
def __repr__(self) -> str:‖"rep = [""DoubleLinkedList""]"‖2
"rep = [""DoubleLinkedList""]"‖node = self.head‖2
node = self.head‖while node.next is not None:‖2
while node.next is not None:‖rep.append(str(node))‖2
rep.append(str(node))‖node = node.next‖2
node = node.next‖rep.append(str(self.rear))‖2
rep.append(str(self.rear))‖"return "",\n    "".join(rep)"‖2
previous.next = node‖node.prev = previous‖2
node.prev = previous‖self.rear.prev = node‖2
self.rear.prev = node‖node.next = self.rear‖2
node.next = self.rear‖node.freq += 1‖1
node.freq += 1‖self._position_node(node)‖1
node.prev = previous_node.prev‖previous_node.next = node.prev‖1
previous_node.next = node.prev‖node.next = previous_node‖1
node.next = previous_node‖previous_node.prev = node‖1
def remove(‖self, node: DoubleLinkedListNode[T, U]‖2
self, node: DoubleLinkedListNode[T, U]‖) -> DoubleLinkedListNode[T, U] | None:‖2
if node.prev is None or node.next is None:‖return None‖2
node.prev.next = node.next‖node.next.prev = node.prev‖2
node.next.prev = node.prev‖node.prev = None‖2
node.prev = None‖node.next = None‖2
node.next = None‖return node‖2
def __init__(self, capacity: int):‖self.list: DoubleLinkedList[T, U] = DoubleLinkedList()‖2
self.list: DoubleLinkedList[T, U] = DoubleLinkedList()‖self.capacity = capacity‖2
self.capacity = capacity‖self.num_keys = 0‖2
self.num_keys = 0‖self.hits = 0‖2
self.hits = 0‖self.miss = 0‖2
self.miss = 0‖self.cache: dict[T, DoubleLinkedListNode[T, U]] = {}‖2
return (‖"f""CacheInfo(hits={self.hits}, misses={self.miss}, """‖2
"f""CacheInfo(hits={self.hits}, misses={self.miss}, """‖"f""capacity={self.capacity}, current_size={self.num_keys})"""‖1
"f""capacity={self.capacity}, current_size={self.num_keys})"""‖)‖1
if key in self.cache:‖self.hits += 1‖2
self.hits += 1‖value_node: DoubleLinkedListNode[T, U] = self.cache[key]‖2
value_node: DoubleLinkedListNode[T, U] = self.cache[key]‖node = self.list.remove(self.cache[key])‖2
node = self.list.remove(self.cache[key])‖assert node == value_node‖2
assert node is not None‖self.list.add(node)‖2
self.list.add(node)‖return node.val‖2
return node.val‖self.miss += 1‖2
self.miss += 1‖return None‖2
if key not in self.cache:‖if self.num_keys >= self.capacity:‖2
assert first_node is not None‖assert first_node.key is not None‖2
assert first_node.key is not None‖assert self.list.remove(first_node) is not None‖1
del self.cache[first_node.key]‖self.num_keys -= 1‖2
self.num_keys -= 1‖self.cache[key] = DoubleLinkedListNode(key, value)‖2
self.cache[key] = DoubleLinkedListNode(key, value)‖self.list.add(self.cache[key])‖2
self.list.add(self.cache[key])‖self.num_keys += 1‖2
else:‖node = self.list.remove(self.cache[key])‖1
node = self.list.remove(self.cache[key])‖assert node is not None‖2
assert node is not None‖node.val = value‖2
node.val = value‖self.list.add(node)‖2
@classmethod‖def decorator(‖2
def decorator(‖cls: type[LFUCache[T, U]], size: int = 128‖1
cls: type[LFUCache[T, U]], size: int = 128‖) -> Callable[[Callable[[T], U]], Callable[..., U]]:‖1
def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:‖def cache_decorator_wrapper(*args: T) -> U:‖2
def cache_decorator_wrapper(*args: T) -> U:‖if func not in cls.decorator_function_to_instance_map:‖2
if func not in cls.decorator_function_to_instance_map:‖cls.decorator_function_to_instance_map[func] = LFUCache(size)‖1
result = cls.decorator_function_to_instance_map[func].get(args[0])‖if result is None:‖2
if result is None:‖result = func(*args)‖2
result = func(*args)‖cls.decorator_function_to_instance_map[func].put(args[0], result)‖2
cls.decorator_function_to_instance_map[func].put(args[0], result)‖return result‖2
def cache_info() -> LFUCache[T, U]:‖return cls.decorator_function_to_instance_map[func]‖1
def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:‖first_input_list_length: int = len(first_input_list)‖1
first_input_list_length: int = len(first_input_list)‖second_input_list_length: int = len(second_input_list)‖1
second_input_list_length: int = len(second_input_list)‖abs_length: int = (‖1
abs_length: int = (‖first_input_list_length‖1
first_input_list_length‖if first_input_list_length > second_input_list_length‖1
if first_input_list_length > second_input_list_length‖else second_input_list_length‖1
else second_input_list_length‖)‖1
)‖output_result_list: list = []‖1
output_result_list: list = []‖for char_count in range(abs_length):‖1
for char_count in range(abs_length):‖if char_count < first_input_list_length:‖1
if char_count < first_input_list_length:‖output_result_list.append(first_input_list[char_count])‖1
output_result_list.append(first_input_list[char_count])‖if char_count < second_input_list_length:‖1
if char_count < second_input_list_length:‖output_result_list.append(second_input_list[char_count])‖1
"if __name__ == ""__main__"":"‖"print(alternative_list_arrange([""A"", ""B"", ""C""], [1, 2, 3, 4, 5]), end="" "")"‖1
def __str__(self) -> str:‖"return ""{"" + "" , "".join(self.literals) + ""}"""‖1
def __len__(self) -> int:‖return len(self.literals)‖1
def assign(self, model: dict[str, bool | None]) -> None:‖for literal in self.literals:‖1
for literal in self.literals:‖symbol = literal[:2]‖1
symbol = literal[:2]‖if symbol in model:‖1
if symbol in model:‖value = model[symbol]‖1
value = model[symbol]‖else:‖1
else:‖continue‖1
"if value is not None and literal.endswith(""'""):"‖value = not value‖1
value = not value‖self.literals[literal] = value‖1
def evaluate(self, model: dict[str, bool | None]) -> bool | None:‖for literal in self.literals:‖1
for literal in self.literals:‖"symbol = literal.rstrip(""'"") if literal.endswith(""'"") else literal + ""'"""‖1
"symbol = literal.rstrip(""'"") if literal.endswith(""'"") else literal + ""'"""‖if symbol in self.literals:‖1
if symbol in self.literals:‖return True‖1
self.assign(model)‖for value in self.literals.values():‖1
for value in self.literals.values():‖if value in (True, None):‖1
if value in (True, None):‖return value‖1
return value‖return any(self.literals.values())‖1
def __init__(self, clauses: Iterable[Clause]) -> None:‖self.clauses = list(clauses)‖1
def __str__(self) -> str:‖"return ""{"" + "" , "".join(str(clause) for clause in self.clauses) + ""}"""‖1
def generate_clause() -> Clause:‖literals = []‖1
literals = []‖no_of_literals = random.randint(1, 5)‖1
no_of_literals = random.randint(1, 5)‖"base_var = ""A"""‖1
"base_var = ""A"""‖i = 0‖1
i = 0‖while i < no_of_literals:‖1
while i < no_of_literals:‖var_no = random.randint(1, 5)‖1
var_no = random.randint(1, 5)‖var_name = base_var + str(var_no)‖1
var_name = base_var + str(var_no)‖var_complement = random.randint(0, 1)‖1
var_complement = random.randint(0, 1)‖if var_complement == 1:‖1
if var_complement == 1:‖"var_name += ""'"""‖1
"var_name += ""'"""‖if var_name in literals:‖1
if var_name in literals:‖i -= 1‖1
else:‖literals.append(var_name)‖1
literals.append(var_name)‖i += 1‖1
i += 1‖return Clause(literals)‖1
def generate_formula() -> Formula:‖clauses: set[Clause] = set()‖1
clauses: set[Clause] = set()‖no_of_clauses = random.randint(1, 10)‖1
no_of_clauses = random.randint(1, 10)‖while len(clauses) < no_of_clauses:‖1
while len(clauses) < no_of_clauses:‖clauses.add(generate_clause())‖1
clauses.add(generate_clause())‖return Formula(clauses)‖1
def generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:‖clauses = formula.clauses‖1
clauses = formula.clauses‖symbols_set = []‖1
symbols_set = []‖for clause in formula.clauses:‖1
for clause in formula.clauses:‖for literal in clause.literals:‖1
for literal in clause.literals:‖symbol = literal[:2]‖1
symbol = literal[:2]‖if symbol not in symbols_set:‖1
if symbol not in symbols_set:‖symbols_set.append(symbol)‖1
symbols_set.append(symbol)‖return clauses, symbols_set‖1
def find_pure_symbols(‖clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]‖1
clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]‖) -> tuple[list[str], dict[str, bool | None]]:‖1
) -> tuple[list[str], dict[str, bool | None]]:‖pure_symbols = []‖1
pure_symbols = []‖assignment: dict[str, bool | None] = {}‖1
assignment: dict[str, bool | None] = {}‖literals = []‖1
for clause in clauses:‖if clause.evaluate(model):‖1
if clause.evaluate(model):‖continue‖1
continue‖for literal in clause.literals:‖1
for literal in clause.literals:‖literals.append(literal)‖1
for s in symbols:‖"sym = s + ""'"""‖1
"sym = s + ""'"""‖if (s in literals and sym not in literals) or (‖1
if (s in literals and sym not in literals) or (‖s not in literals and sym in literals‖1
s not in literals and sym in literals‖):‖1
):‖pure_symbols.append(s)‖1
pure_symbols.append(s)‖for p in pure_symbols:‖1
for p in pure_symbols:‖assignment[p] = None‖1
assignment[p] = None‖for s in pure_symbols:‖1
for s in pure_symbols:‖"sym = s + ""'"""‖1
"sym = s + ""'"""‖if s in literals:‖1
if s in literals:‖assignment[s] = True‖1
assignment[s] = True‖elif sym in literals:‖1
elif sym in literals:‖assignment[s] = False‖1
assignment[s] = False‖return pure_symbols, assignment‖1
def find_unit_clauses(‖clauses: list[Clause],‖1
clauses: list[Clause],‖model: dict[str, bool | None],‖1
model: dict[str, bool | None],‖) -> tuple[list[str], dict[str, bool | None]]:‖1
) -> tuple[list[str], dict[str, bool | None]]:‖unit_symbols = []‖1
unit_symbols = []‖for clause in clauses:‖1
for clause in clauses:‖if len(clause) == 1:‖1
if len(clause) == 1:‖unit_symbols.append(next(iter(clause.literals.keys())))‖1
unit_symbols.append(next(iter(clause.literals.keys())))‖else:‖1
else:‖f_count, n_count = 0, 0‖1
f_count, n_count = 0, 0‖for literal, value in clause.literals.items():‖1
for literal, value in clause.literals.items():‖if value is False:‖1
if value is False:‖f_count += 1‖1
f_count += 1‖elif value is None:‖1
elif value is None:‖sym = literal‖1
sym = literal‖n_count += 1‖1
n_count += 1‖if f_count == len(clause) - 1 and n_count == 1:‖1
if f_count == len(clause) - 1 and n_count == 1:‖unit_symbols.append(sym)‖1
unit_symbols.append(sym)‖assignment: dict[str, bool | None] = {}‖1
assignment: dict[str, bool | None] = {}‖for i in unit_symbols:‖1
for i in unit_symbols:‖symbol = i[:2]‖1
symbol = i[:2]‖assignment[symbol] = len(i) == 2‖1
assignment[symbol] = len(i) == 2‖unit_symbols = [i[:2] for i in unit_symbols]‖1
def dpll_algorithm(‖clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]‖1
clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]‖) -> tuple[bool | None, dict[str, bool | None] | None]:‖1
) -> tuple[bool | None, dict[str, bool | None] | None]:‖check_clause_all_true = True‖1
check_clause_all_true = True‖for clause in clauses:‖1
for clause in clauses:‖clause_check = clause.evaluate(model)‖1
clause_check = clause.evaluate(model)‖if clause_check is False:‖1
if clause_check is False:‖return False, None‖1
return False, None‖elif clause_check is None:‖1
elif clause_check is None:‖check_clause_all_true = False‖1
check_clause_all_true = False‖continue‖1
if check_clause_all_true:‖return True, model‖1
try:‖pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)‖1
pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)‖except RecursionError:‖1
except RecursionError:‖"print(""raises a RecursionError and is"")"‖1
"print(""raises a RecursionError and is"")"‖return None, {}‖1
return None, {}‖p = None‖1
p = None‖if len(pure_symbols) > 0:‖1
if len(pure_symbols) > 0:‖p, value = pure_symbols[0], assignment[pure_symbols[0]]‖1
if p:‖tmp_model = model‖2
tmp_model = model‖tmp_model[p] = value‖2
tmp_model[p] = value‖tmp_symbols = list(symbols)‖2
tmp_symbols = list(symbols)‖if p in tmp_symbols:‖2
if p in tmp_symbols:‖tmp_symbols.remove(p)‖2
tmp_symbols.remove(p)‖return dpll_algorithm(clauses, tmp_symbols, tmp_model)‖2
unit_symbols, assignment = find_unit_clauses(clauses, model)‖p = None‖1
p = None‖if len(unit_symbols) > 0:‖1
if len(unit_symbols) > 0:‖p, value = unit_symbols[0], assignment[unit_symbols[0]]‖1
p, value = unit_symbols[0], assignment[unit_symbols[0]]‖if p:‖1
return dpll_algorithm(clauses, tmp_symbols, tmp_model)‖p = symbols[0]‖1
p = symbols[0]‖rest = symbols[1:]‖1
rest = symbols[1:]‖tmp1, tmp2 = model, model‖1
tmp1, tmp2 = model, model‖tmp1[p], tmp2[p] = True, False‖1
formula = generate_formula()‖"print(f""The formula {formula} is"", end="" "")"‖1
clauses, symbols = generate_parameters(formula)‖solution, model = dpll_algorithm(clauses, symbols, {})‖1
if solution:‖"print(f""satisfiable with the assignment {model}."")"‖1
"print(f""satisfiable with the assignment {model}."")"‖else:‖1
else:‖"print(""not satisfiable."")"‖1
if not isinstance(citations, list) or not all(‖isinstance(item, int) and item >= 0 for item in citations‖1
isinstance(item, int) and item >= 0 for item in citations‖):‖1
):‖"raise ValueError(""The citations should be a list of non negative integers."")"‖1
citations.sort()‖len_citations = len(citations)‖1
for i in range(len_citations):‖if citations[len_citations - 1 - i] <= i:‖1
if citations[len_citations - 1 - i] <= i:‖return i‖1
DOOMSDAY_LEAP = [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]‖DOOMSDAY_NOT_LEAP = [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]‖1
DOOMSDAY_NOT_LEAP = [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]‖WEEK_DAY_NAMES = {‖1
WEEK_DAY_NAMES = {‖"0: ""Sunday"","‖1
"0: ""Sunday"","‖"1: ""Monday"","‖1
"1: ""Monday"","‖"2: ""Tuesday"","‖1
"2: ""Tuesday"","‖"3: ""Wednesday"","‖1
"3: ""Wednesday"","‖"4: ""Thursday"","‖1
"4: ""Thursday"","‖"5: ""Friday"","‖1
"5: ""Friday"","‖"6: ""Saturday"","‖1
"6: ""Saturday"","‖}‖1
"assert len(str(year)) > 2, ""year should be in YYYY format"""‖"assert 1 <= month <= 12, ""month should be between 1 to 12"""‖1
"assert 1 <= month <= 12, ""month should be between 1 to 12"""‖"assert 1 <= day <= 31, ""day should be between 1 to 31"""‖1
century = year // 100‖century_anchor = (5 * (century % 4) + 2) % 7‖1
century_anchor = (5 * (century % 4) + 2) % 7‖centurian = year % 100‖1
centurian = year % 100‖centurian_m = centurian % 12‖1
centurian_m = centurian % 12‖dooms_day = (‖1
dooms_day = (‖(centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor‖1
(centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor‖) % 7‖1
) % 7‖day_anchor = (‖1
day_anchor = (‖DOOMSDAY_NOT_LEAP[month - 1]‖1
DOOMSDAY_NOT_LEAP[month - 1]‖if (year % 4 != 0) or (centurian == 0 and (year % 400) == 0)‖1
if (year % 4 != 0) or (centurian == 0 and (year % 400) == 0)‖else DOOMSDAY_LEAP[month - 1]‖1
else DOOMSDAY_LEAP[month - 1]‖)‖1
)‖week_day = (dooms_day + day - day_anchor) % 7‖1
week_day = (dooms_day + day - day_anchor) % 7‖return WEEK_DAY_NAMES[week_day]‖1
import secrets‖from random import shuffle‖1
from random import shuffle‖from string import ascii_letters, ascii_lowercase, ascii_uppercase, digits, punctuation‖1
def password_generator(length: int = 8) -> str:‖chars = ascii_letters + digits + punctuation‖1
chars = ascii_letters + digits + punctuation‖"return """".join(secrets.choice(chars) for _ in range(length))"‖1
i -= len(chars_incl)‖quotient = i // 3‖1
quotient = i // 3‖remainder = i % 3‖1
chars = (‖chars_incl‖1
chars_incl‖+ random(ascii_letters, quotient + remainder)‖1
+ random(ascii_letters, quotient + remainder)‖+ random(digits, quotient)‖1
+ random(digits, quotient)‖+ random(punctuation, quotient)‖1
+ random(punctuation, quotient)‖)‖1
)‖list_of_chars = list(chars)‖1
list_of_chars = list(chars)‖shuffle(list_of_chars)‖1
shuffle(list_of_chars)‖"return """".join(list_of_chars)"‖1
def random(chars_incl: str, i: int) -> str:‖"return """".join(secrets.choice(chars_incl) for _ in range(i))"‖1
if len(password) < min_length:‖return False‖1
upper = any(char in ascii_uppercase for char in password)‖lower = any(char in ascii_lowercase for char in password)‖1
lower = any(char in ascii_lowercase for char in password)‖num = any(char in digits for char in password)‖1
num = any(char in digits for char in password)‖spec_char = any(char in punctuation for char in password)‖1
def main():‖"length = int(input(""Please indicate the max length of your password: "").strip())"‖1
"length = int(input(""Please indicate the max length of your password: "").strip())"‖chars_incl = input(‖1
chars_incl = input(‖"""Please indicate the characters that must be in your password: """‖1
"""Please indicate the characters that must be in your password: """‖).strip()‖1
).strip()‖"print(""Password generated:"", password_generator(length))"‖1
"print(""Password generated:"", password_generator(length))"‖print(‖1
print(‖"""Alternative Password generated:"","‖1
"""Alternative Password generated:"","‖alternative_password_generator(chars_incl, length),‖1
alternative_password_generator(chars_incl, length),‖)‖1
)‖"print(""[If you are thinking of using this password, You better save it.]"")"‖1
def __init__(self, multiplier, increment, modulo, seed=int(time())):‖self.multiplier = multiplier‖1
self.multiplier = multiplier‖self.increment = increment‖1
self.increment = increment‖self.modulo = modulo‖1
self.modulo = modulo‖self.seed = seed‖1
def next_number(self):‖self.seed = (self.multiplier * self.seed + self.increment) % self.modulo‖1
self.seed = (self.multiplier * self.seed + self.increment) % self.modulo‖return self.seed‖1
lcg = LinearCongruentialGenerator(1664525, 1013904223, 2 << 31)‖while True:‖1
while True:‖print(lcg.next_number())‖1
def max_subsequence_sum(nums: Sequence[int] | None = None) -> int:‖if nums is None or not nums:‖1
if nums is None or not nums:‖"raise ValueError(""Input sequence should not be empty"")"‖1
ans = nums[0]‖for i in range(1, len(nums)):‖1
for i in range(1, len(nums)):‖num = nums[i]‖1
num = nums[i]‖ans = max(ans, ans + num, num)‖1
"n = int(input(""Enter number of elements : "").strip())"‖"array = list(map(int, input(""\nEnter the numbers : "").strip().split()))[:n]"‖1
"array = list(map(int, input(""\nEnter the numbers : "").strip().split()))[:n]"‖print(max_subsequence_sum(array))‖1
def is_balanced(s: str) -> bool:‖"open_to_closed = {""{"": ""}"", ""["": ""]"", ""("": "")""}"‖1
"open_to_closed = {""{"": ""}"", ""["": ""]"", ""("": "")""}"‖stack = []‖1
stack = []‖for symbol in s:‖1
for symbol in s:‖if symbol in open_to_closed:‖1
if symbol in open_to_closed:‖stack.append(symbol)‖1
stack.append(symbol)‖elif symbol in open_to_closed.values() and (‖1
elif symbol in open_to_closed.values() and (‖not stack or open_to_closed[stack.pop()] != symbol‖1
not stack or open_to_closed[stack.pop()] != symbol‖):‖1
return False‖return not stack‖1
def main():‖"s = input(""Enter sequence of brackets: "")"‖1
"s = input(""Enter sequence of brackets: "")"‖"print(f""'{s}' is {'' if is_balanced(s) else 'not '}balanced."")"‖1
testmod()‖main()‖1
import sys‖from collections import deque‖1
from collections import deque‖from typing import Generic, TypeVar‖1
dq_store: deque[T]‖key_reference: set[T]‖1
key_reference: set[T]‖_MAX_CAPACITY: int = 10‖1
def __init__(self, n: int) -> None:‖self.dq_store = deque()‖1
self.dq_store = deque()‖self.key_reference = set()‖1
self.key_reference = set()‖if not n:‖1
if not n:‖LRUCache._MAX_CAPACITY = sys.maxsize‖1
LRUCache._MAX_CAPACITY = sys.maxsize‖elif n < 0:‖1
elif n < 0:‖"raise ValueError(""n should be an integer greater than 0."")"‖1
"raise ValueError(""n should be an integer greater than 0."")"‖else:‖1
else:‖LRUCache._MAX_CAPACITY = n‖1
def refer(self, x: T) -> None:‖if x not in self.key_reference:‖1
if x not in self.key_reference:‖if len(self.dq_store) == LRUCache._MAX_CAPACITY:‖1
if len(self.dq_store) == LRUCache._MAX_CAPACITY:‖last_element = self.dq_store.pop()‖1
last_element = self.dq_store.pop()‖self.key_reference.remove(last_element)‖1
self.key_reference.remove(last_element)‖else:‖1
else:‖self.dq_store.remove(x)‖1
self.dq_store.appendleft(x)‖self.key_reference.add(x)‖1
def display(self) -> None:‖for k in self.dq_store:‖1
for k in self.dq_store:‖print(k)‖1
def __repr__(self) -> str:‖"return f""LRUCache({self._MAX_CAPACITY}) => {list(self.dq_store)}"""‖1
lru_cache: LRUCache[str | int] = LRUCache(4)‖"lru_cache.refer(""A"")"‖1
"lru_cache.refer(""A"")"‖lru_cache.refer(2)‖1
lru_cache.refer(2)‖lru_cache.refer(3)‖1
lru_cache.refer(3)‖"lru_cache.refer(""A"")"‖1
"lru_cache.refer(""A"")"‖lru_cache.refer(4)‖1
lru_cache.refer(4)‖lru_cache.refer(5)‖1
lru_cache.refer(5)‖lru_cache.display()‖1
print(lru_cache)‖"assert str(lru_cache) == ""LRUCache(4) => [5, 4, 'A', 3]"""‖1
if pressure > 101325:‖"raise ValueError(""Value Higher than Pressure at Sea Level !"")"‖1
"raise ValueError(""Value Higher than Pressure at Sea Level !"")"‖if pressure < 0:‖1
if pressure < 0:‖"raise ValueError(""Atmospheric Pressure can not be negative !"")"‖1
"raise ValueError(""Atmospheric Pressure can not be negative !"")"‖return 44_330 * (1 - (pressure / 101_325) ** (1 / 5.5255))‖1
def temp_input_value(‖min_val: int = 10, max_val: int = 1000, option: bool = True‖1
min_val: int = 10, max_val: int = 1000, option: bool = True‖) -> int:‖1
) -> int:‖assert (‖1
assert (‖isinstance(min_val, int)‖1
isinstance(min_val, int)‖and isinstance(max_val, int)‖1
and isinstance(max_val, int)‖and isinstance(option, bool)‖1
and isinstance(option, bool)‖"), ""Invalid type of value(s) specified to function!"""‖1
if min_val > max_val:‖"raise ValueError(""Invalid value for min_val or max_val (min_value < max_value)"")"‖1
"raise ValueError(""Invalid value for min_val or max_val (min_value < max_value)"")"‖return min_val if option else max_val‖1
def get_avg(number_1: int, number_2: int) -> int:‖return int((number_1 + number_2) / 2)‖1
def guess_the_number(lower: int, higher: int, to_guess: int) -> None:‖assert (‖1
assert (‖isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)‖1
isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)‖"), 'argument values must be type of ""int""'"‖1
if lower > higher:‖"raise ValueError(""argument value for lower and higher must be(lower > higher)"")"‖1
if not lower < to_guess < higher:‖raise ValueError(‖1
raise ValueError(‖"""guess value must be within the range of lower and higher value"""‖1
"""guess value must be within the range of lower and higher value"""‖)‖1
def answer(number: int) -> str:‖if number > to_guess:‖1
if number > to_guess:‖"return ""high"""‖1
"return ""high"""‖elif number < to_guess:‖1
elif number < to_guess:‖"return ""low"""‖1
"return ""low"""‖else:‖1
else:‖"return ""same"""‖1
last_lowest = lower‖last_highest = higher‖1
while True:‖number = get_avg(last_lowest, last_highest)‖1
number = get_avg(last_lowest, last_highest)‖last_numbers.append(number)‖1
"if answer(number) == ""low"":"‖last_lowest = number‖1
last_lowest = number‖"elif answer(number) == ""high"":"‖1
"elif answer(number) == ""high"":"‖last_highest = number‖1
last_highest = number‖else:‖1
"print(f""guess the number : {last_numbers[-1]}"")"‖"print(f""details : {last_numbers!s}"")"‖1
def main() -> None:‖"lower = int(input(""Enter lower value : "").strip())"‖1
"lower = int(input(""Enter lower value : "").strip())"‖"higher = int(input(""Enter high value : "").strip())"‖1
"higher = int(input(""Enter high value : "").strip())"‖"guess = int(input(""Enter value to guess : "").strip())"‖1
"guess = int(input(""Enter value to guess : "").strip())"‖guess_the_number(lower, higher, guess)‖1
class NumberContainer:‖def __init__(self) -> None:‖1
def binary_search_delete(self, array: list | str | range, item: int) -> list[int]:‖if isinstance(array, (range, str)):‖1
if isinstance(array, (range, str)):‖array = list(array)‖2
array = list(array)‖elif not isinstance(array, list):‖2
elif not isinstance(array, list):‖raise TypeError(‖2
raise TypeError(‖"""binary_search_delete() only accepts either a list, range or str"""‖1
"""binary_search_delete() only accepts either a list, range or str"""‖)‖1
low = 0‖high = len(array) - 1‖2
while low <= high:‖mid = (low + high) // 2‖3
mid = (low + high) // 2‖if array[mid] == item:‖1
if array[mid] == item:‖array.pop(mid)‖1
array.pop(mid)‖return array‖1
return array‖elif array[mid] < item:‖1
elif array[mid] < item:‖low = mid + 1‖1
low = mid + 1‖else:‖2
else:‖high = mid - 1‖2
high = mid - 1‖raise ValueError(‖1
raise ValueError(‖"""Either the item is not in the array or the array was unsorted"""‖1
"""Either the item is not in the array or the array was unsorted"""‖)‖1
def binary_search_insert(self, array: list | str | range, index: int) -> list[int]:‖if isinstance(array, (range, str)):‖1
raise TypeError(‖"""binary_search_insert() only accepts either a list, range or str"""‖1
"""binary_search_insert() only accepts either a list, range or str"""‖)‖1
mid = (low + high) // 2‖if array[mid] == index:‖1
array.insert(mid + 1, index)‖return array‖1
return array‖elif array[mid] < index:‖1
elif array[mid] < index:‖low = mid + 1‖1
array.insert(low, index)‖return array‖1
if index in self.indexmap:‖n = self.indexmap[index]‖1
n = self.indexmap[index]‖if len(self.numbermap[n]) == 1:‖1
if len(self.numbermap[n]) == 1:‖del self.numbermap[n]‖1
del self.numbermap[n]‖else:‖1
else:‖self.numbermap[n] = self.binary_search_delete(self.numbermap[n], index)‖1
if number not in self.numbermap:‖self.numbermap[number] = [index]‖1
else:‖self.numbermap[number] = self.binary_search_insert(‖1
self.numbermap[number] = self.binary_search_insert(‖self.numbermap[number], index‖1
self.numbermap[number], index‖)‖1
def floyd(n):‖"result = """""‖1
"result = """""‖for i in range(n):‖1
for i in range(n):‖for _ in range(n - i - 1):‖1
for _ in range(n - i - 1):‖"result += "" """‖1
"result += "" """‖for _ in range(i + 1):‖1
for _ in range(i + 1):‖"result += ""* """‖1
"result += ""* """‖"result += ""\n"""‖2
"result += ""\n"""‖return result‖1
def reverse_floyd(n):‖"result = """""‖1
"result = """""‖for i in range(n, 0, -1):‖1
for i in range(n, 0, -1):‖for _ in range(i, 0, -1):‖1
for _ in range(i, 0, -1):‖"result += ""* """‖1
"result += ""\n"""‖for _ in range(n - i + 1, 0, -1):‖1
for _ in range(n - i + 1, 0, -1):‖"result += "" """‖1
"result += "" """‖return result‖1
def pretty_print(n):‖if n <= 0:‖1
if n <= 0:‖"return ""       ...       ....        nothing printing :("""‖1
"return ""       ...       ....        nothing printing :("""‖upper_half = floyd(n)‖1
upper_half = floyd(n)‖lower_half = reverse_floyd(n)‖1
lower_half = reverse_floyd(n)‖return upper_half + lower_half‖1
def coulombs_law(q1: float, q2: float, radius: float) -> float:‖if radius <= 0:‖1
if radius <= 0:‖"raise ValueError(""The radius is always a positive number"")"‖1
"raise ValueError(""The radius is always a positive number"")"‖return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)‖1
def hubble_parameter(‖hubble_constant: float,‖1
hubble_constant: float,‖radiation_density: float,‖1
radiation_density: float,‖matter_density: float,‖1
matter_density: float,‖dark_energy: float,‖1
dark_energy: float,‖redshift: float,‖1
redshift: float,‖) -> float:‖1
) -> float:‖parameters = [redshift, radiation_density, matter_density, dark_energy]‖1
parameters = [redshift, radiation_density, matter_density, dark_energy]‖if any(p < 0 for p in parameters):‖1
if any(p < 0 for p in parameters):‖"raise ValueError(""All input parameters must be positive"")"‖1
if any(p > 1 for p in parameters[1:4]):‖"raise ValueError(""Relative densities cannot be greater than one"")"‖1
"raise ValueError(""Relative densities cannot be greater than one"")"‖else:‖1
else:‖curvature = 1 - (matter_density + radiation_density + dark_energy)‖1
e_2 = (‖radiation_density * (redshift + 1) ** 4‖1
radiation_density * (redshift + 1) ** 4‖+ matter_density * (redshift + 1) ** 3‖1
+ matter_density * (redshift + 1) ** 3‖+ curvature * (redshift + 1) ** 2‖1
+ curvature * (redshift + 1) ** 2‖+ dark_energy‖1
+ dark_energy‖)‖1
hubble = hubble_constant * e_2 ** (1 / 2)‖return hubble‖1
print(‖hubble_parameter(‖1
hubble_parameter(‖hubble_constant=68.3,‖1
hubble_constant=68.3,‖radiation_density=1e-4,‖1
radiation_density=1e-4,‖matter_density=matter_density,‖1
matter_density=matter_density,‖dark_energy=1 - matter_density,‖1
dark_energy=1 - matter_density,‖redshift=0,‖1
redshift=0,‖)‖1
def centripetal(mass: float, velocity: float, radius: float) -> float:‖if mass < 0:‖1
if mass < 0:‖"raise ValueError(""The mass of the body cannot be negative"")"‖1
"raise ValueError(""The mass of the body cannot be negative"")"‖if radius <= 0:‖1
if radius <= 0:‖"raise ValueError(""The radius is always a positive non zero integer"")"‖1
"raise ValueError(""The radius is always a positive non zero integer"")"‖return (mass * (velocity) ** 2) / radius‖1
def doppler_effect(‖org_freq: float, wave_vel: float, obs_vel: float, src_vel: float‖1
org_freq: float, wave_vel: float, obs_vel: float, src_vel: float‖) -> float:‖1
if wave_vel == src_vel:‖raise ZeroDivisionError(‖1
raise ZeroDivisionError(‖"""Division by zero implies vs=v and observer in front of the source"""‖1
"""Division by zero implies vs=v and observer in front of the source"""‖)‖1
)‖doppler_freq = (org_freq * (wave_vel + obs_vel)) / (wave_vel - src_vel)‖1
doppler_freq = (org_freq * (wave_vel + obs_vel)) / (wave_vel - src_vel)‖if doppler_freq <= 0:‖1
if doppler_freq <= 0:‖raise ValueError(‖1
raise ValueError(‖"""Non-positive frequency implies vs>v or v0>v (in the opposite direction)"""‖1
"""Non-positive frequency implies vs>v or v0>v (in the opposite direction)"""‖)‖1
)‖return doppler_freq‖1
def move_tower(height, from_pole, to_pole, with_pole):‖if height >= 1:‖1
if height >= 1:‖move_tower(height - 1, from_pole, with_pole, to_pole)‖1
move_tower(height - 1, from_pole, with_pole, to_pole)‖move_disk(from_pole, to_pole)‖1
move_disk(from_pole, to_pole)‖move_tower(height - 1, with_pole, to_pole, from_pole)‖1
def move_disk(fp, tp):‖"print(""moving disk from"", fp, ""to"", tp)"‖1
def main():‖"height = int(input(""Height of hanoi: "").strip())"‖1
"height = int(input(""Height of hanoi: "").strip())"‖"move_tower(height, ""A"", ""B"", ""C"")"‖1
def archimedes_principle(‖fluid_density: float, volume: float, gravity: float = g‖1
fluid_density: float, volume: float, gravity: float = g‖) -> float:‖1
if fluid_density <= 0:‖"raise ValueError(""Impossible fluid density"")"‖1
"raise ValueError(""Impossible fluid density"")"‖if volume <= 0:‖1
if volume <= 0:‖"raise ValueError(""Impossible object volume"")"‖1
"raise ValueError(""Impossible object volume"")"‖if gravity < 0:‖1
if gravity < 0:‖"raise ValueError(""Impossible gravity"")"‖1
def capture_radii(‖target_body_radius: float, target_body_mass: float, projectile_velocity: float‖1
target_body_radius: float, target_body_mass: float, projectile_velocity: float‖) -> float:‖1
if target_body_mass < 0:‖"raise ValueError(""Mass cannot be less than 0"")"‖1
"raise ValueError(""Mass cannot be less than 0"")"‖if target_body_radius < 0:‖1
if target_body_radius < 0:‖"raise ValueError(""Radius cannot be less than 0"")"‖1
"raise ValueError(""Radius cannot be less than 0"")"‖if projectile_velocity > c:‖1
if projectile_velocity > c:‖"raise ValueError(""Cannot go beyond speed of light"")"‖1
escape_velocity_squared = (2 * G * target_body_mass) / target_body_radius‖capture_radius = target_body_radius * sqrt(‖1
capture_radius = target_body_radius * sqrt(‖1 + escape_velocity_squared / pow(projectile_velocity, 2)‖1
1 + escape_velocity_squared / pow(projectile_velocity, 2)‖)‖1
)‖return round(capture_radius, 0)‖1
if capture_radius < 0:‖"raise ValueError(""Cannot have a capture radius less than 0"")"‖1
"raise ValueError(""Cannot have a capture radius less than 0"")"‖sigma = pi * pow(capture_radius, 2)‖1
sigma = pi * pow(capture_radius, 2)‖return round(sigma, 0)‖1
def apply_table(inp, table):‖"res = """""‖1
"res = """""‖for i in table:‖1
for i in table:‖res += inp[i - 1]‖1
res += inp[i - 1]‖return res‖1
def left_shift(data):‖return data[1:] + data[0]‖1
def xor(a, b):‖"res = """""‖1
"res = """""‖for i in range(len(a)):‖1
for i in range(len(a)):‖if a[i] == b[i]:‖1
if a[i] == b[i]:‖"res += ""0"""‖1
"res += ""0"""‖else:‖1
else:‖"res += ""1"""‖1
"res += ""1"""‖return res‖1
def apply_sbox(s, data):‖"row = int(""0b"" + data[0] + data[-1], 2)"‖1
"row = int(""0b"" + data[0] + data[-1], 2)"‖"col = int(""0b"" + data[1:3], 2)"‖1
"col = int(""0b"" + data[1:3], 2)"‖return bin(s[row][col])[2:]‖1
def function(expansion, s0, s1, key, message):‖left = message[:4]‖1
left = message[:4]‖right = message[4:]‖1
right = message[4:]‖temp = apply_table(right, expansion)‖1
temp = apply_table(right, expansion)‖temp = xor(temp, key)‖1
temp = xor(temp, key)‖left_bin_str = apply_sbox(s0, temp[:4])‖1
left_bin_str = apply_sbox(s0, temp[:4])‖right_bin_str = apply_sbox(s1, temp[4:])‖1
right_bin_str = apply_sbox(s1, temp[4:])‖"left_bin_str = ""0"" * (2 - len(left_bin_str)) + left_bin_str"‖1
"left_bin_str = ""0"" * (2 - len(left_bin_str)) + left_bin_str"‖"right_bin_str = ""0"" * (2 - len(right_bin_str)) + right_bin_str"‖1
"right_bin_str = ""0"" * (2 - len(right_bin_str)) + right_bin_str"‖temp = apply_table(left_bin_str + right_bin_str, p4_table)‖1
temp = apply_table(left_bin_str + right_bin_str, p4_table)‖temp = xor(left, temp)‖1
temp = xor(left, temp)‖return temp + right‖1
"if __name__ == ""__main__"":"‖"key = input(""Enter 10 bit key: "")"‖1
"key = input(""Enter 10 bit key: "")"‖"message = input(""Enter 8 bit message: "")"‖1
p8_table = [6, 3, 7, 4, 8, 5, 10, 9]‖p10_table = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]‖1
p10_table = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]‖p4_table = [2, 4, 3, 1]‖1
p4_table = [2, 4, 3, 1]‖IP = [2, 6, 3, 1, 4, 8, 5, 7]‖1
IP = [2, 6, 3, 1, 4, 8, 5, 7]‖IP_inv = [4, 1, 3, 5, 7, 2, 8, 6]‖1
IP_inv = [4, 1, 3, 5, 7, 2, 8, 6]‖expansion = [4, 1, 2, 3, 2, 3, 4, 1]‖1
expansion = [4, 1, 2, 3, 2, 3, 4, 1]‖s0 = [[1, 0, 3, 2], [3, 2, 1, 0], [0, 2, 1, 3], [3, 1, 3, 2]]‖1
s0 = [[1, 0, 3, 2], [3, 2, 1, 0], [0, 2, 1, 3], [3, 1, 3, 2]]‖s1 = [[0, 1, 2, 3], [2, 0, 1, 3], [3, 0, 1, 0], [2, 1, 0, 3]]‖1
temp = apply_table(key, p10_table)‖left = temp[:5]‖1
left = temp[:5]‖right = temp[5:]‖1
right = temp[5:]‖left = left_shift(left)‖1
left = left_shift(left)‖right = left_shift(right)‖3
right = left_shift(right)‖key1 = apply_table(left + right, p8_table)‖1
key1 = apply_table(left + right, p8_table)‖left = left_shift(left)‖1
right = left_shift(right)‖left = left_shift(left)‖1
right = left_shift(right)‖key2 = apply_table(left + right, p8_table)‖1
temp = apply_table(message, IP)‖temp = function(expansion, s0, s1, key1, temp)‖1
temp = function(expansion, s0, s1, key1, temp)‖temp = temp[4:] + temp[:4]‖1
temp = temp[4:] + temp[:4]‖temp = function(expansion, s0, s1, key2, temp)‖1
temp = function(expansion, s0, s1, key2, temp)‖CT = apply_table(temp, IP_inv)‖1
CT = apply_table(temp, IP_inv)‖"print(""Cipher text is:"", CT)"‖1
temp = apply_table(CT, IP)‖temp = function(expansion, s0, s1, key2, temp)‖1
temp = function(expansion, s0, s1, key2, temp)‖temp = temp[4:] + temp[:4]‖1
temp = temp[4:] + temp[:4]‖temp = function(expansion, s0, s1, key1, temp)‖1
temp = function(expansion, s0, s1, key1, temp)‖PT = apply_table(temp, IP_inv)‖1
PT = apply_table(temp, IP_inv)‖"print(""Plain text after decypting is:"", PT)"‖1
WIDTH = 10‖HEIGHT = 10‖1
def __init__(self, words: list[str], width: int, height: int) -> None:‖self.words = words‖1
self.words = words‖self.width = width‖1
def insert_north(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
if word_length > row + 1:‖continue‖3
letters_above = [self.board[row - i][col] for i in range(word_length)]‖if all(letter is None for letter in letters_above):‖1
for i in range(word_length):‖self.board[row - i][col] = word[i]‖1
self.board[row - i][col] = word[i]‖return‖1
def insert_northeast(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
if word_length + col > self.width:‖continue‖3
letters_diagonal_left = [‖self.board[row - i][col + i] for i in range(word_length)‖1
self.board[row - i][col + i] for i in range(word_length)‖]‖1
]‖if all(letter is None for letter in letters_diagonal_left):‖4
for i in range(word_length):‖self.board[row - i][col + i] = word[i]‖1
self.board[row - i][col + i] = word[i]‖return‖1
def insert_east(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
letters_left = [self.board[row][col + i] for i in range(word_length)]‖if all(letter is None for letter in letters_left):‖1
for i in range(word_length):‖self.board[row][col + i] = word[i]‖1
self.board[row][col + i] = word[i]‖return‖1
def insert_southeast(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
if word_length + row > self.height:‖continue‖3
letters_diagonal_left = [‖self.board[row + i][col + i] for i in range(word_length)‖1
self.board[row + i][col + i] for i in range(word_length)‖]‖1
for i in range(word_length):‖self.board[row + i][col + i] = word[i]‖1
self.board[row + i][col + i] = word[i]‖return‖1
def insert_south(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
letters_below = [self.board[row + i][col] for i in range(word_length)]‖if all(letter is None for letter in letters_below):‖1
for i in range(word_length):‖self.board[row + i][col] = word[i]‖1
self.board[row + i][col] = word[i]‖return‖1
def insert_southwest(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
if word_length > col + 1:‖continue‖3
letters_diagonal_left = [‖self.board[row + i][col - i] for i in range(word_length)‖1
self.board[row + i][col - i] for i in range(word_length)‖]‖1
for i in range(word_length):‖self.board[row + i][col - i] = word[i]‖1
self.board[row + i][col - i] = word[i]‖return‖1
def insert_west(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
letters_left = [self.board[row][col - i] for i in range(word_length)]‖if all(letter is None for letter in letters_left):‖1
for i in range(word_length):‖self.board[row][col - i] = word[i]‖1
self.board[row][col - i] = word[i]‖return‖1
def insert_northwest(self, word: str, rows: list[int], cols: list[int]) -> None:‖word_length = len(word)‖1
letters_diagonal_left = [‖self.board[row - i][col - i] for i in range(word_length)‖1
self.board[row - i][col - i] for i in range(word_length)‖]‖1
for i in range(word_length):‖self.board[row - i][col - i] = word[i]‖1
self.board[row - i][col - i] = word[i]‖return‖1
def generate_board(self) -> None:‖directions = (‖1
directions = (‖self.insert_north,‖1
self.insert_north,‖self.insert_northeast,‖1
self.insert_northeast,‖self.insert_east,‖1
self.insert_east,‖self.insert_southeast,‖1
self.insert_southeast,‖self.insert_south,‖1
self.insert_south,‖self.insert_southwest,‖1
self.insert_southwest,‖self.insert_west,‖1
self.insert_west,‖self.insert_northwest,‖1
self.insert_northwest,‖)‖1
)‖for word in self.words:‖1
rows, cols = list(range(self.height)), list(range(self.width))‖shuffle(rows)‖1
shuffle(rows)‖shuffle(cols)‖1
def visualise_word_search(‖board: list[list[str | None]] | None = None, *, add_fake_chars: bool = True‖1
board: list[list[str | None]] | None = None, *, add_fake_chars: bool = True‖) -> None:‖1
) -> None:‖if board is None:‖1
if board is None:‖word_search = WordSearch(WORDS, WIDTH, HEIGHT)‖1
word_search = WordSearch(WORDS, WIDTH, HEIGHT)‖word_search.generate_board()‖1
word_search.generate_board()‖board = word_search.board‖1
"result = """""‖for row in range(len(board)):‖1
for row in range(len(board)):‖for col in range(len(board[0])):‖1
for col in range(len(board[0])):‖"character = ""#"""‖1
"character = ""#"""‖if (letter := board[row][col]) is not None:‖1
if (letter := board[row][col]) is not None:‖character = letter‖1
elif add_fake_chars:‖character = chr(randint(97, 122))‖1
character = chr(randint(97, 122))‖"result += f""{character} """‖1
"result += f""{character} """‖"result += ""\n"""‖1
"result += ""\n"""‖"print(result, end="""")"‖1
if (force, area, distance).count(0) != 1:‖"raise ValueError(""One and only one argument must be 0"")"‖1
"raise ValueError(""One and only one argument must be 0"")"‖if force < 0:‖2
if force < 0:‖"raise ValueError(""Magnitude of force can not be negative"")"‖1
"raise ValueError(""Magnitude of force can not be negative"")"‖if distance < 0:‖1
if distance < 0:‖"raise ValueError(""Distance can not be negative"")"‖2
"raise ValueError(""Distance can not be negative"")"‖if area < 0:‖1
if area < 0:‖"raise ValueError(""Area can not be negative"")"‖1
"raise ValueError(""Area can not be negative"")"‖if force == 0:‖1
if force == 0:‖force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (‖1
force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (‖240 * (distance) ** 4‖1
240 * (distance) ** 4‖)‖1
)‖"return {""force"": force}"‖1
"return {""force"": force}"‖elif area == 0:‖1
elif area == 0:‖area = (240 * force * (distance) ** 4) / (‖1
area = (240 * force * (distance) ** 4) / (‖REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2‖1
REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2‖)‖1
)‖"return {""area"": area}"‖1
"return {""area"": area}"‖elif distance == 0:‖1
elif distance == 0:‖distance = (‖1
distance = (‖(REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)‖1
(REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)‖) ** (1 / 4)‖1
) ** (1 / 4)‖"return {""distance"": distance}"‖1
"return {""distance"": distance}"‖"raise ValueError(""One and only one argument must be 0"")"‖2
def get_data(source_data: list[list[float]]) -> list[list[float]]:‖data_lists: list[list[float]] = []‖1
data_lists: list[list[float]] = []‖for data in source_data:‖1
for data in source_data:‖for i, el in enumerate(data):‖1
for i, el in enumerate(data):‖if len(data_lists) < i + 1:‖1
if len(data_lists) < i + 1:‖data_lists.append([])‖1
data_lists.append([])‖data_lists[i].append(float(el))‖1
data_lists[i].append(float(el))‖return data_lists‖1
def calculate_each_score(‖data_lists: list[list[float]], weights: list[int]‖1
data_lists: list[list[float]], weights: list[int]‖) -> list[list[float]]:‖1
) -> list[list[float]]:‖score_lists: list[list[float]] = []‖1
score_lists: list[list[float]] = []‖for dlist, weight in zip(data_lists, weights):‖1
for dlist, weight in zip(data_lists, weights):‖mind = min(dlist)‖1
mind = min(dlist)‖maxd = max(dlist)‖1
if weight == 0:‖for item in dlist:‖1
for item in dlist:‖try:‖2
try:‖score.append(1 - ((item - mind) / (maxd - mind)))‖1
score.append(1 - ((item - mind) / (maxd - mind)))‖except ZeroDivisionError:‖1
except ZeroDivisionError:‖score.append(1)‖1
elif weight == 1:‖for item in dlist:‖1
try:‖score.append((item - mind) / (maxd - mind))‖1
score.append((item - mind) / (maxd - mind))‖except ZeroDivisionError:‖1
except ZeroDivisionError:‖score.append(0)‖1
else:‖"msg = f""Invalid weight of {weight:f} provided"""‖1
"msg = f""Invalid weight of {weight:f} provided"""‖raise ValueError(msg)‖1
for slist in score_lists:‖for j, ele in enumerate(slist):‖1
for j, ele in enumerate(slist):‖final_scores[j] = final_scores[j] + ele‖1
def procentual_proximity(‖source_data: list[list[float]], weights: list[int]‖1
source_data: list[list[float]], weights: list[int]‖) -> list[list[float]]:‖1
data_lists = get_data(source_data)‖score_lists = calculate_each_score(data_lists, weights)‖1
score_lists = calculate_each_score(data_lists, weights)‖final_scores = generate_final_scores(score_lists)‖1
for i, ele in enumerate(final_scores):‖source_data[i].append(ele)‖1
self.val = val‖self.next: DoubleLinkedListNode[T, U] | None = None‖1
return (‖"f""Node: key: {self.key}, val: {self.val}, """‖1
"f""Node: key: {self.key}, val: {self.val}, """‖"f""has next: {bool(self.next)}, has prev: {bool(self.prev)}"""‖1
"f""has next: {bool(self.next)}, has prev: {bool(self.prev)}"""‖)‖1
"f""CacheInfo(hits={self.hits}, misses={self.miss}, """‖"f""capacity={self.capacity}, current size={self.num_keys})"""‖1
"f""capacity={self.capacity}, current size={self.num_keys})"""‖)‖1
assert first_node.key is not None‖assert (‖1
assert (‖self.list.remove(first_node) is not None‖1
self.list.remove(first_node) is not None‖)‖1
def decorator(‖cls, size: int = 128‖1
cls, size: int = 128‖) -> Callable[[Callable[[T], U]], Callable[..., U]]:‖1
if func not in cls.decorator_function_to_instance_map:‖cls.decorator_function_to_instance_map[func] = LRUCache(size)‖1
def cache_info() -> LRUCache[T, U]:‖return cls.decorator_function_to_instance_map[func]‖1
import numpy as np‖from sympy import symbols‖1
def beta(velocity: float) -> float:‖if velocity > c:‖1
if velocity > c:‖"raise ValueError(""Speed must not exceed light speed 299,792,458 [m/s]!"")"‖1
"raise ValueError(""Speed must not exceed light speed 299,792,458 [m/s]!"")"‖elif velocity < 1:‖1
def gamma(velocity: float) -> float:‖return 1 / sqrt(1 - beta(velocity) ** 2)‖1
def transformation_matrix(velocity: float) -> np.ndarray:‖return np.array(‖1
return np.array(‖[‖1
[‖[gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],‖1
[gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],‖[-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],‖1
[-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],‖[0, 0, 1, 0],‖1
[0, 0, 1, 0],‖[0, 0, 0, 1],‖1
[0, 0, 0, 1],‖]‖1
if event is None:‖event = np.array([ct, x, y, z])‖1
event = np.array([ct, x, y, z])‖else:‖1
else:‖event[0] *= c‖1
four_vector = transform(29979245)‖"print(""Example of four vector: "")"‖1
"print(""Example of four vector: "")"‖"print(f""ct' = {four_vector[0]}"")"‖1
"print(f""ct' = {four_vector[0]}"")"‖"print(f""x' = {four_vector[1]}"")"‖1
"print(f""x' = {four_vector[1]}"")"‖"print(f""y' = {four_vector[2]}"")"‖1
"print(f""y' = {four_vector[2]}"")"‖"print(f""z' = {four_vector[3]}"")"‖1
sub_dict = {ct: c, x: 1, y: 1, z: 1}‖numerical_vector = [four_vector[i].subs(sub_dict) for i in range(4)]‖1
from math import radians as angle_to_radians‖from math import sin‖1
if not isinstance(init_velocity, (int, float)):‖"raise TypeError(""Invalid velocity. Should be a positive number."")"‖1
if not isinstance(angle, (int, float)):‖"raise TypeError(""Invalid angle. Range is 1-90 degrees."")"‖1
if angle > 90 or angle < 1:‖"raise ValueError(""Invalid angle. Range is 1-90 degrees."")"‖1
if init_velocity < 0:‖"raise ValueError(""Invalid velocity. Should be a positive number."")"‖1
check_args(init_velocity, angle)‖radians = angle_to_radians(2 * angle)‖1
radians = angle_to_radians(2 * angle)‖return round(init_velocity**2 * sin(radians) / g, 2)‖1
check_args(init_velocity, angle)‖radians = angle_to_radians(angle)‖2
radians = angle_to_radians(angle)‖return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)‖1
radians = angle_to_radians(angle)‖return round(2 * init_velocity * sin(radians) / g, 2)‖1
v0, angle = 25, 20‖assert horizontal_distance(v0, angle) == 40.97‖1
assert horizontal_distance(v0, angle) == 40.97‖assert max_height(v0, angle) == 3.73‖1
assert max_height(v0, angle) == 3.73‖assert total_time(v0, angle) == 1.74‖1
print()‖"print(""Results: "")"‖1
"print(""Results: "")"‖"print(f""Horizontal Distance: {horizontal_distance(init_vel, angle)!s} [m]"")"‖1
"print(f""Horizontal Distance: {horizontal_distance(init_vel, angle)!s} [m]"")"‖"print(f""Maximum Height: {max_height(init_vel, angle)!s} [m]"")"‖1
"print(f""Maximum Height: {max_height(init_vel, angle)!s} [m]"")"‖"print(f""Total Time: {total_time(init_vel, angle)!s} [s]"")"‖1
from numpy import array, cos, cross, float64, radians, sin‖from numpy.typing import NDArray‖1
def polar_force(‖magnitude: float, angle: float, radian_mode: bool = False‖1
magnitude: float, angle: float, radian_mode: bool = False‖) -> list[float]:‖1
) -> list[float]:‖if radian_mode:‖1
if radian_mode:‖return [magnitude * cos(angle), magnitude * sin(angle)]‖1
return [magnitude * cos(angle), magnitude * sin(angle)]‖return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]‖1
def in_static_equilibrium(‖forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1‖1
forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1‖) -> bool:‖1
moments: NDArray[float64] = cross(location, forces)‖sum_moments: float = sum(moments)‖1
sum_moments: float = sum(moments)‖return bool(abs(sum_moments) < eps)‖1
forces = array(‖[‖2
[‖polar_force(718.4, 180 - 30),‖1
polar_force(718.4, 180 - 30),‖polar_force(879.54, 45),‖1
polar_force(879.54, 45),‖polar_force(100, -90),‖1
polar_force(100, -90),‖]‖1
[‖polar_force(30 * 9.81, 15),‖1
polar_force(30 * 9.81, 15),‖polar_force(215, 180 - 45),‖1
polar_force(215, 180 - 45),‖polar_force(264, 90 - 30),‖1
polar_force(264, 90 - 30),‖]‖1
def reynolds_number(‖density: float, velocity: float, diameter: float, viscosity: float‖1
density: float, velocity: float, diameter: float, viscosity: float‖) -> float:‖1
if density <= 0 or diameter <= 0 or viscosity <= 0:‖raise ValueError(‖1
raise ValueError(‖"""please ensure that density, diameter and viscosity are positive"""‖1
"""please ensure that density, diameter and viscosity are positive"""‖)‖1
)‖return (density * abs(velocity) * diameter) / viscosity‖1
def pressure_of_gas_system(moles: float, kelvin: float, volume: float) -> float:‖if moles < 0 or kelvin < 0 or volume < 0:‖1
if moles < 0 or kelvin < 0 or volume < 0:‖"raise ValueError(""Invalid inputs. Enter positive value."")"‖1
"raise ValueError(""Invalid inputs. Enter positive value."")"‖return moles * kelvin * UNIVERSAL_GAS_CONSTANT / volume‖1
def volume_of_gas_system(moles: float, kelvin: float, pressure: float) -> float:‖if moles < 0 or kelvin < 0 or pressure < 0:‖1
if moles < 0 or kelvin < 0 or pressure < 0:‖"raise ValueError(""Invalid inputs. Enter positive value."")"‖1
"raise ValueError(""Invalid inputs. Enter positive value."")"‖return moles * kelvin * UNIVERSAL_GAS_CONSTANT / pressure‖1
def temperature_of_gas_system(moles: float, volume: float, pressure: float) -> float:‖if moles < 0 or volume < 0 or pressure < 0:‖1
if moles < 0 or volume < 0 or pressure < 0:‖"raise ValueError(""Invalid inputs. Enter positive value."")"‖1
def moles_of_gas_system(kelvin: float, volume: float, pressure: float) -> float:‖if kelvin < 0 or volume < 0 or pressure < 0:‖1
if kelvin < 0 or volume < 0 or pressure < 0:‖"raise ValueError(""Invalid inputs. Enter positive value."")"‖1
if distance_of_object == 0 or distance_of_image == 0:‖raise ValueError(‖1
raise ValueError(‖"""Invalid inputs. Enter non zero values with respect to the sign convention."""‖6
"""Invalid inputs. Enter non zero values with respect to the sign convention."""‖)‖6
)‖focal_length = 1 / ((1 / distance_of_object) + (1 / distance_of_image))‖1
focal_length = 1 / ((1 / distance_of_object) + (1 / distance_of_image))‖return focal_length‖1
if distance_of_image == 0 or focal_length == 0:‖raise ValueError(‖1
)‖object_distance = 1 / ((1 / focal_length) - (1 / distance_of_image))‖1
object_distance = 1 / ((1 / focal_length) - (1 / distance_of_image))‖return object_distance‖1
if distance_of_object == 0 or focal_length == 0:‖raise ValueError(‖1
)‖image_distance = 1 / ((1 / focal_length) - (1 / distance_of_object))‖1
image_distance = 1 / ((1 / focal_length) - (1 / distance_of_object))‖return image_distance‖1
def validate(*values: float) -> bool:‖result = len(values) > 0 and all(value > 0.0 for value in values)‖1
result = len(values) > 0 and all(value > 0.0 for value in values)‖return result‖1
def effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:‖return (‖1
return (‖round(sqrt(molar_mass_2 / molar_mass_1), 6)‖1
round(sqrt(molar_mass_2 / molar_mass_1), 6)‖if validate(molar_mass_1, molar_mass_2)‖1
if validate(molar_mass_1, molar_mass_2)‖"else ValueError(""Input Error: Molar mass values must greater than 0."")"‖1
"else ValueError(""Input Error: Molar mass values must greater than 0."")"‖)‖1
def first_effusion_rate(‖effusion_rate: float, molar_mass_1: float, molar_mass_2: float‖1
effusion_rate: float, molar_mass_1: float, molar_mass_2: float‖) -> float | ValueError:‖2
) -> float | ValueError:‖return (‖4
return (‖round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)‖1
round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)‖if validate(effusion_rate, molar_mass_1, molar_mass_2)‖1
if validate(effusion_rate, molar_mass_1, molar_mass_2)‖else ValueError(‖2
else ValueError(‖"""Input Error: Molar mass and effusion rate values must greater than 0."""‖4
"""Input Error: Molar mass and effusion rate values must greater than 0."""‖)‖4
def second_effusion_rate(‖effusion_rate: float, molar_mass_1: float, molar_mass_2: float‖1
return (‖round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)‖1
round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)‖if validate(effusion_rate, molar_mass_1, molar_mass_2)‖1
def first_molar_mass(‖molar_mass: float, effusion_rate_1: float, effusion_rate_2: float‖1
molar_mass: float, effusion_rate_1: float, effusion_rate_2: float‖) -> float | ValueError:‖2
return (‖round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)‖1
round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)‖if validate(molar_mass, effusion_rate_1, effusion_rate_2)‖1
if validate(molar_mass, effusion_rate_1, effusion_rate_2)‖else ValueError(‖2
def second_molar_mass(‖molar_mass: float, effusion_rate_1: float, effusion_rate_2: float‖1
return (‖round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)‖1
round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)‖if validate(molar_mass, effusion_rate_1, effusion_rate_2)‖1
"Particle = namedtuple(""Particle"", ""x y z mass"")"‖"Coord3D = namedtuple(""Coord3D"", ""x y z"")"‖1
def center_of_mass(particles: list[Particle]) -> Coord3D:‖if not particles:‖1
if not particles:‖"raise ValueError(""No particles provided"")"‖1
if any(particle.mass <= 0 for particle in particles):‖"raise ValueError(""Mass of all particles must be greater than 0"")"‖1
center_of_mass_x = round(‖sum(particle.x * particle.mass for particle in particles) / total_mass, 2‖1
sum(particle.x * particle.mass for particle in particles) / total_mass, 2‖)‖1
)‖center_of_mass_y = round(‖1
center_of_mass_y = round(‖sum(particle.y * particle.mass for particle in particles) / total_mass, 2‖1
sum(particle.y * particle.mass for particle in particles) / total_mass, 2‖)‖1
)‖center_of_mass_z = round(‖1
center_of_mass_z = round(‖sum(particle.z * particle.mass for particle in particles) / total_mass, 2‖1
sum(particle.z * particle.mass for particle in particles) / total_mass, 2‖)‖1
)‖return Coord3D(center_of_mass_x, center_of_mass_y, center_of_mass_z)‖1
def focal_length_of_lens(‖object_distance_from_lens: float, image_distance_from_lens: float‖1
object_distance_from_lens: float, image_distance_from_lens: float‖) -> float:‖1
if object_distance_from_lens == 0 or image_distance_from_lens == 0:‖raise ValueError(‖1
)‖focal_length = 1 / (‖1
focal_length = 1 / (‖(1 / image_distance_from_lens) - (1 / object_distance_from_lens)‖1
(1 / image_distance_from_lens) - (1 / object_distance_from_lens)‖)‖1
)‖return focal_length‖1
def object_distance(‖focal_length_of_lens: float, image_distance_from_lens: float‖1
focal_length_of_lens: float, image_distance_from_lens: float‖) -> float:‖1
if image_distance_from_lens == 0 or focal_length_of_lens == 0:‖raise ValueError(‖1
object_distance = 1 / ((1 / image_distance_from_lens) - (1 / focal_length_of_lens))‖return object_distance‖1
def image_distance(‖focal_length_of_lens: float, object_distance_from_lens: float‖1
focal_length_of_lens: float, object_distance_from_lens: float‖) -> float:‖1
) -> float:‖if object_distance_from_lens == 0 or focal_length_of_lens == 0:‖1
if object_distance_from_lens == 0 or focal_length_of_lens == 0:‖raise ValueError(‖1
)‖image_distance = 1 / ((1 / object_distance_from_lens) + (1 / focal_length_of_lens))‖1
image_distance = 1 / ((1 / object_distance_from_lens) + (1 / focal_length_of_lens))‖return image_distance‖1
def gravitational_law(‖force: float, mass_1: float, mass_2: float, distance: float‖1
force: float, mass_1: float, mass_2: float, distance: float‖) -> dict[str, float]:‖1
if (force, mass_1, mass_2, distance).count(0) != 1:‖"raise ValueError(""One and only one argument must be 0"")"‖1
if force < 0:‖"raise ValueError(""Gravitational force can not be negative"")"‖1
"raise ValueError(""Gravitational force can not be negative"")"‖if distance < 0:‖1
"raise ValueError(""Distance can not be negative"")"‖if mass_1 < 0 or mass_2 < 0:‖1
if mass_1 < 0 or mass_2 < 0:‖"raise ValueError(""Mass can not be negative"")"‖1
"raise ValueError(""Mass can not be negative"")"‖if force == 0:‖1
if force == 0:‖force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)‖1
force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)‖"return {""force"": force}"‖1
"return {""force"": force}"‖elif mass_1 == 0:‖1
elif mass_1 == 0:‖mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)‖1
mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)‖"return {""mass_1"": mass_1}"‖1
"return {""mass_1"": mass_1}"‖elif mass_2 == 0:‖1
elif mass_2 == 0:‖mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)‖1
mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)‖"return {""mass_2"": mass_2}"‖1
"return {""mass_2"": mass_2}"‖elif distance == 0:‖1
elif distance == 0:‖distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5‖1
distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5‖"return {""distance"": distance}"‖1
def kinetic_energy(mass: float, velocity: float) -> float:‖if mass < 0:‖1
if mass < 0:‖"raise ValueError(""The mass of a body cannot be negative"")"‖1
"raise ValueError(""The mass of a body cannot be negative"")"‖return 0.5 * mass * abs(velocity) * abs(velocity)‖1
def rainfall_intensity(‖coefficient_k: float,‖1
coefficient_k: float,‖coefficient_a: float,‖1
coefficient_a: float,‖coefficient_b: float,‖1
coefficient_b: float,‖coefficient_c: float,‖1
coefficient_c: float,‖return_period: float,‖1
return_period: float,‖duration: float,‖1
duration: float,‖) -> float:‖1
) -> float:‖if (‖1
if (‖coefficient_k <= 0‖1
coefficient_k <= 0‖or coefficient_a <= 0‖1
or coefficient_a <= 0‖or coefficient_b <= 0‖1
or coefficient_b <= 0‖or coefficient_c <= 0‖1
or coefficient_c <= 0‖or return_period <= 0‖1
or return_period <= 0‖or duration <= 0‖1
or duration <= 0‖):‖1
):‖"raise ValueError(""All parameters must be positive."")"‖1
"raise ValueError(""All parameters must be positive."")"‖intensity = (coefficient_k * (return_period**coefficient_a)) / (‖1
intensity = (coefficient_k * (return_period**coefficient_a)) / (‖(duration + coefficient_b) ** coefficient_c‖1
(duration + coefficient_b) ** coefficient_c‖)‖1
)‖return intensity‖1
from matplotlib import animation‖from matplotlib import pyplot as plt‖1
class Body:‖def __init__(‖1
self,‖position_x: float,‖1
position_x: float,‖position_y: float,‖1
position_y: float,‖velocity_x: float,‖1
velocity_x: float,‖velocity_y: float,‖1
velocity_y: float,‖mass: float = 1.0,‖1
mass: float = 1.0,‖size: float = 1.0,‖1
size: float = 1.0,‖"color: str = ""blue"","‖1
"color: str = ""blue"","‖) -> None:‖1
) -> None:‖self.position_x = position_x‖1
self.position_x = position_x‖self.position_y = position_y‖1
self.position_y = position_y‖self.velocity_x = velocity_x‖1
self.velocity_x = velocity_x‖self.velocity_y = velocity_y‖1
self.velocity_y = velocity_y‖self.mass = mass‖1
self.mass = mass‖self.size = size‖1
self.size = size‖self.color = color‖1
@property‖def position(self) -> tuple[float, float]:‖1
def position(self) -> tuple[float, float]:‖return self.position_x, self.position_y‖1
@property‖def velocity(self) -> tuple[float, float]:‖1
def velocity(self) -> tuple[float, float]:‖return self.velocity_x, self.velocity_y‖1
def update_velocity(‖self, force_x: float, force_y: float, delta_time: float‖1
self, force_x: float, force_y: float, delta_time: float‖) -> None:‖1
) -> None:‖self.velocity_x += force_x * delta_time‖1
self.velocity_x += force_x * delta_time‖self.velocity_y += force_y * delta_time‖1
def update_position(self, delta_time: float) -> None:‖self.position_x += self.velocity_x * delta_time‖1
self.position_x += self.velocity_x * delta_time‖self.position_y += self.velocity_y * delta_time‖1
self,‖bodies: list[Body],‖1
bodies: list[Body],‖gravitation_constant: float = 1.0,‖1
gravitation_constant: float = 1.0,‖time_factor: float = 1.0,‖1
time_factor: float = 1.0,‖softening_factor: float = 0.0,‖1
softening_factor: float = 0.0,‖) -> None:‖1
) -> None:‖self.bodies = bodies‖1
self.bodies = bodies‖self.gravitation_constant = gravitation_constant‖1
self.gravitation_constant = gravitation_constant‖self.time_factor = time_factor‖1
self.time_factor = time_factor‖self.softening_factor = softening_factor‖1
def __len__(self) -> int:‖return len(self.bodies)‖1
def update_system(self, delta_time: float) -> None:‖for body1 in self.bodies:‖1
for body1 in self.bodies:‖force_x = 0.0‖1
force_x = 0.0‖force_y = 0.0‖1
force_y = 0.0‖for body2 in self.bodies:‖1
for body2 in self.bodies:‖if body1 != body2:‖1
if body1 != body2:‖dif_x = body2.position_x - body1.position_x‖1
dif_x = body2.position_x - body1.position_x‖dif_y = body2.position_y - body1.position_y‖1
force_x += (‖self.gravitation_constant * body2.mass * dif_x / distance**3‖1
self.gravitation_constant * body2.mass * dif_x / distance**3‖)‖1
)‖force_y += (‖1
force_y += (‖self.gravitation_constant * body2.mass * dif_y / distance**3‖1
self.gravitation_constant * body2.mass * dif_y / distance**3‖)‖1
for body in self.bodies:‖body.update_position(delta_time * self.time_factor)‖1
def update_step(‖body_system: BodySystem, delta_time: float, patches: list[plt.Circle]‖1
body_system: BodySystem, delta_time: float, patches: list[plt.Circle]‖) -> None:‖1
for patch, body in zip(patches, body_system.bodies):‖patch.center = (body.position_x, body.position_y)‖1
def plot(‖title: str,‖1
title: str,‖body_system: BodySystem,‖1
body_system: BodySystem,‖x_start: float = -1,‖1
x_start: float = -1,‖x_end: float = 1,‖1
x_end: float = 1,‖y_start: float = -1,‖1
y_start: float = -1,‖y_end: float = 1,‖1
y_end: float = 1,‖) -> None:‖1
) -> None:‖fig = plt.figure()‖1
fig = plt.figure()‖fig.canvas.manager.set_window_title(title)‖1
fig.canvas.manager.set_window_title(title)‖ax = plt.axes(‖1
ax = plt.axes(‖xlim=(x_start, x_end), ylim=(y_start, y_end)‖1
xlim=(x_start, x_end), ylim=(y_start, y_end)‖)‖1
)‖"plt.gca().set_aspect(""equal"")"‖1
patches = [‖plt.Circle((body.position_x, body.position_y), body.size, fc=body.color)‖1
plt.Circle((body.position_x, body.position_y), body.size, fc=body.color)‖for body in body_system.bodies‖1
for body in body_system.bodies‖]‖1
for patch in patches:‖ax.add_patch(patch)‖1
def update(frame: int) -> list[plt.Circle]:‖update_step(body_system, DELTA_TIME, patches)‖1
update_step(body_system, DELTA_TIME, patches)‖return patches‖1
anim = animation.FuncAnimation(‖fig, update, interval=INTERVAL, blit=True‖1
fig, update, interval=INTERVAL, blit=True‖)‖1
position_x = 0.9700436‖position_y = -0.24308753‖1
position_y = -0.24308753‖velocity_x = 0.466203685‖1
velocity_x = 0.466203685‖velocity_y = 0.43236573‖1
bodies1 = [‖"Body(position_x, position_y, velocity_x, velocity_y, size=0.2, color=""red""),"‖1
"Body(position_x, position_y, velocity_x, velocity_y, size=0.2, color=""red""),"‖"Body(-position_x, -position_y, velocity_x, velocity_y, size=0.2, color=""green""),"‖1
"Body(-position_x, -position_y, velocity_x, velocity_y, size=0.2, color=""green""),"‖"Body(0, 0, -2 * velocity_x, -2 * velocity_y, size=0.2, color=""blue""),"‖1
"Body(0, 0, -2 * velocity_x, -2 * velocity_y, size=0.2, color=""blue""),"‖]‖1
]‖return BodySystem(bodies1, time_factor=3)‖1
moon_mass = 7.3476e22‖earth_mass = 5.972e24‖1
earth_mass = 5.972e24‖velocity_dif = 1022‖1
velocity_dif = 1022‖earth_moon_distance = 384399000‖1
earth_moon_distance = 384399000‖gravitation_constant = 6.674e-11‖1
moon_velocity = earth_mass * velocity_dif / (earth_mass + moon_mass)‖earth_velocity = moon_velocity - velocity_dif‖1
"moon = Body(-earth_moon_distance, 0, 0, moon_velocity, moon_mass, 10000000, ""grey"")"‖"earth = Body(0, 0, 0, earth_velocity, earth_mass, 50000000, ""blue"")"‖1
"earth = Body(0, 0, 0, earth_velocity, earth_mass, 50000000, ""blue"")"‖return BodySystem([earth, moon], gravitation_constant, time_factor=1000000)‖1
bodies = []‖for _ in range(10):‖1
for _ in range(10):‖velocity_x = random.uniform(-0.5, 0.5)‖1
velocity_x = random.uniform(-0.5, 0.5)‖velocity_y = random.uniform(-0.5, 0.5)‖1
bodies.append(‖Body(‖2
Body(‖random.uniform(-0.5, 0.5),‖2
random.uniform(-0.5, 0.5),‖random.uniform(-0.5, 0.5),‖2
random.uniform(-0.5, 0.5),‖velocity_x,‖1
velocity_x,‖velocity_y,‖1
velocity_y,‖size=0.05,‖1
size=0.05,‖)‖2
)‖bodies.append(‖1
random.uniform(-0.5, 0.5),‖-velocity_x,‖1
-velocity_x,‖-velocity_y,‖1
-velocity_y,‖size=0.05,‖1
)‖return BodySystem(bodies, 0.01, 10, 0.1)‖1
"if __name__ == ""__main__"":"‖"plot(""Figure-8 solution to the 3-body-problem"", example_1(), -2, 2, -2, 2)"‖1
"plot(""Figure-8 solution to the 3-body-problem"", example_1(), -2, 2, -2, 2)"‖plot(‖1
plot(‖"""Moon's orbit around the earth"","‖1
"""Moon's orbit around the earth"","‖example_2(),‖1
example_2(),‖-430000000,‖1
-430000000,‖430000000,‖2
430000000,‖-430000000,‖1
430000000,‖)‖1
)‖"plot(""Random system with many bodies"", example_3(), -1.5, 1.5, -1.5, 1.5)"‖1
if initial_intensity < 0:‖"raise ValueError(""The value of intensity cannot be negative"")"‖1
if angle < 0 or angle > 360:‖"raise ValueError(""In Malus Law, the angle is in the range 0-360 degrees"")"‖1
def calculate_waiting_times(duration_times: list[int]) -> list[int]:‖waiting_times = [0] * len(duration_times)‖1
waiting_times = [0] * len(duration_times)‖for i in range(1, len(duration_times)):‖1
for i in range(1, len(duration_times)):‖waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]‖1
waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]‖return waiting_times‖1
def calculate_turnaround_times(‖duration_times: list[int], waiting_times: list[int]‖1
duration_times: list[int], waiting_times: list[int]‖) -> list[int]:‖1
) -> list[int]:‖return [‖1
return [‖duration_time + waiting_times[i]‖1
duration_time + waiting_times[i]‖for i, duration_time in enumerate(duration_times)‖1
for i, duration_time in enumerate(duration_times)‖]‖1
def calculate_average_turnaround_time(turnaround_times: list[int]) -> float:‖return sum(turnaround_times) / len(turnaround_times)‖1
def calculate_average_waiting_time(waiting_times: list[int]) -> float:‖return sum(waiting_times) / len(waiting_times)‖1
if len(processes) == 0:‖"print(""Zero amount of processes"")"‖1
"print(""Zero amount of processes"")"‖raise SystemExit(0)‖1
if len(duration_times) != len(processes):‖"print(""Unable to match all id's with their duration time"")"‖1
"print(""Unable to match all id's with their duration time"")"‖raise SystemExit(0)‖1
waiting_times = calculate_waiting_times(duration_times)‖turnaround_times = calculate_turnaround_times(duration_times, waiting_times)‖1
average_waiting_time = calculate_average_waiting_time(waiting_times)‖average_turnaround_time = calculate_average_turnaround_time(turnaround_times)‖1
"print(""Process ID\tDuration Time\tWaiting Time\tTurnaround Time"")"‖for i, process in enumerate(processes):‖1
for i, process in enumerate(processes):‖print(‖1
print(‖"f""{process}\t\t{duration_times[i]}\t\t{waiting_times[i]}\t\t"""‖1
"f""{process}\t\t{duration_times[i]}\t\t{waiting_times[i]}\t\t"""‖"f""{turnaround_times[i]}"""‖1
"f""{turnaround_times[i]}"""‖)‖1
)‖"print(f""Average waiting time = {average_waiting_time}"")"‖1
"print(f""Average waiting time = {average_waiting_time}"")"‖"print(f""Average turn around time = {average_turnaround_time}"")"‖1
PLANCK_CONSTANT_JS = 6.6261 * pow(10, -34)‖PLANCK_CONSTANT_EVS = 4.1357 * pow(10, -15)‖1
def maximum_kinetic_energy(‖frequency: float, work_function: float, in_ev: bool = False‖1
frequency: float, work_function: float, in_ev: bool = False‖) -> float:‖1
) -> float:‖if frequency < 0:‖1
if frequency < 0:‖"raise ValueError(""Frequency can't be negative."")"‖1
"raise ValueError(""Frequency can't be negative."")"‖if in_ev:‖1
if in_ev:‖return max(PLANCK_CONSTANT_EVS * frequency - work_function, 0)‖1
return max(PLANCK_CONSTANT_EVS * frequency - work_function, 0)‖return max(PLANCK_CONSTANT_JS * frequency - work_function, 0)‖1
def energy_from_mass(mass: float) -> float:‖if mass < 0:‖1
if mass < 0:‖"raise ValueError(""Mass can't be negative."")"‖1
"raise ValueError(""Mass can't be negative."")"‖return mass * c**2‖1
def mass_from_energy(energy: float) -> float:‖if energy < 0:‖1
if energy < 0:‖"raise ValueError(""Energy can't be negative."")"‖1
"raise ValueError(""Energy can't be negative."")"‖return energy / c**2‖1
def shear_stress(‖stress: float,‖1
stress: float,‖tangential_force: float,‖1
tangential_force: float,‖area: float,‖1
area: float,‖) -> tuple[str, float]:‖1
) -> tuple[str, float]:‖if (stress, tangential_force, area).count(0) != 1:‖1
if (stress, tangential_force, area).count(0) != 1:‖"raise ValueError(""You cannot supply more or less than 2 values"")"‖1
"raise ValueError(""You cannot supply more or less than 2 values"")"‖elif stress < 0:‖1
elif stress < 0:‖"raise ValueError(""Stress cannot be negative"")"‖1
"raise ValueError(""Stress cannot be negative"")"‖elif tangential_force < 0:‖1
elif tangential_force < 0:‖"raise ValueError(""Tangential Force cannot be negative"")"‖1
"raise ValueError(""Tangential Force cannot be negative"")"‖elif area < 0:‖1
elif area < 0:‖"raise ValueError(""Area cannot be negative"")"‖1
"raise ValueError(""Area cannot be negative"")"‖elif stress == 0:‖1
elif stress == 0:‖return (‖1
return (‖"""stress"","‖1
"""stress"","‖tangential_force / area,‖1
tangential_force / area,‖)‖1
)‖elif tangential_force == 0:‖1
elif tangential_force == 0:‖return (‖1
return (‖"""tangential_force"","‖1
"""tangential_force"","‖stress * area,‖1
stress * area,‖)‖1
return (‖"""area"","‖1
"""area"","‖tangential_force / stress,‖1
tangential_force / stress,‖)‖1
"raise ValueError(""The mass of a body cannot be negative"")"‖if height < 0:‖1
"raise ValueError(""The height above the ground cannot be negative"")"‖return mass * g * height‖1
def period_of_pendulum(length: float) -> float:‖if length < 0:‖1
if length < 0:‖"raise ValueError(""The length should be non-negative"")"‖1
"raise ValueError(""The length should be non-negative"")"‖return 2 * pi * (length / g) ** 0.5‖1
def calculate_turn_around_time(‖process_name: list, arrival_time: list, burst_time: list, no_of_process: int‖1
process_name: list, arrival_time: list, burst_time: list, no_of_process: int‖) -> list:‖1
burst_time = [burst_time[i] for i in np.argsort(arrival_time)]‖process_name = [process_name[i] for i in np.argsort(arrival_time)]‖1
process_name = [process_name[i] for i in np.argsort(arrival_time)]‖arrival_time.sort()‖1
while no_of_process > finished_process_count:‖i = 0‖1
i = 0‖while finished_process[i] == 1:‖1
while finished_process[i] == 1:‖i += 1‖1
i += 1‖current_time = max(current_time, arrival_time[i])‖1
temp = 0‖for i in range(no_of_process):‖1
for i in range(no_of_process):‖if finished_process[i] == 0 and arrival_time[i] <= current_time:‖1
if finished_process[i] == 0 and arrival_time[i] <= current_time:‖temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[‖1
temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[‖i‖1
i‖]‖1
]‖if response_ratio < temp:‖1
if response_ratio < temp:‖response_ratio = temp‖1
response_ratio = temp‖loc = i‖1
turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]‖current_time += burst_time[loc]‖1
def calculate_waiting_time(‖process_name: list,‖1
process_name: list,‖turn_around_time: list,‖1
turn_around_time: list,‖burst_time: list,‖1
burst_time: list,‖no_of_process: int,‖1
no_of_process: int,‖) -> list:‖1
waiting_time = [0] * no_of_process‖for i in range(no_of_process):‖1
for i in range(no_of_process):‖waiting_time[i] = turn_around_time[i] - burst_time[i]‖1
waiting_time[i] = turn_around_time[i] - burst_time[i]‖return waiting_time‖1
"if __name__ == ""__main__"":"‖no_of_process = 5‖1
no_of_process = 5‖"process_name = [""A"", ""B"", ""C"", ""D"", ""E""]"‖1
"process_name = [""A"", ""B"", ""C"", ""D"", ""E""]"‖arrival_time = [1, 2, 3, 4, 5]‖1
arrival_time = [1, 2, 3, 4, 5]‖burst_time = [1, 2, 3, 4, 5]‖1
turn_around_time = calculate_turn_around_time(‖process_name, arrival_time, burst_time, no_of_process‖1
process_name, arrival_time, burst_time, no_of_process‖)‖1
)‖waiting_time = calculate_waiting_time(‖1
waiting_time = calculate_waiting_time(‖process_name, turn_around_time, burst_time, no_of_process‖1
process_name, turn_around_time, burst_time, no_of_process‖)‖1
"print(""Process name \tArrival time \tBurst time \tTurn around time \tWaiting time"")"‖for i in range(no_of_process):‖1
for i in range(no_of_process):‖print(‖1
print(‖"f""{process_name[i]}\t\t{arrival_time[i]}\t\t{burst_time[i]}\t\t"""‖1
"f""{process_name[i]}\t\t{arrival_time[i]}\t\t{burst_time[i]}\t\t"""‖"f""{turn_around_time[i]}\t\t\t{waiting_time[i]}"""‖1
"f""{turn_around_time[i]}\t\t\t{waiting_time[i]}"""‖)‖1
"print(f""average waiting time : {mean(waiting_time):.5f}"")"‖"print(f""average turn around time : {mean(turn_around_time):.5f}"")"‖1
if temperature < 0:‖"raise Exception(""Absolute temperature cannot be less than 0 K"")"‖2
"raise Exception(""Absolute temperature cannot be less than 0 K"")"‖if molar_mass <= 0:‖2
if molar_mass <= 0:‖"raise Exception(""Molar mass should be greater than 0 kg/mol"")"‖2
"raise Exception(""Molar mass should be greater than 0 kg/mol"")"‖return (8 * R * temperature / (pi * molar_mass)) ** 0.5‖1
"raise Exception(""Molar mass should be greater than 0 kg/mol"")"‖return (2 * R * temperature / molar_mass) ** 0.5‖1
force = 0.0‖try:‖1
try:‖force = mass * acceleration‖1
force = mass * acceleration‖except Exception:‖1
except Exception:‖return -0.0‖1
return -0.0‖return force‖1
mass = 12.5‖acceleration = 10‖1
acceleration = 10‖force = newtons_second_law_of_motion(mass, acceleration)‖1
force = newtons_second_law_of_motion(mass, acceleration)‖"print(""The force is "", force, ""N"")"‖1
import numpy as np‖import qiskit‖1
import qiskit‖from qiskit import Aer, ClassicalRegister, QuantumCircuit, QuantumRegister, execute‖1
def quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:‖if isinstance(number_of_qubits, str):‖1
if isinstance(number_of_qubits, str):‖"raise TypeError(""number of qubits must be a integer."")"‖1
"raise TypeError(""number of qubits must be a integer."")"‖if number_of_qubits <= 0:‖1
if number_of_qubits <= 0:‖"raise ValueError(""number of qubits must be > 0."")"‖1
"raise ValueError(""number of qubits must be > 0."")"‖if math.floor(number_of_qubits) != number_of_qubits:‖1
if math.floor(number_of_qubits) != number_of_qubits:‖"raise ValueError(""number of qubits must be exact integer."")"‖1
"raise ValueError(""number of qubits must be exact integer."")"‖if number_of_qubits > 10:‖1
if number_of_qubits > 10:‖"raise ValueError(""number of qubits too large to simulate(>10)."")"‖1
"qr = QuantumRegister(number_of_qubits, ""qr"")"‖"cr = ClassicalRegister(number_of_qubits, ""cr"")"‖1
for i in range(counter):‖quantum_circuit.h(number_of_qubits - i - 1)‖1
quantum_circuit.h(number_of_qubits - i - 1)‖counter -= 1‖1
counter -= 1‖for j in range(counter):‖1
for j in range(counter):‖quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)‖1
for k in range(number_of_qubits // 2):‖quantum_circuit.swap(k, number_of_qubits - k - 1)‖1
"backend = Aer.get_backend(""qasm_simulator"")"‖job = execute(quantum_circuit, backend, shots=10000)‖1
print(‖"f""Total count for quantum fourier transform state is: \"‖1
"f""Total count for quantum fourier transform state is: \"‖"{quantum_fourier_transform(3)}"""‖1
"{quantum_fourier_transform(3)}"""‖)‖1
@dataclass‖class Task:‖1
class Task:‖task_id: int‖1
task_id: int‖deadline: int‖1
deadline: int‖reward: int‖1
def max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:‖tasks = sorted(‖1
tasks = sorted(‖(‖1
(‖Task(task_id, deadline, reward)‖1
Task(task_id, deadline, reward)‖for task_id, (deadline, reward) in enumerate(tasks_info)‖1
for task_id, (deadline, reward) in enumerate(tasks_info)‖),‖1
),‖"key=attrgetter(""reward""),"‖1
"key=attrgetter(""reward""),"‖reverse=True,‖1
reverse=True,‖)‖1
)‖return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]‖1
doctest.testmod()‖"print(f""{max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)]) = }"")"‖1
"print(f""{max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)]) = }"")"‖"print(f""{max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)]) = }"")"‖1
try:‖from .build_directory_md import good_file_paths‖1
from .build_directory_md import good_file_paths‖except ImportError:‖1
except ImportError:‖from build_directory_md import good_file_paths‖1
filepaths = list(good_file_paths())‖"assert filepaths, ""good_file_paths() failed!"""‖1
upper_files = [file for file in filepaths if file != file.lower()]‖if upper_files:‖1
if upper_files:‖"print(f""{len(upper_files)} files contain uppercase characters:"")"‖1
"print(f""{len(upper_files)} files contain uppercase characters:"")"‖"print(""\n"".join(upper_files) + ""\n"")"‖1
"space_files = [file for file in filepaths if "" "" in file]"‖if space_files:‖1
if space_files:‖"print(f""{len(space_files)} files contain space characters:"")"‖1
"print(f""{len(space_files)} files contain space characters:"")"‖"print(""\n"".join(space_files) + ""\n"")"‖1
"hyphen_files = [file for file in filepaths if ""-"" in file]"‖if hyphen_files:‖1
if hyphen_files:‖"print(f""{len(hyphen_files)} files contain hyphen characters:"")"‖1
"print(f""{len(hyphen_files)} files contain hyphen characters:"")"‖"print(""\n"".join(hyphen_files) + ""\n"")"‖1
nodir_files = [file for file in filepaths if os.sep not in file]‖if nodir_files:‖1
if nodir_files:‖"print(f""{len(nodir_files)} files are not in a directory:"")"‖1
"print(f""{len(nodir_files)} files are not in a directory:"")"‖"print(""\n"".join(nodir_files) + ""\n"")"‖1
bad_files = len(upper_files + space_files + hyphen_files + nodir_files)‖if bad_files:‖1
if bad_files:‖import sys‖1
max_deadline = max(jobs, key=lambda value: value[1])[1]‖time_slots = [-1] * max_deadline‖1
count = 0‖max_profit = 0‖1
max_profit = 0‖for job in jobs:‖1
for i in range(job[1] - 1, -1, -1):‖if time_slots[i] == -1:‖1
if time_slots[i] == -1:‖time_slots[i] = job[0]‖1
time_slots[i] = job[0]‖count += 1‖1
count += 1‖max_profit += job[2]‖1
max_profit += job[2]‖break‖1
break‖return [count, max_profit]‖1
class Process:‖def __init__(self, process_name: str, arrival_time: int, burst_time: int) -> None:‖1
def __init__(self, process_name: str, arrival_time: int, burst_time: int) -> None:‖self.process_name = process_name‖1
self.process_name = process_name‖self.arrival_time = arrival_time‖1
self.stop_time = arrival_time‖self.burst_time = burst_time‖1
self.burst_time = burst_time‖self.waiting_time = 0‖1
self.waiting_time = 0‖self.turnaround_time = 0‖1
self,‖number_of_queues: int,‖1
number_of_queues: int,‖time_slices: list[int],‖1
time_slices: list[int],‖queue: deque[Process],‖1
queue: deque[Process],‖current_time: int,‖1
current_time: int,‖) -> None:‖1
def calculate_sequence_of_finish_queue(self) -> list[str]:‖sequence = []‖1
sequence = []‖for i in range(len(self.finish_queue)):‖1
for i in range(len(self.finish_queue)):‖sequence.append(self.finish_queue[i].process_name)‖1
sequence.append(self.finish_queue[i].process_name)‖return sequence‖1
def calculate_waiting_time(self, queue: list[Process]) -> list[int]:‖waiting_times = []‖1
waiting_times = []‖for i in range(len(queue)):‖1
for i in range(len(queue)):‖waiting_times.append(queue[i].waiting_time)‖1
waiting_times.append(queue[i].waiting_time)‖return waiting_times‖1
def calculate_turnaround_time(self, queue: list[Process]) -> list[int]:‖turnaround_times = []‖1
turnaround_times = []‖for i in range(len(queue)):‖1
for i in range(len(queue)):‖turnaround_times.append(queue[i].turnaround_time)‖1
turnaround_times.append(queue[i].turnaround_time)‖return turnaround_times‖1
def calculate_completion_time(self, queue: list[Process]) -> list[int]:‖completion_times = []‖1
completion_times = []‖for i in range(len(queue)):‖1
for i in range(len(queue)):‖completion_times.append(queue[i].stop_time)‖1
completion_times.append(queue[i].stop_time)‖return completion_times‖1
def calculate_remaining_burst_time_of_processes(‖self, queue: deque[Process]‖1
self, queue: deque[Process]‖) -> list[int]:‖1
) -> list[int]:‖return [q.burst_time for q in queue]‖1
def update_waiting_time(self, process: Process) -> int:‖process.waiting_time += self.current_time - process.stop_time‖1
process.waiting_time += self.current_time - process.stop_time‖return process.waiting_time‖1
def first_come_first_served(self, ready_queue: deque[Process]) -> deque[Process]:‖finished: deque[Process] = deque()‖1
finished: deque[Process] = deque()‖while len(ready_queue) != 0:‖1
while len(ready_queue) != 0:‖cp = ready_queue.popleft()‖1
if self.current_time < cp.arrival_time:‖self.current_time += cp.arrival_time‖2
def round_robin(‖self, ready_queue: deque[Process], time_slice: int‖1
self, ready_queue: deque[Process], time_slice: int‖) -> tuple[deque[Process], deque[Process]]:‖1
) -> tuple[deque[Process], deque[Process]]:‖finished: deque[Process] = deque()‖1
for _ in range(len(ready_queue)):‖cp = ready_queue.popleft()‖1
ready_queue.append(cp)‖else:‖1
for i in range(self.number_of_queues - 1):‖finished, self.ready_queue = self.round_robin(‖1
finished, self.ready_queue = self.round_robin(‖self.ready_queue, self.time_slices[i]‖1
self.ready_queue, self.time_slices[i]‖)‖1
"P1 = Process(""P1"", 0, 53)"‖"P2 = Process(""P2"", 0, 17)"‖2
"P2 = Process(""P2"", 0, 17)"‖"P3 = Process(""P3"", 0, 68)"‖2
"P3 = Process(""P3"", 0, 68)"‖"P4 = Process(""P4"", 0, 24)"‖2
"P4 = Process(""P4"", 0, 24)"‖number_of_queues = 3‖2
number_of_queues = 3‖time_slices = [17, 25]‖2
time_slices = [17, 25]‖queue = deque([P1, P2, P3, P4])‖2
if len(time_slices) != number_of_queues - 1:‖raise SystemExit(0)‖1
queue = deque([P1, P2, P3, P4])‖mlfq = MLFQ(number_of_queues, time_slices, queue, 0)‖1
mlfq = MLFQ(number_of_queues, time_slices, queue, 0)‖finish_queue = mlfq.multi_level_feedback_queue()‖1
print(‖"f""waiting time:\"‖1
"f""waiting time:\"‖"\t\t\t{MLFQ.calculate_waiting_time(mlfq, [P1, P2, P3, P4])}"""‖1
"\t\t\t{MLFQ.calculate_waiting_time(mlfq, [P1, P2, P3, P4])}"""‖)‖1
print(‖"f""completion time:\"‖1
"f""completion time:\"‖"\t\t{MLFQ.calculate_completion_time(mlfq, [P1, P2, P3, P4])}"""‖1
"\t\t{MLFQ.calculate_completion_time(mlfq, [P1, P2, P3, P4])}"""‖)‖1
print(‖"f""turnaround time:\"‖1
"f""turnaround time:\"‖"\t\t{MLFQ.calculate_turnaround_time(mlfq, [P1, P2, P3, P4])}"""‖1
"\t\t{MLFQ.calculate_turnaround_time(mlfq, [P1, P2, P3, P4])}"""‖)‖1
print(‖"f""sequence of finished processes:\"‖1
"f""sequence of finished processes:\"‖"{mlfq.calculate_sequence_of_finish_queue()}"""‖1
"{mlfq.calculate_sequence_of_finish_queue()}"""‖)‖1
def terminal_velocity(‖mass: float, density: float, area: float, drag_coefficient: float‖1
mass: float, density: float, area: float, drag_coefficient: float‖) -> float:‖1
) -> float:‖if mass <= 0 or density <= 0 or area <= 0 or drag_coefficient <= 0:‖1
if mass <= 0 or density <= 0 or area <= 0 or drag_coefficient <= 0:‖raise ValueError(‖1
raise ValueError(‖"""mass, density, area and the drag coefficient all need to be positive"""‖1
"""mass, density, area and the drag coefficient all need to be positive"""‖)‖1
)‖return ((2 * mass * g) / (density * area * drag_coefficient)) ** 0.5‖1
if density <= 0:‖"raise ValueError(""Impossible fluid density"")"‖1
"raise ValueError(""Impossible fluid density"")"‖if bulk_modulus <= 0:‖1
if bulk_modulus <= 0:‖"raise ValueError(""Impossible bulk modulus"")"‖1
def calculate_waitingtime(‖arrival_time: list[int], burst_time: list[int], no_of_processes: int‖2
arrival_time: list[int], burst_time: list[int], no_of_processes: int‖) -> list[int]:‖2
) -> list[int]:‖remaining_time = [0] * no_of_processes‖1
remaining_time = [0] * no_of_processes‖waiting_time = [0] * no_of_processes‖1
for i in range(no_of_processes):‖remaining_time[i] = burst_time[i]‖2
complete = 0‖increment_time = 0‖1
increment_time = 0‖minm = 999999999‖1
minm = 999999999‖short = 0‖1
short = 0‖check = False‖1
while complete != no_of_processes:‖for j in range(no_of_processes):‖1
for j in range(no_of_processes):‖if (‖1
if (‖arrival_time[j] <= increment_time‖1
arrival_time[j] <= increment_time‖and remaining_time[j] > 0‖1
and remaining_time[j] > 0‖and remaining_time[j] < minm‖1
and remaining_time[j] < minm‖):‖1
):‖minm = remaining_time[j]‖1
minm = remaining_time[j]‖short = j‖1
short = j‖check = True‖1
if not check:‖increment_time += 1‖1
increment_time += 1‖continue‖1
continue‖remaining_time[short] -= 1‖1
minm = remaining_time[short]‖if minm == 0:‖1
if minm == 0:‖minm = 999999999‖1
if remaining_time[short] == 0:‖complete += 1‖1
complete += 1‖check = False‖1
finar = finish_time - arrival_time[short]‖waiting_time[short] = finar - burst_time[short]‖1
increment_time += 1‖return waiting_time‖1
def calculate_turnaroundtime(‖burst_time: list[int], no_of_processes: int, waiting_time: list[int]‖2
burst_time: list[int], no_of_processes: int, waiting_time: list[int]‖) -> list[int]:‖2
) -> list[int]:‖turn_around_time = [0] * no_of_processes‖1
turn_around_time = [0] * no_of_processes‖for i in range(no_of_processes):‖2
for i in range(no_of_processes):‖turn_around_time[i] = burst_time[i] + waiting_time[i]‖2
turn_around_time[i] = burst_time[i] + waiting_time[i]‖return turn_around_time‖2
def calculate_average_times(‖waiting_time: list[int], turn_around_time: list[int], no_of_processes: int‖1
waiting_time: list[int], turn_around_time: list[int], no_of_processes: int‖) -> None:‖1
) -> None:‖total_waiting_time = 0‖1
total_waiting_time = 0‖total_turn_around_time = 0‖1
total_turn_around_time = 0‖for i in range(no_of_processes):‖1
for i in range(no_of_processes):‖total_waiting_time = total_waiting_time + waiting_time[i]‖1
total_waiting_time = total_waiting_time + waiting_time[i]‖total_turn_around_time = total_turn_around_time + turn_around_time[i]‖1
total_turn_around_time = total_turn_around_time + turn_around_time[i]‖"print(f""Average waiting time = {total_waiting_time / no_of_processes:.5f}"")"‖1
"print(f""Average waiting time = {total_waiting_time / no_of_processes:.5f}"")"‖"print(""Average turn around time ="", total_turn_around_time / no_of_processes)"‖1
"if __name__ == ""__main__"":"‖"print(""Enter how many process you want to analyze"")"‖1
"print(""Enter how many process you want to analyze"")"‖no_of_processes = int(input())‖1
no_of_processes = int(input())‖burst_time = [0] * no_of_processes‖1
burst_time = [0] * no_of_processes‖arrival_time = [0] * no_of_processes‖1
arrival_time = [0] * no_of_processes‖processes = list(range(1, no_of_processes + 1))‖1
for i in range(no_of_processes):‖"print(""Enter the arrival time and burst time for process:--"" + str(i + 1))"‖1
"print(""Enter the arrival time and burst time for process:--"" + str(i + 1))"‖arrival_time[i], burst_time[i] = map(int, input().split())‖1
bt = burst_time‖n = no_of_processes‖1
n = no_of_processes‖wt = waiting_time‖1
wt = waiting_time‖turn_around_time = calculate_turnaroundtime(bt, n, wt)‖1
fcfs = pd.DataFrame(‖list(zip(processes, burst_time, arrival_time, waiting_time, turn_around_time)),‖1
list(zip(processes, burst_time, arrival_time, waiting_time, turn_around_time)),‖columns=[‖1
columns=[‖"""Process"","‖1
"""Process"","‖"""BurstTime"","‖1
"""BurstTime"","‖"""ArrivalTime"","‖1
"""ArrivalTime"","‖"""WaitingTime"","‖1
"""WaitingTime"","‖"""TurnAroundTime"","‖1
"""TurnAroundTime"","‖],‖1
"pd.set_option(""display.max_rows"", fcfs.shape[0] + 1)"‖print(fcfs)‖1
waiting_time = [0] * no_of_processes‖remaining_time = [0] * no_of_processes‖1
remaining_time[i] = burst_time[i]‖ready_process: list[int] = []‖1
completed = 0‖total_time = 0‖1
while completed != no_of_processes:‖ready_process = []‖1
ready_process = []‖target_process = -1‖1
for i in range(no_of_processes):‖if (arrival_time[i] <= total_time) and (remaining_time[i] > 0):‖1
if (arrival_time[i] <= total_time) and (remaining_time[i] > 0):‖ready_process.append(i)‖1
if len(ready_process) > 0:‖target_process = ready_process[0]‖1
target_process = ready_process[0]‖for i in ready_process:‖1
for i in ready_process:‖if remaining_time[i] < remaining_time[target_process]:‖1
if remaining_time[i] < remaining_time[target_process]:‖target_process = i‖1
target_process = i‖total_time += burst_time[target_process]‖1
total_time += burst_time[target_process]‖completed += 1‖1
completed += 1‖remaining_time[target_process] = 0‖1
remaining_time[target_process] = 0‖waiting_time[target_process] = (‖1
waiting_time[target_process] = (‖total_time - arrival_time[target_process] - burst_time[target_process]‖1
total_time - arrival_time[target_process] - burst_time[target_process]‖)‖1
else:‖total_time += 1‖1
"if __name__ == ""__main__"":"‖"print(""[TEST CASE 01]"")"‖1
no_of_processes = 4‖burst_time = [2, 5, 3, 7]‖1
burst_time = [2, 5, 3, 7]‖arrival_time = [0, 0, 0, 0]‖1
arrival_time = [0, 0, 0, 0]‖waiting_time = calculate_waitingtime(arrival_time, burst_time, no_of_processes)‖1
waiting_time = calculate_waitingtime(arrival_time, burst_time, no_of_processes)‖turn_around_time = calculate_turnaroundtime(‖1
turn_around_time = calculate_turnaroundtime(‖burst_time, no_of_processes, waiting_time‖1
burst_time, no_of_processes, waiting_time‖)‖1
"print(""PID\tBurst Time\tArrival Time\tWaiting Time\tTurnaround Time"")"‖for i, process_id in enumerate(list(range(1, 5))):‖1
for i, process_id in enumerate(list(range(1, 5))):‖print(‖1
print(‖"f""{process_id}\t{burst_time[i]}\t\t\t{arrival_time[i]}\t\t\t\t"""‖1
"f""{process_id}\t{burst_time[i]}\t\t\t{arrival_time[i]}\t\t\t\t"""‖"f""{waiting_time[i]}\t\t\t\t{turn_around_time[i]}"""‖1
"f""{waiting_time[i]}\t\t\t\t{turn_around_time[i]}"""‖)‖1
)‖"print(f""\nAverage waiting time = {mean(waiting_time):.5f}"")"‖1
"print(f""\nAverage waiting time = {mean(waiting_time):.5f}"")"‖"print(f""Average turnaround time = {mean(turn_around_time):.5f}"")"‖1
import os‖from collections.abc import Iterator‖1
"def good_file_paths(top_dir: str = ""."") -> Iterator[str]:"‖for dir_path, dir_names, filenames in os.walk(top_dir):‖1
for dir_path, dir_names, filenames in os.walk(top_dir):‖dir_names[:] = [‖1
dir_names[:] = [‖d‖1
d‖for d in dir_names‖1
for d in dir_names‖"if d != ""scripts"" and d[0] not in ""._"" and ""venv"" not in d"‖1
"if d != ""scripts"" and d[0] not in ""._"" and ""venv"" not in d"‖]‖1
]‖for filename in filenames:‖1
for filename in filenames:‖"if filename == ""__init__.py"":"‖1
"if filename == ""__init__.py"":"‖continue‖1
continue‖"if os.path.splitext(filename)[1] in ("".py"", "".ipynb""):"‖1
"if os.path.splitext(filename)[1] in ("".py"", "".ipynb""):"‖"yield os.path.join(dir_path, filename).lstrip(""./"")"‖1
def md_prefix(i):‖"return f""{i * '  '}*"" if i else ""\n##"""‖1
def print_path(old_path: str, new_path: str) -> str:‖old_parts = old_path.split(os.sep)‖1
old_parts = old_path.split(os.sep)‖for i, new_part in enumerate(new_path.split(os.sep)):‖1
for i, new_part in enumerate(new_path.split(os.sep)):‖if (i + 1 > len(old_parts) or old_parts[i] != new_part) and new_part:‖1
if (i + 1 > len(old_parts) or old_parts[i] != new_part) and new_part:‖"print(f""{md_prefix(i)} {new_part.replace('_', ' ').title()}"")"‖1
"print(f""{md_prefix(i)} {new_part.replace('_', ' ').title()}"")"‖return new_path‖1
"def print_directory_md(top_dir: str = ""."") -> None:"‖"old_path = """""‖1
"old_path = """""‖for filepath in sorted(good_file_paths(top_dir)):‖1
for filepath in sorted(good_file_paths(top_dir)):‖filepath, filename = os.path.split(filepath)‖1
filepath, filename = os.path.split(filepath)‖if filepath != old_path:‖1
if filepath != old_path:‖old_path = print_path(old_path, filepath)‖1
old_path = print_path(old_path, filepath)‖indent = (filepath.count(os.sep) + 1) if filepath else 0‖1
indent = (filepath.count(os.sep) + 1) if filepath else 0‖"url = f""{filepath}/{filename}"".replace("" "", ""%20"")"‖1
"url = f""{filepath}/{filename}"".replace("" "", ""%20"")"‖"filename = os.path.splitext(filename.replace(""_"", "" "").title())[0]"‖1
"filename = os.path.splitext(filename.replace(""_"", "" "").title())[0]"‖"print(f""{md_prefix(indent)} [{filename}]({url})"")"‖1
"if __name__ == ""__main__"":"‖"print_directory_md(""."")"‖1
@lru_cache‖def fibonacci(k: int) -> int:‖1
def fibonacci(k: int) -> int:‖if not isinstance(k, int):‖1
if not isinstance(k, int):‖"raise TypeError(""k must be an integer."")"‖1
"raise TypeError(""k must be an integer."")"‖if k < 0:‖1
if k < 0:‖"raise ValueError(""k integer must be greater or equal to zero."")"‖1
"raise ValueError(""k integer must be greater or equal to zero."")"‖if k == 0:‖1
if k == 0:‖return 0‖1
return 0‖elif k == 1:‖1
elif k == 1:‖return 1‖1
return 1‖else:‖1
else:‖return fibonacci(k - 1) + fibonacci(k - 2)‖1
def fibonacci_search(arr: list, val: int) -> int:‖len_list = len(arr)‖1
while True:‖if fibonacci(i) >= len_list:‖1
if fibonacci(i) >= len_list:‖fibb_k = i‖1
fibb_k = i‖break‖1
i += 1‖offset = 0‖1
offset = 0‖while fibb_k > 0:‖1
while fibb_k > 0:‖index_k = min(‖1
index_k = min(‖offset + fibonacci(fibb_k - 1), len_list - 1‖1
offset + fibonacci(fibb_k - 1), len_list - 1‖)‖1
)‖item_k_1 = arr[index_k]‖1
item_k_1 = arr[index_k]‖if item_k_1 == val:‖1
if item_k_1 == val:‖return index_k‖1
return index_k‖elif val < item_k_1:‖1
elif val < item_k_1:‖fibb_k -= 1‖1
fibb_k -= 1‖elif val > item_k_1:‖1
elif val > item_k_1:‖offset += fibonacci(fibb_k - 1)‖1
offset += fibonacci(fibb_k - 1)‖fibb_k -= 2‖1
fibb_k -= 2‖return -1‖1
start_ind, end_ind = 0, len(array) - 1‖while start_ind <= end_ind:‖1
while start_ind <= end_ind:‖if array[start_ind] == search_item:‖1
if array[start_ind] == search_item:‖return start_ind‖1
return start_ind‖elif array[end_ind] == search_item:‖1
elif array[end_ind] == search_item:‖return end_ind‖1
return end_ind‖else:‖1
else:‖start_ind += 1‖1
start_ind += 1‖end_ind -= 1‖1
"if __name__ == ""__main__"":"‖print(double_linear_search(list(range(100)), 40))‖1
def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:‖right = right or len(list_data) - 1‖1
right = right or len(list_data) - 1‖if left > right:‖1
if left > right:‖return -1‖1
return -1‖elif list_data[left] == key:‖1
elif list_data[left] == key:‖return left‖1
return left‖elif list_data[right] == key:‖1
elif list_data[right] == key:‖return right‖1
return right‖else:‖1
else:‖return search(list_data, key, left + 1, right - 1)‖1
def __init__(self, x: int, y: int, step_size: int, function_to_optimize):‖self.x = x‖1
self.y = y‖self.step_size = step_size‖1
self.step_size = step_size‖self.function = function_to_optimize‖1
def score(self) -> int:‖return self.function(self.x, self.y)‖1
def get_neighbors(self):‖step_size = self.step_size‖1
step_size = self.step_size‖return [‖1
return [‖SearchProblem(x, y, step_size, self.function)‖1
SearchProblem(x, y, step_size, self.function)‖for x, y in (‖1
for x, y in (‖(self.x - step_size, self.y - step_size),‖1
(self.x - step_size, self.y - step_size),‖(self.x - step_size, self.y),‖1
(self.x - step_size, self.y),‖(self.x - step_size, self.y + step_size),‖1
(self.x - step_size, self.y + step_size),‖(self.x, self.y - step_size),‖1
(self.x, self.y - step_size),‖(self.x, self.y + step_size),‖1
(self.x, self.y + step_size),‖(self.x + step_size, self.y - step_size),‖1
(self.x + step_size, self.y - step_size),‖(self.x + step_size, self.y),‖1
(self.x + step_size, self.y),‖(self.x + step_size, self.y + step_size),‖1
(self.x + step_size, self.y + step_size),‖)‖1
def __hash__(self):‖return hash(str(self))‖1
def __eq__(self, obj):‖if isinstance(obj, SearchProblem):‖1
if isinstance(obj, SearchProblem):‖return hash(str(self)) == hash(str(obj))‖1
return hash(str(self)) == hash(str(obj))‖return False‖1
def __str__(self):‖"return f""x: {self.x} y: {self.y}"""‖1
def hill_climbing(‖search_prob,‖1
search_prob,‖find_max: bool = True,‖2
find_max: bool = True,‖max_x: float = math.inf,‖2
max_x: float = math.inf,‖min_x: float = -math.inf,‖2
min_x: float = -math.inf,‖max_y: float = math.inf,‖2
max_y: float = math.inf,‖min_y: float = -math.inf,‖2
min_y: float = -math.inf,‖visualization: bool = False,‖2
visualization: bool = False,‖max_iter: int = 10000,‖1
max_iter: int = 10000,‖) -> SearchProblem:‖1
) -> SearchProblem:‖current_state = search_prob‖1
current_state = search_prob‖scores = []‖1
scores = []‖iterations = 0‖2
iterations = 0‖solution_found = False‖1
solution_found = False‖visited = set()‖1
visited = set()‖while not solution_found and iterations < max_iter:‖1
while not solution_found and iterations < max_iter:‖visited.add(current_state)‖1
visited.add(current_state)‖iterations += 1‖1
iterations += 1‖current_score = current_state.score()‖1
current_score = current_state.score()‖scores.append(current_score)‖1
scores.append(current_score)‖neighbors = current_state.get_neighbors()‖1
neighbors = current_state.get_neighbors()‖max_change = -math.inf‖1
max_change = -math.inf‖min_change = math.inf‖1
min_change = math.inf‖next_state = None‖1
next_state = None‖for neighbor in neighbors:‖1
for neighbor in neighbors:‖if neighbor in visited:‖1
if neighbor in visited:‖continue‖1
continue‖if (‖1
if (‖neighbor.x > max_x‖1
neighbor.x > max_x‖or neighbor.x < min_x‖1
or neighbor.x < min_x‖or neighbor.y > max_y‖1
or neighbor.y > max_y‖or neighbor.y < min_y‖1
or neighbor.y < min_y‖):‖1
continue‖change = neighbor.score() - current_score‖1
change = neighbor.score() - current_score‖if find_max:‖1
if change > max_change and change > 0:‖max_change = change‖1
max_change = change‖next_state = neighbor‖1
next_state = neighbor‖elif change < min_change and change < 0:‖1
min_change = change‖next_state = neighbor‖1
next_state = neighbor‖if next_state is not None:‖1
current_state = next_state‖else:‖1
if visualization:‖from matplotlib import pyplot as plt‖2
plt.plot(range(iterations), scores)‖"plt.xlabel(""Iterations"")"‖2
"plt.xlabel(""Iterations"")"‖"plt.ylabel(""Function values"")"‖2
"plt.ylabel(""Function values"")"‖plt.show()‖2
def test_f1(x, y):‖return (x**2) + (y**2)‖2
prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)‖local_min = hill_climbing(prob, find_max=False)‖1
local_min = hill_climbing(prob, find_max=False)‖print(‖1
print(‖"""The minimum score for f(x, y) = x^2 + y^2 found via hill climbing: """‖1
"""The minimum score for f(x, y) = x^2 + y^2 found via hill climbing: """‖"f""{local_min.score()}"""‖1
"f""{local_min.score()}"""‖)‖4
prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)‖local_min = hill_climbing(‖1
local_min = hill_climbing(‖prob, find_max=False, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True‖1
prob, find_max=False, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True‖)‖2
print(‖"""The minimum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 """‖2
"""The minimum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 """‖"f""and 50 > y > - 5 found via hill climbing: {local_min.score()}"""‖2
"f""and 50 > y > - 5 found via hill climbing: {local_min.score()}"""‖)‖3
def test_f2(x, y):‖return (3 * x**2) - (6 * y)‖2
prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)‖local_min = hill_climbing(prob, find_max=True)‖1
local_min = hill_climbing(prob, find_max=True)‖print(‖1
print(‖"""The maximum score for f(x, y) = x^2 + y^2 found via hill climbing: """‖1
"""The maximum score for f(x, y) = x^2 + y^2 found via hill climbing: """‖"f""{local_min.score()}"""‖1
def rms_speed_of_molecule(temperature: float, molar_mass: float) -> float:‖if temperature < 0:‖1
if temperature < 0:‖"raise Exception(""Temperature cannot be less than 0 K"")"‖1
"raise Exception(""Temperature cannot be less than 0 K"")"‖if molar_mass <= 0:‖1
if molar_mass <= 0:‖"raise Exception(""Molar mass cannot be less than or equal to 0 kg/mol"")"‖1
"raise Exception(""Molar mass cannot be less than or equal to 0 kg/mol"")"‖else:‖1
else:‖return (3 * UNIVERSAL_GAS_CONSTANT * temperature / molar_mass) ** 0.5‖1
temperature = 300‖molar_mass = 28‖1
molar_mass = 28‖vrms = rms_speed_of_molecule(temperature, molar_mass)‖1
vrms = rms_speed_of_molecule(temperature, molar_mass)‖"print(f""Vrms of Nitrogen gas at 300 K is {vrms} m/s"")"‖1
import hashlib‖import importlib.util‖1
import importlib.util‖import json‖1
import json‖import os‖1
import os‖import pathlib‖1
import pathlib‖from types import ModuleType‖1
import pytest‖import requests‖1
"PROJECT_EULER_DIR_PATH = pathlib.Path.cwd().joinpath(""project_euler"")"‖PROJECT_EULER_ANSWERS_PATH = pathlib.Path.cwd().joinpath(‖1
PROJECT_EULER_ANSWERS_PATH = pathlib.Path.cwd().joinpath(‖"""scripts"", ""project_euler_answers.json"""‖1
"""scripts"", ""project_euler_answers.json"""‖)‖1
with open(PROJECT_EULER_ANSWERS_PATH) as file_handle:‖PROBLEM_ANSWERS: dict[str, str] = json.load(file_handle)‖1
def convert_path_to_module(file_path: pathlib.Path) -> ModuleType:‖spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))‖1
spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))‖module = importlib.util.module_from_spec(spec)‖1
module = importlib.util.module_from_spec(spec)‖spec.loader.exec_module(module)‖1
spec.loader.exec_module(module)‖return module‖1
def all_solution_file_paths() -> list[pathlib.Path]:‖solution_file_paths = []‖1
solution_file_paths = []‖for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():‖1
for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():‖"if problem_dir_path.is_file() or problem_dir_path.name.startswith(""_""):"‖1
"if problem_dir_path.is_file() or problem_dir_path.name.startswith(""_""):"‖continue‖1
continue‖for file_path in problem_dir_path.iterdir():‖1
for file_path in problem_dir_path.iterdir():‖"if file_path.suffix != "".py"" or file_path.name.startswith((""_"", ""test"")):"‖1
"if file_path.suffix != "".py"" or file_path.name.startswith((""_"", ""test"")):"‖continue‖1
continue‖solution_file_paths.append(file_path)‖1
solution_file_paths.append(file_path)‖return solution_file_paths‖1
def get_files_url() -> str:‖"with open(os.environ[""GITHUB_EVENT_PATH""]) as file:"‖1
"with open(os.environ[""GITHUB_EVENT_PATH""]) as file:"‖event = json.load(file)‖1
event = json.load(file)‖"return event[""pull_request""][""url""] + ""/files"""‖1
def added_solution_file_path() -> list[pathlib.Path]:‖solution_file_paths = []‖1
solution_file_paths = []‖headers = {‖1
headers = {‖"""Accept"": ""application/vnd.github.v3+json"","‖1
"""Accept"": ""application/vnd.github.v3+json"","‖"""Authorization"": ""token "" + os.environ[""GITHUB_TOKEN""],"‖1
"""Authorization"": ""token "" + os.environ[""GITHUB_TOKEN""],"‖}‖1
}‖files = requests.get(get_files_url(), headers=headers, timeout=10).json()‖1
files = requests.get(get_files_url(), headers=headers, timeout=10).json()‖for file in files:‖1
for file in files:‖"filepath = pathlib.Path.cwd().joinpath(file[""filename""])"‖1
"filepath = pathlib.Path.cwd().joinpath(file[""filename""])"‖if (‖1
if (‖"filepath.suffix != "".py"""‖1
"filepath.suffix != "".py"""‖"or filepath.name.startswith((""_"", ""test""))"‖1
"or filepath.name.startswith((""_"", ""test""))"‖"or not filepath.name.startswith(""sol"")"‖1
"or not filepath.name.startswith(""sol"")"‖):‖1
continue‖solution_file_paths.append(filepath)‖1
solution_file_paths.append(filepath)‖return solution_file_paths‖1
if (‖"os.environ.get(""CI"")"‖1
"os.environ.get(""CI"")"‖"and os.environ.get(""GITHUB_EVENT_NAME"") == ""pull_request"""‖1
"and os.environ.get(""GITHUB_EVENT_NAME"") == ""pull_request"""‖and (filepaths := added_solution_file_path())‖1
and (filepaths := added_solution_file_path())‖):‖1
):‖return filepaths‖1
return filepaths‖return all_solution_file_paths()‖1
@pytest.mark.parametrize(‖"""solution_path"","‖1
"""solution_path"","‖collect_solution_file_paths(),‖1
collect_solution_file_paths(),‖"ids=lambda path: f""{path.parent.name}/{path.name}"","‖1
"ids=lambda path: f""{path.parent.name}/{path.name}"","‖)‖1
)‖def test_project_euler(solution_path: pathlib.Path) -> None:‖1
problem_number: str = solution_path.parent.name[8:].zfill(3)‖expected: str = PROBLEM_ANSWERS[problem_number]‖1
expected: str = PROBLEM_ANSWERS[problem_number]‖solution_module = convert_path_to_module(solution_path)‖1
solution_module = convert_path_to_module(solution_path)‖answer = str(solution_module.solution())‖1
answer = str(solution_module.solution())‖answer = hashlib.sha256(answer.encode()).hexdigest()‖1
answer = hashlib.sha256(answer.encode()).hexdigest()‖assert answer == expected, (‖1
assert answer == expected, (‖"f""Expected solution to {problem_number} to have hash {expected}, got {answer}"""‖1
"f""Expected solution to {problem_number} to have hash {expected}, got {answer}"""‖)‖1
def calculate_waiting_times(burst_times: list[int]) -> list[int]:‖quantum = 2‖1
quantum = 2‖rem_burst_times = list(burst_times)‖1
rem_burst_times = list(burst_times)‖waiting_times = [0] * len(burst_times)‖1
waiting_times = [0] * len(burst_times)‖t = 0‖1
t = 0‖while True:‖1
while True:‖done = True‖1
done = True‖for i, burst_time in enumerate(burst_times):‖1
for i, burst_time in enumerate(burst_times):‖if rem_burst_times[i] > 0:‖1
if rem_burst_times[i] > 0:‖done = False‖1
done = False‖if rem_burst_times[i] > quantum:‖1
if rem_burst_times[i] > quantum:‖t += quantum‖1
t += quantum‖rem_burst_times[i] -= quantum‖1
rem_burst_times[i] -= quantum‖else:‖1
else:‖t += rem_burst_times[i]‖1
t += rem_burst_times[i]‖waiting_times[i] = t - burst_time‖1
waiting_times[i] = t - burst_time‖rem_burst_times[i] = 0‖1
rem_burst_times[i] = 0‖if done is True:‖1
if done is True:‖return waiting_times‖1
def calculate_turn_around_times(‖burst_times: list[int], waiting_times: list[int]‖1
burst_times: list[int], waiting_times: list[int]‖) -> list[int]:‖1
) -> list[int]:‖return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]‖1
"if __name__ == ""__main__"":"‖burst_times = [3, 5, 7]‖1
burst_times = [3, 5, 7]‖waiting_times = calculate_waiting_times(burst_times)‖1
waiting_times = calculate_waiting_times(burst_times)‖turn_around_times = calculate_turn_around_times(burst_times, waiting_times)‖1
turn_around_times = calculate_turn_around_times(burst_times, waiting_times)‖"print(""Process ID \tBurst Time \tWaiting Time \tTurnaround Time"")"‖1
"print(""Process ID \tBurst Time \tWaiting Time \tTurnaround Time"")"‖for i, burst_time in enumerate(burst_times):‖1
for i, burst_time in enumerate(burst_times):‖print(‖1
print(‖"f""  {i + 1}\t\t  {burst_time}\t\t  {waiting_times[i]}\t\t  """‖1
"f""  {i + 1}\t\t  {burst_time}\t\t  {waiting_times[i]}\t\t  """‖"f""{turn_around_times[i]}"""‖1
"f""{turn_around_times[i]}"""‖)‖1
)‖"print(f""\nAverage waiting time = {mean(waiting_times):.5f}"")"‖1
"print(f""\nAverage waiting time = {mean(waiting_times):.5f}"")"‖"print(f""Average turn around time = {mean(turn_around_times):.5f}"")"‖1
def sentinel_linear_search(sequence, target):‖sequence.append(target)‖1
index = 0‖while sequence[index] != target:‖1
while sequence[index] != target:‖index += 1‖1
if index == len(sequence):‖return None‖1
"if __name__ == ""__main__"":"‖"user_input = input(""Enter numbers separated by comma:\n"").strip()"‖3
"user_input = input(""Enter numbers separated by comma:\n"").strip()"‖"sequence = [int(item) for item in user_input.split("","")]"‖1
"target_input = input(""Enter a single number to be found in the list:\n"")"‖target = int(target_input)‖1
target = int(target_input)‖result = sentinel_linear_search(sequence, target)‖1
result = sentinel_linear_search(sequence, target)‖if result is not None:‖1
if result is not None:‖"print(f""{target} found at positions: {result}"")"‖1
"print(f""{target} found at positions: {result}"")"‖else:‖1
else:‖"print(""Not found"")"‖2
def median_of_five(arr: list) -> int:‖arr = sorted(arr)‖1
arr = sorted(arr)‖return arr[len(arr) // 2]‖1
if len(arr) <= 5:‖return median_of_five(arr)‖1
return median_of_five(arr)‖medians = []‖1
medians = []‖i = 0‖1
i = 0‖while i < len(arr):‖1
while i < len(arr):‖if (i + 4) <= len(arr):‖1
if (i + 4) <= len(arr):‖medians.append(median_of_five(arr[i:].copy()))‖1
medians.append(median_of_five(arr[i:].copy()))‖else:‖1
else:‖medians.append(median_of_five(arr[i : i + 5].copy()))‖1
medians.append(median_of_five(arr[i : i + 5].copy()))‖i += 5‖1
i += 5‖return median_of_medians(medians)‖1
if target > len(arr):‖return -1‖1
x = median_of_medians(arr)‖left = []‖1
left = []‖right = []‖1
right = []‖check = False‖1
check = False‖for i in range(len(arr)):‖1
for i in range(len(arr)):‖if arr[i] < x:‖1
if arr[i] < x:‖left.append(arr[i])‖1
left.append(arr[i])‖elif arr[i] > x:‖1
elif arr[i] > x:‖right.append(arr[i])‖1
right.append(arr[i])‖elif arr[i] == x and not check:‖1
elif arr[i] == x and not check:‖check = True‖1
check = True‖else:‖1
else:‖right.append(arr[i])‖1
right.append(arr[i])‖rank_x = len(left) + 1‖1
rank_x = len(left) + 1‖if rank_x == target:‖1
if rank_x == target:‖answer = x‖1
answer = x‖elif rank_x > target:‖1
elif rank_x > target:‖answer = quick_select(left, target)‖1
answer = quick_select(left, target)‖elif rank_x < target:‖1
elif rank_x < target:‖answer = quick_select(right, target - rank_x)‖1
answer = quick_select(right, target - rank_x)‖return answer‖1
import argparse‖import copy‖1
with open(path) as f:‖for line in f:‖1
for line in f:‖if line.split()[0] not in dict_of_neighbours:‖1
if line.split()[0] not in dict_of_neighbours:‖_list = []‖1
_list = []‖_list.append([line.split()[1], line.split()[2]])‖1
_list.append([line.split()[1], line.split()[2]])‖dict_of_neighbours[line.split()[0]] = _list‖1
dict_of_neighbours[line.split()[0]] = _list‖else:‖1
else:‖dict_of_neighbours[line.split()[0]].append(‖1
dict_of_neighbours[line.split()[0]].append(‖[line.split()[1], line.split()[2]]‖1
[line.split()[1], line.split()[2]]‖)‖1
)‖if line.split()[1] not in dict_of_neighbours:‖1
if line.split()[1] not in dict_of_neighbours:‖_list = []‖1
_list = []‖_list.append([line.split()[0], line.split()[2]])‖1
_list.append([line.split()[0], line.split()[2]])‖dict_of_neighbours[line.split()[1]] = _list‖1
dict_of_neighbours[line.split()[1]] = _list‖else:‖1
else:‖dict_of_neighbours[line.split()[1]].append(‖1
dict_of_neighbours[line.split()[1]].append(‖[line.split()[0], line.split()[2]]‖1
[line.split()[0], line.split()[2]]‖)‖1
with open(path) as f:‖start_node = f.read(1)‖1
start_node = f.read(1)‖end_node = start_node‖1
distance_of_first_solution = 0‖while visiting not in first_solution:‖1
while visiting not in first_solution:‖minim = 10000‖1
minim = 10000‖for k in dict_of_neighbours[visiting]:‖1
for k in dict_of_neighbours[visiting]:‖if int(k[1]) < int(minim) and k[0] not in first_solution:‖1
if int(k[1]) < int(minim) and k[0] not in first_solution:‖minim = k[1]‖1
minim = k[1]‖best_node = k[0]‖1
first_solution.append(visiting)‖distance_of_first_solution = distance_of_first_solution + int(minim)‖1
distance_of_first_solution = distance_of_first_solution + int(minim)‖visiting = best_node‖1
position = 0‖for k in dict_of_neighbours[first_solution[-2]]:‖1
for k in dict_of_neighbours[first_solution[-2]]:‖if k[0] == start_node:‖1
if k[0] == start_node:‖break‖1
break‖position += 1‖1
distance_of_first_solution = (‖distance_of_first_solution‖1
distance_of_first_solution‖+ int(dict_of_neighbours[first_solution[-2]][position][1])‖1
+ int(dict_of_neighbours[first_solution[-2]][position][1])‖- 10000‖1
- 10000‖)‖1
)‖return first_solution, distance_of_first_solution‖1
for n in solution[1:-1]:‖idx1 = solution.index(n)‖1
idx1 = solution.index(n)‖for kn in solution[1:-1]:‖1
for kn in solution[1:-1]:‖idx2 = solution.index(kn)‖1
idx2 = solution.index(kn)‖if n == kn:‖1
if n == kn:‖continue‖1
_tmp = copy.deepcopy(solution)‖_tmp[idx1] = kn‖1
_tmp[idx1] = kn‖_tmp[idx2] = n‖1
for k in _tmp[:-1]:‖next_node = _tmp[_tmp.index(k) + 1]‖1
next_node = _tmp[_tmp.index(k) + 1]‖for i in dict_of_neighbours[k]:‖1
for i in dict_of_neighbours[k]:‖if i[0] == next_node:‖1
if i[0] == next_node:‖distance = distance + int(i[1])‖1
distance = distance + int(i[1])‖_tmp.append(distance)‖1
if _tmp not in neighborhood_of_solution:‖neighborhood_of_solution.append(_tmp)‖1
neighborhood_of_solution.sort(key=lambda x: x[index_of_last_item_in_the_list])‖return neighborhood_of_solution‖1
def tabu_search(‖first_solution, distance_of_first_solution, dict_of_neighbours, iters, size‖1
first_solution, distance_of_first_solution, dict_of_neighbours, iters, size‖):‖1
):‖count = 1‖1
count = 1‖solution = first_solution‖1
solution = first_solution‖tabu_list = []‖1
tabu_list = []‖best_cost = distance_of_first_solution‖1
best_cost = distance_of_first_solution‖best_solution_ever = solution‖1
while count <= iters:‖neighborhood = find_neighborhood(solution, dict_of_neighbours)‖1
neighborhood = find_neighborhood(solution, dict_of_neighbours)‖index_of_best_solution = 0‖1
index_of_best_solution = 0‖best_solution = neighborhood[index_of_best_solution]‖1
best_solution = neighborhood[index_of_best_solution]‖best_cost_index = len(best_solution) - 1‖1
found = False‖while not found:‖1
while not found:‖i = 0‖1
i = 0‖while i < len(best_solution):‖1
while i < len(best_solution):‖if best_solution[i] != solution[i]:‖1
if best_solution[i] != solution[i]:‖first_exchange_node = best_solution[i]‖1
first_exchange_node = best_solution[i]‖second_exchange_node = solution[i]‖1
second_exchange_node = solution[i]‖break‖1
break‖i = i + 1‖1
if [first_exchange_node, second_exchange_node] not in tabu_list and [‖second_exchange_node,‖1
second_exchange_node,‖first_exchange_node,‖1
first_exchange_node,‖] not in tabu_list:‖1
] not in tabu_list:‖tabu_list.append([first_exchange_node, second_exchange_node])‖1
tabu_list.append([first_exchange_node, second_exchange_node])‖found = True‖1
found = True‖solution = best_solution[:-1]‖1
solution = best_solution[:-1]‖cost = neighborhood[index_of_best_solution][best_cost_index]‖1
cost = neighborhood[index_of_best_solution][best_cost_index]‖if cost < best_cost:‖1
if cost < best_cost:‖best_cost = cost‖1
best_cost = cost‖best_solution_ever = solution‖1
best_solution_ever = solution‖else:‖1
else:‖index_of_best_solution = index_of_best_solution + 1‖1
index_of_best_solution = index_of_best_solution + 1‖best_solution = neighborhood[index_of_best_solution]‖1
if len(tabu_list) >= size:‖tabu_list.pop(0)‖1
def main(args=None):‖dict_of_neighbours = generate_neighbours(args.File)‖1
first_solution, distance_of_first_solution = generate_first_solution(‖args.File, dict_of_neighbours‖1
args.File, dict_of_neighbours‖)‖1
best_sol, best_cost = tabu_search(‖first_solution,‖1
first_solution,‖distance_of_first_solution,‖1
distance_of_first_solution,‖dict_of_neighbours,‖1
dict_of_neighbours,‖args.Iterations,‖1
args.Iterations,‖args.Size,‖1
args.Size,‖)‖1
"if __name__ == ""__main__"":"‖"parser = argparse.ArgumentParser(description=""Tabu Search"")"‖1
"parser = argparse.ArgumentParser(description=""Tabu Search"")"‖parser.add_argument(‖1
parser.add_argument(‖"""-f"","‖1
"""-f"","‖"""--File"","‖1
"""--File"","‖type=str,‖1
type=str,‖"help=""Path to the file containing the data"","‖1
"help=""Path to the file containing the data"","‖required=True,‖1
required=True,‖)‖2
parser.add_argument(‖"""-i"","‖1
"""-i"","‖"""--Iterations"","‖1
"""--Iterations"","‖type=int,‖1
type=int,‖"help=""How many iterations the algorithm should perform"","‖1
"help=""How many iterations the algorithm should perform"","‖required=True,‖1
parser.add_argument(‖"""-s"", ""--Size"", type=int, help=""Size of the tabu list"", required=True"‖1
"""-s"", ""--Size"", type=int, help=""Size of the tabu list"", required=True"‖)‖1
def interpolation_search(sorted_collection: list[int], item: int) -> int | None:‖left = 0‖1
left = 0‖right = len(sorted_collection) - 1‖2
if sorted_collection[left] == sorted_collection[right]:‖if sorted_collection[left] == item:‖2
if sorted_collection[left] == item:‖return left‖2
return left‖return None‖2
point = left + ((item - sorted_collection[left]) * (right - left)) // (‖sorted_collection[right] - sorted_collection[left]‖2
sorted_collection[right] - sorted_collection[left]‖)‖2
if point < 0 or point >= len(sorted_collection):‖return None‖2
current_item = sorted_collection[point]‖if current_item == item:‖1
if current_item == item:‖return point‖1
return point‖if point < left:‖2
if point < left:‖right = left‖1
right = left‖left = point‖1
left = point‖elif point > right:‖1
elif point > right:‖left = right‖1
left = right‖right = point‖1
right = point‖elif item < current_item:‖1
elif item < current_item:‖right = point - 1‖1
right = point - 1‖else:‖1
else:‖left = point + 1‖1
left = point + 1‖return None‖1
def interpolation_search_by_recursion(‖sorted_collection: list[int], item: int, left: int = 0, right: int | None = None‖1
sorted_collection: list[int], item: int, left: int = 0, right: int | None = None‖) -> int | None:‖1
) -> int | None:‖if right is None:‖1
if right is None:‖right = len(sorted_collection) - 1‖1
if sorted_collection[point] == item:‖return point‖1
if point < left:‖return interpolation_search_by_recursion(sorted_collection, item, point, left)‖1
return interpolation_search_by_recursion(sorted_collection, item, point, left)‖if point > right:‖1
if point > right:‖return interpolation_search_by_recursion(sorted_collection, item, right, left)‖1
return interpolation_search_by_recursion(sorted_collection, item, right, left)‖if sorted_collection[point] > item:‖1
if sorted_collection[point] > item:‖return interpolation_search_by_recursion(‖1
return interpolation_search_by_recursion(‖sorted_collection, item, left, point - 1‖1
sorted_collection, item, left, point - 1‖)‖1
)‖return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)‖1
import math‖from collections.abc import Sequence‖1
from collections.abc import Sequence‖from typing import Any, Protocol, TypeVar‖1
class Comparable(Protocol):‖def __lt__(self, other: Any, /) -> bool: ...‖2
arr_size = len(arr)‖block_size = int(math.sqrt(arr_size))‖1
prev = 0‖step = block_size‖1
step = block_size‖while arr[min(step, arr_size) - 1] < item:‖1
while arr[min(step, arr_size) - 1] < item:‖prev = step‖1
prev = step‖step += block_size‖1
step += block_size‖if prev >= arr_size:‖1
if prev >= arr_size:‖return -1‖1
while arr[prev] < item:‖prev += 1‖1
prev += 1‖if prev == min(step, arr_size):‖1
if prev == min(step, arr_size):‖return -1‖1
return -1‖if arr[prev] == item:‖1
if arr[prev] == item:‖return prev‖1
return prev‖return -1‖1
"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖"array = [int(item) for item in user_input.split("","")]"‖1
"array = [int(item) for item in user_input.split("","")]"‖"x = int(input(""Enter the number to be searched:\n""))"‖1
res = jump_search(array, x)‖if res == -1:‖1
if res == -1:‖"print(""Number not found!"")"‖1
"print(""Number not found!"")"‖else:‖1
else:‖"print(f""Number {x} is at index {res}"")"‖1
def bisect_left(‖sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1‖1
sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1‖) -> int:‖2
) -> int:‖if hi < 0:‖2
if hi < 0:‖hi = len(sorted_collection)‖2
while lo < hi:‖mid = lo + (hi - lo) // 2‖2
mid = lo + (hi - lo) // 2‖if sorted_collection[mid] < item:‖1
if sorted_collection[mid] < item:‖lo = mid + 1‖1
lo = mid + 1‖else:‖2
else:‖hi = mid‖2
def bisect_right(‖sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1‖1
mid = lo + (hi - lo) // 2‖if sorted_collection[mid] <= item:‖1
if sorted_collection[mid] <= item:‖lo = mid + 1‖1
def insort_left(‖sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1‖1
sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1‖) -> None:‖2
) -> None:‖sorted_collection.insert(bisect_left(sorted_collection, item, lo, hi), item)‖1
def insort_right(‖sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1‖1
) -> None:‖sorted_collection.insert(bisect_right(sorted_collection, item, lo, hi), item)‖1
def binary_search(sorted_collection: list[int], item: int) -> int:‖if list(sorted_collection) != sorted(sorted_collection):‖1
if list(sorted_collection) != sorted(sorted_collection):‖"raise ValueError(""sorted_collection must be sorted in ascending order"")"‖6
"raise ValueError(""sorted_collection must be sorted in ascending order"")"‖left = 0‖1
while left <= right:‖midpoint = left + (right - left) // 2‖1
midpoint = left + (right - left) // 2‖current_item = sorted_collection[midpoint]‖1
current_item = sorted_collection[midpoint]‖if current_item == item:‖1
if current_item == item:‖return midpoint‖1
return midpoint‖elif item < current_item:‖1
elif item < current_item:‖right = midpoint - 1‖1
right = midpoint - 1‖else:‖1
else:‖left = midpoint + 1‖1
left = midpoint + 1‖return -1‖1
def binary_search_std_lib(sorted_collection: list[int], item: int) -> int:‖if list(sorted_collection) != sorted(sorted_collection):‖1
"raise ValueError(""sorted_collection must be sorted in ascending order"")"‖index = bisect.bisect_left(sorted_collection, item)‖1
index = bisect.bisect_left(sorted_collection, item)‖if index != len(sorted_collection) and sorted_collection[index] == item:‖1
if index != len(sorted_collection) and sorted_collection[index] == item:‖return index‖1
return index‖return -1‖2
def binary_search_by_recursion(‖sorted_collection: list[int], item: int, left: int = 0, right: int = -1‖2
sorted_collection: list[int], item: int, left: int = 0, right: int = -1‖) -> int:‖2
) -> int:‖if right < 0:‖2
if right < 0:‖right = len(sorted_collection) - 1‖2
right = len(sorted_collection) - 1‖if list(sorted_collection) != sorted(sorted_collection):‖2
"raise ValueError(""sorted_collection must be sorted in ascending order"")"‖if right < left:‖2
if right < left:‖return -1‖2
if sorted_collection[midpoint] == item:‖return midpoint‖2
return midpoint‖elif sorted_collection[midpoint] > item:‖2
elif sorted_collection[midpoint] > item:‖return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)‖2
return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)‖else:‖2
else:‖return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)‖2
def exponential_search(sorted_collection: list[int], item: int) -> int:‖if list(sorted_collection) != sorted(sorted_collection):‖2
"raise ValueError(""sorted_collection must be sorted in ascending order"")"‖bound = 1‖1
bound = 1‖while bound < len(sorted_collection) and sorted_collection[bound] < item:‖2
while bound < len(sorted_collection) and sorted_collection[bound] < item:‖bound *= 2‖2
bound *= 2‖left = bound // 2‖1
left = bound // 2‖right = min(bound, len(sorted_collection) - 1)‖2
right = min(bound, len(sorted_collection) - 1)‖last_result = binary_search_by_recursion(‖1
last_result = binary_search_by_recursion(‖sorted_collection=sorted_collection, item=item, left=left, right=right‖1
sorted_collection=sorted_collection, item=item, left=left, right=right‖)‖1
)‖if last_result is None:‖1
if last_result is None:‖return -1‖1
return -1‖return last_result‖1
searches = (‖binary_search_std_lib,‖1
binary_search_std_lib,‖binary_search,‖1
binary_search,‖exponential_search,‖1
exponential_search,‖binary_search_by_recursion,‖1
binary_search_by_recursion,‖)‖1
import doctest‖import timeit‖1
doctest.testmod()‖for search in searches:‖1
for search in searches:‖"name = f""{search.__name__:>26}"""‖1
"name = f""{search.__name__:>26}"""‖"print(f""{name}: {search([0, 5, 7, 10, 15], 10) = }"")"‖1
"print(""\nBenchmarks..."")"‖"setup = ""collection = range(1000)"""‖1
"setup = ""collection = range(1000)"""‖for search in searches:‖1
for search in searches:‖name = search.__name__‖1
name = search.__name__‖print(‖1
print(‖"f""{name:>26}:"","‖1
"f""{name:>26}:"","‖timeit.timeit(‖1
timeit.timeit(‖"f""{name}(collection, 500)"", setup=setup, number=5_000, globals=globals()"‖1
"f""{name}(collection, 500)"", setup=setup, number=5_000, globals=globals()"‖),‖1
"user_input = input(""\nEnter numbers separated by comma: "").strip()"‖"collection = sorted(int(item) for item in user_input.split("",""))"‖1
"collection = sorted(int(item) for item in user_input.split("",""))"‖"target = int(input(""Enter a single number to be found in the list: ""))"‖1
"target = int(input(""Enter a single number to be found in the list: ""))"‖result = binary_search(sorted_collection=collection, item=target)‖1
result = binary_search(sorted_collection=collection, item=target)‖if result == -1:‖1
if result == -1:‖"print(f""{target} was not found in {collection}."")"‖2
"print(f""{target} was not found in {collection}."")"‖else:‖2
else:‖"print(f""{target} was found at position {result} of {collection}."")"‖1
def _partition(data: list, pivot) -> tuple:‖less, equal, greater = [], [], []‖1
less, equal, greater = [], [], []‖for element in data:‖1
for element in data:‖if element < pivot:‖1
if element < pivot:‖less.append(element)‖1
less.append(element)‖elif element > pivot:‖1
elif element > pivot:‖greater.append(element)‖1
greater.append(element)‖else:‖1
else:‖equal.append(element)‖1
equal.append(element)‖return less, equal, greater‖1
if index >= len(items) or index < 0:‖return None‖1
pivot = items[random.randint(0, len(items) - 1)]‖count = 0‖1
count = 0‖smaller, equal, larger = _partition(items, pivot)‖1
smaller, equal, larger = _partition(items, pivot)‖count = len(equal)‖1
count = len(equal)‖m = len(smaller)‖1
if m <= index < m + count:‖return pivot‖1
elif m > index:‖return quick_select(smaller, index)‖1
else:‖return quick_select(larger, index - (m + count))‖1
def simulated_annealing(‖search_prob,‖1
visualization: bool = False,‖start_temperate: float = 100,‖1
start_temperate: float = 100,‖rate_of_decrease: float = 0.01,‖1
rate_of_decrease: float = 0.01,‖threshold_temp: float = 1,‖1
threshold_temp: float = 1,‖) -> Any:‖1
) -> Any:‖search_end = False‖1
search_end = False‖current_state = search_prob‖1
current_state = search_prob‖current_temp = start_temperate‖1
current_temp = start_temperate‖scores = []‖1
iterations = 0‖best_state = None‖1
while not search_end:‖current_score = current_state.score()‖1
current_score = current_state.score()‖if best_state is None or current_score > best_state.score():‖1
if best_state is None or current_score > best_state.score():‖best_state = current_state‖1
best_state = current_state‖scores.append(current_score)‖1
scores.append(current_score)‖iterations += 1‖1
iterations += 1‖next_state = None‖1
next_state = None‖neighbors = current_state.get_neighbors()‖1
neighbors = current_state.get_neighbors()‖while (‖1
while (‖next_state is None and neighbors‖1
next_state is None and neighbors‖):‖1
):‖index = random.randint(0, len(neighbors) - 1)‖1
index = random.randint(0, len(neighbors) - 1)‖picked_neighbor = neighbors.pop(index)‖1
picked_neighbor = neighbors.pop(index)‖change = picked_neighbor.score() - current_score‖1
if (‖picked_neighbor.x > max_x‖1
picked_neighbor.x > max_x‖or picked_neighbor.x < min_x‖1
or picked_neighbor.x < min_x‖or picked_neighbor.y > max_y‖1
or picked_neighbor.y > max_y‖or picked_neighbor.y < min_y‖1
or picked_neighbor.y < min_y‖):‖1
if not find_max:‖change = change * -1‖1
change = change * -1‖if change > 0:‖1
if change > 0:‖next_state = picked_neighbor‖1
next_state = picked_neighbor‖else:‖1
else:‖probability = (math.e) ** (‖1
probability = (math.e) ** (‖change / current_temp‖1
change / current_temp‖)‖1
)‖if random.random() < probability:‖1
if random.random() < probability:‖next_state = picked_neighbor‖1
next_state = picked_neighbor‖current_temp = current_temp - (current_temp * rate_of_decrease)‖1
search_end = True‖else:‖1
else:‖current_state = next_state‖3
plt.show()‖return best_state‖1
prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)‖local_min = simulated_annealing(‖2
local_min = simulated_annealing(‖prob, find_max=False, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True‖1
local_min = simulated_annealing(‖prob, find_max=True, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True‖1
prob, find_max=True, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True‖)‖1
print(‖"""The maximum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 """‖1
"""The maximum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 """‖"f""and 50 > y > - 5 found via hill climbing: {local_min.score()}"""‖1
prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)‖local_min = simulated_annealing(prob, find_max=False, visualization=True)‖1
local_min = simulated_annealing(prob, find_max=False, visualization=True)‖print(‖1
print(‖"""The minimum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: """‖1
"""The minimum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: """‖"f""{local_min.score()}"""‖1
prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)‖local_min = simulated_annealing(prob, find_max=True, visualization=True)‖1
local_min = simulated_annealing(prob, find_max=True, visualization=True)‖print(‖1
print(‖"""The maximum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: """‖1
"""The maximum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: """‖"f""{local_min.score()}"""‖1
def bead_sort(sequence: list) -> list:‖if any(not isinstance(x, int) or x < 0 for x in sequence):‖1
if any(not isinstance(x, int) or x < 0 for x in sequence):‖"raise TypeError(""Sequence must be list of non-negative integers"")"‖1
"raise TypeError(""Sequence must be list of non-negative integers"")"‖for _ in range(len(sequence)):‖1
for _ in range(len(sequence)):‖for i, (rod_upper, rod_lower) in enumerate(zip(sequence, sequence[1:])):‖1
for i, (rod_upper, rod_lower) in enumerate(zip(sequence, sequence[1:])):‖if rod_upper > rod_lower:‖1
if rod_upper > rod_lower:‖sequence[i] -= rod_upper - rod_lower‖1
sequence[i] -= rod_upper - rod_lower‖sequence[i + 1] += rod_upper - rod_lower‖1
sequence[i + 1] += rod_upper - rod_lower‖return sequence‖1
"if __name__ == ""__main__"":"‖assert bead_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]‖1
assert bead_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]‖assert bead_sort([7, 9, 4, 3, 5]) == [3, 4, 5, 7, 9]‖1
def bubble_sort_iterative(collection: list[Any]) -> list[Any]:‖length = len(collection)‖1
length = len(collection)‖for i in reversed(range(length)):‖1
for i in reversed(range(length)):‖swapped = False‖1
swapped = False‖for j in range(i):‖1
for j in range(i):‖if collection[j] > collection[j + 1]:‖1
if collection[j] > collection[j + 1]:‖swapped = True‖1
swapped = True‖collection[j], collection[j + 1] = collection[j + 1], collection[j]‖1
collection[j], collection[j + 1] = collection[j + 1], collection[j]‖if not swapped:‖1
if not swapped:‖break‖3
break‖return collection‖1
def bubble_sort_recursive(collection: list[Any]) -> list[Any]:‖length = len(collection)‖1
length = len(collection)‖swapped = False‖1
swapped = False‖for i in range(length - 1):‖1
for i in range(length - 1):‖if collection[i] > collection[i + 1]:‖1
if collection[i] > collection[i + 1]:‖collection[i], collection[i + 1] = collection[i + 1], collection[i]‖1
collection[i], collection[i + 1] = collection[i + 1], collection[i]‖swapped = True‖1
import doctest‖from random import sample‖1
from random import sample‖from timeit import timeit‖1
num_runs = 10_000‖unsorted = sample(range(-50, 50), 100)‖1
unsorted = sample(range(-50, 50), 100)‖timer_iterative = timeit(‖1
timer_iterative = timeit(‖"""bubble_sort_iterative(unsorted[:])"", globals=globals(), number=num_runs"‖1
"""bubble_sort_iterative(unsorted[:])"", globals=globals(), number=num_runs"‖)‖1
)‖"print(""\nIterative bubble sort:"")"‖1
"print(""\nIterative bubble sort:"")"‖"print(*bubble_sort_iterative(unsorted), sep="","")"‖1
"print(*bubble_sort_iterative(unsorted), sep="","")"‖"print(f""Processing time (iterative): {timer_iterative:.5f}s for {num_runs:,} runs"")"‖1
unsorted = sample(range(-50, 50), 100)‖timer_recursive = timeit(‖1
timer_recursive = timeit(‖"""bubble_sort_recursive(unsorted[:])"", globals=globals(), number=num_runs"‖1
"""bubble_sort_recursive(unsorted[:])"", globals=globals(), number=num_runs"‖)‖1
)‖"print(""\nRecursive bubble sort:"")"‖1
"print(""\nRecursive bubble sort:"")"‖"print(*bubble_sort_recursive(unsorted), sep="","")"‖1
"print(*bubble_sort_recursive(unsorted), sep="","")"‖"print(f""Processing time (recursive): {timer_recursive:.5f}s for {num_runs:,} runs"")"‖1
def linear_search(sequence: list, target: int) -> int:‖for index, item in enumerate(sequence):‖1
for index, item in enumerate(sequence):‖if item == target:‖1
if item == target:‖return index‖1
def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:‖if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):‖1
if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):‖"raise Exception(""Invalid upper or lower bound!"")"‖1
"raise Exception(""Invalid upper or lower bound!"")"‖if high < low:‖1
if high < low:‖return -1‖1
return -1‖if sequence[low] == target:‖1
if sequence[low] == target:‖return low‖1
return low‖if sequence[high] == target:‖1
if sequence[high] == target:‖return high‖1
return high‖return rec_linear_search(sequence, low + 1, high - 1, target)‖1
"user_input = input(""Enter numbers separated by comma:\n"").strip()"‖"sequence = [int(item.strip()) for item in user_input.split("","")]"‖2
"target = int(input(""Enter a single number to be found in the list:\n"").strip())"‖result = linear_search(sequence, target)‖1
result = linear_search(sequence, target)‖if result != -1:‖1
if result != -1:‖"print(f""linear_search({sequence}, {target}) = {result}"")"‖1
"print(f""linear_search({sequence}, {target}) = {result}"")"‖else:‖1
else:‖"print(f""{target} was not found in {sequence}"")"‖1
if sorted_collection[0] == item:‖return 0‖1
right = min(bound, len(sorted_collection) - 1)‖return binary_search_by_recursion(sorted_collection, item, left, right)‖1
"user_input = input(""Enter numbers separated by commas: "").strip()"‖"collection = sorted(int(item) for item in user_input.split("",""))"‖1
"collection = sorted(int(item) for item in user_input.split("",""))"‖"target = int(input(""Enter a number to search for: ""))"‖1
"target = int(input(""Enter a number to search for: ""))"‖result = exponential_search(sorted_collection=collection, item=target)‖1
result = exponential_search(sorted_collection=collection, item=target)‖if result == -1:‖1
else:‖"print(f""{target} was found at index {result} in {collection}."")"‖1
def is_sorted(collection):‖for i in range(len(collection) - 1):‖1
for i in range(len(collection) - 1):‖if collection[i] > collection[i + 1]:‖1
if collection[i] > collection[i + 1]:‖return False‖1
while not is_sorted(collection):‖random.shuffle(collection)‖1
random.shuffle(collection)‖return collection‖1
"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖"unsorted = [int(item) for item in user_input.split("","")]"‖18
"unsorted = [int(item) for item in user_input.split("","")]"‖print(bogo_sort(unsorted))‖1
def lin_search(left: int, right: int, array: list[int], target: int) -> int:‖for i in range(left, right):‖1
for i in range(left, right):‖if array[i] == target:‖1
if array[i] == target:‖return i‖1
return i‖return -1‖2
left = 0‖right = len(array)‖1
right = len(array)‖while left <= right:‖1
while left <= right:‖if right - left < precision:‖1
if right - left < precision:‖return lin_search(left, right, array, target)‖2
one_third = (left + right) // 3 + 1‖two_third = 2 * (left + right) // 3 + 1‖2
if array[one_third] == target:‖return one_third‖2
return one_third‖elif array[two_third] == target:‖2
elif array[two_third] == target:‖return two_third‖2
elif target < array[one_third]:‖right = one_third - 1‖1
right = one_third - 1‖elif array[two_third] < target:‖1
elif array[two_third] < target:‖left = two_third + 1‖1
else:‖left = one_third + 1‖1
left = one_third + 1‖right = two_third - 1‖1
right = two_third - 1‖return -1‖1
def rec_ternary_search(left: int, right: int, array: list[int], target: int) -> int:‖if left < right:‖1
if left < right:‖if right - left < precision:‖1
return lin_search(left, right, array, target)‖one_third = (left + right) // 3 + 1‖1
elif target < array[one_third]:‖return rec_ternary_search(left, one_third - 1, array, target)‖1
return rec_ternary_search(left, one_third - 1, array, target)‖elif array[two_third] < target:‖1
elif array[two_third] < target:‖return rec_ternary_search(two_third + 1, right, array, target)‖1
return rec_ternary_search(two_third + 1, right, array, target)‖else:‖1
else:‖return rec_ternary_search(one_third + 1, two_third - 1, array, target)‖1
return rec_ternary_search(one_third + 1, two_third - 1, array, target)‖else:‖1
"user_input = input(""Enter numbers separated by comma:\n"").strip()"‖"collection = [int(item.strip()) for item in user_input.split("","")]"‖1
"collection = [int(item.strip()) for item in user_input.split("","")]"‖"assert collection == sorted(collection), f""List must be ordered.\n{collection}."""‖1
"assert collection == sorted(collection), f""List must be ordered.\n{collection}."""‖"target = int(input(""Enter the number to be found in the list:\n"").strip())"‖1
"target = int(input(""Enter the number to be found in the list:\n"").strip())"‖result1 = ite_ternary_search(collection, target)‖1
result1 = ite_ternary_search(collection, target)‖result2 = rec_ternary_search(0, len(collection) - 1, collection, target)‖1
result2 = rec_ternary_search(0, len(collection) - 1, collection, target)‖if result2 != -1:‖1
if result2 != -1:‖"print(f""Iterative search: {target} found at positions: {result1}"")"‖1
"print(f""Iterative search: {target} found at positions: {result1}"")"‖"print(f""Recursive search: {target} found at positions: {result2}"")"‖1
"print(f""Recursive search: {target} found at positions: {result2}"")"‖else:‖1
def comb_sort(data: list) -> list:‖shrink_factor = 1.3‖1
shrink_factor = 1.3‖gap = len(data)‖1
gap = len(data)‖completed = False‖1
gap = int(gap / shrink_factor)‖if gap <= 1:‖1
if gap <= 1:‖completed = True‖1
index = 0‖while index + gap < len(data):‖1
while index + gap < len(data):‖if data[index] > data[index + gap]:‖1
data[index], data[index + gap] = data[index + gap], data[index]‖completed = False‖1
completed = False‖index += 1‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(comb_sort(unsorted))‖1
if len(my_list) == 0 or bucket_count <= 0:‖return []‖1
min_value, max_value = min(my_list), max(my_list)‖bucket_size = (max_value - min_value) / bucket_count‖1
bucket_size = (max_value - min_value) / bucket_count‖buckets: list[list] = [[] for _ in range(bucket_count)]‖1
for val in my_list:‖index = min(int((val - min_value) / bucket_size), bucket_count - 1)‖1
index = min(int((val - min_value) / bucket_size), bucket_count - 1)‖buckets[index].append(val)‖1
testmod()‖assert bucket_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]‖1
assert bucket_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]‖assert bucket_sort([0, 1, -10, 15, 2, -2]) == [-10, -2, 0, 1, 2, 15]‖1
class TreeNode:‖def __init__(self, data):‖1
self.data = data‖self.right = None‖1
self.right = None‖self.left = None‖1
def build_tree() -> TreeNode:‖"print(""\n********Press N to stop entering at any point of time********\n"")"‖1
"print(""\n********Press N to stop entering at any point of time********\n"")"‖"check = input(""Enter the value of the root node: "").strip().lower()"‖1
"check = input(""Enter the value of the root node: "").strip().lower()"‖q: queue.Queue = queue.Queue()‖1
q: queue.Queue = queue.Queue()‖tree_node = TreeNode(int(check))‖1
tree_node = TreeNode(int(check))‖q.put(tree_node)‖1
q.put(tree_node)‖while not q.empty():‖1
while not q.empty():‖node_found = q.get()‖1
node_found = q.get()‖"msg = f""Enter the left node of {node_found.data}: """‖1
"msg = f""Enter the left node of {node_found.data}: """‖"check = input(msg).strip().lower() or ""n"""‖1
"check = input(msg).strip().lower() or ""n"""‖"if check == ""n"":"‖2
"if check == ""n"":"‖return tree_node‖2
return tree_node‖left_node = TreeNode(int(check))‖1
left_node = TreeNode(int(check))‖node_found.left = left_node‖1
node_found.left = left_node‖q.put(left_node)‖1
q.put(left_node)‖"msg = f""Enter the right node of {node_found.data}: """‖1
"msg = f""Enter the right node of {node_found.data}: """‖"check = input(msg).strip().lower() or ""n"""‖1
return tree_node‖right_node = TreeNode(int(check))‖1
right_node = TreeNode(int(check))‖node_found.right = right_node‖1
node_found.right = right_node‖q.put(right_node)‖1
q.put(right_node)‖"raise ValueError(""Something went wrong"")"‖1
def pre_order(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
if not isinstance(node, TreeNode) or not node:‖return‖8
return‖"print(node.data, end="","")"‖1
"print(node.data, end="","")"‖pre_order(node.left)‖1
pre_order(node.left)‖pre_order(node.right)‖1
def in_order(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
return‖in_order(node.left)‖1
in_order(node.left)‖"print(node.data, end="","")"‖1
"print(node.data, end="","")"‖in_order(node.right)‖1
def post_order(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
return‖post_order(node.left)‖1
post_order(node.left)‖post_order(node.right)‖1
post_order(node.right)‖"print(node.data, end="","")"‖1
def level_order(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
return‖q: queue.Queue = queue.Queue()‖2
q: queue.Queue = queue.Queue()‖q.put(node)‖2
q.put(node)‖while not q.empty():‖2
while not q.empty():‖node_dequeued = q.get()‖2
node_dequeued = q.get()‖"print(node_dequeued.data, end="","")"‖2
"print(node_dequeued.data, end="","")"‖if node_dequeued.left:‖2
if node_dequeued.left:‖q.put(node_dequeued.left)‖1
q.put(node_dequeued.left)‖if node_dequeued.right:‖1
if node_dequeued.right:‖q.put(node_dequeued.right)‖1
def level_order_actual(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
while not q.empty():‖list_ = []‖1
list_ = []‖while not q.empty():‖1
if node_dequeued.left:‖list_.append(node_dequeued.left)‖1
list_.append(node_dequeued.left)‖if node_dequeued.right:‖1
if node_dequeued.right:‖list_.append(node_dequeued.right)‖1
list_.append(node_dequeued.right)‖print()‖1
print()‖for inner_node in list_:‖1
for inner_node in list_:‖q.put(inner_node)‖1
def pre_order_iter(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
return‖stack: list[TreeNode] = []‖2
stack: list[TreeNode] = []‖n = node‖2
n = node‖while n or stack:‖2
while n or stack:‖while n:‖2
while n:‖"print(n.data, end="","")"‖1
"print(n.data, end="","")"‖stack.append(n)‖1
stack.append(n)‖n = n.left‖2
def in_order_iter(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
while n:‖stack.append(n)‖1
n = n.left‖n = stack.pop()‖1
n = stack.pop()‖"print(n.data, end="","")"‖1
"print(n.data, end="","")"‖n = n.right‖1
def post_order_iter(node: TreeNode) -> None:‖if not isinstance(node, TreeNode) or not node:‖1
return‖stack1, stack2 = [], []‖1
stack1, stack2 = [], []‖n = node‖1
n = node‖stack1.append(n)‖1
stack1.append(n)‖while stack1:‖1
while stack1:‖n = stack1.pop()‖1
n = stack1.pop()‖if n.left:‖1
if n.left:‖stack1.append(n.left)‖1
stack1.append(n.left)‖if n.right:‖1
if n.right:‖stack1.append(n.right)‖1
stack1.append(n.right)‖stack2.append(n)‖1
stack2.append(n)‖while stack2:‖1
while stack2:‖"print(stack2.pop().data, end="","")"‖1
"def prompt(s: str = """", width=50, char=""*"") -> str:"‖if not s:‖1
if not s:‖"return ""\n"" + width * char"‖1
"return ""\n"" + width * char"‖left, extra = divmod(width - len(s) - 2, 2)‖1
left, extra = divmod(width - len(s) - 2, 2)‖"return f""{left * char} {s} {(left + extra) * char}"""‖1
doctest.testmod()‖"print(prompt(""Binary Tree Traversals""))"‖1
node: TreeNode = build_tree()‖"print(prompt(""Pre Order Traversal""))"‖1
"print(prompt(""Pre Order Traversal""))"‖pre_order(node)‖1
pre_order(node)‖"print(prompt() + ""\n"")"‖1
"print(prompt(""In Order Traversal""))"‖in_order(node)‖1
in_order(node)‖"print(prompt() + ""\n"")"‖1
"print(prompt(""Post Order Traversal""))"‖post_order(node)‖1
post_order(node)‖"print(prompt() + ""\n"")"‖1
"print(prompt(""Level Order Traversal""))"‖level_order(node)‖1
level_order(node)‖"print(prompt() + ""\n"")"‖1
"print(prompt(""Actual Level Order Traversal""))"‖level_order_actual(node)‖1
level_order_actual(node)‖"print(""*"" * 50 + ""\n"")"‖1
"print(prompt(""Pre Order Traversal - Iteration Version""))"‖pre_order_iter(node)‖1
pre_order_iter(node)‖"print(prompt() + ""\n"")"‖1
"print(prompt(""In Order Traversal - Iteration Version""))"‖in_order_iter(node)‖1
in_order_iter(node)‖"print(prompt() + ""\n"")"‖1
"print(prompt(""Post Order Traversal - Iteration Version""))"‖post_order_iter(node)‖1
post_order_iter(node)‖print(prompt())‖1
def binary_search(a_list: list[int], item: int) -> bool:‖if len(a_list) == 0:‖1
if len(a_list) == 0:‖return False‖1
return False‖midpoint = len(a_list) // 2‖1
midpoint = len(a_list) // 2‖if a_list[midpoint] == item:‖1
if a_list[midpoint] == item:‖return True‖1
return True‖if item < a_list[midpoint]:‖1
if item < a_list[midpoint]:‖return binary_search(a_list[:midpoint], item)‖1
return binary_search(a_list[:midpoint], item)‖else:‖1
else:‖return binary_search(a_list[midpoint + 1 :], item)‖1
"sequence = [int(item.strip()) for item in user_input.split("","")]"‖"target = int(input(""Enter the number to be found in the list:\n"").strip())"‖1
"target = int(input(""Enter the number to be found in the list:\n"").strip())"‖"not_str = """" if binary_search(sequence, target) else ""not """‖1
"not_str = """" if binary_search(sequence, target) else ""not """‖"print(f""{target} was {not_str}found in {sequence}"")"‖1
import argparse‖import os‖1
class FileSplitter:‖"BLOCK_FILENAME_FORMAT = ""block_{0}.dat"""‖1
def __init__(self, filename):‖self.filename = filename‖1
self.filename = filename‖self.block_filenames = []‖1
def write_block(self, data, block_number):‖filename = self.BLOCK_FILENAME_FORMAT.format(block_number)‖1
filename = self.BLOCK_FILENAME_FORMAT.format(block_number)‖"with open(filename, ""w"") as file:"‖1
"with open(filename, ""w"") as file:"‖file.write(data)‖1
file.write(data)‖self.block_filenames.append(filename)‖1
def get_block_filenames(self):‖return self.block_filenames‖1
def split(self, block_size, sort_key=None):‖i = 0‖1
i = 0‖with open(self.filename) as file:‖1
with open(self.filename) as file:‖while True:‖1
while True:‖lines = file.readlines(block_size)‖1
if lines == []:‖break‖1
if sort_key is None:‖lines.sort()‖1
lines.sort()‖else:‖1
else:‖lines.sort(key=sort_key)‖1
"self.write_block("""".join(lines), i)"‖i += 1‖1
def cleanup(self):‖map(os.remove, self.block_filenames)‖1
class NWayMerge:‖def select(self, choices):‖1
def select(self, choices):‖min_index = -1‖1
min_index = -1‖min_str = None‖1
for i in range(len(choices)):‖if min_str is None or choices[i] < min_str:‖1
if min_str is None or choices[i] < min_str:‖min_index = i‖1
class FilesArray:‖def __init__(self, files):‖1
def __init__(self, files):‖self.files = files‖1
self.files = files‖self.empty = set()‖1
self.empty = set()‖self.num_buffers = len(files)‖1
self.num_buffers = len(files)‖self.buffers = {i: None for i in range(self.num_buffers)}‖1
def get_dict(self):‖return {‖1
return {‖i: self.buffers[i] for i in range(self.num_buffers) if i not in self.empty‖1
i: self.buffers[i] for i in range(self.num_buffers) if i not in self.empty‖}‖1
def refresh(self):‖for i in range(self.num_buffers):‖1
for i in range(self.num_buffers):‖if self.buffers[i] is None and i not in self.empty:‖1
if self.buffers[i] is None and i not in self.empty:‖self.buffers[i] = self.files[i].readline()‖1
"if self.buffers[i] == """":"‖self.empty.add(i)‖1
self.empty.add(i)‖self.files[i].close()‖1
def unshift(self, index):‖value = self.buffers[index]‖1
value = self.buffers[index]‖self.buffers[index] = None‖1
class FileMerger:‖def __init__(self, merge_strategy):‖1
def __init__(self, merge_strategy):‖self.merge_strategy = merge_strategy‖1
def merge(self, filenames, outfilename, buffer_size):‖buffers = FilesArray(self.get_file_handles(filenames, buffer_size))‖1
buffers = FilesArray(self.get_file_handles(filenames, buffer_size))‖"with open(outfilename, ""w"", buffer_size) as outfile:"‖1
"with open(outfilename, ""w"", buffer_size) as outfile:"‖while buffers.refresh():‖1
while buffers.refresh():‖min_index = self.merge_strategy.select(buffers.get_dict())‖1
min_index = self.merge_strategy.select(buffers.get_dict())‖outfile.write(buffers.unshift(min_index))‖1
def get_file_handles(self, filenames, buffer_size):‖files = {}‖1
for i in range(len(filenames)):‖"files[i] = open(filenames[i], ""r"", buffer_size)"‖1
class ExternalSort:‖def __init__(self, block_size):‖1
def __init__(self, block_size):‖self.block_size = block_size‖1
def sort(self, filename, sort_key=None):‖num_blocks = self.get_number_blocks(filename, self.block_size)‖1
num_blocks = self.get_number_blocks(filename, self.block_size)‖splitter = FileSplitter(filename)‖1
splitter = FileSplitter(filename)‖splitter.split(self.block_size, sort_key)‖1
merger = FileMerger(NWayMerge())‖buffer_size = self.block_size / (num_blocks + 1)‖1
buffer_size = self.block_size / (num_blocks + 1)‖"merger.merge(splitter.get_block_filenames(), filename + "".out"", buffer_size)"‖1
def get_number_blocks(self, filename, block_size):‖return (os.stat(filename).st_size / block_size) + 1‖1
def parse_memory(string):‖"if string[-1].lower() == ""k"":"‖1
"if string[-1].lower() == ""k"":"‖return int(string[:-1]) * 1024‖1
return int(string[:-1]) * 1024‖"elif string[-1].lower() == ""m"":"‖1
"elif string[-1].lower() == ""m"":"‖return int(string[:-1]) * 1024 * 1024‖1
return int(string[:-1]) * 1024 * 1024‖"elif string[-1].lower() == ""g"":"‖1
"elif string[-1].lower() == ""g"":"‖return int(string[:-1]) * 1024 * 1024 * 1024‖1
return int(string[:-1]) * 1024 * 1024 * 1024‖else:‖1
else:‖return int(string)‖1
def main():‖parser = argparse.ArgumentParser()‖1
parser.add_argument(‖"""-m"", ""--mem"", help=""amount of memory to use for sorting"", default=""100M"""‖1
"""-m"", ""--mem"", help=""amount of memory to use for sorting"", default=""100M"""‖)‖1
parser.add_argument(‖"""filename"", metavar=""<filename>"", nargs=1, help=""name of file to sort"""‖1
"""filename"", metavar=""<filename>"", nargs=1, help=""name of file to sort"""‖)‖1
sorter = ExternalSort(parse_memory(args.mem))‖sorter.sort(args.filename[0])‖1
def cycle_sort(array: list) -> list:‖array_len = len(array)‖1
array_len = len(array)‖for cycle_start in range(array_len - 1):‖1
for cycle_start in range(array_len - 1):‖item = array[cycle_start]‖1
pos = cycle_start‖for i in range(cycle_start + 1, array_len):‖2
for i in range(cycle_start + 1, array_len):‖if array[i] < item:‖2
if array[i] < item:‖pos += 1‖2
if pos == cycle_start:‖continue‖1
while item == array[pos]:‖pos += 1‖2
array[pos], item = item, array[pos]‖while pos != cycle_start:‖1
while pos != cycle_start:‖pos = cycle_start‖1
"if __name__ == ""__main__"":"‖assert cycle_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]‖1
assert cycle_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]‖assert cycle_sort([0, 1, -10, 15, 2, -2]) == [-10, -2, 0, 1, 2, 15]‖1
red = 0‖white = 1‖1
white = 1‖blue = 2‖1
blue = 2‖colors = (red, white, blue)‖1
def dutch_national_flag_sort(sequence: list) -> list:‖if not sequence:‖1
if not sequence:‖return []‖1
return []‖if len(sequence) == 1:‖1
if len(sequence) == 1:‖return list(sequence)‖1
return list(sequence)‖low = 0‖1
low = 0‖high = len(sequence) - 1‖1
high = len(sequence) - 1‖mid = 0‖1
mid = 0‖while mid <= high:‖1
while mid <= high:‖if sequence[mid] == colors[0]:‖1
if sequence[mid] == colors[0]:‖sequence[low], sequence[mid] = sequence[mid], sequence[low]‖1
sequence[low], sequence[mid] = sequence[mid], sequence[low]‖low += 1‖1
low += 1‖mid += 1‖1
mid += 1‖elif sequence[mid] == colors[1]:‖1
elif sequence[mid] == colors[1]:‖mid += 1‖1
mid += 1‖elif sequence[mid] == colors[2]:‖1
elif sequence[mid] == colors[2]:‖sequence[mid], sequence[high] = sequence[high], sequence[mid]‖1
sequence[mid], sequence[high] = sequence[high], sequence[mid]‖high -= 1‖1
high -= 1‖else:‖1
else:‖"msg = f""The elements inside the sequence must contains only {colors} values"""‖1
"msg = f""The elements inside the sequence must contains only {colors} values"""‖raise ValueError(msg)‖1
raise ValueError(msg)‖return sequence‖1
"user_input = input(""Enter numbers separated by commas:\n"").strip()"‖"unsorted = [int(item.strip()) for item in user_input.split("","")]"‖1
"unsorted = [int(item.strip()) for item in user_input.split("","")]"‖"print(f""{dutch_national_flag_sort(unsorted)}"")"‖1
def double_sort(collection: list[Any]) -> list[Any]:‖no_of_elements = len(collection)‖1
no_of_elements = len(collection)‖for _ in range(‖1
for _ in range(‖int(((no_of_elements - 1) / 2) + 1)‖1
int(((no_of_elements - 1) / 2) + 1)‖):‖1
):‖for j in range(no_of_elements - 1):‖1
if collection[j + 1] < collection[j]:‖collection[j], collection[j + 1] = collection[j + 1], collection[j]‖1
if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:‖(‖1
(‖collection[no_of_elements - 1 - j],‖1
collection[no_of_elements - 1 - j],‖collection[no_of_elements - 2 - j],‖1
collection[no_of_elements - 2 - j],‖) = (‖1
) = (‖collection[no_of_elements - 2 - j],‖1
collection[no_of_elements - 2 - j],‖collection[no_of_elements - 1 - j],‖1
collection[no_of_elements - 1 - j],‖)‖1
)‖return collection‖1
"unsorted = [int(x) for x in input(""Enter the list to be sorted: "").split() if x]"‖"print(""the sorted list is"")"‖1
"print(""the sorted list is"")"‖"print(f""{double_sort(unsorted) = }"")"‖1
def exchange_sort(numbers: list[int]) -> list[int]:‖numbers_length = len(numbers)‖1
numbers_length = len(numbers)‖for i in range(numbers_length):‖1
for i in range(numbers_length):‖for j in range(i + 1, numbers_length):‖1
for j in range(i + 1, numbers_length):‖if numbers[j] < numbers[i]:‖1
if numbers[j] < numbers[i]:‖numbers[i], numbers[j] = numbers[j], numbers[i]‖1
numbers[i], numbers[j] = numbers[j], numbers[i]‖return numbers‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(exchange_sort(unsorted))‖1
if len(collection) < 2:‖return collection‖2
if low == high:‖return swapped‖1
left = low‖right = high‖1
while left < right:‖if collection[left] > collection[right]:‖1
if collection[left] > collection[right]:‖collection[left], collection[right] = (‖1
collection[left], collection[right] = (‖collection[right],‖1
collection[right],‖collection[left],‖1
collection[left],‖)‖2
)‖swapped = True‖1
left += 1‖right -= 1‖1
if left == right and collection[left] > collection[right + 1]:‖collection[left], collection[right + 1] = (‖1
collection[left], collection[right + 1] = (‖collection[right + 1],‖1
collection[right + 1],‖collection[left],‖1
mid = low + int((high - low) / 2)‖left_swap = circle_sort_util(collection, low, mid)‖1
left_swap = circle_sort_util(collection, low, mid)‖right_swap = circle_sort_util(collection, mid + 1, high)‖1
while is_not_sorted is True:‖is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(circle_sort(unsorted))‖1
if collection == []:‖return []‖1
coll_len = len(collection)‖coll_max = max(collection)‖1
coll_max = max(collection)‖coll_min = min(collection)‖1
counting_arr_length = coll_max + 1 - coll_min‖counting_arr = [0] * counting_arr_length‖1
for number in collection:‖counting_arr[number - coll_min] += 1‖1
for i in range(1, counting_arr_length):‖counting_arr[i] = counting_arr[i] + counting_arr[i - 1]‖1
for i in reversed(range(coll_len)):‖ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]‖1
ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]‖counting_arr[collection[i] - coll_min] -= 1‖1
def counting_sort_string(string):‖"return """".join([chr(i) for i in counting_sort([ord(c) for c in string])])"‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(counting_sort(unsorted))‖1
n = len(collection)‖for i in range(1, n):‖1
for i in range(1, n):‖value_to_insert = collection[i]‖1
value_to_insert = collection[i]‖low = 0‖1
low = 0‖high = i - 1‖1
mid = (low + high) // 2‖if value_to_insert < collection[mid]:‖1
if value_to_insert < collection[mid]:‖high = mid - 1‖1
high = mid - 1‖else:‖1
else:‖low = mid + 1‖1
low = mid + 1‖for j in range(i, low, -1):‖1
for j in range(i, low, -1):‖collection[j] = collection[j - 1]‖1
collection[j] = collection[j - 1]‖collection[low] = value_to_insert‖1
collection[low] = value_to_insert‖return collection‖1
"if __name__ == ""__main"":"‖"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖1
"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖try:‖1
try:‖"unsorted = [int(item) for item in user_input.split("","")]"‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖except ValueError:‖1
except ValueError:‖"print(""Invalid input. Please enter valid integers separated by commas."")"‖2
"print(""Invalid input. Please enter valid integers separated by commas."")"‖raise‖1
raise‖"print(f""{binary_insertion_sort(unsorted) = }"")"‖1
def insertion_sort(array: list, start: int = 0, end: int = 0) -> list:‖end = end or len(array)‖1
end = end or len(array)‖for i in range(start, end):‖1
for i in range(start, end):‖temp_index = i‖1
temp_index = i‖temp_index_value = array[i]‖1
temp_index_value = array[i]‖while temp_index != start and temp_index_value < array[temp_index - 1]:‖1
while temp_index != start and temp_index_value < array[temp_index - 1]:‖array[temp_index] = array[temp_index - 1]‖1
array[temp_index] = array[temp_index - 1]‖temp_index -= 1‖1
temp_index -= 1‖array[temp_index] = temp_index_value‖1
array[temp_index] = temp_index_value‖return array‖1
def heapify(array: list, index: int, heap_size: int) -> None:‖largest = index‖1
largest = index‖left_index = 2 * index + 1‖2
left_index = 2 * index + 1‖right_index = 2 * index + 2‖2
if left_index < heap_size and array[largest] < array[left_index]:‖largest = left_index‖1
if right_index < heap_size and array[largest] < array[right_index]:‖largest = right_index‖1
if largest != index:‖array[index], array[largest] = array[largest], array[index]‖1
array[index], array[largest] = array[largest], array[index]‖heapify(array, largest, heap_size)‖1
def heap_sort(array: list) -> list:‖n = len(array)‖1
for i in range(n // 2, -1, -1):‖heapify(array, i, n)‖1
for i in range(n - 1, 0, -1):‖array[i], array[0] = array[0], array[i]‖1
array[i], array[0] = array[0], array[i]‖heapify(array, 0, i)‖1
def median_of_3(‖array: list, first_index: int, middle_index: int, last_index: int‖1
array: list, first_index: int, middle_index: int, last_index: int‖) -> int:‖1
) -> int:‖if (array[first_index] > array[middle_index]) != (‖1
if (array[first_index] > array[middle_index]) != (‖array[first_index] > array[last_index]‖1
array[first_index] > array[last_index]‖):‖1
):‖return array[first_index]‖1
return array[first_index]‖elif (array[middle_index] > array[first_index]) != (‖1
elif (array[middle_index] > array[first_index]) != (‖array[middle_index] > array[last_index]‖1
array[middle_index] > array[last_index]‖):‖1
):‖return array[middle_index]‖1
return array[middle_index]‖else:‖1
else:‖return array[last_index]‖1
def partition(array: list, low: int, high: int, pivot: int) -> int:‖i = low‖1
i = low‖j = high‖1
j = high‖while True:‖1
while True:‖while array[i] < pivot:‖1
while array[i] < pivot:‖i += 1‖1
i += 1‖j -= 1‖1
j -= 1‖while pivot < array[j]:‖1
while pivot < array[j]:‖j -= 1‖1
j -= 1‖if i >= j:‖1
if i >= j:‖return i‖1
return i‖array[i], array[j] = array[j], array[i]‖1
array[i], array[j] = array[j], array[i]‖i += 1‖1
def sort(array: list) -> list:‖if len(array) == 0:‖1
if len(array) == 0:‖return array‖2
return array‖max_depth = 2 * math.ceil(math.log2(len(array)))‖1
max_depth = 2 * math.ceil(math.log2(len(array)))‖size_threshold = 16‖1
size_threshold = 16‖return intro_sort(array, 0, len(array), size_threshold, max_depth)‖1
def intro_sort(‖array: list, start: int, end: int, size_threshold: int, max_depth: int‖1
array: list, start: int, end: int, size_threshold: int, max_depth: int‖) -> list:‖1
) -> list:‖while end - start > size_threshold:‖1
while end - start > size_threshold:‖if max_depth == 0:‖1
if max_depth == 0:‖return heap_sort(array)‖1
return heap_sort(array)‖max_depth -= 1‖1
max_depth -= 1‖pivot = median_of_3(array, start, start + ((end - start) // 2) + 1, end - 1)‖1
pivot = median_of_3(array, start, start + ((end - start) // 2) + 1, end - 1)‖p = partition(array, start, end, pivot)‖1
p = partition(array, start, end, pivot)‖intro_sort(array, p, end, size_threshold, max_depth)‖1
intro_sort(array, p, end, size_threshold, max_depth)‖end = p‖1
end = p‖return insertion_sort(array, start, end)‖1
doctest.testmod()‖"user_input = input(""Enter numbers separated by a comma : "").strip()"‖1
"user_input = input(""Enter numbers separated by a comma : "").strip()"‖"unsorted = [float(item) for item in user_input.split("","")]"‖1
"unsorted = [float(item) for item in user_input.split("","")]"‖"print(f""{sort(unsorted) = }"")"‖1
def cocktail_shaker_sort(arr: list[int]) -> list[int]:‖start, end = 0, len(arr) - 1‖1
while start < end:‖swapped = False‖1
for i in range(start, end):‖if arr[i] > arr[i + 1]:‖1
if arr[i] > arr[i + 1]:‖arr[i], arr[i + 1] = arr[i + 1], arr[i]‖1
arr[i], arr[i + 1] = arr[i + 1], arr[i]‖swapped = True‖1
for i in range(end, start, -1):‖if arr[i] < arr[i - 1]:‖1
if arr[i] < arr[i - 1]:‖arr[i], arr[i - 1] = arr[i - 1], arr[i]‖1
arr[i], arr[i - 1] = arr[i - 1], arr[i]‖swapped = True‖1
doctest.testmod()‖"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖2
"unsorted = [int(item) for item in user_input.split("","")]"‖"print(f""{cocktail_shaker_sort(unsorted) = }"")"‖1
def heapify(unsorted: list[int], index: int, heap_size: int) -> None:‖largest = index‖1
right_index = 2 * index + 2‖if left_index < heap_size and unsorted[left_index] > unsorted[largest]:‖1
if left_index < heap_size and unsorted[left_index] > unsorted[largest]:‖largest = left_index‖1
if right_index < heap_size and unsorted[right_index] > unsorted[largest]:‖largest = right_index‖1
if largest != index:‖unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])‖1
unsorted[largest], unsorted[index] = (unsorted[index], unsorted[largest])‖heapify(unsorted, largest, heap_size)‖1
def heap_sort(unsorted: list[int]) -> list[int]:‖n = len(unsorted)‖1
n = len(unsorted)‖for i in range(n // 2 - 1, -1, -1):‖1
for i in range(n // 2 - 1, -1, -1):‖heapify(unsorted, i, n)‖1
heapify(unsorted, i, n)‖for i in range(n - 1, 0, -1):‖1
for i in range(n - 1, 0, -1):‖unsorted[0], unsorted[i] = unsorted[i], unsorted[0]‖1
unsorted[0], unsorted[i] = unsorted[i], unsorted[0]‖heapify(unsorted, 0, i)‖1
heapify(unsorted, 0, i)‖return unsorted‖1
"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖if user_input:‖1
if user_input:‖"unsorted = [int(item) for item in user_input.split("","")]"‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖"print(f""{heap_sort(unsorted) = }"")"‖1
def gnome_sort(lst: list) -> list:‖if len(lst) <= 1:‖1
if len(lst) <= 1:‖return lst‖1
while i < len(lst):‖if lst[i - 1] <= lst[i]:‖1
if lst[i - 1] <= lst[i]:‖i += 1‖1
else:‖lst[i - 1], lst[i] = lst[i], lst[i - 1]‖1
lst[i - 1], lst[i] = lst[i], lst[i - 1]‖i -= 1‖1
i -= 1‖if i == 0:‖1
if i == 0:‖i = 1‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(gnome_sort(unsorted))‖1
from collections.abc import MutableSequence‖from typing import Any, Protocol, TypeVar‖1
for insert_index in range(1, len(collection)):‖insert_value = collection[insert_index]‖1
insert_value = collection[insert_index]‖while insert_index > 0 and insert_value < collection[insert_index - 1]:‖1
while insert_index > 0 and insert_value < collection[insert_index - 1]:‖collection[insert_index] = collection[insert_index - 1]‖1
collection[insert_index] = collection[insert_index - 1]‖insert_index -= 1‖1
insert_index -= 1‖collection[insert_index] = insert_value‖1
collection[insert_index] = insert_value‖return collection‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖"print(f""{insertion_sort(unsorted) = }"")"‖1
def comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:‖if (direction == 1 and array[index1] > array[index2]) or (‖1
if (direction == 1 and array[index1] > array[index2]) or (‖direction == 0 and array[index1] < array[index2]‖1
direction == 0 and array[index1] < array[index2]‖):‖1
):‖array[index1], array[index2] = array[index2], array[index1]‖1
def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:‖if length > 1:‖1
if length > 1:‖middle = int(length / 2)‖2
middle = int(length / 2)‖for i in range(low, low + middle):‖1
for i in range(low, low + middle):‖comp_and_swap(array, i, i + middle, direction)‖1
comp_and_swap(array, i, i + middle, direction)‖bitonic_merge(array, low, middle, direction)‖1
bitonic_merge(array, low, middle, direction)‖bitonic_merge(array, low + middle, middle, direction)‖1
def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:‖if length > 1:‖1
middle = int(length / 2)‖bitonic_sort(array, low, middle, 1)‖1
bitonic_sort(array, low, middle, 1)‖bitonic_sort(array, low + middle, middle, 0)‖1
bitonic_sort(array, low + middle, middle, 0)‖bitonic_merge(array, low, length, direction)‖1
"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖"unsorted = [int(item.strip()) for item in user_input.split("","")]"‖1
bitonic_sort(unsorted, 0, len(unsorted), 1)‖"print(""\nSorted array in ascending order is: "", end="""")"‖1
"print(""\nSorted array in ascending order is: "", end="""")"‖"print(*unsorted, sep="", "")"‖1
bitonic_merge(unsorted, 0, len(unsorted), 0)‖"print(""Sorted array in descending order is: "", end="""")"‖1
"print(""Sorted array in descending order is: "", end="""")"‖"print(*unsorted, sep="", "")"‖1
def merge(input_list: list, low: int, mid: int, high: int) -> list:‖result = []‖1
result = []‖left, right = input_list[low:mid], input_list[mid : high + 1]‖1
left, right = input_list[low:mid], input_list[mid : high + 1]‖while left and right:‖1
while left and right:‖result.append((left if left[0] <= right[0] else right).pop(0))‖1
result.append((left if left[0] <= right[0] else right).pop(0))‖input_list[low : high + 1] = result + left + right‖1
input_list[low : high + 1] = result + left + right‖return input_list‖1
def iter_merge_sort(input_list: list) -> list:‖if len(input_list) <= 1:‖1
if len(input_list) <= 1:‖return input_list‖1
return input_list‖input_list = list(input_list)‖1
p = 2‖while p <= len(input_list):‖1
for i in range(0, len(input_list), p):‖low = i‖1
low = i‖high = i + p - 1‖1
high = i + p - 1‖mid = (low + high + 1) // 2‖1
mid = (low + high + 1) // 2‖input_list = merge(input_list, low, mid, high)‖1
if p * 2 >= len(input_list):‖mid = i‖1
mid = i‖input_list = merge(input_list, 0, mid, len(input_list) - 1)‖1
input_list = merge(input_list, 0, mid, len(input_list) - 1)‖break‖1
break‖p *= 2‖1
"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖"if user_input == """":"‖1
"if user_input == """":"‖unsorted = []‖1
unsorted = []‖else:‖1
else:‖"unsorted = [int(item.strip()) for item in user_input.split("","")]"‖1
"unsorted = [int(item.strip()) for item in user_input.split("","")]"‖print(iter_merge_sort(unsorted))‖1
def binary_search_insertion(sorted_list, item):‖left = 0‖1
left = 0‖right = len(sorted_list) - 1‖1
right = len(sorted_list) - 1‖while left <= right:‖1
while left <= right:‖middle = (left + right) // 2‖1
middle = (left + right) // 2‖if left == right:‖1
if left == right:‖if sorted_list[middle] < item:‖1
if sorted_list[middle] < item:‖left = middle + 1‖1
left = middle + 1‖break‖1
break‖elif sorted_list[middle] < item:‖1
elif sorted_list[middle] < item:‖left = middle + 1‖1
left = middle + 1‖else:‖1
else:‖right = middle - 1‖1
right = middle - 1‖sorted_list.insert(left, item)‖1
sorted_list.insert(left, item)‖return sorted_list‖1
def merge(left, right):‖result = []‖1
result = []‖while left and right:‖2
while left and right:‖if left[0][0] < right[0][0]:‖1
if left[0][0] < right[0][0]:‖result.append(left.pop(0))‖1
result.append(left.pop(0))‖else:‖1
else:‖result.append(right.pop(0))‖1
result.append(right.pop(0))‖return result + left + right‖1
def sortlist_2d(list_2d):‖length = len(list_2d)‖1
length = len(list_2d)‖if length <= 1:‖1
if length <= 1:‖return list_2d‖1
return list_2d‖middle = length // 2‖1
middle = length // 2‖return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))‖1
if len(collection) <= 1:‖return collection‖2
two_paired_list = []‖has_last_odd_item = False‖1
has_last_odd_item = False‖for i in range(0, len(collection), 2):‖1
for i in range(0, len(collection), 2):‖if i == len(collection) - 1:‖1
if i == len(collection) - 1:‖has_last_odd_item = True‖1
has_last_odd_item = True‖else:‖1
else:‖if collection[i] < collection[i + 1]:‖1
if collection[i] < collection[i + 1]:‖two_paired_list.append([collection[i], collection[i + 1]])‖1
two_paired_list.append([collection[i], collection[i + 1]])‖else:‖1
else:‖two_paired_list.append([collection[i + 1], collection[i]])‖1
if has_last_odd_item:‖pivot = collection[-1]‖1
pivot = collection[-1]‖result = binary_search_insertion(result, pivot)‖1
is_last_odd_item_inserted_before_this_index = False‖for i in range(len(sorted_list_2d) - 1):‖1
for i in range(len(sorted_list_2d) - 1):‖if result[i] == collection[-1] and has_last_odd_item:‖1
if result[i] == collection[-1] and has_last_odd_item:‖is_last_odd_item_inserted_before_this_index = True‖1
is_last_odd_item_inserted_before_this_index = True‖pivot = sorted_list_2d[i][1]‖1
if is_last_odd_item_inserted_before_this_index:‖result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)‖1
result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)‖else:‖1
else:‖result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(merge_insertion_sort(unsorted))‖1
def msd_radix_sort(list_of_ints: list[int]) -> list[int]:‖if not list_of_ints:‖1
if not list_of_ints:‖return []‖1
if min(list_of_ints) < 0:‖"raise ValueError(""All numbers must be positive"")"‖2
most_bits = max(len(bin(x)[2:]) for x in list_of_ints)‖return _msd_radix_sort(list_of_ints, most_bits)‖1
def _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:‖if bit_position == 0 or len(list_of_ints) in [0, 1]:‖1
if bit_position == 0 or len(list_of_ints) in [0, 1]:‖return list_of_ints‖1
zeros = []‖ones = []‖1
for number in list_of_ints:‖if (number >> (bit_position - 1)) & 1:‖1
ones.append(number)‖else:‖1
zeros = _msd_radix_sort(zeros, bit_position - 1)‖ones = _msd_radix_sort(ones, bit_position - 1)‖1
res = zeros‖res.extend(ones)‖1
length = len(list_of_ints)‖if not list_of_ints or length == 1:‖1
if not list_of_ints or length == 1:‖return‖1
most_bits = max(len(bin(x)[2:]) for x in list_of_ints)‖_msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)‖1
def _msd_radix_sort_inplace(‖list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int‖1
list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int‖):‖1
):‖if bit_position == 0 or end_index - begin_index <= 1:‖1
if bit_position == 0 or end_index - begin_index <= 1:‖return‖1
i = begin_index‖j = end_index - 1‖1
j = end_index - 1‖while i <= j:‖1
while i <= j:‖changed = False‖1
changed = False‖if not (list_of_ints[i] >> bit_position) & 1:‖1
i += 1‖changed = True‖1
changed = True‖if (list_of_ints[j] >> bit_position) & 1:‖1
j -= 1‖changed = True‖1
if changed:‖continue‖1
list_of_ints[i], list_of_ints[j] = list_of_ints[j], list_of_ints[i]‖j -= 1‖1
j -= 1‖if j != i:‖1
if j != i:‖i += 1‖1
_msd_radix_sort_inplace(list_of_ints, bit_position, begin_index, i)‖_msd_radix_sort_inplace(list_of_ints, bit_position, i, end_index)‖1
def alphanum_key(key):‖"return [int(s) if s.isdigit() else s.lower() for s in re.split(""([0-9]+)"", key)]"‖1
def merge(left: list, right: list) -> list:‖result = []‖1
while left and right:‖result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))‖1
result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))‖result.extend(left)‖1
result.extend(left)‖result.extend(right)‖1
result.extend(right)‖return result‖1
return collection‖mid_index = len(collection) // 2‖1
mid_index = len(collection) // 2‖return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))‖1
try:‖"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖sorted_list = merge_sort(unsorted)‖1
sorted_list = merge_sort(unsorted)‖"print(*sorted_list, sep="","")"‖1
"print(*sorted_list, sep="","")"‖except ValueError:‖1
def odd_even_sort(input_list: list) -> list:‖is_sorted = False‖1
is_sorted = False‖while is_sorted is False:‖1
while is_sorted is False:‖is_sorted = True‖1
is_sorted = True‖for i in range(0, len(input_list) - 1, 2):‖1
for i in range(0, len(input_list) - 1, 2):‖if input_list[i] > input_list[i + 1]:‖1
if input_list[i] > input_list[i + 1]:‖input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]‖2
for i in range(1, len(input_list) - 1, 2):‖if input_list[i] > input_list[i + 1]:‖1
is_sorted = False‖return input_list‖1
"if __name__ == ""__main__"":"‖"print(""Enter list to be sorted"")"‖1
"print(""Enter list to be sorted"")"‖input_list = [int(x) for x in input().split()]‖1
sorted_list = odd_even_sort(input_list)‖"print(""The sorted list is"")"‖1
"print(""The sorted list is"")"‖print(sorted_list)‖1
def odd_even_transposition(arr: list) -> list:‖arr_size = len(arr)‖1
arr_size = len(arr)‖for _ in range(arr_size):‖1
for _ in range(arr_size):‖for i in range(_ % 2, arr_size - 1, 2):‖1
for i in range(_ % 2, arr_size - 1, 2):‖if arr[i + 1] < arr[i]:‖1
if arr[i + 1] < arr[i]:‖arr[i], arr[i + 1] = arr[i + 1], arr[i]‖1
"if __name__ == ""__main__"":"‖arr = list(range(10, 0, -1))‖1
arr = list(range(10, 0, -1))‖"print(f""Original: {arr}. Sorted: {odd_even_transposition(arr)}"")"‖1
def oe_process(‖position,‖1
position,‖value,‖1
value,‖l_send,‖1
l_send,‖r_send,‖1
r_send,‖lr_cv,‖1
lr_cv,‖rr_cv,‖1
rr_cv,‖result_pipe,‖1
result_pipe,‖multiprocessing_context,‖1
multiprocessing_context,‖):‖1
):‖process_lock = multiprocessing_context.Lock()‖1
for i in range(10):‖if (i + position) % 2 == 0 and r_send is not None:‖1
with process_lock:‖r_send[1].send(value)‖1
with process_lock:‖temp = rr_cv[0].recv()‖1
value = min(value, temp)‖elif (i + position) % 2 != 0 and l_send is not None:‖1
with process_lock:‖l_send[1].send(value)‖1
with process_lock:‖temp = lr_cv[0].recv()‖1
process_array_ = []‖result_pipe = []‖1
for _ in arr:‖result_pipe.append(multiprocessing_context.Pipe())‖1
temp_rs = multiprocessing_context.Pipe()‖temp_rr = multiprocessing_context.Pipe()‖2
temp_rr = multiprocessing_context.Pipe()‖process_array_.append(‖2
process_array_.append(‖multiprocessing_context.Process(‖3
multiprocessing_context.Process(‖target=oe_process,‖3
target=oe_process,‖args=(‖3
args=(‖0,‖1
0,‖arr[0],‖1
arr[0],‖None,‖1
None,‖temp_rs,‖1
temp_rs,‖None,‖1
None,‖temp_rr,‖1
temp_rr,‖result_pipe[0],‖1
result_pipe[0],‖multiprocessing_context,‖1
multiprocessing_context,‖),‖3
)‖temp_lr = temp_rs‖2
temp_lr = temp_rs‖temp_ls = temp_rr‖2
for i in range(1, len(arr) - 1):‖temp_rs = multiprocessing_context.Pipe()‖1
args=(‖i,‖1
i,‖arr[i],‖1
arr[i],‖temp_ls,‖1
temp_ls,‖temp_rs,‖1
temp_rs,‖temp_lr,‖1
temp_lr,‖temp_rr,‖1
temp_rr,‖result_pipe[i],‖1
result_pipe[i],‖multiprocessing_context,‖1
args=(‖len(arr) - 1,‖1
len(arr) - 1,‖arr[len(arr) - 1],‖1
arr[len(arr) - 1],‖temp_ls,‖1
temp_ls,‖None,‖1
None,‖temp_lr,‖1
temp_lr,‖None,‖1
None,‖result_pipe[len(arr) - 1],‖1
result_pipe[len(arr) - 1],‖multiprocessing_context,‖1
for p in process_array_:‖p.start()‖1
for p in range(len(result_pipe)):‖arr[p] = result_pipe[p][0].recv()‖1
arr[p] = result_pipe[p][0].recv()‖process_array_[p].join()‖1
process_array_[p].join()‖return arr‖1
def main():‖arr = list(range(10, 0, -1))‖1
arr = list(range(10, 0, -1))‖"print(""Initial List"")"‖1
"print(""Initial List"")"‖print(*arr)‖1
print(*arr)‖arr = odd_even_transposition(arr)‖1
arr = odd_even_transposition(arr)‖"print(""Sorted List\n"")"‖1
"print(""Sorted List\n"")"‖print(*arr)‖1
def pancake_sort(arr):‖cur = len(arr)‖1
cur = len(arr)‖while cur > 1:‖1
arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]‖cur -= 1‖1
cur -= 1‖return arr‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(pancake_sort(unsorted))‖1
from bisect import bisect_left‖from functools import total_ordering‖1
from functools import total_ordering‖from heapq import merge‖1
@total_ordering‖class Stack(list):‖1
class Stack(list):‖def __lt__(self, other):‖1
def __lt__(self, other):‖return self[-1] < other[-1]‖1
def __eq__(self, other):‖return self[-1] == other[-1]‖1
def patience_sort(collection: list) -> list:‖stacks: list[Stack] = []‖1
for element in collection:‖new_stacks = Stack([element])‖1
new_stacks = Stack([element])‖i = bisect_left(stacks, new_stacks)‖1
i = bisect_left(stacks, new_stacks)‖if i != len(stacks):‖1
if i != len(stacks):‖stacks[i].append(element)‖1
stacks[i].append(element)‖else:‖1
else:‖stacks.append(new_stacks)‖1
collection[:] = merge(*(reversed(stack) for stack in stacks))‖return collection‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(patience_sort(unsorted))‖1
def pigeon_sort(array: list[int]) -> list[int]:‖if len(array) == 0:‖1
holes_range = _max - _min + 1‖holes, holes_repeat = [0] * holes_range, [0] * holes_range‖1
for i in array:‖index = i - _min‖1
index = i - _min‖holes[index] = i‖1
holes[index] = i‖holes_repeat[index] += 1‖1
index = 0‖for i in range(holes_range):‖1
for i in range(holes_range):‖while holes_repeat[i] > 0:‖1
while holes_repeat[i] > 0:‖array[index] = holes[i]‖1
array[index] = holes[i]‖index += 1‖1
index += 1‖holes_repeat[i] -= 1‖1
doctest.testmod()‖"user_input = input(""Enter numbers separated by comma:\n"")"‖1
"user_input = input(""Enter numbers separated by comma:\n"")"‖"unsorted = [int(x) for x in user_input.split("","")]"‖1
"unsorted = [int(x) for x in user_input.split("","")]"‖print(pigeon_sort(unsorted))‖1
min_val = min(a)‖max_val = max(a)‖1
for x in a:‖"assert isinstance(x, int), ""integers only please"""‖1
"assert isinstance(x, int), ""integers only please"""‖holes[x - min_val] += 1‖1
i = 0‖for count in range(size):‖1
for count in range(size):‖while holes[count] > 0:‖1
while holes[count] > 0:‖holes[count] -= 1‖1
holes[count] -= 1‖a[i] = count + min_val‖1
a[i] = count + min_val‖i += 1‖1
def main():‖a = [8, 3, 2, 7, 4, 6, 8]‖1
a = [8, 3, 2, 7, 4, 6, 8]‖pigeonhole_sort(a)‖1
pigeonhole_sort(a)‖"print(""Sorted order is:"", "" "".join(a))"‖1
if len(collection) <= 1 or n <= 1:‖return‖1
insert_next(collection, n - 1)‖rec_insertion_sort(collection, n - 1)‖1
if index >= len(collection) or collection[index - 1] <= collection[index]:‖return‖1
collection[index - 1], collection[index] = (‖collection[index],‖1
collection[index],‖collection[index - 1],‖1
collection[index - 1],‖)‖1
"if __name__ == ""__main__"":"‖"numbers = input(""Enter integers separated by spaces: "")"‖1
"numbers = input(""Enter integers separated by spaces: "")"‖number_list: list[int] = [int(num) for num in numbers.split()]‖1
number_list: list[int] = [int(num) for num in numbers.split()]‖rec_insertion_sort(number_list, len(number_list))‖1
rec_insertion_sort(number_list, len(number_list))‖print(number_list)‖1
pivot_index = randrange(len(collection))‖pivot = collection.pop(pivot_index)‖1
lesser = [item for item in collection if item <= pivot]‖greater = [item for item in collection if item > pivot]‖1
def radix_sort(list_of_ints: list[int]) -> list[int]:‖placement = 1‖1
placement = 1‖max_digit = max(list_of_ints)‖1
max_digit = max(list_of_ints)‖while placement <= max_digit:‖1
for i in list_of_ints:‖tmp = int((i / placement) % RADIX)‖1
tmp = int((i / placement) % RADIX)‖buckets[tmp].append(i)‖1
a = 0‖for b in range(RADIX):‖1
for b in range(RADIX):‖for i in buckets[b]:‖1
for i in buckets[b]:‖list_of_ints[a] = i‖1
list_of_ints[a] = i‖a += 1‖1
placement *= RADIX‖return list_of_ints‖1
def quick_sort_3partition(sorting: list, left: int, right: int) -> None:‖if right <= left:‖1
if right <= left:‖return‖1
return‖a = i = left‖1
a = i = left‖b = right‖1
b = right‖pivot = sorting[left]‖1
pivot = sorting[left]‖while i <= b:‖1
while i <= b:‖if sorting[i] < pivot:‖1
if sorting[i] < pivot:‖sorting[a], sorting[i] = sorting[i], sorting[a]‖1
sorting[a], sorting[i] = sorting[i], sorting[a]‖a += 1‖1
a += 1‖i += 1‖1
i += 1‖elif sorting[i] > pivot:‖1
elif sorting[i] > pivot:‖sorting[b], sorting[i] = sorting[i], sorting[b]‖1
sorting[b], sorting[i] = sorting[i], sorting[b]‖b -= 1‖1
b -= 1‖else:‖1
i += 1‖quick_sort_3partition(sorting, left, a - 1)‖1
quick_sort_3partition(sorting, left, a - 1)‖quick_sort_3partition(sorting, b + 1, right)‖1
def quick_sort_lomuto_partition(sorting: list, left: int, right: int) -> None:‖if left < right:‖1
if left < right:‖pivot_index = lomuto_partition(sorting, left, right)‖1
pivot_index = lomuto_partition(sorting, left, right)‖quick_sort_lomuto_partition(sorting, left, pivot_index - 1)‖1
quick_sort_lomuto_partition(sorting, left, pivot_index - 1)‖quick_sort_lomuto_partition(sorting, pivot_index + 1, right)‖1
def lomuto_partition(sorting: list, left: int, right: int) -> int:‖pivot = sorting[right]‖1
pivot = sorting[right]‖store_index = left‖1
store_index = left‖for i in range(left, right):‖1
for i in range(left, right):‖if sorting[i] < pivot:‖1
if sorting[i] < pivot:‖sorting[store_index], sorting[i] = sorting[i], sorting[store_index]‖1
sorting[store_index], sorting[i] = sorting[i], sorting[store_index]‖store_index += 1‖1
store_index += 1‖sorting[right], sorting[store_index] = sorting[store_index], sorting[right]‖1
sorting[right], sorting[store_index] = sorting[store_index], sorting[right]‖return store_index‖1
def three_way_radix_quicksort(sorting: list) -> list:‖if len(sorting) <= 1:‖1
if len(sorting) <= 1:‖return sorting‖1
return sorting‖return (‖1
return (‖three_way_radix_quicksort([i for i in sorting if i < sorting[0]])‖1
three_way_radix_quicksort([i for i in sorting if i < sorting[0]])‖+ [i for i in sorting if i == sorting[0]]‖1
+ [i for i in sorting if i == sorting[0]]‖+ three_way_radix_quicksort([i for i in sorting if i > sorting[0]])‖1
+ three_way_radix_quicksort([i for i in sorting if i > sorting[0]])‖)‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖quick_sort_3partition(unsorted, 0, len(unsorted) - 1)‖1
quick_sort_3partition(unsorted, 0, len(unsorted) - 1)‖print(unsorted)‖1
def merge(arr: list[int]) -> list[int]:‖if len(arr) > 1:‖1
if len(arr) > 1:‖middle_length = len(arr) // 2‖1
middle_length = len(arr) // 2‖left_array = arr[‖1
left_array = arr[‖:middle_length‖1
:middle_length‖]‖1
]‖right_array = arr[‖1
right_array = arr[‖middle_length:‖1
middle_length:‖]‖1
]‖left_size = len(left_array)‖1
left_size = len(left_array)‖right_size = len(right_array)‖1
right_size = len(right_array)‖merge(left_array)‖1
merge(left_array)‖merge(right_array)‖1
merge(right_array)‖left_index = 0‖1
left_index = 0‖right_index = 0‖1
right_index = 0‖index = 0‖1
index = 0‖while (‖1
while (‖left_index < left_size and right_index < right_size‖1
left_index < left_size and right_index < right_size‖):‖1
):‖if left_array[left_index] < right_array[right_index]:‖1
if left_array[left_index] < right_array[right_index]:‖arr[index] = left_array[left_index]‖1
arr[index] = left_array[left_index]‖left_index += 1‖2
left_index += 1‖else:‖1
else:‖arr[index] = right_array[right_index]‖1
arr[index] = right_array[right_index]‖right_index += 1‖2
right_index += 1‖index += 1‖2
index += 1‖while (‖2
while (‖left_index < left_size‖1
left_index < left_size‖):‖1
):‖arr[index] = left_array[left_index]‖1
left_index += 1‖index += 1‖1
while (‖right_index < right_size‖1
right_index < right_size‖):‖1
):‖arr[index] = right_array[right_index]‖1
index += 1‖return arr‖1
def quick_sort(data: list) -> list:‖if len(data) <= 1:‖1
if len(data) <= 1:‖return data‖1
return data‖else:‖1
else:‖return [‖1
return [‖*quick_sort([e for e in data[1:] if e <= data[0]]),‖1
*quick_sort([e for e in data[1:] if e <= data[0]]),‖data[0],‖1
data[0],‖*quick_sort([e for e in data[1:] if e > data[0]]),‖1
*quick_sort([e for e in data[1:] if e > data[0]]),‖]‖1
length = len(collection)‖for i in range(length - 1):‖1
for i in range(length - 1):‖min_index = i‖1
min_index = i‖for k in range(i + 1, length):‖1
for k in range(i + 1, length):‖if collection[k] < collection[min_index]:‖1
if collection[k] < collection[min_index]:‖min_index = k‖1
min_index = k‖if min_index != i:‖1
if min_index != i:‖collection[i], collection[min_index] = collection[min_index], collection[i]‖1
collection[i], collection[min_index] = collection[min_index], collection[i]‖return collection‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖sorted_list = selection_sort(unsorted)‖1
sorted_list = selection_sort(unsorted)‖"print(""Sorted List:"", sorted_list)"‖1
def slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:‖if start is None:‖1
if start is None:‖start = 0‖1
if end is None:‖end = len(sequence) - 1‖1
if start >= end:‖return‖1
slowsort(sequence, start, mid)‖slowsort(sequence, mid + 1, end)‖1
if sequence[end] < sequence[mid]:‖sequence[end], sequence[mid] = sequence[mid], sequence[end]‖1
for i in range(gap, len(collection)):‖temp = collection[i]‖1
temp = collection[i]‖j = i‖1
j = i‖while j >= gap and collection[j - gap] > temp:‖1
while j >= gap and collection[j - gap] > temp:‖collection[j] = collection[j - gap]‖1
collection[j] = collection[j - gap]‖j -= gap‖2
j -= gap‖collection[j] = temp‖1
gaps = [701, 301, 132, 57, 23, 10, 4, 1]‖for gap in gaps:‖1
for gap in gaps:‖for i in range(gap, len(collection)):‖1
for i in range(gap, len(collection)):‖insert_value = collection[i]‖1
insert_value = collection[i]‖j = i‖1
j = i‖while j >= gap and collection[j - gap] > insert_value:‖1
while j >= gap and collection[j - gap] > insert_value:‖collection[j] = collection[j - gap]‖1
j -= gap‖if j != i:‖1
if j != i:‖collection[j] = insert_value‖1
collection[j] = insert_value‖return collection‖1
testmod()‖"user_input = input(""Enter numbers separated by a comma:\n"").strip()"‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(shell_sort(unsorted))‖1
def strand_sort(arr: list, reverse: bool = False, solution: list | None = None) -> list:‖_operator = operator.lt if reverse else operator.gt‖1
_operator = operator.lt if reverse else operator.gt‖solution = solution or []‖1
if not arr:‖return solution‖1
sublist = [arr.pop(0)]‖for i, item in enumerate(arr):‖1
for i, item in enumerate(arr):‖if _operator(item, sublist[-1]):‖1
if _operator(item, sublist[-1]):‖sublist.append(item)‖1
sublist.append(item)‖arr.pop(i)‖1
if not solution:‖solution.extend(sublist)‖1
solution.extend(sublist)‖else:‖1
else:‖while sublist:‖1
while sublist:‖item = sublist.pop(0)‖1
item = sublist.pop(0)‖for i, xx in enumerate(solution):‖1
for i, xx in enumerate(solution):‖if not _operator(item, xx):‖1
if not _operator(item, xx):‖solution.insert(i, item)‖1
solution.insert(i, item)‖break‖1
else:‖solution.append(item)‖1
strand_sort(arr, reverse, solution)‖return solution‖1
"if __name__ == ""__main__"":"‖assert strand_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5]‖1
assert strand_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5]‖assert strand_sort([4, 3, 5, 1, 2], reverse=True) == [5, 4, 3, 2, 1]‖1
def stooge_sort(arr: list[int]) -> list[int]:‖stooge(arr, 0, len(arr) - 1)‖1
stooge(arr, 0, len(arr) - 1)‖return arr‖1
def stooge(arr: list[int], i: int, h: int) -> None:‖if i >= h:‖1
if i >= h:‖return‖1
if arr[i] > arr[h]:‖arr[i], arr[h] = arr[h], arr[i]‖1
if h - i + 1 > 2:‖t = (int)((h - i + 1) / 3)‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖print(stooge_sort(unsorted))‖1
def binary_search(lst, item, start, end):‖if start == end:‖1
if start == end:‖return start if lst[start] > item else start + 1‖1
return start if lst[start] > item else start + 1‖if start > end:‖1
if start > end:‖return start‖1
mid = (start + end) // 2‖if lst[mid] < item:‖1
if lst[mid] < item:‖return binary_search(lst, item, mid + 1, end)‖1
return binary_search(lst, item, mid + 1, end)‖elif lst[mid] > item:‖1
elif lst[mid] > item:‖return binary_search(lst, item, start, mid - 1)‖1
return binary_search(lst, item, start, mid - 1)‖else:‖1
else:‖return mid‖1
def insertion_sort(lst):‖length = len(lst)‖1
for index in range(1, length):‖value = lst[index]‖1
value = lst[index]‖pos = binary_search(lst, value, 0, index - 1)‖1
pos = binary_search(lst, value, 0, index - 1)‖lst = lst[:pos] + [value] + lst[pos:index] + lst[index + 1 :]‖1
def merge(left, right):‖if not left:‖1
if not left:‖return right‖1
if not right:‖return left‖1
if left[0] < right[0]:‖return [left[0], *merge(left[1:], right)]‖1
def tim_sort(lst):‖length = len(lst)‖1
length = len(lst)‖runs, sorted_runs = [], []‖1
runs, sorted_runs = [], []‖new_run = [lst[0]]‖1
new_run = [lst[0]]‖sorted_array = []‖1
sorted_array = []‖i = 1‖1
i = 1‖while i < length:‖1
while i < length:‖if lst[i] < lst[i - 1]:‖1
if lst[i] < lst[i - 1]:‖runs.append(new_run)‖1
runs.append(new_run)‖new_run = [lst[i]]‖1
new_run = [lst[i]]‖else:‖1
else:‖new_run.append(lst[i])‖1
new_run.append(lst[i])‖i += 1‖1
i += 1‖runs.append(new_run)‖1
for run in runs:‖sorted_runs.append(insertion_sort(run))‖1
sorted_runs.append(insertion_sort(run))‖for run in sorted_runs:‖1
for run in sorted_runs:‖sorted_array = merge(sorted_array, run)‖1
def main():‖lst = [5, 9, 10, 3, -4, 5, 178, 92, 46, -18, 0, 7]‖1
lst = [5, 9, 10, 3, -4, 5, 178, 92, 46, -18, 0, 7]‖sorted_lst = tim_sort(lst)‖1
sorted_lst = tim_sort(lst)‖print(sorted_lst)‖1
def wiggle_sort(nums: list) -> list:‖for i, _ in enumerate(nums):‖1
for i, _ in enumerate(nums):‖if (i % 2 == 1) == (nums[i - 1] > nums[i]):‖1
if (i % 2 == 1) == (nums[i - 1] > nums[i]):‖nums[i - 1], nums[i] = nums[i], nums[i - 1]‖1
"if __name__ == ""__main__"":"‖"print(""Enter the array elements:"")"‖1
"print(""Enter the array elements:"")"‖array = list(map(int, input().split()))‖1
array = list(map(int, input().split()))‖"print(""The unsorted array is:"")"‖1
"print(""The unsorted array is:"")"‖print(array)‖1
print(array)‖"print(""Array after Wiggle sort:"")"‖1
"print(""Array after Wiggle sort:"")"‖print(wiggle_sort(array))‖1
class Node:‖val: int‖1
val: int‖left: Node | None = None‖1
yield from self.left‖yield self.val‖1
yield self.val‖if self.right:‖1
def insert(self, val: int) -> None:‖if val < self.val:‖1
if val < self.val:‖if self.left is None:‖1
if self.left is None:‖self.left = Node(val)‖1
self.left = Node(val)‖else:‖1
else:‖self.left.insert(val)‖1
self.left.insert(val)‖elif val > self.val:‖1
elif val > self.val:‖if self.right is None:‖1
if self.right is None:‖self.right = Node(val)‖1
self.right = Node(val)‖else:‖1
else:‖self.right.insert(val)‖1
def tree_sort(arr: list[int]) -> tuple[int, ...]:‖if len(arr) == 0:‖1
if len(arr) == 0:‖return tuple(arr)‖1
return tuple(arr)‖root = Node(arr[0])‖1
root = Node(arr[0])‖for item in arr[1:]:‖1
for item in arr[1:]:‖root.insert(item)‖1
root.insert(item)‖return tuple(root)‖1
doctest.testmod()‖"print(f""{tree_sort([5, 6, 1, -1, 4, 37, -3, 7]) = }"")"‖1
def merge_sort(collection):‖start, end = [], []‖1
start, end = [], []‖while len(collection) > 1:‖1
while len(collection) > 1:‖min_one, max_one = min(collection), max(collection)‖1
min_one, max_one = min(collection), max(collection)‖start.append(min_one)‖1
start.append(min_one)‖end.append(max_one)‖1
end.append(max_one)‖collection.remove(min_one)‖1
collection.remove(min_one)‖collection.remove(max_one)‖1
collection.remove(max_one)‖end.reverse()‖1
end.reverse()‖return start + collection + end‖1
"unsorted = [int(item) for item in user_input.split("","")]"‖"print(*merge_sort(unsorted), sep="","")"‖1
edges: dict[str, list[str]] = {‖"""a"": [""c"", ""b""],"‖1
"""a"": [""c"", ""b""],"‖"""b"": [""d"", ""e""],"‖1
"""b"": [""d"", ""e""],"‖"""c"": [],"‖1
"""c"": [],"‖"""d"": [],"‖1
"""d"": [],"‖"""e"": [],"‖1
"""e"": [],"‖}‖1
}‖"vertices: list[str] = [""a"", ""b"", ""c"", ""d"", ""e""]"‖1
def topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:‖current = start‖1
visited.append(current)‖neighbors = edges[current]‖1
neighbors = edges[current]‖for neighbor in neighbors:‖1
if neighbor not in visited:‖sort = topological_sort(neighbor, visited, sort)‖1
if len(visited) != len(vertices):‖for vertice in vertices:‖1
for vertice in vertices:‖if vertice not in visited:‖1
if vertice not in visited:‖sort = topological_sort(vertice, visited, sort)‖1
"if __name__ == ""__main__"":"‖"sort = topological_sort(""a"", [], [])"‖1
"sort = topological_sort(""a"", [], [])"‖print(sort)‖1
class Automaton:‖def __init__(self, keywords: list[str]):‖1
def __init__(self, keywords: list[str]):‖self.adlist: list[dict] = []‖1
self.adlist: list[dict] = []‖self.adlist.append(‖1
self.adlist.append(‖"{""value"": """", ""next_states"": [], ""fail_state"": 0, ""output"": []}"‖1
"{""value"": """", ""next_states"": [], ""fail_state"": 0, ""output"": []}"‖)‖1
for keyword in keywords:‖self.add_keyword(keyword)‖1
self.add_keyword(keyword)‖self.set_fail_transitions()‖1
def find_next_state(self, current_state: int, char: str) -> int | None:‖"for state in self.adlist[current_state][""next_states""]:"‖1
"for state in self.adlist[current_state][""next_states""]:"‖"if char == self.adlist[state][""value""]:"‖1
"if char == self.adlist[state][""value""]:"‖return state‖1
return state‖return None‖1
def add_keyword(self, keyword: str) -> None:‖current_state = 0‖1
current_state = 0‖for character in keyword:‖1
for character in keyword:‖next_state = self.find_next_state(current_state, character)‖1
next_state = self.find_next_state(current_state, character)‖if next_state is None:‖1
if next_state is None:‖self.adlist.append(‖1
self.adlist.append(‖{‖1
{‖"""value"": character,"‖1
"""value"": character,"‖"""next_states"": [],"‖1
"""next_states"": [],"‖"""fail_state"": 0,"‖1
"""fail_state"": 0,"‖"""output"": [],"‖1
"""output"": [],"‖}‖1
}‖)‖1
)‖"self.adlist[current_state][""next_states""].append(len(self.adlist) - 1)"‖1
"self.adlist[current_state][""next_states""].append(len(self.adlist) - 1)"‖current_state = len(self.adlist) - 1‖1
current_state = len(self.adlist) - 1‖else:‖1
current_state = next_state‖"self.adlist[current_state][""output""].append(keyword)"‖1
def set_fail_transitions(self) -> None:‖q: deque = deque()‖1
q: deque = deque()‖"for node in self.adlist[0][""next_states""]:"‖1
"for node in self.adlist[0][""next_states""]:"‖q.append(node)‖1
q.append(node)‖"self.adlist[node][""fail_state""] = 0"‖1
"self.adlist[node][""fail_state""] = 0"‖while q:‖1
while q:‖r = q.popleft()‖1
r = q.popleft()‖"for child in self.adlist[r][""next_states""]:"‖1
"for child in self.adlist[r][""next_states""]:"‖q.append(child)‖1
q.append(child)‖"state = self.adlist[r][""fail_state""]"‖1
"state = self.adlist[r][""fail_state""]"‖while (‖1
while (‖"self.find_next_state(state, self.adlist[child][""value""]) is None"‖1
"self.find_next_state(state, self.adlist[child][""value""]) is None"‖and state != 0‖1
and state != 0‖):‖1
):‖"state = self.adlist[state][""fail_state""]"‖1
"state = self.adlist[state][""fail_state""]"‖"self.adlist[child][""fail_state""] = self.find_next_state("‖1
"self.adlist[child][""fail_state""] = self.find_next_state("‖"state, self.adlist[child][""value""]"‖1
"state, self.adlist[child][""value""]"‖)‖1
)‖"if self.adlist[child][""fail_state""] is None:"‖1
"if self.adlist[child][""fail_state""] is None:"‖"self.adlist[child][""fail_state""] = 0"‖1
"self.adlist[child][""fail_state""] = 0"‖"self.adlist[child][""output""] = ("‖1
"self.adlist[child][""output""] = ("‖"self.adlist[child][""output""]"‖1
"self.adlist[child][""output""]"‖"+ self.adlist[self.adlist[child][""fail_state""]][""output""]"‖1
"+ self.adlist[self.adlist[child][""fail_state""]][""output""]"‖)‖1
def search_in(self, string: str) -> dict[str, list[int]]:‖result: dict = {}‖1
result: dict = {}‖current_state = 0‖1
current_state = 0‖for i in range(len(string)):‖1
for i in range(len(string)):‖while (‖1
while (‖self.find_next_state(current_state, string[i]) is None‖1
self.find_next_state(current_state, string[i]) is None‖and current_state != 0‖1
and current_state != 0‖):‖1
):‖"current_state = self.adlist[current_state][""fail_state""]"‖1
"current_state = self.adlist[current_state][""fail_state""]"‖next_state = self.find_next_state(current_state, string[i])‖1
next_state = self.find_next_state(current_state, string[i])‖if next_state is None:‖1
if next_state is None:‖current_state = 0‖1
current_state = 0‖else:‖1
current_state = next_state‖"for key in self.adlist[current_state][""output""]:"‖1
"for key in self.adlist[current_state][""output""]:"‖if key not in result:‖1
if key not in result:‖result[key] = []‖1
result[key] = []‖result[key].append(i - len(key) + 1)‖1
result[key].append(i - len(key) + 1)‖return result‖1
def alternative_string_arrange(first_str: str, second_str: str) -> str:‖first_str_length: int = len(first_str)‖1
first_str_length: int = len(first_str)‖second_str_length: int = len(second_str)‖1
second_str_length: int = len(second_str)‖abs_length: int = (‖1
abs_length: int = (‖first_str_length if first_str_length > second_str_length else second_str_length‖1
first_str_length if first_str_length > second_str_length else second_str_length‖)‖1
)‖output_list: list = []‖1
output_list: list = []‖for char_count in range(abs_length):‖1
for char_count in range(abs_length):‖if char_count < first_str_length:‖1
if char_count < first_str_length:‖output_list.append(first_str[char_count])‖1
output_list.append(first_str[char_count])‖if char_count < second_str_length:‖1
if char_count < second_str_length:‖output_list.append(second_str[char_count])‖1
output_list.append(second_str[char_count])‖"return """".join(output_list)"‖1
"if __name__ == ""__main__"":"‖"print(alternative_string_arrange(""AB"", ""XYZ""), end="" "")"‖1
class Trie:‖def __init__(self) -> None:‖1
def __init__(self) -> None:‖self._trie: dict = {}‖1
def insert_word(self, text: str) -> None:‖trie = self._trie‖1
trie = self._trie‖for char in text:‖1
for char in text:‖if char not in trie:‖1
if char not in trie:‖trie[char] = {}‖1
trie[char] = {}‖trie = trie[char]‖1
trie = trie[char]‖trie[END] = True‖1
def find_word(self, prefix: str) -> tuple | list:‖trie = self._trie‖1
trie = self._trie‖for char in prefix:‖1
for char in prefix:‖if char in trie:‖1
if char in trie:‖trie = trie[char]‖1
trie = trie[char]‖else:‖1
return []‖return self._elements(trie)‖1
def _elements(self, d: dict) -> tuple:‖result = []‖1
result = []‖for c, v in d.items():‖1
for c, v in d.items():‖"sub_result = ["" ""] if c == END else [(c + s) for s in self._elements(v)]"‖1
"sub_result = ["" ""] if c == END else [(c + s) for s in self._elements(v)]"‖result.extend(sub_result)‖1
result.extend(sub_result)‖return tuple(result)‖1
trie = Trie()‖"words = (""depart"", ""detergent"", ""daring"", ""dog"", ""deer"", ""deal"")"‖1
"words = (""depart"", ""detergent"", ""daring"", ""dog"", ""deer"", ""deal"")"‖for word in words:‖1
for word in words:‖trie.insert_word(word)‖1
def autocomplete_using_trie(string: str) -> tuple:‖suffixes = trie.find_word(string)‖1
suffixes = trie.find_word(string)‖return tuple(string + word for word in suffixes)‖1
def main() -> None:‖"print(autocomplete_using_trie(""de""))"‖1
import collections‖import pprint‖1
import pprint‖from pathlib import Path‖1
def signature(word: str) -> str:‖"return """".join(sorted(word))"‖1
def anagram(my_word: str) -> list[str]:‖return word_by_signature[signature(my_word)]‖1
"data: str = Path(__file__).parent.joinpath(""words.txt"").read_text(encoding=""utf-8"")"‖word_list = sorted({word.strip().lower() for word in data.splitlines()})‖1
word_by_signature = collections.defaultdict(list)‖for word in word_list:‖1
for word in word_list:‖word_by_signature[signature(word)].append(word)‖1
"if __name__ == ""__main__"":"‖all_anagrams = {word: anagram(word) for word in word_list if len(anagram(word)) > 1}‖1
"with open(""anagrams.txt"", ""w"") as file:"‖"file.write(""all_anagrams = \n "")"‖1
"file.write(""all_anagrams = \n "")"‖file.write(pprint.pformat(all_anagrams))‖1
from collections import Counter‖from timeit import timeit‖1
def can_string_be_rearranged_as_palindrome_counter(‖"input_str: str = """","‖1
"input_str: str = """","‖) -> bool:‖1
) -> bool:‖"return sum(c % 2 for c in Counter(input_str.replace("" "", """").lower()).values()) < 2"‖1
"def can_string_be_rearranged_as_palindrome(input_str: str = """") -> bool:"‖if len(input_str) == 0:‖1
if len(input_str) == 0:‖return True‖1
return True‖"lower_case_input_str = input_str.replace("" "", """").lower()"‖1
for character in lower_case_input_str:‖character_freq_dict[character] = character_freq_dict.get(character, 0) + 1‖1
character_freq_dict[character] = character_freq_dict.get(character, 0) + 1‖odd_char = 0‖1
for character_count in character_freq_dict.values():‖if character_count % 2:‖1
if character_count % 2:‖odd_char += 1‖1
odd_char += 1‖return not odd_char > 1‖1
"def benchmark(input_str: str = """") -> None:"‖"print(""\nFor string = "", input_str, "":"")"‖1
"print(""\nFor string = "", input_str, "":"")"‖print(‖1
print(‖"""> can_string_be_rearranged_as_palindrome_counter()"","‖1
"""> can_string_be_rearranged_as_palindrome_counter()"","‖"""\tans ="","‖1
"""\tans ="","‖can_string_be_rearranged_as_palindrome_counter(input_str),‖1
can_string_be_rearranged_as_palindrome_counter(input_str),‖"""\ttime ="","‖1
"""\ttime ="","‖timeit(‖2
timeit(‖"""z.can_string_be_rearranged_as_palindrome_counter(z.check_str)"","‖1
"""z.can_string_be_rearranged_as_palindrome_counter(z.check_str)"","‖"setup=""import __main__ as z"","‖1
"setup=""import __main__ as z"","‖),‖2
),‖"""seconds"","‖2
"""seconds"","‖)‖2
print(‖"""> can_string_be_rearranged_as_palindrome()"","‖1
"""> can_string_be_rearranged_as_palindrome()"","‖"""\tans ="","‖1
"""\tans ="","‖can_string_be_rearranged_as_palindrome(input_str),‖1
can_string_be_rearranged_as_palindrome(input_str),‖"""\ttime ="","‖1
timeit(‖"""z.can_string_be_rearranged_as_palindrome(z.check_str)"","‖1
"""z.can_string_be_rearranged_as_palindrome(z.check_str)"","‖"setup=""import __main__ as z"","‖1
"if __name__ == ""__main__"":"‖check_str = input(‖1
check_str = input(‖"""Enter string to determine if it can be rearranged as a palindrome or not: """‖1
"""Enter string to determine if it can be rearranged as a palindrome or not: """‖).strip()‖1
).strip()‖benchmark(check_str)‖1
benchmark(check_str)‖status = can_string_be_rearranged_as_palindrome_counter(check_str)‖1
status = can_string_be_rearranged_as_palindrome_counter(check_str)‖"print(f""{check_str} can {'' if status else 'not '}be rearranged as a palindrome"")"‖1
class BoyerMooreSearch:‖def __init__(self, text: str, pattern: str):‖1
def __init__(self, text: str, pattern: str):‖self.text, self.pattern = text, pattern‖1
self.text, self.pattern = text, pattern‖self.textLen, self.patLen = len(text), len(pattern)‖1
for i in range(self.patLen - 1, -1, -1):‖if char == self.pattern[i]:‖1
if char == self.pattern[i]:‖return i‖1
for i in range(self.patLen - 1, -1, -1):‖if self.pattern[i] != self.text[current_pos + i]:‖1
if self.pattern[i] != self.text[current_pos + i]:‖return current_pos + i‖1
return current_pos + i‖return -1‖1
positions = []‖for i in range(self.textLen - self.patLen + 1):‖1
for i in range(self.textLen - self.patLen + 1):‖mismatch_index = self.mismatch_in_text(i)‖1
mismatch_index = self.mismatch_in_text(i)‖if mismatch_index == -1:‖1
if mismatch_index == -1:‖positions.append(i)‖1
positions.append(i)‖else:‖1
else:‖match_index = self.match_in_pattern(self.text[mismatch_index])‖1
match_index = self.match_in_pattern(self.text[mismatch_index])‖i = (‖1
i = (‖mismatch_index - match_index‖1
mismatch_index - match_index‖)‖1
)‖return positions‖1
"text = ""ABAABA"""‖"pattern = ""AB"""‖1
"pattern = ""AB"""‖bms = BoyerMooreSearch(text, pattern)‖1
bms = BoyerMooreSearch(text, pattern)‖positions = bms.bad_character_heuristic()‖1
if len(positions) == 0:‖"print(""No match found"")"‖1
"print(""No match found"")"‖else:‖1
else:‖"print(""Pattern found in following positions: "")"‖1
"print(""Pattern found in following positions: "")"‖print(positions)‖1
def capitalize(sentence: str) -> str:‖if not sentence:‖1
if not sentence:‖"return """""‖1
lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))‖return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]‖1
def get_check_digit(barcode: int) -> int:‖barcode //= 10‖1
barcode //= 10‖checker = False‖1
checker = False‖s = 0‖1
while barcode != 0:‖mult = 1 if checker else 3‖1
mult = 1 if checker else 3‖s += mult * (barcode % 10)‖1
s += mult * (barcode % 10)‖barcode //= 10‖1
barcode //= 10‖checker = not checker‖1
def is_valid(barcode: int) -> bool:‖return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10‖1
def get_barcode(barcode: str) -> int:‖if str(barcode).isalpha():‖1
if str(barcode).isalpha():‖"msg = f""Barcode '{barcode}' has alphabetic characters."""‖1
"msg = f""Barcode '{barcode}' has alphabetic characters."""‖raise ValueError(msg)‖1
raise ValueError(msg)‖elif int(barcode) < 0:‖1
elif int(barcode) < 0:‖"raise ValueError(""The entered barcode has a negative value. Try again."")"‖1
"raise ValueError(""The entered barcode has a negative value. Try again."")"‖else:‖1
else:‖return int(barcode)‖1
doctest.testmod()‖"barcode = get_barcode(input(""Barcode: "").strip())"‖1
if is_valid(barcode):‖"print(f""'{barcode}' is a valid barcode."")"‖1
"print(f""'{barcode}' is a valid barcode."")"‖else:‖1
else:‖"print(f""'{barcode}' is NOT a valid barcode."")"‖1
if not isinstance(input_str, str):‖"msg = f""Expected string as input, found {type(input_str)}"""‖2
"msg = f""Expected string as input, found {type(input_str)}"""‖raise ValueError(msg)‖2
for index, char in enumerate(input_str):‖if char.isupper():‖1
if char.isupper():‖"snake_str += ""_"" + char.lower()"‖1
elif input_str[index - 1].isdigit() and char.islower():‖"snake_str += ""_"" + char"‖1
elif input_str[index - 1].isalpha() and char.isnumeric():‖"snake_str += ""_"" + char.lower()"‖1
elif not char.isalnum():‖"snake_str += ""_"""‖1
else:‖snake_str += char‖1
"if snake_str[0] == ""_"":"‖snake_str = snake_str[1:]‖1
def check_anagrams(first_str: str, second_str: str) -> bool:‖first_str = first_str.lower().strip()‖1
first_str = first_str.lower().strip()‖second_str = second_str.lower().strip()‖1
"first_str = first_str.replace("" "", """")"‖"second_str = second_str.replace("" "", """")"‖1
if len(first_str) != len(second_str):‖return False‖1
for i in range(len(first_str)):‖count[first_str[i]] += 1‖1
count[first_str[i]] += 1‖count[second_str[i]] -= 1‖1
testmod()‖"input_a = input(""Enter the first string "").strip()"‖1
"input_a = input(""Enter the first string "").strip()"‖"input_b = input(""Enter the second string "").strip()"‖1
status = check_anagrams(input_a, input_b)‖"print(f""{input_a} and {input_b} are {'' if status else 'not '}anagrams."")"‖1
for i in range(len(first_string) + 1):‖dp_matrix[i][0] = i‖1
dp_matrix[i][0] = i‖for j in range(len(second_string) + 1):‖1
for j in range(len(second_string) + 1):‖dp_matrix[0][j] = j‖1
for i, first_char in enumerate(first_string, start=1):‖for j, second_char in enumerate(second_string, start=1):‖1
for j, second_char in enumerate(second_string, start=1):‖cost = int(first_char != second_char)‖1
dp_matrix[i][j] = min(‖dp_matrix[i - 1][j] + 1,‖1
dp_matrix[i - 1][j] + 1,‖dp_matrix[i][j - 1] + 1,‖1
dp_matrix[i][j - 1] + 1,‖dp_matrix[i - 1][j - 1] + cost,‖1
dp_matrix[i - 1][j - 1] + cost,‖)‖1
if (‖i > 1‖1
i > 1‖and j > 1‖1
and j > 1‖and first_string[i - 1] == second_string[j - 2]‖1
and first_string[i - 1] == second_string[j - 2]‖and first_string[i - 2] == second_string[j - 1]‖1
and first_string[i - 2] == second_string[j - 1]‖):‖1
def count_vowels(s: str) -> int:‖if not isinstance(s, str):‖1
if not isinstance(s, str):‖"raise ValueError(""Input must be a string"")"‖1
"vowels = ""aeiouAEIOU"""‖return sum(1 for char in s if char in vowels)‖1
def bitap_string_match(text: str, pattern: str) -> int:‖if not pattern:‖1
if not pattern:‖return 0‖1
return 0‖m = len(pattern)‖1
m = len(pattern)‖if m > len(text):‖1
if m > len(text):‖return -1‖1
"pattern_index: int = ord(char) - ord(""a"")"‖pattern_mask[pattern_index] &= ~(1 << i)‖1
for i, char in enumerate(text):‖"text_index = ord(char) - ord(""a"")"‖1
state |= pattern_mask[text_index]‖state <<= 1‖1
if (state & (1 << m)) == 0:‖return i - m + 1‖1
import os‖from string import ascii_letters‖1
def load_dictionary() -> dict[str, None]:‖path = os.path.split(os.path.realpath(__file__))‖1
path = os.path.split(os.path.realpath(__file__))‖english_words: dict[str, None] = {}‖1
english_words: dict[str, None] = {}‖"with open(path[0] + ""/dictionary.txt"") as dictionary_file:"‖1
"with open(path[0] + ""/dictionary.txt"") as dictionary_file:"‖"for word in dictionary_file.read().split(""\n""):"‖1
"for word in dictionary_file.read().split(""\n""):"‖english_words[word] = None‖1
english_words[word] = None‖return english_words‖1
def get_english_count(message: str) -> float:‖message = message.upper()‖1
message = message.upper()‖message = remove_non_letters(message)‖1
message = remove_non_letters(message)‖possible_words = message.split()‖1
possible_words = message.split()‖matches = len([word for word in possible_words if word in ENGLISH_WORDS])‖1
matches = len([word for word in possible_words if word in ENGLISH_WORDS])‖return float(matches) / len(possible_words)‖1
def remove_non_letters(message: str) -> str:‖"return """".join(symbol for symbol in message if symbol in LETTERS_AND_SPACE)"‖1
def is_english(‖message: str, word_percentage: int = 20, letter_percentage: int = 85‖1
message: str, word_percentage: int = 20, letter_percentage: int = 85‖) -> bool:‖1
) -> bool:‖words_match = get_english_count(message) * 100 >= word_percentage‖1
words_match = get_english_count(message) * 100 >= word_percentage‖num_letters = len(remove_non_letters(message))‖1
num_letters = len(remove_non_letters(message))‖message_letters_percentage = (float(num_letters) / len(message)) * 100‖1
message_letters_percentage = (float(num_letters) / len(message)) * 100‖letters_match = message_letters_percentage >= letter_percentage‖1
letters_match = message_letters_percentage >= letter_percentage‖return words_match and letters_match‖1
def validate_initial_digits(credit_card_number: str) -> bool:‖"return credit_card_number.startswith((""34"", ""35"", ""37"", ""4"", ""5"", ""6""))"‖1
def luhn_validation(credit_card_number: str) -> bool:‖cc_number = credit_card_number‖1
cc_number = credit_card_number‖total = 0‖1
total = 0‖half_len = len(cc_number) - 2‖1
half_len = len(cc_number) - 2‖for i in range(half_len, -1, -2):‖1
digit = int(cc_number[i])‖digit *= 2‖1
if digit > 9:‖digit %= 10‖1
digit %= 10‖digit += 1‖1
digit += 1‖cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]‖1
cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]‖total += digit‖1
for i in range(len(cc_number) - 1, -1, -2):‖total += int(cc_number[i])‖1
def validate_credit_card_number(credit_card_number: str) -> bool:‖"error_message = f""{credit_card_number} is an invalid credit card number because"""‖1
"error_message = f""{credit_card_number} is an invalid credit card number because"""‖if not credit_card_number.isdigit():‖1
if not credit_card_number.isdigit():‖"print(f""{error_message} it has nonnumerical characters."")"‖1
"print(f""{error_message} it has nonnumerical characters."")"‖return False‖1
if not 13 <= len(credit_card_number) <= 16:‖"print(f""{error_message} of its length."")"‖1
"print(f""{error_message} of its length."")"‖return False‖1
if not validate_initial_digits(credit_card_number):‖"print(f""{error_message} of its first two digits."")"‖1
"print(f""{error_message} of its first two digits."")"‖return False‖1
if not luhn_validation(credit_card_number):‖"print(f""{error_message} it fails the Luhn check."")"‖1
"print(f""{error_message} it fails the Luhn check."")"‖return False‖1
"print(f""{credit_card_number} is a valid credit card number."")"‖return True‖1
doctest.testmod()‖"validate_credit_card_number(""4111111111111111"")"‖1
"validate_credit_card_number(""4111111111111111"")"‖"validate_credit_card_number(""32323"")"‖1
def edit_distance(source: str, target: str) -> int:‖if len(source) == 0:‖1
if len(source) == 0:‖return len(target)‖1
return len(target)‖elif len(target) == 0:‖1
elif len(target) == 0:‖return len(source)‖1
delta = int(source[-1] != target[-1])‖return min(‖1
return min(‖edit_distance(source[:-1], target[:-1]) + delta,‖1
edit_distance(source[:-1], target[:-1]) + delta,‖edit_distance(source, target[:-1]) + 1,‖1
edit_distance(source, target[:-1]) + 1,‖edit_distance(source[:-1], target) + 1,‖1
edit_distance(source[:-1], target) + 1,‖)‖1
"if __name__ == ""__main__"":"‖"print(edit_distance(""ATCGCTG"", ""TAGCTAA""))"‖1
"if len(re.findall(""[ATCG]"", dna)) != len(dna):"‖"raise ValueError(""Invalid Strand"")"‖1
english_letter_freq = {‖"""E"": 12.70,"‖1
"""E"": 12.70,"‖"""T"": 9.06,"‖1
"""T"": 9.06,"‖"""A"": 8.17,"‖1
"""A"": 8.17,"‖"""O"": 7.51,"‖1
"""O"": 7.51,"‖"""I"": 6.97,"‖1
"""I"": 6.97,"‖"""N"": 6.75,"‖1
"""N"": 6.75,"‖"""S"": 6.33,"‖1
"""S"": 6.33,"‖"""H"": 6.09,"‖1
"""H"": 6.09,"‖"""R"": 5.99,"‖1
"""R"": 5.99,"‖"""D"": 4.25,"‖1
"""D"": 4.25,"‖"""L"": 4.03,"‖1
"""L"": 4.03,"‖"""C"": 2.78,"‖1
"""C"": 2.78,"‖"""U"": 2.76,"‖1
"""U"": 2.76,"‖"""M"": 2.41,"‖1
"""M"": 2.41,"‖"""W"": 2.36,"‖1
"""W"": 2.36,"‖"""F"": 2.23,"‖1
"""F"": 2.23,"‖"""G"": 2.02,"‖1
"""G"": 2.02,"‖"""Y"": 1.97,"‖1
"""Y"": 1.97,"‖"""P"": 1.93,"‖1
"""P"": 1.93,"‖"""B"": 1.29,"‖1
"""B"": 1.29,"‖"""V"": 0.98,"‖1
"""V"": 0.98,"‖"""K"": 0.77,"‖1
"""K"": 0.77,"‖"""J"": 0.15,"‖1
"""J"": 0.15,"‖"""X"": 0.15,"‖1
"""X"": 0.15,"‖"""Q"": 0.10,"‖1
"""Q"": 0.10,"‖"""Z"": 0.07,"‖1
"""Z"": 0.07,"‖}‖1
}‖"ETAOIN = ""ETAOINSHRDLCUMWFGYPBVKJXQZ"""‖1
"ETAOIN = ""ETAOINSHRDLCUMWFGYPBVKJXQZ"""‖"LETTERS = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"""‖1
def get_letter_count(message: str) -> dict[str, int]:‖letter_count = {letter: 0 for letter in string.ascii_uppercase}‖1
letter_count = {letter: 0 for letter in string.ascii_uppercase}‖for letter in message.upper():‖1
for letter in message.upper():‖if letter in LETTERS:‖1
if letter in LETTERS:‖letter_count[letter] += 1‖1
def get_item_at_index_zero(x: tuple) -> str:‖return x[0]‖1
def get_frequency_order(message: str) -> str:‖letter_to_freq = get_letter_count(message)‖1
letter_to_freq = get_letter_count(message)‖freq_to_letter: dict[int, list[str]] = {‖1
freq_to_letter: dict[int, list[str]] = {‖freq: [] for letter, freq in letter_to_freq.items()‖1
freq: [] for letter, freq in letter_to_freq.items()‖}‖1
}‖for letter in LETTERS:‖1
for letter in LETTERS:‖freq_to_letter[letter_to_freq[letter]].append(letter)‖1
for freq in freq_to_letter:‖freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)‖1
freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)‖"freq_to_letter_str[freq] = """".join(freq_to_letter[freq])"‖1
freq_pairs = list(freq_to_letter_str.items())‖freq_pairs.sort(key=get_item_at_index_zero, reverse=True)‖1
def english_freq_match_score(message: str) -> int:‖freq_order = get_frequency_order(message)‖1
freq_order = get_frequency_order(message)‖match_score = 0‖1
match_score = 0‖for common_letter in ETAOIN[:6]:‖1
for common_letter in ETAOIN[:6]:‖if common_letter in freq_order[:6]:‖1
if common_letter in freq_order[:6]:‖match_score += 1‖1
for uncommon_letter in ETAOIN[-6:]:‖if uncommon_letter in freq_order[-6:]:‖1
if uncommon_letter in freq_order[-6:]:‖match_score += 1‖1
def indian_phone_validator(phone: str) -> bool:‖"pat = re.compile(r""^(\+91[\-\s]?)?[0]?(91)?[789]\d{9}$"")"‖1
"pat = re.compile(r""^(\+91[\-\s]?)?[0]?(91)?[789]\d{9}$"")"‖if match := re.search(pat, phone):‖1
if match := re.search(pat, phone):‖return match.string == phone‖1
return match.string == phone‖return False‖1
"if __name__ == ""__main__"":"‖"print(indian_phone_validator(""+918827897895""))"‖1
bitmap = 0‖for ch in input_str:‖1
for ch in input_str:‖ch_unicode = ord(ch)‖1
ch_unicode = ord(ch)‖ch_bit_index_on = pow(2, ch_unicode)‖1
if bitmap >> ch_unicode & 1 == 1:‖return False‖1
return False‖bitmap |= ch_bit_index_on‖1
bitmap |= ch_bit_index_on‖return True‖1
def is_pangram(‖"input_str: str = ""The quick brown fox jumps over the lazy dog"","‖1
"input_str: str = ""The quick brown fox jumps over the lazy dog"","‖) -> bool:‖3
"input_str = input_str.replace("" "", """")"‖for alpha in input_str:‖1
for alpha in input_str:‖"if ""a"" <= alpha.lower() <= ""z"":"‖1
"if ""a"" <= alpha.lower() <= ""z"":"‖frequency.add(alpha.lower())‖1
frequency.add(alpha.lower())‖return len(frequency) == 26‖1
def is_pangram_faster(‖"input_str: str = ""The quick brown fox jumps over the lazy dog"","‖1
) -> bool:‖flag = [False] * 26‖1
flag = [False] * 26‖for char in input_str:‖1
for char in input_str:‖if char.islower():‖1
if char.islower():‖flag[ord(char) - 97] = True‖1
flag[ord(char) - 97] = True‖elif char.isupper():‖1
elif char.isupper():‖flag[ord(char) - 65] = True‖1
flag[ord(char) - 65] = True‖return all(flag)‖1
def is_pangram_fastest(‖"input_str: str = ""The quick brown fox jumps over the lazy dog"","‖1
) -> bool:‖return len({char for char in input_str.lower() if char.isalpha()}) == 26‖1
"setup = ""from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest"""‖"print(timeit(""is_pangram()"", setup=setup))"‖1
"print(timeit(""is_pangram()"", setup=setup))"‖"print(timeit(""is_pangram_faster()"", setup=setup))"‖1
"print(timeit(""is_pangram_faster()"", setup=setup))"‖"print(timeit(""is_pangram_fastest()"", setup=setup))"‖1
def is_isogram(string: str) -> bool:‖if not all(x.isalpha() for x in string):‖1
if not all(x.isalpha() for x in string):‖"raise ValueError(""String must only contain alphabetic characters."")"‖1
letters = sorted(string.lower())‖return len(letters) == len(set(letters))‖1
"if __name__ == ""__main__"":"‖"input_str = input(""Enter a string "").strip()"‖1
isogram = is_isogram(input_str)‖"print(f""{input_str} is {'an' if isogram else 'not an'} isogram."")"‖1
def hamming_distance(string1: str, string2: str) -> int:‖if len(string1) != len(string2):‖1
if len(string1) != len(string2):‖"raise ValueError(""String lengths must match!"")"‖1
for char1, char2 in zip(string1, string2):‖if char1 != char2:‖1
if char1 != char2:‖count += 1‖1
if not isinstance(input_str, str):‖"msg = f""Expected str as input, found {type(input_str)}"""‖1
"msg = f""Expected str as input, found {type(input_str)}"""‖raise ValueError(msg)‖1
try:‖input_int = int(input_str)‖1
input_int = int(input_str)‖except ValueError:‖1
except ValueError:‖"msg = ""Expected number as input"""‖1
"msg = ""Expected number as input"""‖raise ValueError(msg)‖1
if not 10100000 <= input_int <= 99923199999:‖return False‖1
if (‖month not in range(1, 13)‖1
month not in range(1, 13)‖and month not in range(21, 33)‖1
and month not in range(21, 33)‖and month not in range(41, 53)‖1
and month not in range(41, 53)‖and month not in range(61, 73)‖1
and month not in range(61, 73)‖and month not in range(81, 93)‖1
and month not in range(81, 93)‖):‖1
if day not in range(1, 32):‖return False‖1
multipliers = [1, 3, 7, 9, 1, 3, 7, 9, 1, 3]‖subtotal = 0‖1
email_tests: tuple[tuple[str, bool], ...] = (‖"(""simple@example.com"", True),"‖1
"(""simple@example.com"", True),"‖"(""very.common@example.com"", True),"‖1
"(""very.common@example.com"", True),"‖"(""disposable.style.email.with+symbol@example.com"", True),"‖1
"(""disposable.style.email.with+symbol@example.com"", True),"‖"(""other-email-with-hyphen@and.subdomains.example.com"", True),"‖1
"(""other-email-with-hyphen@and.subdomains.example.com"", True),"‖"(""fully-qualified-domain@example.com"", True),"‖1
"(""fully-qualified-domain@example.com"", True),"‖"(""user.name+tag+sorting@example.com"", True),"‖1
"(""user.name+tag+sorting@example.com"", True),"‖"(""x@example.com"", True),"‖1
"(""x@example.com"", True),"‖"(""example-indeed@strange-example.com"", True),"‖1
"(""example-indeed@strange-example.com"", True),"‖"(""test/test@test.com"", True),"‖1
"(""test/test@test.com"", True),"‖(‖1
(‖"""123456789012345678901234567890123456789012345678901234567890123@example.com"","‖1
"""123456789012345678901234567890123456789012345678901234567890123@example.com"","‖True,‖1
True,‖),‖1
),‖"(""admin@mailserver1"", True),"‖1
"(""admin@mailserver1"", True),"‖"(""example@s.example"", True),"‖1
"(""example@s.example"", True),"‖"(""Abc.example.com"", False),"‖1
"(""Abc.example.com"", False),"‖"(""A@b@c@example.com"", False),"‖1
"(""A@b@c@example.com"", False),"‖"(""abc@example..com"", False),"‖1
"(""abc@example..com"", False),"‖"(""a(c)d,e:f;g<h>i[j\\k]l@example.com"", False),"‖1
"(""a(c)d,e:f;g<h>i[j\\k]l@example.com"", False),"‖(‖1
(‖"""12345678901234567890123456789012345678901234567890123456789012345@example.com"","‖1
"""12345678901234567890123456789012345678901234567890123456789012345@example.com"","‖False,‖1
False,‖),‖1
),‖"(""i.like.underscores@but_its_not_allowed_in_this_part"", False),"‖1
"(""i.like.underscores@but_its_not_allowed_in_this_part"", False),"‖"("""", False),"‖1
"("""", False),"‖)‖1
MAX_LOCAL_PART_OCTETS = 64‖MAX_DOMAIN_OCTETS = 255‖1
"if email.count(""@"") != 1:"‖return False‖1
if len(local_part) > MAX_LOCAL_PART_OCTETS or len(domain) > MAX_DOMAIN_OCTETS:‖return False‖1
if any(‖"char not in string.ascii_letters + string.digits + "".(!#$%&'*+-/=?^_`{|}~)"""‖1
"char not in string.ascii_letters + string.digits + "".(!#$%&'*+-/=?^_`{|}~)"""‖for char in local_part‖1
for char in local_part‖):‖1
"if local_part.startswith(""."") or local_part.endswith(""."") or "".."" in local_part:"‖return False‖1
"if any(char not in string.ascii_letters + string.digits + "".-"" for char in domain):"‖return False‖1
"if domain.startswith(""-"") or domain.endswith("".""):"‖return False‖1
for email, valid in email_tests:‖is_valid = is_valid_email_address(email)‖1
is_valid = is_valid_email_address(email)‖"assert is_valid == valid, f""{email} is {is_valid}"""‖1
"assert is_valid == valid, f""{email} is {is_valid}"""‖"print(f""Email address {email} is {'not ' if not is_valid else ''}valid"")"‖1
"if __name__ == ""__main__"":"‖"phone = ""0094702343221"""‖1
"NUMBERS_PLUS_LETTER = ""Input must be a string of 8 numbers plus letter"""‖"LOOKUP_LETTERS = ""TRWAGMYFPDXBNJZSQVHLCKE"""‖1
if not isinstance(spanish_id, str):‖"msg = f""Expected string as input, found {type(spanish_id).__name__}"""‖1
"msg = f""Expected string as input, found {type(spanish_id).__name__}"""‖raise TypeError(msg)‖1
"spanish_id_clean = spanish_id.replace(""-"", """").upper()"‖if len(spanish_id_clean) != 9:‖1
if len(spanish_id_clean) != 9:‖raise ValueError(NUMBERS_PLUS_LETTER)‖1
try:‖number = int(spanish_id_clean[0:8])‖1
number = int(spanish_id_clean[0:8])‖letter = spanish_id_clean[8]‖1
letter = spanish_id_clean[8]‖except ValueError as ex:‖1
except ValueError as ex:‖raise ValueError(NUMBERS_PLUS_LETTER) from ex‖1
if letter.isdigit():‖raise ValueError(NUMBERS_PLUS_LETTER)‖1
def get_matched_characters(_str1: str, _str2: str) -> str:‖matched = []‖1
matched = []‖limit = min(len(_str1), len(_str2)) // 2‖1
limit = min(len(_str1), len(_str2)) // 2‖for i, char in enumerate(_str1):‖1
for i, char in enumerate(_str1):‖left = int(max(0, i - limit))‖1
left = int(max(0, i - limit))‖right = int(min(i + limit + 1, len(_str2)))‖1
right = int(min(i + limit + 1, len(_str2)))‖if char in _str2[left:right]:‖1
if char in _str2[left:right]:‖matched.append(char)‖1
matched.append(char)‖_str2 = (‖1
_str2 = (‖"f""{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}"""‖1
"f""{_str2[0 : _str2.index(char)]} {_str2[_str2.index(char) + 1 :]}"""‖)‖1
matching_1 = get_matched_characters(str1, str2)‖matching_2 = get_matched_characters(str2, str1)‖1
matching_2 = get_matched_characters(str2, str1)‖match_count = len(matching_1)‖1
transpositions = (‖len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2‖1
len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2‖)‖1
if not match_count:‖jaro = 0.0‖1
jaro = 0.0‖else:‖1
else:‖jaro = (‖1
jaro = (‖1‖1
/ 3‖* (‖1
* (‖match_count / len(str1)‖1
match_count / len(str1)‖+ match_count / len(str2)‖1
+ match_count / len(str2)‖+ (match_count - transpositions) / match_count‖1
+ (match_count - transpositions) / match_count‖)‖1
prefix_len = 0‖for c1, c2 in zip(str1[:4], str2[:4]):‖1
for c1, c2 in zip(str1[:4], str2[:4]):‖if c1 == c2:‖1
if c1 == c2:‖prefix_len += 1‖1
prefix_len += 1‖else:‖1
doctest.testmod()‖"print(jaro_winkler(""hello"", ""world""))"‖1
if not isinstance(word_or_phrase, str):‖"raise Exception(""join() accepts only strings"")"‖1
"joined: str = """""‖last_index: int = len(separated) - 1‖1
last_index: int = len(separated) - 1‖for word_or_phrase in separated[:last_index]:‖1
if separated != []:‖joined += separated[last_index]‖1
i, j = 0, 0‖while i < len(text):‖1
while i < len(text):‖if pattern[j] == text[i]:‖1
if pattern[j] == text[i]:‖if j == (len(pattern) - 1):‖1
if j == (len(pattern) - 1):‖return i - j‖1
return i - j‖j += 1‖1
elif j > 0:‖j = failure[j - 1]‖1
j = failure[j - 1]‖continue‖1
continue‖i += 1‖1
i += 1‖return -1‖1
def get_failure_array(pattern: str) -> list[int]:‖failure = [0]‖1
failure = [0]‖i = 0‖1
i = 0‖j = 1‖1
j = 1‖while j < len(pattern):‖1
while j < len(pattern):‖if pattern[i] == pattern[j]:‖1
if pattern[i] == pattern[j]:‖i += 1‖1
i += 1‖elif i > 0:‖1
elif i > 0:‖i = failure[i - 1]‖1
i = failure[i - 1]‖continue‖1
continue‖j += 1‖1
j += 1‖failure.append(i)‖1
failure.append(i)‖return failure‖1
"pattern = ""abc1abc12"""‖"text1 = ""alskfjaldsabc1abc1abc12k23adsfabcabc"""‖2
"text1 = ""alskfjaldsabc1abc1abc12k23adsfabcabc"""‖"text2 = ""alskfjaldsk23adsfabcabc"""‖2
"text2 = ""alskfjaldsk23adsfabcabc"""‖assert knuth_morris_pratt(text1, pattern)‖1
assert knuth_morris_pratt(text1, pattern)‖assert knuth_morris_pratt(text2, pattern)‖1
"pattern = ""ABABX"""‖"text = ""ABABZABABYABABX"""‖2
"text = ""ABABZABABYABABX"""‖assert knuth_morris_pratt(text, pattern)‖1
"pattern = ""AAAB"""‖"text = ""ABAAAAAB"""‖2
"text = ""ABAAAAAB"""‖assert knuth_morris_pratt(text, pattern)‖1
"pattern = ""abcdabcy"""‖"text = ""abcxabcdabxabcdabcdabcy"""‖2
"text = ""abcxabcdabxabcdabcdabcy"""‖assert knuth_morris_pratt(text, pattern)‖1
"kmp = ""knuth_morris_pratt"""‖assert all(‖1
assert all(‖knuth_morris_pratt(kmp, s) == kmp.find(s)‖1
knuth_morris_pratt(kmp, s) == kmp.find(s)‖"for s in (""kn"", ""h_m"", ""rr"", ""tt"", ""not there"")"‖1
"for s in (""kn"", ""h_m"", ""rr"", ""tt"", ""not there"")"‖)‖1
"pattern = ""aabaabaaa"""‖assert get_failure_array(pattern) == [0, 1, 0, 1, 2, 3, 4, 5, 2]‖1
def palindromic_string(input_string: str) -> str:‖max_length = 0‖1
"new_input_string = """""‖"output_string = """""‖1
for i in input_string[: len(input_string) - 1]:‖"new_input_string += i + ""|"""‖1
start = 0‖for j in range(len(new_input_string)):‖1
for j in range(len(new_input_string)):‖k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)‖1
k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)‖while (‖1
while (‖j - k >= 0‖1
j - k >= 0‖and j + k < len(new_input_string)‖1
and j + k < len(new_input_string)‖and new_input_string[k + j] == new_input_string[j - k]‖1
and new_input_string[k + j] == new_input_string[j - k]‖):‖1
):‖k += 1‖1
if j + k - 1 > right:‖left = j - k + 1‖1
left = j - k + 1‖right = j + k - 1‖1
if max_length < length[j]:‖max_length = length[j]‖1
max_length = length[j]‖start = j‖1
s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]‖for i in s:‖1
for i in s:‖"if i != ""|"":"‖1
"if i != ""|"":"‖output_string += i‖1
def compute_transform_tables(‖source_string: str,‖1
source_string: str,‖destination_string: str,‖1
destination_string: str,‖copy_cost: int,‖1
copy_cost: int,‖replace_cost: int,‖1
replace_cost: int,‖delete_cost: int,‖1
delete_cost: int,‖insert_cost: int,‖1
insert_cost: int,‖) -> tuple[list[list[int]], list[list[str]]]:‖1
) -> tuple[list[list[int]], list[list[str]]]:‖source_seq = list(source_string)‖1
source_seq = list(source_string)‖destination_seq = list(destination_string)‖1
destination_seq = list(destination_string)‖len_source_seq = len(source_seq)‖1
len_source_seq = len(source_seq)‖len_destination_seq = len(destination_seq)‖1
len_destination_seq = len(destination_seq)‖costs = [‖1
costs = [‖[0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)‖1
[0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)‖]‖1
]‖ops = [‖1
ops = [‖"[""0"" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)"‖1
"[""0"" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)"‖]‖1
for i in range(1, len_source_seq + 1):‖costs[i][0] = i * delete_cost‖1
costs[i][0] = i * delete_cost‖"ops[i][0] = f""D{source_seq[i - 1]}"""‖1
for i in range(1, len_destination_seq + 1):‖costs[0][i] = i * insert_cost‖1
costs[0][i] = i * insert_cost‖"ops[0][i] = f""I{destination_seq[i - 1]}"""‖1
for i in range(1, len_source_seq + 1):‖for j in range(1, len_destination_seq + 1):‖1
for j in range(1, len_destination_seq + 1):‖if source_seq[i - 1] == destination_seq[j - 1]:‖1
if source_seq[i - 1] == destination_seq[j - 1]:‖costs[i][j] = costs[i - 1][j - 1] + copy_cost‖1
costs[i][j] = costs[i - 1][j - 1] + copy_cost‖"ops[i][j] = f""C{source_seq[i - 1]}"""‖1
"ops[i][j] = f""C{source_seq[i - 1]}"""‖else:‖1
else:‖costs[i][j] = costs[i - 1][j - 1] + replace_cost‖1
costs[i][j] = costs[i - 1][j - 1] + replace_cost‖"ops[i][j] = f""R{source_seq[i - 1]}"" + str(destination_seq[j - 1])"‖1
if costs[i - 1][j] + delete_cost < costs[i][j]:‖costs[i][j] = costs[i - 1][j] + delete_cost‖1
costs[i][j] = costs[i - 1][j] + delete_cost‖"ops[i][j] = f""D{source_seq[i - 1]}"""‖1
if costs[i][j - 1] + insert_cost < costs[i][j]:‖costs[i][j] = costs[i][j - 1] + insert_cost‖1
costs[i][j] = costs[i][j - 1] + insert_cost‖"ops[i][j] = f""I{destination_seq[j - 1]}"""‖1
def assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:‖if i == 0 and j == 0:‖1
if i == 0 and j == 0:‖return []‖1
return []‖"elif ops[i][j][0] in {""C"", ""R""}:"‖1
"elif ops[i][j][0] in {""C"", ""R""}:"‖seq = assemble_transformation(ops, i - 1, j - 1)‖1
seq = assemble_transformation(ops, i - 1, j - 1)‖seq.append(ops[i][j])‖1
seq.append(ops[i][j])‖return seq‖3
return seq‖"elif ops[i][j][0] == ""D"":"‖1
"elif ops[i][j][0] == ""D"":"‖seq = assemble_transformation(ops, i - 1, j)‖1
seq = assemble_transformation(ops, i - 1, j)‖seq.append(ops[i][j])‖1
return seq‖else:‖1
else:‖seq = assemble_transformation(ops, i, j - 1)‖1
seq = assemble_transformation(ops, i, j - 1)‖seq.append(ops[i][j])‖1
"if __name__ == ""__main__"":"‖"_, operations = compute_transform_tables(""Python"", ""Algorithms"", -1, 1, 2, 2)"‖1
m = len(operations)‖n = len(operations[0])‖1
n = len(operations[0])‖sequence = assemble_transformation(operations, m - 1, n - 1)‖1
"string = list(""Python"")"‖i = 0‖1
i = 0‖cost = 0‖1
"with open(""min_cost.txt"", ""w"") as file:"‖for op in sequence:‖1
for op in sequence:‖"print("""".join(string))"‖1
"if op[0] == ""C"":"‖"file.write(""%-16s"" % ""Copy %c"" % op[1])"‖1
"file.write(""%-16s"" % ""Copy %c"" % op[1])"‖"file.write(""\t\t\t"" + """".join(string))"‖1
"file.write(""\t\t\t"" + """".join(string))"‖"file.write(""\r\n"")"‖3
cost -= 1‖"elif op[0] == ""R"":"‖1
"elif op[0] == ""R"":"‖string[i] = op[2]‖1
"file.write(""%-16s"" % (""Replace %c"" % op[1] + "" with "" + str(op[2])))"‖"file.write(""\t\t"" + """".join(string))"‖1
"file.write(""\t\t"" + """".join(string))"‖"file.write(""\r\n"")"‖1
cost += 1‖"elif op[0] == ""D"":"‖1
"elif op[0] == ""D"":"‖string.pop(i)‖1
"file.write(""%-16s"" % ""Delete %c"" % op[1])"‖"file.write(""\t\t\t"" + """".join(string))"‖1
cost += 2‖else:‖1
else:‖string.insert(i, op[1])‖1
"file.write(""%-16s"" % ""Insert %c"" % op[1])"‖"file.write(""\t\t\t"" + """".join(string))"‖1
"print("""".join(string))"‖"print(""Cost: "", cost)"‖1
if len(first_word) < len(second_word):‖return levenshtein_distance(second_word, first_word)‖1
if len(second_word) == 0:‖return len(first_word)‖2
for i, c1 in enumerate(first_word):‖current_row = [i + 1]‖1
insertions = previous_row[j + 1] + 1‖deletions = current_row[j] + 1‖2
deletions = current_row[j] + 1‖substitutions = previous_row[j] + (c1 != c2)‖2
def levenshtein_distance_optimized(first_word: str, second_word: str) -> int:‖if len(first_word) < len(second_word):‖1
if len(first_word) < len(second_word):‖return levenshtein_distance_optimized(second_word, first_word)‖1
for i, c1 in enumerate(first_word):‖current_row = [i + 1] + [0] * len(second_word)‖1
for j, c2 in enumerate(second_word):‖insertions = previous_row[j + 1] + 1‖1
substitutions = previous_row[j] + (c1 != c2)‖current_row[j + 1] = min(insertions, deletions, substitutions)‖1
def benchmark_levenshtein_distance(func: Callable) -> None:‖from timeit import timeit‖1
"stmt = f""{func.__name__}('sitting', 'kitten')"""‖"setup = f""from __main__ import {func.__name__}"""‖1
"setup = f""from __main__ import {func.__name__}"""‖number = 25_000‖1
number = 25_000‖result = timeit(stmt=stmt, setup=setup, number=number)‖1
result = timeit(stmt=stmt, setup=setup, number=number)‖"print(f""{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds"")"‖1
"first_word = input(""Enter the first word for Levenshtein distance:\n"").strip()"‖"second_word = input(""Enter the second word for Levenshtein distance:\n"").strip()"‖1
"print(f""{levenshtein_distance(first_word, second_word) = }"")"‖"print(f""{levenshtein_distance_optimized(first_word, second_word) = }"")"‖1
benchmark_levenshtein_distance(levenshtein_distance)‖benchmark_levenshtein_distance(levenshtein_distance_optimized)‖1
test_data = {‖"""MALAYALAM"": True,"‖1
"""MALAYALAM"": True,"‖"""String"": False,"‖1
"""String"": False,"‖"""rotor"": True,"‖1
"""rotor"": True,"‖"""level"": True,"‖1
"""level"": True,"‖"""A"": True,"‖1
"""A"": True,"‖"""BB"": True,"‖1
"""BB"": True,"‖"""ABC"": False,"‖1
"""ABC"": False,"‖"""amanaplanacanalpanama"": True,"‖1
"""amanaplanacanalpanama"": True,"‖}‖1
start_i = 0‖end_i = len(s) - 1‖1
end_i = len(s) - 1‖while start_i < end_i:‖1
while start_i < end_i:‖if s[start_i] == s[end_i]:‖1
if s[start_i] == s[end_i]:‖start_i += 1‖1
start_i += 1‖end_i -= 1‖1
end_i -= 1‖else:‖1
def is_palindrome_traversal(s: str) -> bool:‖end = len(s) // 2‖1
end = len(s) // 2‖n = len(s)‖1
def is_palindrome_recursive(s: str) -> bool:‖if len(s) <= 2:‖1
if len(s) <= 2:‖return True‖1
return True‖if s[0] == s[len(s) - 1]:‖1
if s[0] == s[len(s) - 1]:‖return is_palindrome_recursive(s[1:-1])‖1
return is_palindrome_recursive(s[1:-1])‖else:‖1
def is_palindrome_slice(s: str) -> bool:‖return s == s[::-1]‖1
def benchmark_function(name: str) -> None:‖"stmt = f""all({name}(key) is value for key, value in test_data.items())"""‖1
"stmt = f""all({name}(key) is value for key, value in test_data.items())"""‖"setup = f""from __main__ import test_data, {name}"""‖1
"setup = f""from __main__ import test_data, {name}"""‖number = 500000‖1
number = 500000‖result = timeit(stmt=stmt, setup=setup, number=number)‖1
result = timeit(stmt=stmt, setup=setup, number=number)‖"print(f""{name:<35} finished {number:,} runs in {result:.5f} seconds"")"‖1
"if __name__ == ""__main__"":"‖for key, value in test_data.items():‖1
for key, value in test_data.items():‖assert is_palindrome(key) is is_palindrome_recursive(key)‖1
assert is_palindrome(key) is is_palindrome_recursive(key)‖assert is_palindrome(key) is is_palindrome_slice(key)‖1
assert is_palindrome(key) is is_palindrome_slice(key)‖"print(f""{key:21} {value}"")"‖1
"print(f""{key:21} {value}"")"‖"print(""a man a plan a canal panama"")"‖1
def create_ngram(sentence: str, ngram_size: int) -> list[str]:‖return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]‖1
def pig_latin(word: str) -> str:‖"if not (word or """").strip():"‖1
"if not (word or """").strip():"‖"return """""‖1
"return """""‖word = word.lower()‖1
word = word.lower()‖"if word[0] in ""aeiou"":"‖1
"if word[0] in ""aeiou"":"‖"return f""{word}way"""‖1
"return f""{word}way"""‖for i, char in enumerate(word):‖1
for i, char in enumerate(word):‖"if char in ""aeiou"":"‖1
"if char in ""aeiou"":"‖break‖1
break‖"return f""{word[i:]}{word[:i]}ay"""‖1
"if __name__ == ""__main__"":"‖"print(f""{pig_latin('friends') = }"")"‖1
"print(f""{pig_latin('friends') = }"")"‖"word = input(""Enter a word: "")"‖1
"word = input(""Enter a word: "")"‖"print(f""{pig_latin(word) = }"")"‖1
def reverse_letters(sentence: str, length: int = 0) -> str:‖"return "" "".join("‖1
"return "" "".join("‖""""".join(word[::-1]) if len(word) > length else word for word in sentence.split()"‖1
""""".join(word[::-1]) if len(word) > length else word for word in sentence.split()"‖)‖1
doctest.testmod()‖"print(reverse_letters(""Hey wollef sroirraw""))"‖1
def naive_pattern_search(s: str, pattern: str) -> list:‖pat_len = len(pattern)‖1
pat_len = len(pattern)‖position = []‖1
position = []‖for i in range(len(s) - pat_len + 1):‖1
for i in range(len(s) - pat_len + 1):‖match_found = True‖1
match_found = True‖for j in range(pat_len):‖1
for j in range(pat_len):‖if s[i + j] != pattern[j]:‖1
if s[i + j] != pattern[j]:‖match_found = False‖1
match_found = False‖break‖1
break‖if match_found:‖1
if match_found:‖position.append(i)‖1
position.append(i)‖return position‖1
"if __name__ == ""__main__"":"‖"assert naive_pattern_search(""ABCDEFG"", ""DE"") == [3]"‖1
"assert naive_pattern_search(""ABCDEFG"", ""DE"") == [3]"‖"print(naive_pattern_search(""ABAAABCDBBABCDDEBCABC"", ""ABC""))"‖1
def rabin_karp(pattern: str, text: str) -> bool:‖p_len = len(pattern)‖1
p_len = len(pattern)‖t_len = len(text)‖1
t_len = len(text)‖if p_len > t_len:‖1
if p_len > t_len:‖return False‖1
p_hash = 0‖text_hash = 0‖1
text_hash = 0‖modulus_power = 1‖1
for i in range(p_len):‖p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus‖1
p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus‖text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus‖1
text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus‖if i == p_len - 1:‖1
if i == p_len - 1:‖continue‖1
continue‖modulus_power = (modulus_power * alphabet_size) % modulus‖1
for i in range(t_len - p_len + 1):‖if text_hash == p_hash and text[i : i + p_len] == pattern:‖1
if text_hash == p_hash and text[i : i + p_len] == pattern:‖return True‖1
return True‖if i == t_len - p_len:‖1
if i == t_len - p_len:‖continue‖1
text_hash = (‖(text_hash - ord(text[i]) * modulus_power) * alphabet_size‖1
(text_hash - ord(text[i]) * modulus_power) * alphabet_size‖+ ord(text[i + p_len])‖1
+ ord(text[i + p_len])‖) % modulus‖1
) % modulus‖return False‖1
"text2 = ""alskfjaldsk23adsfabcabc"""‖assert rabin_karp(pattern, text1)‖1
assert rabin_karp(pattern, text1)‖assert not rabin_karp(pattern, text2)‖1
"text = ""ABABZABABYABABX"""‖assert rabin_karp(pattern, text)‖1
"text = ""ABAAAAAB"""‖assert rabin_karp(pattern, text)‖1
"text = ""abcxabcdabxabcdabcdabcy"""‖assert rabin_karp(pattern, text)‖1
"pattern = ""Lü"""‖"text = ""Lüsai"""‖1
"text = ""Lüsai"""‖assert rabin_karp(pattern, text)‖1
assert rabin_karp(pattern, text)‖"pattern = ""Lue"""‖1
"pattern = ""Lue"""‖assert not rabin_karp(pattern, text)‖1
assert not rabin_karp(pattern, text)‖"print(""Success."")"‖1
"if __name__ == ""__main__"":"‖test_rabin_karp()‖1
def reverse_words(input_str: str) -> str:‖"return "" "".join(input_str.split()[::-1])"‖1
j = prefix_result[i - 1]‖while j > 0 and input_string[i] != input_string[j]:‖1
while j > 0 and input_string[i] != input_string[j]:‖j = prefix_result[j - 1]‖1
if input_string[i] == input_string[j]:‖j += 1‖1
j += 1‖prefix_result[i] = j‖1
def remove_duplicates(sentence: str) -> str:‖"return "" "".join(sorted(set(sentence.split())))"‖1
raise ValueError(msg)‖if not isinstance(use_pascal, bool):‖1
if not isinstance(use_pascal, bool):‖"msg = f""Expected boolean as use_pascal parameter, found {type(use_pascal)}"""‖1
"msg = f""Expected boolean as use_pascal parameter, found {type(use_pascal)}"""‖raise ValueError(msg)‖1
last_index = 0‖for index, char in enumerate(string):‖1
for index, char in enumerate(string):‖if char == separator:‖1
if char == separator:‖split_words.append(string[last_index:index])‖1
split_words.append(string[last_index:index])‖last_index = index + 1‖1
last_index = index + 1‖if index + 1 == len(string):‖1
if index + 1 == len(string):‖split_words.append(string[last_index : index + 1])‖1
split_words.append(string[last_index : index + 1])‖return split_words‖1
def split_input(str_: str) -> list:‖"return [char.split() for char in re.split(r""[^ a-z A-Z 0-9 \s]"", str_)]"‖1
def to_simple_case(str_: str) -> str:‖string_split = split_input(str_)‖1
string_split = split_input(str_)‖"return """".join("‖1
"return """".join("‖"["""".join([char.capitalize() for char in sub_str]) for sub_str in string_split]"‖1
"["""".join([char.capitalize() for char in sub_str]) for sub_str in string_split]"‖)‖1
def to_complex_case(text: str, upper: bool, separator: str) -> str:‖try:‖1
try:‖string_split = split_input(text)‖1
string_split = split_input(text)‖if upper:‖1
if upper:‖"res_str = """".join("‖1
"res_str = """".join("‖[‖2
[‖separator.join([char.upper() for char in sub_str])‖1
separator.join([char.upper() for char in sub_str])‖for sub_str in string_split‖1
for sub_str in string_split‖]‖2
else:‖"res_str = """".join("‖1
[‖separator.join([char.lower() for char in sub_str])‖1
separator.join([char.lower() for char in sub_str])‖for sub_str in string_split‖1
)‖return res_str‖1
return res_str‖except IndexError:‖1
except IndexError:‖"return ""not valid string"""‖2
def to_pascal_case(text: str) -> str:‖return to_simple_case(text)‖1
def to_camel_case(text: str) -> str:‖try:‖1
try:‖res_str = to_simple_case(text)‖1
res_str = to_simple_case(text)‖return res_str[0].lower() + res_str[1:]‖1
return res_str[0].lower() + res_str[1:]‖except IndexError:‖1
def to_snake_case(text: str, upper: bool) -> str:‖"return to_complex_case(text, upper, ""_"")"‖1
def to_kebab_case(text: str, upper: bool) -> str:‖"return to_complex_case(text, upper, ""-"")"‖1
def justify(line: list, width: int, max_width: int) -> str:‖overall_spaces_count = max_width - width‖1
overall_spaces_count = max_width - width‖words_count = len(line)‖1
words_count = len(line)‖if len(line) == 1:‖1
"return line[0] + "" "" * overall_spaces_count"‖else:‖1
else:‖spaces_to_insert_between_words = words_count - 1‖1
num_spaces_between_words_list = spaces_to_insert_between_words * [‖overall_spaces_count // spaces_to_insert_between_words‖1
overall_spaces_count // spaces_to_insert_between_words‖]‖1
]‖spaces_count_in_locations = (‖1
spaces_count_in_locations = (‖overall_spaces_count % spaces_to_insert_between_words‖1
overall_spaces_count % spaces_to_insert_between_words‖)‖1
for i in range(spaces_count_in_locations):‖num_spaces_between_words_list[i] += 1‖1
num_spaces_between_words_list[i] += 1‖aligned_words_list = []‖1
aligned_words_list = []‖for i in range(spaces_to_insert_between_words):‖1
answer = []‖line: list[str] = []‖1
line: list[str] = []‖width = 0‖1
width = 0‖for inner_word in words:‖1
for inner_word in words:‖if width + len(inner_word) + len(line) <= max_width:‖1
line.append(inner_word)‖width += len(inner_word)‖1
width += len(inner_word)‖else:‖1
line, width = [inner_word], len(inner_word)‖remaining_spaces = max_width - width - len(line)‖1
remaining_spaces = max_width - width - len(line)‖"answer.append("" "".join(line) + (remaining_spaces + 1) * "" "")"‖1
"answer.append("" "".join(line) + (remaining_spaces + 1) * "" "")"‖return answer‖1
start = 0‖end = len(user_string)‖1
while start < end and user_string[start] in characters:‖start += 1‖1
while end > start and user_string[end - 1] in characters:‖end -= 1‖1
"if ""a"" <= word[0] <= ""z"":"‖word = chr(ord(word[0]) - 32) + word[1:]‖1
for i in range(1, len(word)):‖"if ""A"" <= word[i] <= ""Z"":"‖1
"if ""A"" <= word[i] <= ""Z"":"‖word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]‖1
from collections import Counter‖from functools import total_ordering‖1
@total_ordering‖class WordCount:‖1
class WordCount:‖def __init__(self, word: str, count: int) -> None:‖1
def __init__(self, word: str, count: int) -> None:‖self.word = word‖1
self.word = word‖self.count = count‖1
def __eq__(self, other: object) -> bool:‖if not isinstance(other, WordCount):‖1
if not isinstance(other, WordCount):‖return NotImplemented‖2
return NotImplemented‖return self.count == other.count‖1
def __lt__(self, other: object) -> bool:‖if not isinstance(other, WordCount):‖1
return NotImplemented‖return self.count < other.count‖1
def top_k_frequent_words(words: list[str], k_value: int) -> list[str]:‖heap: Heap[WordCount] = Heap()‖1
heap: Heap[WordCount] = Heap()‖count_by_word = Counter(words)‖1
count_by_word = Counter(words)‖heap.build_max_heap(‖1
heap.build_max_heap(‖[WordCount(word, count) for word, count in count_by_word.items()]‖1
[WordCount(word, count) for word, count in count_by_word.items()]‖)‖1
)‖return [heap.extract_max().word for _ in range(min(k_value, len(count_by_word)))]‖1
return [‖txt[:a] + txt[a].upper() + txt[a + 1 :]‖1
txt[:a] + txt[a].upper() + txt[a + 1 :]‖for a in range(len(txt))‖1
for a in range(len(txt))‖if txt[a].isalpha()‖1
if txt[a].isalpha()‖]‖1
len_string = len(input_string) + 1‖len_pattern = len(pattern) + 1‖1
for i in range(1, len_string):‖dp[i][0] = 0‖1
for j in range(1, len_pattern):‖"dp[0][j] = dp[0][j - 2] if pattern[j - 1] == ""*"" else 0"‖1
for i in range(1, len_string):‖for j in range(1, len_pattern):‖1
for j in range(1, len_pattern):‖"if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == ""."":"‖1
"if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == ""."":"‖dp[i][j] = dp[i - 1][j - 1]‖1
"elif pattern[j - 1] == ""*"":"‖if dp[i][j - 2] == 1:‖1
if dp[i][j - 2] == 1:‖dp[i][j] = 1‖1
dp[i][j] = 1‖"elif pattern[j - 2] in (input_string[i - 1], "".""):"‖1
"elif pattern[j - 2] in (input_string[i - 1], "".""):"‖dp[i][j] = dp[i - 1][j]‖1
dp[i][j] = dp[i - 1][j]‖else:‖1
else:‖dp[i][j] = 0‖2
dp[i][j] = 0‖else:‖1
"input_string = ""aab"""‖"pattern = ""c*a*b"""‖1
if match_pattern(input_string, pattern):‖"print(f""{input_string} matches the given pattern {pattern}"")"‖1
"print(f""{input_string} matches the given pattern {pattern}"")"‖else:‖1
else:‖"print(f""{input_string} does not match with the given pattern {pattern}"")"‖1
def upper(word: str) -> str:‖"return """".join(chr(ord(char) - 32) if ""a"" <= char <= ""z"" else char for char in word)"‖1
def z_function(input_str: str) -> list[int]:‖z_result = [0 for i in range(len(input_str))]‖1
if i <= right_pointer:‖min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])‖1
min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])‖z_result[i] = min_edge‖1
while go_next(i, z_result, input_str):‖z_result[i] += 1‖1
if i + z_result[i] - 1 > right_pointer:‖left_pointer, right_pointer = i, i + z_result[i] - 1‖1
def go_next(i: int, z_result: list[int], s: str) -> bool:‖return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]‖1
def find_pattern(pattern: str, input_str: str) -> int:‖answer = 0‖1
if val >= len(pattern):‖answer += 1‖1
def get_word_pattern(word: str) -> str:‖word = word.upper()‖1
word = word.upper()‖next_num = 0‖1
next_num = 0‖letter_nums = {}‖1
letter_nums = {}‖word_pattern = []‖1
for letter in word:‖if letter not in letter_nums:‖1
if letter not in letter_nums:‖letter_nums[letter] = str(next_num)‖1
letter_nums[letter] = str(next_num)‖next_num += 1‖1
next_num += 1‖word_pattern.append(letter_nums[letter])‖1
word_pattern.append(letter_nums[letter])‖"return ""."".join(word_pattern)"‖1
"if __name__ == ""__main__"":"‖import pprint‖1
import pprint‖import time‖1
start_time = time.time()‖"with open(""dictionary.txt"") as in_file:"‖1
"with open(""dictionary.txt"") as in_file:"‖word_list = in_file.read().splitlines()‖1
all_patterns: dict = {}‖for word in word_list:‖1
for word in word_list:‖pattern = get_word_pattern(word)‖1
pattern = get_word_pattern(word)‖if pattern in all_patterns:‖1
if pattern in all_patterns:‖all_patterns[pattern].append(word)‖1
all_patterns[pattern].append(word)‖else:‖1
else:‖all_patterns[pattern] = [word]‖1
"with open(""word_patterns.txt"", ""w"") as out_file:"‖out_file.write(pprint.pformat(all_patterns))‖1
total_time = round(time.time() - start_time, 2)‖"print(f""Done!  {len(all_patterns):,} word patterns found in {total_time} seconds."")"‖1
def word_occurrence(sentence: str) -> dict:‖occurrence: defaultdict[str, int] = defaultdict(int)‖1
for word in sentence.split():‖occurrence[word] += 1‖1
occurrence[word] += 1‖return occurrence‖1
"if __name__ == ""__main__"":"‖"for word, count in word_occurrence(""INPUT STRING"").items():"‖1
"for word, count in word_occurrence(""INPUT STRING"").items():"‖"print(f""{word}: {count}"")"‖1
